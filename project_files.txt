
============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\.vite\deps\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@adobe\css-tools\package.json
============================================================
{
  "name": "@adobe/css-tools",
  "version": "4.4.4",
  "description": "A modern CSS parser and stringifier with TypeScript support",
  "source": "src/index.ts",
  "main": "./dist/cjs/adobe-css-tools.cjs",
  "module": "./dist/esm/adobe-css-tools.mjs",
  "browser": "./dist/umd/adobe-css-tools.js",
  "sideEffects": false,
  "exports": {
    ".": {
      "import": "./dist/esm/adobe-css-tools.mjs",
      "require": "./dist/cjs/adobe-css-tools.cjs"
    },
    "./package.json": "./package.json"
  },
  "types": "./dist/esm/adobe-css-tools.d.mts",
  "type": "module",
  "files": [
    "dist/cjs",
    "dist/esm",
    "dist/umd",
    "README.md",
    "docs/"
  ],
  "devDependencies": {
    "@arethetypeswrong/cli": "^0.18.2",
    "@biomejs/biome": "^2.1.2",
    "@rollup/plugin-commonjs": "^28.0.6",
    "@rollup/plugin-node-resolve": "^16.0.1",
    "@rollup/plugin-terser": "^0.4.4",
    "@rollup/plugin-typescript": "^12.1.4",
    "@types/benchmark": "^2.1.1",
    "@types/bytes": "^3.1.5",
    "@types/jest": "^29.5.14",
    "@types/node": "^24.0.3",
    "benchmark": "^2.1.4",
    "bytes": "^3.1.0",
    "jest": "^29.7.0",
    "rollup": "^4.45.1",
    "rollup-plugin-dts": "^6.2.1",
    "ts-jest": "^29.1.1",
    "tslib": "^2.8.1",
    "typescript": "^5.7.3"
  },
  "scripts": {
    "benchmark": "npm run build && node benchmark/index.mjs",
    "test": "jest",
    "clean": "rm -rf ./dist",
    "build": "rollup -c",
    "fix": "biome check --write",
    "check-package-bundle": "attw --pack .",
    "lint": "biome check",
    "prebuild": "npm run clean",
    "prepack": "rollup -c",
    "posttest": "npm run lint",
    "postbuild": "tar -czf dist/archive.tgz LICENSE README.md dist/cjs dist/esm dist/umd docs package.json && npx attw --format ascii dist/archive.tgz && rm dist/archive.tgz"
  },
  "author": "TJ Holowaychuk <tj@vision-media.ca>",
  "contributors": [
    "Jean-Philippe Zolesio <holblin@gmail.com>"
  ],
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/adobe/css-tools.git"
  },
  "keywords": [
    "css",
    "parser",
    "stringifier",
    "stylesheet",
    "ast",
    "typescript",
    "css-parser",
    "css-ast",
    "css-tools",
    "minify",
    "format",
    "preprocessor"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@asamuzakjp\css-color\node_modules\lru-cache\dist\commonjs\package.json
============================================================
{
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@asamuzakjp\css-color\node_modules\lru-cache\dist\esm\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@asamuzakjp\css-color\node_modules\lru-cache\package.json
============================================================
{
  "name": "lru-cache",
  "description": "A cache object that deletes the least-recently-used items.",
  "version": "11.2.2",
  "author": "Isaac Z. Schlueter <i@izs.me>",
  "keywords": [
    "mru",
    "lru",
    "cache"
  ],
  "sideEffects": false,
  "scripts": {
    "build": "npm run prepare",
    "prepare": "tshy && bash fixup.sh",
    "pretest": "npm run prepare",
    "presnap": "npm run prepare",
    "test": "tap",
    "snap": "tap",
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags",
    "format": "prettier --write .",
    "typedoc": "typedoc --tsconfig ./.tshy/esm.json ./src/*.ts",
    "benchmark-results-typedoc": "bash scripts/benchmark-results-typedoc.sh",
    "prebenchmark": "npm run prepare",
    "benchmark": "make -C benchmark",
    "preprofile": "npm run prepare",
    "profile": "make -C benchmark profile"
  },
  "main": "./dist/commonjs/index.js",
  "types": "./dist/commonjs/index.d.ts",
  "tshy": {
    "exports": {
      ".": "./src/index.ts",
      "./min": {
        "import": {
          "types": "./dist/esm/index.d.ts",
          "default": "./dist/esm/index.min.js"
        },
        "require": {
          "types": "./dist/commonjs/index.d.ts",
          "default": "./dist/commonjs/index.min.js"
        }
      }
    }
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/node-lru-cache.git"
  },
  "devDependencies": {
    "@types/node": "^24.3.0",
    "benchmark": "^2.1.4",
    "esbuild": "^0.25.9",
    "marked": "^4.2.12",
    "mkdirp": "^3.0.1",
    "prettier": "^3.6.2",
    "tap": "^21.1.0",
    "tshy": "^3.0.2",
    "typedoc": "^0.28.12"
  },
  "license": "ISC",
  "files": [
    "dist"
  ],
  "engines": {
    "node": "20 || >=22"
  },
  "prettier": {
    "experimentalTernaries": true,
    "semi": false,
    "printWidth": 70,
    "tabWidth": 2,
    "useTabs": false,
    "singleQuote": true,
    "jsxSingleQuote": false,
    "bracketSameLine": true,
    "arrowParens": "avoid",
    "endOfLine": "lf"
  },
  "tap": {
    "node-arg": [
      "--expose-gc"
    ],
    "plugin": [
      "@tapjs/clock"
    ]
  },
  "exports": {
    ".": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.js"
      }
    },
    "./min": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.min.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.min.js"
      }
    }
  },
  "type": "module",
  "module": "./dist/esm/index.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@asamuzakjp\css-color\package.json
============================================================
{
  "name": "@asamuzakjp/css-color",
  "description": "CSS color - Resolve and convert CSS colors.",
  "author": "asamuzaK",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/asamuzaK/cssColor.git"
  },
  "homepage": "https://github.com/asamuzaK/cssColor#readme",
  "bugs": {
    "url": "https://github.com/asamuzaK/cssColor/issues"
  },
  "files": [
    "dist",
    "src"
  ],
  "type": "module",
  "types": "dist/esm/index.d.ts",
  "module": "dist/esm/index.js",
  "main": "dist/cjs/index.cjs",
  "exports": {
    ".": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.js"
      },
      "require": {
        "types": "./dist/cjs/index.d.cts",
        "default": "./dist/cjs/index.cjs"
      }
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@csstools/css-calc": "^2.1.4",
    "@csstools/css-color-parser": "^3.1.0",
    "@csstools/css-parser-algorithms": "^3.0.5",
    "@csstools/css-tokenizer": "^3.0.4",
    "lru-cache": "^11.2.1"
  },
  "devDependencies": {
    "@tanstack/vite-config": "^0.2.1",
    "@vitest/coverage-istanbul": "^3.2.4",
    "esbuild": "^0.25.10",
    "eslint": "^9.36.0",
    "eslint-plugin-regexp": "^2.10.0",
    "globals": "^16.4.0",
    "knip": "^5.64.0",
    "neostandard": "^0.12.2",
    "prettier": "^3.6.2",
    "publint": "^0.3.13",
    "rimraf": "^6.0.1",
    "tsup": "^8.5.0",
    "typescript": "^5.9.2",
    "vite": "^6.3.6",
    "vitest": "^3.2.4"
  },
  "packageManager": "pnpm@10.14.0",
  "pnpm": {
    "onlyBuiltDependencies": [
      "esbuild",
      "oxc-resolver",
      "unrs-resolver"
    ]
  },
  "scripts": {
    "build": "pnpm run clean && pnpm run test && pnpm run knip && pnpm run build:prod && pnpm run build:cjs && pnpm run build:browser && pnpm run publint",
    "build:browser": "vite build -c ./vite.browser.config.ts",
    "build:prod": "vite build",
    "build:cjs": "tsup ./src/index.ts --format=cjs --platform=node --outDir=./dist/cjs/ --sourcemap --dts",
    "clean": "rimraf ./coverage ./dist",
    "knip": "knip",
    "prettier": "prettier . --ignore-unknown --write",
    "publint": "publint --strict",
    "test": "pnpm run prettier && pnpm run --stream \"/^test:.*/\"",
    "test:eslint": "eslint ./src ./test --fix",
    "test:types": "tsc",
    "test:unit": "vitest"
  },
  "version": "4.0.5"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@asamuzakjp\dom-selector\node_modules\lru-cache\dist\commonjs\package.json
============================================================
{
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@asamuzakjp\dom-selector\node_modules\lru-cache\dist\esm\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@asamuzakjp\dom-selector\node_modules\lru-cache\package.json
============================================================
{
  "name": "lru-cache",
  "description": "A cache object that deletes the least-recently-used items.",
  "version": "11.2.2",
  "author": "Isaac Z. Schlueter <i@izs.me>",
  "keywords": [
    "mru",
    "lru",
    "cache"
  ],
  "sideEffects": false,
  "scripts": {
    "build": "npm run prepare",
    "prepare": "tshy && bash fixup.sh",
    "pretest": "npm run prepare",
    "presnap": "npm run prepare",
    "test": "tap",
    "snap": "tap",
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags",
    "format": "prettier --write .",
    "typedoc": "typedoc --tsconfig ./.tshy/esm.json ./src/*.ts",
    "benchmark-results-typedoc": "bash scripts/benchmark-results-typedoc.sh",
    "prebenchmark": "npm run prepare",
    "benchmark": "make -C benchmark",
    "preprofile": "npm run prepare",
    "profile": "make -C benchmark profile"
  },
  "main": "./dist/commonjs/index.js",
  "types": "./dist/commonjs/index.d.ts",
  "tshy": {
    "exports": {
      ".": "./src/index.ts",
      "./min": {
        "import": {
          "types": "./dist/esm/index.d.ts",
          "default": "./dist/esm/index.min.js"
        },
        "require": {
          "types": "./dist/commonjs/index.d.ts",
          "default": "./dist/commonjs/index.min.js"
        }
      }
    }
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/node-lru-cache.git"
  },
  "devDependencies": {
    "@types/node": "^24.3.0",
    "benchmark": "^2.1.4",
    "esbuild": "^0.25.9",
    "marked": "^4.2.12",
    "mkdirp": "^3.0.1",
    "prettier": "^3.6.2",
    "tap": "^21.1.0",
    "tshy": "^3.0.2",
    "typedoc": "^0.28.12"
  },
  "license": "ISC",
  "files": [
    "dist"
  ],
  "engines": {
    "node": "20 || >=22"
  },
  "prettier": {
    "experimentalTernaries": true,
    "semi": false,
    "printWidth": 70,
    "tabWidth": 2,
    "useTabs": false,
    "singleQuote": true,
    "jsxSingleQuote": false,
    "bracketSameLine": true,
    "arrowParens": "avoid",
    "endOfLine": "lf"
  },
  "tap": {
    "node-arg": [
      "--expose-gc"
    ],
    "plugin": [
      "@tapjs/clock"
    ]
  },
  "exports": {
    ".": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.js"
      }
    },
    "./min": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.min.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.min.js"
      }
    }
  },
  "type": "module",
  "module": "./dist/esm/index.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@asamuzakjp\dom-selector\package.json
============================================================
{
  "name": "@asamuzakjp/dom-selector",
  "description": "A CSS selector engine.",
  "author": "asamuzaK",
  "license": "MIT",
  "homepage": "https://github.com/asamuzaK/domSelector#readme",
  "bugs": {
    "url": "https://github.com/asamuzaK/domSelector/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/asamuzaK/domSelector.git"
  },
  "files": [
    "dist",
    "src",
    "types"
  ],
  "type": "module",
  "exports": {
    "import": {
      "types": "./types/index.d.ts",
      "default": "./src/index.js"
    },
    "require": {
      "types": "./dist/cjs/index.d.cts",
      "default": "./dist/cjs/index.cjs"
    },
    "default": {
      "types": "./dist/cjs/types/index.d.cts",
      "default": "./dist/cjs/index.cjs"
    }
  },
  "types": "types/index.d.ts",
  "dependencies": {
    "@asamuzakjp/nwsapi": "^2.3.9",
    "bidi-js": "^1.0.3",
    "css-tree": "^3.1.0",
    "is-potential-custom-element-name": "^1.0.1",
    "lru-cache": "^11.2.2"
  },
  "devDependencies": {
    "@types/css-tree": "^2.3.11",
    "benchmark": "^2.1.4",
    "c8": "^10.1.3",
    "chai": "^6.2.0",
    "commander": "^14.0.1",
    "esbuild": "^0.25.11",
    "eslint": "^9.38.0",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-jsdoc": "^61.1.4",
    "eslint-plugin-prettier": "^5.5.4",
    "eslint-plugin-regexp": "^2.10.0",
    "eslint-plugin-unicorn": "^61.0.2",
    "globals": "^16.4.0",
    "happy-dom": "^20.0.5",
    "jsdom": "^27.0.0",
    "linkedom": "^0.18.12",
    "mocha": "^11.7.4",
    "neostandard": "^0.12.2",
    "prettier": "^3.6.2",
    "sinon": "^21.0.0",
    "tsup": "^8.5.0",
    "typescript": "^5.9.3",
    "wpt-runner": "^6.1.0"
  },
  "overrides": {
    "jsdom": "$jsdom"
  },
  "scripts": {
    "bench": "node benchmark/bench.js",
    "bench:sizzle": "node benchmark/bench-sizzle.js",
    "build": "npm run tsc && npm run lint && npm test && npm run bundle && npm run test:cjs",
    "bundle": "tsup src/index.js --format=cjs --platform=node --outDir=dist/cjs/ --sourcemap --dts",
    "lint": "eslint --fix .",
    "test": "c8 --reporter=text mocha --parallel --exit test/**/*.test.js",
    "test:cjs": "mocha --exit test/index.test.cjs",
    "test:wpt": "node test/wpt/wpt-runner.js",
    "tsc": "node scripts/index clean --dir=types -i && npx tsc",
    "update:wpt": "git submodule update --init --recursive --remote"
  },
  "version": "6.7.2"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@asamuzakjp\nwsapi\package.json
============================================================
{
  "name": "@asamuzakjp/nwsapi",
  "version": "2.3.9",
  "description": "Fast CSS Selectors API Engine",
  "homepage": "http://javascript.nwbox.com/nwsapi/",
  "main": "./src/nwsapi",
  "keywords": [
    "css",
    "css3",
    "css4",
    "matcher",
    "selector"
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "http://javascript.nwbox.com/nwsapi/MIT-LICENSE"
    }
  ],
  "license": "MIT",
  "author": {
    "name": "Diego Perini",
    "email": "diego.perini@gmail.com",
    "web": "http://www.iport.it/"
  },
  "maintainers": [
    {
      "name": "Diego Perini",
      "email": "diego.perini@gmail.com",
      "web": "http://www.iport.it/"
    }
  ],
  "bugs": {
    "url": "http://github.com/dperini/nwsapi/issues"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/dperini/nwsapi.git"
  },
  "scripts": {
    "lint": "eslint ./src/nwsapi.js"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\code-frame\package.json
============================================================
{
  "name": "@babel/code-frame",
  "version": "7.27.1",
  "description": "Generate errors that contain a code frame that point to source locations.",
  "author": "The Babel Team (https://babel.dev/team)",
  "homepage": "https://babel.dev/docs/en/next/babel-code-frame",
  "bugs": "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-code-frame"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-validator-identifier": "^7.27.1",
    "js-tokens": "^4.0.0",
    "picocolors": "^1.1.1"
  },
  "devDependencies": {
    "import-meta-resolve": "^4.1.0",
    "strip-ansi": "^4.0.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\compat-data\package.json
============================================================
{
  "name": "@babel/compat-data",
  "version": "7.28.4",
  "author": "The Babel Team (https://babel.dev/team)",
  "license": "MIT",
  "description": "The compat-data to determine required Babel plugins",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-compat-data"
  },
  "publishConfig": {
    "access": "public"
  },
  "exports": {
    "./plugins": "./plugins.js",
    "./native-modules": "./native-modules.js",
    "./corejs2-built-ins": "./corejs2-built-ins.js",
    "./corejs3-shipped-proposals": "./corejs3-shipped-proposals.js",
    "./overlapping-plugins": "./overlapping-plugins.js",
    "./plugin-bugfixes": "./plugin-bugfixes.js"
  },
  "scripts": {
    "build-data": "./scripts/download-compat-table.sh && node ./scripts/build-data.mjs && node ./scripts/build-modules-support.mjs && node ./scripts/build-bugfixes-targets.mjs"
  },
  "keywords": [
    "babel",
    "compat-table",
    "compat-data"
  ],
  "devDependencies": {
    "@mdn/browser-compat-data": "^6.0.8",
    "core-js-compat": "^3.43.0",
    "electron-to-chromium": "^1.5.140"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\core\package.json
============================================================
{
  "name": "@babel/core",
  "version": "7.28.4",
  "description": "Babel compiler core.",
  "main": "./lib/index.js",
  "author": "The Babel Team (https://babel.dev/team)",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-core"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-core",
  "bugs": "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22pkg%3A%20core%22+is%3Aopen",
  "keywords": [
    "6to5",
    "babel",
    "classes",
    "const",
    "es6",
    "harmony",
    "let",
    "modules",
    "transpile",
    "transpiler",
    "var",
    "babel-core",
    "compiler"
  ],
  "engines": {
    "node": ">=6.9.0"
  },
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/babel"
  },
  "browser": {
    "./lib/config/files/index.js": "./lib/config/files/index-browser.js",
    "./lib/config/resolve-targets.js": "./lib/config/resolve-targets-browser.js",
    "./lib/transform-file.js": "./lib/transform-file-browser.js",
    "./src/config/files/index.ts": "./src/config/files/index-browser.ts",
    "./src/config/resolve-targets.ts": "./src/config/resolve-targets-browser.ts",
    "./src/transform-file.ts": "./src/transform-file-browser.ts"
  },
  "dependencies": {
    "@babel/code-frame": "^7.27.1",
    "@babel/generator": "^7.28.3",
    "@babel/helper-compilation-targets": "^7.27.2",
    "@babel/helper-module-transforms": "^7.28.3",
    "@babel/helpers": "^7.28.4",
    "@babel/parser": "^7.28.4",
    "@babel/template": "^7.27.2",
    "@babel/traverse": "^7.28.4",
    "@babel/types": "^7.28.4",
    "@jridgewell/remapping": "^2.3.5",
    "convert-source-map": "^2.0.0",
    "debug": "^4.1.0",
    "gensync": "^1.0.0-beta.2",
    "json5": "^2.2.3",
    "semver": "^6.3.1"
  },
  "devDependencies": {
    "@babel/helper-transform-fixture-test-runner": "^7.28.3",
    "@babel/plugin-syntax-flow": "^7.27.1",
    "@babel/plugin-transform-flow-strip-types": "^7.27.1",
    "@babel/plugin-transform-modules-commonjs": "^7.27.1",
    "@babel/preset-env": "^7.28.3",
    "@babel/preset-typescript": "^7.27.1",
    "@jridgewell/trace-mapping": "^0.3.28",
    "@types/convert-source-map": "^2.0.0",
    "@types/debug": "^4.1.0",
    "@types/resolve": "^1.3.2",
    "@types/semver": "^5.4.0",
    "rimraf": "^3.0.0",
    "ts-node": "^11.0.0-beta.1",
    "tsx": "^4.20.3"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\generator\package.json
============================================================
{
  "name": "@babel/generator",
  "version": "7.28.3",
  "description": "Turns an AST into code.",
  "author": "The Babel Team (https://babel.dev/team)",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-generator"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-generator",
  "bugs": "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22pkg%3A%20generator%22+is%3Aopen",
  "main": "./lib/index.js",
  "files": [
    "lib"
  ],
  "dependencies": {
    "@babel/parser": "^7.28.3",
    "@babel/types": "^7.28.2",
    "@jridgewell/gen-mapping": "^0.3.12",
    "@jridgewell/trace-mapping": "^0.3.28",
    "jsesc": "^3.0.2"
  },
  "devDependencies": {
    "@babel/core": "^7.28.3",
    "@babel/helper-fixtures": "^7.28.0",
    "@babel/plugin-transform-typescript": "^7.28.0",
    "@jridgewell/sourcemap-codec": "^1.5.3",
    "charcodes": "^0.2.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-annotate-as-pure\package.json
============================================================
{
  "name": "@babel/helper-annotate-as-pure",
  "version": "7.27.3",
  "description": "Helper function to annotate paths and nodes with #__PURE__ comment",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-annotate-as-pure"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-helper-annotate-as-pure",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/types": "^7.27.3"
  },
  "devDependencies": {
    "@babel/traverse": "^7.27.3"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-compilation-targets\package.json
============================================================
{
  "name": "@babel/helper-compilation-targets",
  "version": "7.27.2",
  "author": "The Babel Team (https://babel.dev/team)",
  "license": "MIT",
  "description": "Helper functions on Babel compilation targets",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-compilation-targets"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "publishConfig": {
    "access": "public"
  },
  "keywords": [
    "babel",
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/compat-data": "^7.27.2",
    "@babel/helper-validator-option": "^7.27.1",
    "browserslist": "^4.24.0",
    "lru-cache": "^5.1.1",
    "semver": "^6.3.1"
  },
  "devDependencies": {
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@types/lru-cache": "^5.1.1",
    "@types/semver": "^5.5.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-create-class-features-plugin\package.json
============================================================
{
  "name": "@babel/helper-create-class-features-plugin",
  "version": "7.28.3",
  "author": "The Babel Team (https://babel.dev/team)",
  "license": "MIT",
  "description": "Compile class public and private fields, private methods and decorators to ES6",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-create-class-features-plugin"
  },
  "main": "./lib/index.js",
  "publishConfig": {
    "access": "public"
  },
  "keywords": [
    "babel",
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-annotate-as-pure": "^7.27.3",
    "@babel/helper-member-expression-to-functions": "^7.27.1",
    "@babel/helper-optimise-call-expression": "^7.27.1",
    "@babel/helper-replace-supers": "^7.27.1",
    "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1",
    "@babel/traverse": "^7.28.3",
    "semver": "^6.3.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.28.3",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/preset-env": "^7.28.3",
    "@types/charcodes": "^0.2.0",
    "charcodes": "^0.2.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-create-regexp-features-plugin\package.json
============================================================
{
  "name": "@babel/helper-create-regexp-features-plugin",
  "version": "7.27.1",
  "author": "The Babel Team (https://babel.dev/team)",
  "license": "MIT",
  "description": "Compile ESNext Regular Expressions to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-create-regexp-features-plugin"
  },
  "main": "./lib/index.js",
  "publishConfig": {
    "access": "public"
  },
  "keywords": [
    "babel",
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-annotate-as-pure": "^7.27.1",
    "regexpu-core": "^6.2.0",
    "semver": "^6.3.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-define-polyfill-provider\package.json
============================================================
{
  "name": "@babel/helper-define-polyfill-provider",
  "version": "0.6.5",
  "description": "Babel helper to create your own polyfill provider",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel-polyfills.git",
    "directory": "packages/babel-helper-define-polyfill-provider"
  },
  "keywords": [
    "babel-plugin"
  ],
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "browser": {
    "./lib/node/dependencies.js": "./lib/browser/dependencies.js",
    "./src/node/dependencies.js": "./src/browser/dependencies.js"
  },
  "exports": {
    ".": [
      {
        "import": {
          "node": "./esm/index.node.mjs",
          "browser": "./esm/index.browser.mjs"
        },
        "default": "./lib/index.js"
      },
      "./lib/index.js"
    ],
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@babel/helper-compilation-targets": "^7.27.2",
    "@babel/helper-plugin-utils": "^7.27.1",
    "debug": "^4.4.1",
    "lodash.debounce": "^4.0.8",
    "resolve": "^1.22.10"
  },
  "peerDependencies": {
    "@babel/core": "^7.4.0 || ^8.0.0-0 <8.0.0"
  },
  "devDependencies": {
    "@babel/cli": "^7.27.2",
    "@babel/core": "^7.27.7",
    "@babel/generator": "^7.27.5",
    "@babel/plugin-transform-modules-commonjs": "^7.27.1",
    "@babel/traverse": "^7.27.7",
    "babel-loader": "^8.4.1",
    "rollup": "^2.79.2",
    "rollup-plugin-babel": "^4.4.0",
    "strip-ansi": "^6.0.1",
    "webpack": "^4.47.0",
    "webpack-cli": "^3.3.12"
  },
  "gitHead": "fddd6fc6e7c3c41b1234d82e53faf5de832bbf2b"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-globals\package.json
============================================================
{
  "name": "@babel/helper-globals",
  "version": "7.28.0",
  "author": "The Babel Team (https://babel.dev/team)",
  "license": "MIT",
  "description": "A collection of JavaScript globals for Babel internal usage",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-globals"
  },
  "publishConfig": {
    "access": "public"
  },
  "exports": {
    "./data/browser-upper.json": "./data/browser-upper.json",
    "./data/builtin-lower.json": "./data/builtin-lower.json",
    "./data/builtin-upper.json": "./data/builtin-upper.json",
    "./package.json": "./package.json"
  },
  "keywords": [
    "babel",
    "globals"
  ],
  "devDependencies": {
    "globals": "^16.1.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-member-expression-to-functions\package.json
============================================================
{
  "name": "@babel/helper-member-expression-to-functions",
  "version": "7.27.1",
  "description": "Helper function to replace certain member expressions with function calls",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-member-expression-to-functions"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-helper-member-expression-to-functions",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "author": "The Babel Team (https://babel.dev/team)",
  "dependencies": {
    "@babel/traverse": "^7.27.1",
    "@babel/types": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-module-imports\package.json
============================================================
{
  "name": "@babel/helper-module-imports",
  "version": "7.27.1",
  "description": "Babel helper functions for inserting module loads",
  "author": "The Babel Team (https://babel.dev/team)",
  "homepage": "https://babel.dev/docs/en/next/babel-helper-module-imports",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-module-imports"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/traverse": "^7.27.1",
    "@babel/types": "^7.27.1"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-module-transforms\package.json
============================================================
{
  "name": "@babel/helper-module-transforms",
  "version": "7.28.3",
  "description": "Babel helper functions for implementing ES6 module transformations",
  "author": "The Babel Team (https://babel.dev/team)",
  "homepage": "https://babel.dev/docs/en/next/babel-helper-module-transforms",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-module-transforms"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-module-imports": "^7.27.1",
    "@babel/helper-validator-identifier": "^7.27.1",
    "@babel/traverse": "^7.28.3"
  },
  "devDependencies": {
    "@babel/core": "^7.28.3"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-optimise-call-expression\package.json
============================================================
{
  "name": "@babel/helper-optimise-call-expression",
  "version": "7.27.1",
  "description": "Helper function to optimise call expression",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-optimise-call-expression"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-helper-optimise-call-expression",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/types": "^7.27.1"
  },
  "devDependencies": {
    "@babel/generator": "^7.27.1",
    "@babel/parser": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-plugin-utils\package.json
============================================================
{
  "name": "@babel/helper-plugin-utils",
  "version": "7.27.1",
  "description": "General utilities for plugins to use",
  "author": "The Babel Team (https://babel.dev/team)",
  "homepage": "https://babel.dev/docs/en/next/babel-helper-plugin-utils",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-plugin-utils"
  },
  "main": "./lib/index.js",
  "engines": {
    "node": ">=6.9.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-remap-async-to-generator\package.json
============================================================
{
  "name": "@babel/helper-remap-async-to-generator",
  "version": "7.27.1",
  "description": "Helper function to remap async functions to generators",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-remap-async-to-generator"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-helper-remap-async-to-generator",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-annotate-as-pure": "^7.27.1",
    "@babel/helper-wrap-function": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-replace-supers\package.json
============================================================
{
  "name": "@babel/helper-replace-supers",
  "version": "7.27.1",
  "description": "Helper function to replace supers",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-replace-supers"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-helper-replace-supers",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-member-expression-to-functions": "^7.27.1",
    "@babel/helper-optimise-call-expression": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-skip-transparent-expression-wrappers\package.json
============================================================
{
  "name": "@babel/helper-skip-transparent-expression-wrappers",
  "version": "7.27.1",
  "description": "Helper which skips types and parentheses",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-skip-transparent-expression-wrappers"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@babel/traverse": "^7.27.1",
    "@babel/types": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-string-parser\package.json
============================================================
{
  "name": "@babel/helper-string-parser",
  "version": "7.27.1",
  "description": "A utility package to parse strings",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-string-parser"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-helper-string-parser",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "devDependencies": {
    "charcodes": "^0.2.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-validator-identifier\package.json
============================================================
{
  "name": "@babel/helper-validator-identifier",
  "version": "7.27.1",
  "description": "Validate identifier/keywords name",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-validator-identifier"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "devDependencies": {
    "@unicode/unicode-16.0.0": "^1.0.0",
    "charcodes": "^0.2.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-validator-option\package.json
============================================================
{
  "name": "@babel/helper-validator-option",
  "version": "7.27.1",
  "description": "Validate plugin/preset options",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-validator-option"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helper-wrap-function\package.json
============================================================
{
  "name": "@babel/helper-wrap-function",
  "version": "7.28.3",
  "description": "Helper to wrap functions inside a function call.",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-wrap-function"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-helper-wrap-function",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/template": "^7.27.2",
    "@babel/traverse": "^7.28.3",
    "@babel/types": "^7.28.2"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\helpers\package.json
============================================================
{
  "name": "@babel/helpers",
  "version": "7.28.4",
  "description": "Collection of helper functions used by Babel transforms.",
  "author": "The Babel Team (https://babel.dev/team)",
  "homepage": "https://babel.dev/docs/en/next/babel-helpers",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-helpers"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/template": "^7.27.2",
    "@babel/types": "^7.28.4"
  },
  "devDependencies": {
    "@babel/generator": "^7.28.3",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/parser": "^7.28.4",
    "regenerator-runtime": "^0.14.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\parser\package.json
============================================================
{
  "name": "@babel/parser",
  "version": "7.28.4",
  "description": "A JavaScript parser",
  "author": "The Babel Team (https://babel.dev/team)",
  "homepage": "https://babel.dev/docs/en/next/babel-parser",
  "bugs": "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22pkg%3A+parser+%28babylon%29%22+is%3Aopen",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "keywords": [
    "babel",
    "javascript",
    "parser",
    "tc39",
    "ecmascript",
    "@babel/parser"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-parser"
  },
  "main": "./lib/index.js",
  "types": "./typings/babel-parser.d.ts",
  "files": [
    "bin",
    "lib",
    "typings/babel-parser.d.ts",
    "index.cjs"
  ],
  "engines": {
    "node": ">=6.0.0"
  },
  "# dependencies": "This package doesn't actually have runtime dependencies. @babel/types is only needed for type definitions.",
  "dependencies": {
    "@babel/types": "^7.28.4"
  },
  "devDependencies": {
    "@babel/code-frame": "^7.27.1",
    "@babel/helper-check-duplicate-nodes": "^7.27.1",
    "@babel/helper-fixtures": "^7.28.0",
    "@babel/helper-string-parser": "^7.27.1",
    "@babel/helper-validator-identifier": "^7.27.1",
    "charcodes": "^0.2.0"
  },
  "bin": "./bin/babel-parser.js",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-bugfix-firefox-class-in-computed-class-key\package.json
============================================================
{
  "name": "@babel/plugin-bugfix-firefox-class-in-computed-class-key",
  "version": "7.27.1",
  "description": "Wraps classes defined in computed keys of other classes affected by https://bugzilla.mozilla.org/show_bug.cgi?id=1887677",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-bugfix-firefox-class-in-computed-class-key"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-bugfix-firefox-class-in-computed-class-key",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "keywords": [
    "babel-plugin",
    "bugfix"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-bugfix-safari-class-field-initializer-scope\package.json
============================================================
{
  "name": "@babel/plugin-bugfix-safari-class-field-initializer-scope",
  "version": "7.27.1",
  "description": "Wrap class field initializers with IIFE to workaround https://webkit.org/b/236843",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-bugfix-safari-class-field-initializer-scope"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-bugfix-safari-class-field-initializer-scope",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "keywords": [
    "babel-plugin",
    "bugfix"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-bugfix-safari-id-destructuring-collision-in-function-expression\package.json
============================================================
{
  "name": "@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression",
  "version": "7.27.1",
  "description": "Rename destructuring parameter to workaround https://bugs.webkit.org/show_bug.cgi?id=220517",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-bugfix-safari-id-destructuring-collision-in-function-expression"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-bugfix-safari-id-destructuring-collision-in-function-expression",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "keywords": [
    "babel-plugin",
    "bugfix"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-bugfix-v8-spread-parameters-in-optional-chaining\package.json
============================================================
{
  "name": "@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining",
  "version": "7.27.1",
  "description": "Transform optional chaining operators to workaround https://crbug.com/v8/11558",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-bugfix-v8-spread-parameters-in-optional-chaining"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-bugfix-v8-spread-parameters-in-optional-chaining",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "keywords": [
    "babel-plugin",
    "bugfix"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1",
    "@babel/plugin-transform-optional-chaining": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.13.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-bugfix-v8-static-class-fields-redefine-readonly\package.json
============================================================
{
  "name": "@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly",
  "version": "7.28.3",
  "description": "Transform static class fields assignments that are affected by https://crbug.com/v8/12421",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-bugfix-v8-static-class-fields-redefine-readonly"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-bugfix-v8-static-class-fields-redefine-readonly",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "keywords": [
    "babel-plugin",
    "bugfix"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/traverse": "^7.28.3"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.28.3",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.28.3"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-proposal-private-property-in-object\package.json
============================================================
{
  "name": "@babel/plugin-proposal-private-property-in-object",
  "version": "7.21.0-placeholder-for-preset-env.2",
  "description": "This plugin transforms checks for a private property in an object",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel-plugin-proposal-private-property-in-object.git"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-proposal-private-property-in-object",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {},
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-async-generators\package.json
============================================================
{
  "name": "@babel/plugin-syntax-async-generators",
  "version": "7.8.4",
  "description": "Allow parsing of async generator functions",
  "repository": "https://github.com/babel/babel/tree/master/packages/babel-plugin-syntax-async-generators",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.8.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.8.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-bigint\package.json
============================================================
{
  "name": "@babel/plugin-syntax-bigint",
  "version": "7.8.3",
  "description": "Allow parsing of BigInt literals",
  "repository": "https://github.com/babel/babel/tree/master/packages/babel-plugin-syntax-bigint",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.8.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.8.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-class-properties\package.json
============================================================
{
  "name": "@babel/plugin-syntax-class-properties",
  "version": "7.12.13",
  "description": "Allow parsing of class properties",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-class-properties"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-syntax-class-properties",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.12.13"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "7.12.13"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-class-static-block\package.json
============================================================
{
  "name": "@babel/plugin-syntax-class-static-block",
  "version": "7.14.5",
  "description": "Allow parsing of class static blocks",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-class-static-block"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-syntax-class-static-block",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": "./lib/index.js"
  },
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.14.5"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-import-assertions\package.json
============================================================
{
  "name": "@babel/plugin-syntax-import-assertions",
  "version": "7.27.1",
  "description": "Allow parsing of the module assertion attributes in the import statement",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-import-assertions"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-import-attributes\package.json
============================================================
{
  "name": "@babel/plugin-syntax-import-attributes",
  "version": "7.27.1",
  "description": "Allow parsing of the module attributes in the import statement",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-import-attributes"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-import-meta\package.json
============================================================
{
  "name": "@babel/plugin-syntax-import-meta",
  "version": "7.10.4",
  "description": "Allow parsing of import.meta",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-import-meta"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.10.4"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.10.4"
  },
  "gitHead": "7fd40d86a0d03ff0e9c3ea16b29689945433d4df"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-json-strings\package.json
============================================================
{
  "name": "@babel/plugin-syntax-json-strings",
  "version": "7.8.3",
  "description": "Allow parsing of the U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR in JS strings",
  "repository": "https://github.com/babel/babel/tree/master/packages/babel-plugin-syntax-json-strings",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.8.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.8.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-jsx\package.json
============================================================
{
  "name": "@babel/plugin-syntax-jsx",
  "version": "7.27.1",
  "description": "Allow parsing of jsx",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-jsx"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-syntax-jsx",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-logical-assignment-operators\package.json
============================================================
{
  "name": "@babel/plugin-syntax-logical-assignment-operators",
  "version": "7.10.4",
  "description": "Allow parsing of the logical assignment operators",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-logical-assignment-operators"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.10.4"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.10.4"
  },
  "gitHead": "7fd40d86a0d03ff0e9c3ea16b29689945433d4df"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-nullish-coalescing-operator\package.json
============================================================
{
  "name": "@babel/plugin-syntax-nullish-coalescing-operator",
  "version": "7.8.3",
  "description": "Allow parsing of the nullish-coalescing operator",
  "repository": "https://github.com/babel/babel/tree/master/packages/babel-plugin-syntax-nullish-coalescing-operator",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.8.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.8.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-numeric-separator\package.json
============================================================
{
  "name": "@babel/plugin-syntax-numeric-separator",
  "version": "7.10.4",
  "description": "Allow parsing of Decimal, Binary, Hex and Octal literals that contain a Numeric Literal Separator",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-numeric-separator"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.10.4"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.10.4"
  },
  "gitHead": "7fd40d86a0d03ff0e9c3ea16b29689945433d4df"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-object-rest-spread\package.json
============================================================
{
  "name": "@babel/plugin-syntax-object-rest-spread",
  "version": "7.8.3",
  "description": "Allow parsing of object rest/spread",
  "repository": "https://github.com/babel/babel/tree/master/packages/babel-plugin-syntax-object-rest-spread",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.8.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.8.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-optional-catch-binding\package.json
============================================================
{
  "name": "@babel/plugin-syntax-optional-catch-binding",
  "version": "7.8.3",
  "description": "Allow parsing of optional catch bindings",
  "repository": "https://github.com/babel/babel/tree/master/packages/babel-plugin-syntax-optional-catch-binding",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.8.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.8.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-optional-chaining\package.json
============================================================
{
  "name": "@babel/plugin-syntax-optional-chaining",
  "version": "7.8.3",
  "description": "Allow parsing of optional properties",
  "repository": "https://github.com/babel/babel/tree/master/packages/babel-plugin-syntax-optional-chaining",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.8.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.8.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-private-property-in-object\package.json
============================================================
{
  "name": "@babel/plugin-syntax-private-property-in-object",
  "version": "7.14.5",
  "description": "Allow parsing of '#foo in obj' brand checks",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-private-property-in-object"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-syntax-private-property-in-object",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": "./lib/index.js"
  },
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.14.5"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-top-level-await\package.json
============================================================
{
  "name": "@babel/plugin-syntax-top-level-await",
  "version": "7.14.5",
  "description": "Allow parsing of top-level await in modules",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-top-level-await"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-syntax-top-level-await",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.14.5"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "7.14.5"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-typescript\package.json
============================================================
{
  "name": "@babel/plugin-syntax-typescript",
  "version": "7.27.1",
  "description": "Allow parsing of TypeScript syntax",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-typescript"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-syntax-typescript",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin",
    "typescript"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-syntax-unicode-sets-regex\package.json
============================================================
{
  "name": "@babel/plugin-syntax-unicode-sets-regex",
  "version": "7.18.6",
  "description": "Parse regular expressions' unicodeSets (v) flag.",
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-syntax-unicode-sets-regex",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin",
    "regex",
    "regexp",
    "unicode",
    "sets",
    "properties",
    "property",
    "string",
    "strings",
    "regular expressions"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-unicode-sets-regex"
  },
  "bugs": "https://github.com/babel/babel/issues",
  "dependencies": {
    "@babel/helper-create-regexp-features-plugin": "^7.18.6",
    "@babel/helper-plugin-utils": "^7.18.6"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.18.6",
    "@babel/helper-plugin-test-runner": "^7.18.6"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "exports": {
    ".": "./lib/index.js",
    "./package.json": "./package.json"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-arrow-functions\package.json
============================================================
{
  "name": "@babel/plugin-transform-arrow-functions",
  "version": "7.27.1",
  "description": "Compile ES2015 arrow functions to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-arrow-functions"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-arrow-functions",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.27.1",
    "@babel/types": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-async-generator-functions\package.json
============================================================
{
  "name": "@babel/plugin-transform-async-generator-functions",
  "version": "7.28.0",
  "description": "Turn async generator functions into ES2015 generators",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-async-generator-functions"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-async-generator-functions",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-remap-async-to-generator": "^7.27.1",
    "@babel/traverse": "^7.28.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.28.0",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "babel-plugin-polyfill-corejs3": "^0.13.0",
    "core-js-pure": "^3.43.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-async-to-generator\package.json
============================================================
{
  "name": "@babel/plugin-transform-async-to-generator",
  "version": "7.27.1",
  "description": "Turn async functions into ES2015 generators",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-async-to-generator"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-async-to-generator",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-module-imports": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-remap-async-to-generator": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-block-scoped-functions\package.json
============================================================
{
  "name": "@babel/plugin-transform-block-scoped-functions",
  "version": "7.27.1",
  "description": "Babel plugin to ensure function declarations at the block level are block scoped",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-block-scoped-functions"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-block-scoped-functions",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-block-scoping\package.json
============================================================
{
  "name": "@babel/plugin-transform-block-scoping",
  "version": "7.28.4",
  "description": "Compile ES2015 block scoping (const and let) to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-block-scoping"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-block-scoping",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.28.4",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.28.4"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-class-properties\package.json
============================================================
{
  "name": "@babel/plugin-transform-class-properties",
  "version": "7.27.1",
  "description": "This plugin transforms static class properties as well as properties declared with the property initializer syntax",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-class-properties"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-class-properties",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-create-class-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-class-static-block\package.json
============================================================
{
  "name": "@babel/plugin-transform-class-static-block",
  "version": "7.28.3",
  "description": "Transform class static blocks",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-class-static-block"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-create-class-features-plugin": "^7.28.3",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.12.0"
  },
  "devDependencies": {
    "@babel/core": "^7.28.3",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-external-helpers": "^7.27.1",
    "@babel/plugin-transform-class-properties": "^7.27.1",
    "@babel/traverse": "^7.28.3",
    "@babel/types": "^7.28.2"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-class-static-block",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-classes\package.json
============================================================
{
  "name": "@babel/plugin-transform-classes",
  "version": "7.28.4",
  "description": "Compile ES2015 classes to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-classes"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-classes",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-annotate-as-pure": "^7.27.3",
    "@babel/helper-compilation-targets": "^7.27.2",
    "@babel/helper-globals": "^7.28.0",
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-replace-supers": "^7.27.1",
    "@babel/traverse": "^7.28.4"
  },
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.28.4",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-computed-properties\package.json
============================================================
{
  "name": "@babel/plugin-transform-computed-properties",
  "version": "7.27.1",
  "description": "Compile ES2015 computed properties to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-computed-properties"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-computed-properties",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/template": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-destructuring\package.json
============================================================
{
  "name": "@babel/plugin-transform-destructuring",
  "version": "7.28.0",
  "description": "Compile ES2015 destructuring to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-destructuring"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-destructuring",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/traverse": "^7.28.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.28.0",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-dotall-regex\package.json
============================================================
{
  "name": "@babel/plugin-transform-dotall-regex",
  "version": "7.27.1",
  "description": "Compile regular expressions using the `s` (`dotAll`) flag to ES5.",
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-dotall-regex",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin",
    "regex",
    "regexp",
    "regular expressions",
    "dotall"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-dotall-regex"
  },
  "bugs": "https://github.com/babel/babel/issues",
  "dependencies": {
    "@babel/helper-create-regexp-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-duplicate-keys\package.json
============================================================
{
  "name": "@babel/plugin-transform-duplicate-keys",
  "version": "7.27.1",
  "description": "Compile objects with duplicate keys to valid strict ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-duplicate-keys"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-duplicate-keys",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-duplicate-named-capturing-groups-regex\package.json
============================================================
{
  "name": "@babel/plugin-transform-duplicate-named-capturing-groups-regex",
  "version": "7.27.1",
  "description": "Compile regular expressions using duplicate named groups to index-based groups.",
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-duplicate-named-capturing-groups-regex",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin",
    "regex",
    "regexp",
    "regular expressions"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-duplicate-named-capturing-groups-regex"
  },
  "bugs": "https://github.com/babel/babel/issues",
  "dependencies": {
    "@babel/helper-create-regexp-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "core-js": "^3.30.2"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-dynamic-import\package.json
============================================================
{
  "name": "@babel/plugin-transform-dynamic-import",
  "version": "7.27.1",
  "description": "Transform import() expressions",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-dynamic-import"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-explicit-resource-management\package.json
============================================================
{
  "name": "@babel/plugin-transform-explicit-resource-management",
  "version": "7.28.0",
  "description": "Compile `using` and `await using` declarations to ES2015",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-explicit-resource-management"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-explicit-resource-management",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/plugin-transform-destructuring": "^7.28.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.28.0",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-exponentiation-operator\package.json
============================================================
{
  "name": "@babel/plugin-transform-exponentiation-operator",
  "version": "7.27.1",
  "description": "Compile exponentiation operator to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-exponentiation-operator"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-exponentiation-operator",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-export-namespace-from\package.json
============================================================
{
  "name": "@babel/plugin-transform-export-namespace-from",
  "version": "7.27.1",
  "description": "Compile export namespace to ES2015",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-export-namespace-from"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-export-namespace-from",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-for-of\package.json
============================================================
{
  "name": "@babel/plugin-transform-for-of",
  "version": "7.27.1",
  "description": "Compile ES2015 for...of to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-for-of"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-for-of",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-function-name\package.json
============================================================
{
  "name": "@babel/plugin-transform-function-name",
  "version": "7.27.1",
  "description": "Apply ES2015 function.name semantics to all functions",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-function-name"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-function-name",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-compilation-targets": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-json-strings\package.json
============================================================
{
  "name": "@babel/plugin-transform-json-strings",
  "version": "7.27.1",
  "description": "Escape U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR in JS strings",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-json-strings"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-json-strings",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-literals\package.json
============================================================
{
  "name": "@babel/plugin-transform-literals",
  "version": "7.27.1",
  "description": "Compile ES2015 unicode string and number literals to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-literals"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-literals",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-logical-assignment-operators\package.json
============================================================
{
  "name": "@babel/plugin-transform-logical-assignment-operators",
  "version": "7.27.1",
  "description": "Transforms logical assignment operators into short-circuited assignments",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-logical-assignment-operators"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-transform-nullish-coalescing-operator": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-logical-assignment-operators",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-member-expression-literals\package.json
============================================================
{
  "name": "@babel/plugin-transform-member-expression-literals",
  "version": "7.27.1",
  "description": "Ensure that reserved words are quoted in property accesses",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-member-expression-literals"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-member-expression-literals",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-modules-amd\package.json
============================================================
{
  "name": "@babel/plugin-transform-modules-amd",
  "version": "7.27.1",
  "description": "This plugin transforms ES2015 modules to AMD",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-modules-amd"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-modules-amd",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-module-transforms": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-external-helpers": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-modules-commonjs\package.json
============================================================
{
  "name": "@babel/plugin-transform-modules-commonjs",
  "version": "7.27.1",
  "description": "This plugin transforms ES2015 modules to CommonJS",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-modules-commonjs"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-module-transforms": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-external-helpers": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-modules-commonjs",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-modules-systemjs\package.json
============================================================
{
  "name": "@babel/plugin-transform-modules-systemjs",
  "version": "7.27.1",
  "description": "This plugin transforms ES2015 modules to SystemJS",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-modules-systemjs"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-module-transforms": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-validator-identifier": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/helper-transform-fixture-test-runner": "^7.27.1",
    "core-js": "^3.35.0"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-modules-systemjs",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-modules-umd\package.json
============================================================
{
  "name": "@babel/plugin-transform-modules-umd",
  "version": "7.27.1",
  "description": "This plugin transforms ES2015 modules to UMD",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-modules-umd"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-modules-umd",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-module-transforms": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-external-helpers": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-named-capturing-groups-regex\package.json
============================================================
{
  "name": "@babel/plugin-transform-named-capturing-groups-regex",
  "version": "7.27.1",
  "description": "Compile regular expressions using named groups to ES5.",
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-named-capturing-groups-regex",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin",
    "regex",
    "regexp",
    "regular expressions"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-named-capturing-groups-regex"
  },
  "bugs": "https://github.com/babel/babel/issues",
  "dependencies": {
    "@babel/helper-create-regexp-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "core-js": "^3.30.2"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-new-target\package.json
============================================================
{
  "name": "@babel/plugin-transform-new-target",
  "version": "7.27.1",
  "description": "Transforms new.target meta property",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-new-target"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-new-target",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-transform-arrow-functions": "^7.27.1",
    "@babel/plugin-transform-class-properties": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-nullish-coalescing-operator\package.json
============================================================
{
  "name": "@babel/plugin-transform-nullish-coalescing-operator",
  "version": "7.27.1",
  "description": "Remove nullish coalescing operator",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-nullish-coalescing-operator"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-nullish-coalescing-operator",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-numeric-separator\package.json
============================================================
{
  "name": "@babel/plugin-transform-numeric-separator",
  "version": "7.27.1",
  "description": "Remove numeric separators from Decimal, Binary, Hex and Octal literals",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-numeric-separator"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-numeric-separator",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.27.1",
    "@babel/types": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-object-rest-spread\package.json
============================================================
{
  "name": "@babel/plugin-transform-object-rest-spread",
  "version": "7.28.4",
  "description": "Compile object rest and spread to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-object-rest-spread"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-object-rest-spread",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-compilation-targets": "^7.27.2",
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/plugin-transform-destructuring": "^7.28.0",
    "@babel/plugin-transform-parameters": "^7.27.7",
    "@babel/traverse": "^7.28.4"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.28.4",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/parser": "^7.28.4"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-object-super\package.json
============================================================
{
  "name": "@babel/plugin-transform-object-super",
  "version": "7.27.1",
  "description": "Compile ES2015 object super to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-object-super"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-object-super",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-replace-supers": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-optional-catch-binding\package.json
============================================================
{
  "name": "@babel/plugin-transform-optional-catch-binding",
  "version": "7.27.1",
  "description": "Compile optional catch bindings",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-optional-catch-binding"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-optional-catch-binding",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-optional-chaining\package.json
============================================================
{
  "name": "@babel/plugin-transform-optional-chaining",
  "version": "7.27.1",
  "description": "Transform optional chaining operators into a series of nil checks",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-optional-chaining"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-optional-chaining",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-transform-block-scoping": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-parameters\package.json
============================================================
{
  "name": "@babel/plugin-transform-parameters",
  "version": "7.27.7",
  "description": "Compile ES2015 default and rest parameters to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-parameters"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-parameters",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.7",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-private-methods\package.json
============================================================
{
  "name": "@babel/plugin-transform-private-methods",
  "version": "7.27.1",
  "description": "This plugin transforms private class methods",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-private-methods"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-private-methods",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-create-class-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-private-property-in-object\package.json
============================================================
{
  "name": "@babel/plugin-transform-private-property-in-object",
  "version": "7.27.1",
  "description": "This plugin transforms checks for a private property in an object",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-private-property-in-object"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-private-property-in-object",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-annotate-as-pure": "^7.27.1",
    "@babel/helper-create-class-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-property-literals\package.json
============================================================
{
  "name": "@babel/plugin-transform-property-literals",
  "version": "7.27.1",
  "description": "Ensure that reserved words are quoted in object property keys",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-property-literals"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-property-literals",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-react-display-name\package.json
============================================================
{
  "name": "@babel/plugin-transform-react-display-name",
  "version": "7.28.0",
  "description": "Add displayName to React.createClass calls",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-react-display-name"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-react-display-name",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.28.0",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-react-jsx\package.json
============================================================
{
  "name": "@babel/plugin-transform-react-jsx",
  "version": "7.27.1",
  "description": "Turn JSX into React function calls",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-react-jsx"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-react-jsx",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-annotate-as-pure": "^7.27.1",
    "@babel/helper-module-imports": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/plugin-syntax-jsx": "^7.27.1",
    "@babel/types": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-react-jsx-development\package.json
============================================================
{
  "name": "@babel/plugin-transform-react-jsx-development",
  "version": "7.27.1",
  "description": "Turn JSX into React function calls in development",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-react-jsx-development"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/plugin-transform-react-jsx": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-react-jsx-self\package.json
============================================================
{
  "name": "@babel/plugin-transform-react-jsx-self",
  "version": "7.27.1",
  "description": "Add a __self prop to all JSX Elements",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-react-jsx-self"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-react-jsx-self",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-syntax-jsx": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-react-jsx-source\package.json
============================================================
{
  "name": "@babel/plugin-transform-react-jsx-source",
  "version": "7.27.1",
  "description": "Add a __source prop to all JSX Elements",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-react-jsx-source"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-react-jsx-source",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-syntax-jsx": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-react-pure-annotations\package.json
============================================================
{
  "name": "@babel/plugin-transform-react-pure-annotations",
  "version": "7.27.1",
  "description": "Mark top-level React method calls as pure for tree shaking",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-react-pure-annotations"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-annotate-as-pure": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-regenerator\package.json
============================================================
{
  "name": "@babel/plugin-transform-regenerator",
  "author": "The Babel Team (https://babel.dev/team)",
  "description": "Explode async and generator functions into a state machine.",
  "version": "7.28.4",
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-regenerator",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-regenerator"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.28.4",
    "@babel/helper-check-duplicate-nodes": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-proposal-function-sent": "^7.27.1",
    "@babel/plugin-transform-arrow-functions": "^7.27.1",
    "@babel/plugin-transform-block-scoping": "^7.28.4",
    "@babel/plugin-transform-classes": "^7.28.4",
    "@babel/plugin-transform-for-of": "^7.27.1",
    "@babel/plugin-transform-modules-commonjs": "^7.27.1",
    "@babel/plugin-transform-parameters": "^7.27.7",
    "@babel/plugin-transform-runtime": "^7.28.3",
    "babel-plugin-polyfill-regenerator": "^0.6.5",
    "mocha": "^10.0.0",
    "recast": "^0.23.3",
    "uglify-js": "^3.14.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-regexp-modifiers\package.json
============================================================
{
  "name": "@babel/plugin-transform-regexp-modifiers",
  "version": "7.27.1",
  "description": "Compile inline regular expression modifiers",
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-regexp-modifiers",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin",
    "regex",
    "regexp",
    "regular expressions"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-regexp-modifiers"
  },
  "bugs": "https://github.com/babel/babel/issues",
  "dependencies": {
    "@babel/helper-create-regexp-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-reserved-words\package.json
============================================================
{
  "name": "@babel/plugin-transform-reserved-words",
  "version": "7.27.1",
  "description": "Ensure that no reserved words are used.",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-reserved-words"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-reserved-words",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-shorthand-properties\package.json
============================================================
{
  "name": "@babel/plugin-transform-shorthand-properties",
  "version": "7.27.1",
  "description": "Compile ES2015 shorthand properties to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-shorthand-properties"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-shorthand-properties",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-spread\package.json
============================================================
{
  "name": "@babel/plugin-transform-spread",
  "version": "7.27.1",
  "description": "Compile ES2015 spread to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-spread"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-spread",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-sticky-regex\package.json
============================================================
{
  "name": "@babel/plugin-transform-sticky-regex",
  "version": "7.27.1",
  "description": "Compile ES2015 sticky regex to an ES5 RegExp constructor",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-sticky-regex"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-sticky-regex",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-template-literals\package.json
============================================================
{
  "name": "@babel/plugin-transform-template-literals",
  "version": "7.27.1",
  "description": "Compile ES2015 template literals to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-template-literals"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-template-literals",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-typeof-symbol\package.json
============================================================
{
  "name": "@babel/plugin-transform-typeof-symbol",
  "version": "7.27.1",
  "description": "This transformer wraps all typeof expressions with a method that replicates native behaviour. (ie. returning “symbol” for symbols)",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-typeof-symbol"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/runtime": "^7.27.1",
    "@babel/runtime-corejs2": "^7.24.0",
    "@babel/runtime-corejs3": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-typeof-symbol",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-unicode-escapes\package.json
============================================================
{
  "name": "@babel/plugin-transform-unicode-escapes",
  "version": "7.27.1",
  "description": "Compile ES2015 Unicode escapes to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-unicode-escapes"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-unicode-escapes",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-unicode-property-regex\package.json
============================================================
{
  "name": "@babel/plugin-transform-unicode-property-regex",
  "version": "7.27.1",
  "description": "Compile Unicode property escapes in Unicode regular expressions to ES5.",
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-unicode-property-regex",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "engines": {
    "node": ">=6.9.0"
  },
  "keywords": [
    "babel-plugin",
    "regex",
    "regexp",
    "regular expressions",
    "unicode properties",
    "unicode"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-unicode-property-regex"
  },
  "bugs": "https://github.com/babel/babel/issues",
  "dependencies": {
    "@babel/helper-create-regexp-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-unicode-regex\package.json
============================================================
{
  "name": "@babel/plugin-transform-unicode-regex",
  "version": "7.27.1",
  "description": "Compile ES2015 Unicode regex to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-unicode-regex"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-create-regexp-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-unicode-regex",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\plugin-transform-unicode-sets-regex\package.json
============================================================
{
  "name": "@babel/plugin-transform-unicode-sets-regex",
  "version": "7.27.1",
  "description": "Compile regular expressions' unicodeSets (v) flag.",
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-unicode-sets-regex",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin",
    "regex",
    "regexp",
    "unicode",
    "sets",
    "properties",
    "property",
    "string",
    "strings",
    "regular expressions"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-unicode-sets-regex"
  },
  "bugs": "https://github.com/babel/babel/issues",
  "dependencies": {
    "@babel/helper-create-regexp-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\preset-env\data\package.json
============================================================
{ "type": "commonjs" }

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\preset-env\package.json
============================================================
{
  "name": "@babel/preset-env",
  "version": "7.28.3",
  "description": "A Babel preset for each environment.",
  "author": "The Babel Team (https://babel.dev/team)",
  "homepage": "https://babel.dev/docs/en/next/babel-preset-env",
  "bugs": "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22pkg%3A%20preset-env%22+is%3Aopen",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-preset-env"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/compat-data": "^7.28.0",
    "@babel/helper-compilation-targets": "^7.27.2",
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-validator-option": "^7.27.1",
    "@babel/plugin-bugfix-firefox-class-in-computed-class-key": "^7.27.1",
    "@babel/plugin-bugfix-safari-class-field-initializer-scope": "^7.27.1",
    "@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression": "^7.27.1",
    "@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining": "^7.27.1",
    "@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly": "^7.28.3",
    "@babel/plugin-proposal-private-property-in-object": "7.21.0-placeholder-for-preset-env.2",
    "@babel/plugin-syntax-import-assertions": "^7.27.1",
    "@babel/plugin-syntax-import-attributes": "^7.27.1",
    "@babel/plugin-syntax-unicode-sets-regex": "^7.18.6",
    "@babel/plugin-transform-arrow-functions": "^7.27.1",
    "@babel/plugin-transform-async-generator-functions": "^7.28.0",
    "@babel/plugin-transform-async-to-generator": "^7.27.1",
    "@babel/plugin-transform-block-scoped-functions": "^7.27.1",
    "@babel/plugin-transform-block-scoping": "^7.28.0",
    "@babel/plugin-transform-class-properties": "^7.27.1",
    "@babel/plugin-transform-class-static-block": "^7.28.3",
    "@babel/plugin-transform-classes": "^7.28.3",
    "@babel/plugin-transform-computed-properties": "^7.27.1",
    "@babel/plugin-transform-destructuring": "^7.28.0",
    "@babel/plugin-transform-dotall-regex": "^7.27.1",
    "@babel/plugin-transform-duplicate-keys": "^7.27.1",
    "@babel/plugin-transform-duplicate-named-capturing-groups-regex": "^7.27.1",
    "@babel/plugin-transform-dynamic-import": "^7.27.1",
    "@babel/plugin-transform-explicit-resource-management": "^7.28.0",
    "@babel/plugin-transform-exponentiation-operator": "^7.27.1",
    "@babel/plugin-transform-export-namespace-from": "^7.27.1",
    "@babel/plugin-transform-for-of": "^7.27.1",
    "@babel/plugin-transform-function-name": "^7.27.1",
    "@babel/plugin-transform-json-strings": "^7.27.1",
    "@babel/plugin-transform-literals": "^7.27.1",
    "@babel/plugin-transform-logical-assignment-operators": "^7.27.1",
    "@babel/plugin-transform-member-expression-literals": "^7.27.1",
    "@babel/plugin-transform-modules-amd": "^7.27.1",
    "@babel/plugin-transform-modules-commonjs": "^7.27.1",
    "@babel/plugin-transform-modules-systemjs": "^7.27.1",
    "@babel/plugin-transform-modules-umd": "^7.27.1",
    "@babel/plugin-transform-named-capturing-groups-regex": "^7.27.1",
    "@babel/plugin-transform-new-target": "^7.27.1",
    "@babel/plugin-transform-nullish-coalescing-operator": "^7.27.1",
    "@babel/plugin-transform-numeric-separator": "^7.27.1",
    "@babel/plugin-transform-object-rest-spread": "^7.28.0",
    "@babel/plugin-transform-object-super": "^7.27.1",
    "@babel/plugin-transform-optional-catch-binding": "^7.27.1",
    "@babel/plugin-transform-optional-chaining": "^7.27.1",
    "@babel/plugin-transform-parameters": "^7.27.7",
    "@babel/plugin-transform-private-methods": "^7.27.1",
    "@babel/plugin-transform-private-property-in-object": "^7.27.1",
    "@babel/plugin-transform-property-literals": "^7.27.1",
    "@babel/plugin-transform-regenerator": "^7.28.3",
    "@babel/plugin-transform-regexp-modifiers": "^7.27.1",
    "@babel/plugin-transform-reserved-words": "^7.27.1",
    "@babel/plugin-transform-shorthand-properties": "^7.27.1",
    "@babel/plugin-transform-spread": "^7.27.1",
    "@babel/plugin-transform-sticky-regex": "^7.27.1",
    "@babel/plugin-transform-template-literals": "^7.27.1",
    "@babel/plugin-transform-typeof-symbol": "^7.27.1",
    "@babel/plugin-transform-unicode-escapes": "^7.27.1",
    "@babel/plugin-transform-unicode-property-regex": "^7.27.1",
    "@babel/plugin-transform-unicode-regex": "^7.27.1",
    "@babel/plugin-transform-unicode-sets-regex": "^7.27.1",
    "@babel/preset-modules": "0.1.6-no-external-plugins",
    "babel-plugin-polyfill-corejs2": "^0.4.14",
    "babel-plugin-polyfill-corejs3": "^0.13.0",
    "babel-plugin-polyfill-regenerator": "^0.6.5",
    "core-js-compat": "^3.43.0",
    "semver": "^6.3.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.28.3",
    "@babel/core-7.12": "npm:@babel/core@7.12.9",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.28.3"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\preset-modules\package.json
============================================================
{
  "name": "@babel/preset-modules",
  "version": "0.1.6-no-external-plugins",
  "description": "A Babel preset that targets modern browsers by fixing engine bugs.",
  "main": "lib/index.js",
  "license": "MIT",
  "scripts": {
    "start": "concurrently -r 'npm:watch:* -s'",
    "build": "babel src -d lib --ignore '**/*.test.js'",
    "test": "eslint src test && jest --colors",
    "test:browser": "cd test/browser && karmatic --no-coverage --browsers chrome:headless,sauce-chrome-61,sauce-firefox-60,sauce-safari-10,sauce-safari-11,sauce-edge-16,sauce-edge-17 '**/*.js'",
    "test:local": "cd test/browser && karmatic --no-coverage '**/*.js'",
    "test:safari": "npm run test:local -- --browsers sauce-safari-10",
    "test:edge": "npm run test:local -- --browsers sauce-edge-16",
    "watch:test": "jest --watch",
    "watch:build": "npm run -s build -- -w"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/preset-modules.git"
  },
  "keywords": [
    "babel",
    "preset",
    "preset-env",
    "modern",
    "modules",
    "ES Modules",
    "module/nomodule"
  ],
  "files": [
    "src",
    "lib"
  ],
  "lint-staged": {
    "*.js": [
      "eslint --format=codeframe"
    ]
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "jest": {
    "testEnvironment": "node",
    "roots": [
      "src",
      "test"
    ]
  },
  "eslintConfig": {
    "extends": "developit",
    "rules": {
      "no-console": 0,
      "new-cap": 0
    }
  },
  "eslintIgnore": [
    "test/fixtures/**/*",
    "test/integration/**/*"
  ],
  "authors": [
    "Jason Miller <jason@developit.ca>"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0 || ^8.0.0-0 <8.0.0"
  },
  "devDependencies": {
    "@babel/cli": "^7.7.0",
    "@babel/core": "^7.7.2",
    "@babel/helper-fixtures": "^7.6.3",
    "@babel/helper-plugin-test-runner": "^7.14.5",
    "@babel/plugin-transform-modules-commonjs": "^7.5.0",
    "@babel/plugin-transform-react-jsx": "^7.7.0",
    "@babel/preset-env": "^7.9.6",
    "acorn-jsx": "^5.0.1",
    "babel-eslint": "^10.0.3",
    "babel-plugin-add-module-exports": "^1.0.2",
    "chalk": "^2.4.2",
    "concurrently": "^4.1.0",
    "eslint": "^6.6.0",
    "eslint-config-babel": "^9.0.0",
    "eslint-plugin-flowtype": "3",
    "eslint-plugin-import": "^2.18.2",
    "eslint-plugin-prettier": "^3.1.1",
    "gzip-size": "^5.1.1",
    "if-env": "^1.0.4",
    "jest": "^24.8.0",
    "karmatic": "^1.4.0",
    "prettier": "^1.19.1",
    "pretty-bytes": "^5.2.0",
    "rollup": "^1.16.3",
    "rollup-plugin-babel": "^4.3.3",
    "rollup-plugin-node-resolve": "^5.2.0",
    "terser": "^4.0.2",
    "webpack": "^4.35.0"
  },
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.0.0",
    "@babel/types": "^7.4.4",
    "esutils": "^2.0.2"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\preset-react\package.json
============================================================
{
  "name": "@babel/preset-react",
  "version": "7.27.1",
  "description": "Babel preset for all React plugins.",
  "author": "The Babel Team (https://babel.dev/team)",
  "homepage": "https://babel.dev/docs/en/next/babel-preset-react",
  "bugs": "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20react%22+is%3Aopen",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-preset-react"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-validator-option": "^7.27.1",
    "@babel/plugin-transform-react-display-name": "^7.27.1",
    "@babel/plugin-transform-react-jsx": "^7.27.1",
    "@babel/plugin-transform-react-jsx-development": "^7.27.1",
    "@babel/plugin-transform-react-pure-annotations": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\runtime\helpers\esm\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\runtime\package.json
============================================================
{
  "name": "@babel/runtime",
  "version": "7.28.4",
  "description": "babel's modular runtime helpers",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-runtime"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-runtime",
  "author": "The Babel Team (https://babel.dev/team)",
  "exports": {
    "./helpers/OverloadYield": [
      {
        "node": "./helpers/OverloadYield.js",
        "import": "./helpers/esm/OverloadYield.js",
        "default": "./helpers/OverloadYield.js"
      },
      "./helpers/OverloadYield.js"
    ],
    "./helpers/esm/OverloadYield": "./helpers/esm/OverloadYield.js",
    "./helpers/applyDecoratedDescriptor": [
      {
        "node": "./helpers/applyDecoratedDescriptor.js",
        "import": "./helpers/esm/applyDecoratedDescriptor.js",
        "default": "./helpers/applyDecoratedDescriptor.js"
      },
      "./helpers/applyDecoratedDescriptor.js"
    ],
    "./helpers/esm/applyDecoratedDescriptor": "./helpers/esm/applyDecoratedDescriptor.js",
    "./helpers/applyDecs2311": [
      {
        "node": "./helpers/applyDecs2311.js",
        "import": "./helpers/esm/applyDecs2311.js",
        "default": "./helpers/applyDecs2311.js"
      },
      "./helpers/applyDecs2311.js"
    ],
    "./helpers/esm/applyDecs2311": "./helpers/esm/applyDecs2311.js",
    "./helpers/arrayLikeToArray": [
      {
        "node": "./helpers/arrayLikeToArray.js",
        "import": "./helpers/esm/arrayLikeToArray.js",
        "default": "./helpers/arrayLikeToArray.js"
      },
      "./helpers/arrayLikeToArray.js"
    ],
    "./helpers/esm/arrayLikeToArray": "./helpers/esm/arrayLikeToArray.js",
    "./helpers/arrayWithHoles": [
      {
        "node": "./helpers/arrayWithHoles.js",
        "import": "./helpers/esm/arrayWithHoles.js",
        "default": "./helpers/arrayWithHoles.js"
      },
      "./helpers/arrayWithHoles.js"
    ],
    "./helpers/esm/arrayWithHoles": "./helpers/esm/arrayWithHoles.js",
    "./helpers/arrayWithoutHoles": [
      {
        "node": "./helpers/arrayWithoutHoles.js",
        "import": "./helpers/esm/arrayWithoutHoles.js",
        "default": "./helpers/arrayWithoutHoles.js"
      },
      "./helpers/arrayWithoutHoles.js"
    ],
    "./helpers/esm/arrayWithoutHoles": "./helpers/esm/arrayWithoutHoles.js",
    "./helpers/assertClassBrand": [
      {
        "node": "./helpers/assertClassBrand.js",
        "import": "./helpers/esm/assertClassBrand.js",
        "default": "./helpers/assertClassBrand.js"
      },
      "./helpers/assertClassBrand.js"
    ],
    "./helpers/esm/assertClassBrand": "./helpers/esm/assertClassBrand.js",
    "./helpers/assertThisInitialized": [
      {
        "node": "./helpers/assertThisInitialized.js",
        "import": "./helpers/esm/assertThisInitialized.js",
        "default": "./helpers/assertThisInitialized.js"
      },
      "./helpers/assertThisInitialized.js"
    ],
    "./helpers/esm/assertThisInitialized": "./helpers/esm/assertThisInitialized.js",
    "./helpers/asyncGeneratorDelegate": [
      {
        "node": "./helpers/asyncGeneratorDelegate.js",
        "import": "./helpers/esm/asyncGeneratorDelegate.js",
        "default": "./helpers/asyncGeneratorDelegate.js"
      },
      "./helpers/asyncGeneratorDelegate.js"
    ],
    "./helpers/esm/asyncGeneratorDelegate": "./helpers/esm/asyncGeneratorDelegate.js",
    "./helpers/asyncIterator": [
      {
        "node": "./helpers/asyncIterator.js",
        "import": "./helpers/esm/asyncIterator.js",
        "default": "./helpers/asyncIterator.js"
      },
      "./helpers/asyncIterator.js"
    ],
    "./helpers/esm/asyncIterator": "./helpers/esm/asyncIterator.js",
    "./helpers/asyncToGenerator": [
      {
        "node": "./helpers/asyncToGenerator.js",
        "import": "./helpers/esm/asyncToGenerator.js",
        "default": "./helpers/asyncToGenerator.js"
      },
      "./helpers/asyncToGenerator.js"
    ],
    "./helpers/esm/asyncToGenerator": "./helpers/esm/asyncToGenerator.js",
    "./helpers/awaitAsyncGenerator": [
      {
        "node": "./helpers/awaitAsyncGenerator.js",
        "import": "./helpers/esm/awaitAsyncGenerator.js",
        "default": "./helpers/awaitAsyncGenerator.js"
      },
      "./helpers/awaitAsyncGenerator.js"
    ],
    "./helpers/esm/awaitAsyncGenerator": "./helpers/esm/awaitAsyncGenerator.js",
    "./helpers/callSuper": [
      {
        "node": "./helpers/callSuper.js",
        "import": "./helpers/esm/callSuper.js",
        "default": "./helpers/callSuper.js"
      },
      "./helpers/callSuper.js"
    ],
    "./helpers/esm/callSuper": "./helpers/esm/callSuper.js",
    "./helpers/checkInRHS": [
      {
        "node": "./helpers/checkInRHS.js",
        "import": "./helpers/esm/checkInRHS.js",
        "default": "./helpers/checkInRHS.js"
      },
      "./helpers/checkInRHS.js"
    ],
    "./helpers/esm/checkInRHS": "./helpers/esm/checkInRHS.js",
    "./helpers/checkPrivateRedeclaration": [
      {
        "node": "./helpers/checkPrivateRedeclaration.js",
        "import": "./helpers/esm/checkPrivateRedeclaration.js",
        "default": "./helpers/checkPrivateRedeclaration.js"
      },
      "./helpers/checkPrivateRedeclaration.js"
    ],
    "./helpers/esm/checkPrivateRedeclaration": "./helpers/esm/checkPrivateRedeclaration.js",
    "./helpers/classCallCheck": [
      {
        "node": "./helpers/classCallCheck.js",
        "import": "./helpers/esm/classCallCheck.js",
        "default": "./helpers/classCallCheck.js"
      },
      "./helpers/classCallCheck.js"
    ],
    "./helpers/esm/classCallCheck": "./helpers/esm/classCallCheck.js",
    "./helpers/classNameTDZError": [
      {
        "node": "./helpers/classNameTDZError.js",
        "import": "./helpers/esm/classNameTDZError.js",
        "default": "./helpers/classNameTDZError.js"
      },
      "./helpers/classNameTDZError.js"
    ],
    "./helpers/esm/classNameTDZError": "./helpers/esm/classNameTDZError.js",
    "./helpers/classPrivateFieldGet2": [
      {
        "node": "./helpers/classPrivateFieldGet2.js",
        "import": "./helpers/esm/classPrivateFieldGet2.js",
        "default": "./helpers/classPrivateFieldGet2.js"
      },
      "./helpers/classPrivateFieldGet2.js"
    ],
    "./helpers/esm/classPrivateFieldGet2": "./helpers/esm/classPrivateFieldGet2.js",
    "./helpers/classPrivateFieldInitSpec": [
      {
        "node": "./helpers/classPrivateFieldInitSpec.js",
        "import": "./helpers/esm/classPrivateFieldInitSpec.js",
        "default": "./helpers/classPrivateFieldInitSpec.js"
      },
      "./helpers/classPrivateFieldInitSpec.js"
    ],
    "./helpers/esm/classPrivateFieldInitSpec": "./helpers/esm/classPrivateFieldInitSpec.js",
    "./helpers/classPrivateFieldLooseBase": [
      {
        "node": "./helpers/classPrivateFieldLooseBase.js",
        "import": "./helpers/esm/classPrivateFieldLooseBase.js",
        "default": "./helpers/classPrivateFieldLooseBase.js"
      },
      "./helpers/classPrivateFieldLooseBase.js"
    ],
    "./helpers/esm/classPrivateFieldLooseBase": "./helpers/esm/classPrivateFieldLooseBase.js",
    "./helpers/classPrivateFieldLooseKey": [
      {
        "node": "./helpers/classPrivateFieldLooseKey.js",
        "import": "./helpers/esm/classPrivateFieldLooseKey.js",
        "default": "./helpers/classPrivateFieldLooseKey.js"
      },
      "./helpers/classPrivateFieldLooseKey.js"
    ],
    "./helpers/esm/classPrivateFieldLooseKey": "./helpers/esm/classPrivateFieldLooseKey.js",
    "./helpers/classPrivateFieldSet2": [
      {
        "node": "./helpers/classPrivateFieldSet2.js",
        "import": "./helpers/esm/classPrivateFieldSet2.js",
        "default": "./helpers/classPrivateFieldSet2.js"
      },
      "./helpers/classPrivateFieldSet2.js"
    ],
    "./helpers/esm/classPrivateFieldSet2": "./helpers/esm/classPrivateFieldSet2.js",
    "./helpers/classPrivateGetter": [
      {
        "node": "./helpers/classPrivateGetter.js",
        "import": "./helpers/esm/classPrivateGetter.js",
        "default": "./helpers/classPrivateGetter.js"
      },
      "./helpers/classPrivateGetter.js"
    ],
    "./helpers/esm/classPrivateGetter": "./helpers/esm/classPrivateGetter.js",
    "./helpers/classPrivateMethodInitSpec": [
      {
        "node": "./helpers/classPrivateMethodInitSpec.js",
        "import": "./helpers/esm/classPrivateMethodInitSpec.js",
        "default": "./helpers/classPrivateMethodInitSpec.js"
      },
      "./helpers/classPrivateMethodInitSpec.js"
    ],
    "./helpers/esm/classPrivateMethodInitSpec": "./helpers/esm/classPrivateMethodInitSpec.js",
    "./helpers/classPrivateSetter": [
      {
        "node": "./helpers/classPrivateSetter.js",
        "import": "./helpers/esm/classPrivateSetter.js",
        "default": "./helpers/classPrivateSetter.js"
      },
      "./helpers/classPrivateSetter.js"
    ],
    "./helpers/esm/classPrivateSetter": "./helpers/esm/classPrivateSetter.js",
    "./helpers/classStaticPrivateMethodGet": [
      {
        "node": "./helpers/classStaticPrivateMethodGet.js",
        "import": "./helpers/esm/classStaticPrivateMethodGet.js",
        "default": "./helpers/classStaticPrivateMethodGet.js"
      },
      "./helpers/classStaticPrivateMethodGet.js"
    ],
    "./helpers/esm/classStaticPrivateMethodGet": "./helpers/esm/classStaticPrivateMethodGet.js",
    "./helpers/construct": [
      {
        "node": "./helpers/construct.js",
        "import": "./helpers/esm/construct.js",
        "default": "./helpers/construct.js"
      },
      "./helpers/construct.js"
    ],
    "./helpers/esm/construct": "./helpers/esm/construct.js",
    "./helpers/createClass": [
      {
        "node": "./helpers/createClass.js",
        "import": "./helpers/esm/createClass.js",
        "default": "./helpers/createClass.js"
      },
      "./helpers/createClass.js"
    ],
    "./helpers/esm/createClass": "./helpers/esm/createClass.js",
    "./helpers/createForOfIteratorHelper": [
      {
        "node": "./helpers/createForOfIteratorHelper.js",
        "import": "./helpers/esm/createForOfIteratorHelper.js",
        "default": "./helpers/createForOfIteratorHelper.js"
      },
      "./helpers/createForOfIteratorHelper.js"
    ],
    "./helpers/esm/createForOfIteratorHelper": "./helpers/esm/createForOfIteratorHelper.js",
    "./helpers/createForOfIteratorHelperLoose": [
      {
        "node": "./helpers/createForOfIteratorHelperLoose.js",
        "import": "./helpers/esm/createForOfIteratorHelperLoose.js",
        "default": "./helpers/createForOfIteratorHelperLoose.js"
      },
      "./helpers/createForOfIteratorHelperLoose.js"
    ],
    "./helpers/esm/createForOfIteratorHelperLoose": "./helpers/esm/createForOfIteratorHelperLoose.js",
    "./helpers/createSuper": [
      {
        "node": "./helpers/createSuper.js",
        "import": "./helpers/esm/createSuper.js",
        "default": "./helpers/createSuper.js"
      },
      "./helpers/createSuper.js"
    ],
    "./helpers/esm/createSuper": "./helpers/esm/createSuper.js",
    "./helpers/decorate": [
      {
        "node": "./helpers/decorate.js",
        "import": "./helpers/esm/decorate.js",
        "default": "./helpers/decorate.js"
      },
      "./helpers/decorate.js"
    ],
    "./helpers/esm/decorate": "./helpers/esm/decorate.js",
    "./helpers/defaults": [
      {
        "node": "./helpers/defaults.js",
        "import": "./helpers/esm/defaults.js",
        "default": "./helpers/defaults.js"
      },
      "./helpers/defaults.js"
    ],
    "./helpers/esm/defaults": "./helpers/esm/defaults.js",
    "./helpers/defineAccessor": [
      {
        "node": "./helpers/defineAccessor.js",
        "import": "./helpers/esm/defineAccessor.js",
        "default": "./helpers/defineAccessor.js"
      },
      "./helpers/defineAccessor.js"
    ],
    "./helpers/esm/defineAccessor": "./helpers/esm/defineAccessor.js",
    "./helpers/defineProperty": [
      {
        "node": "./helpers/defineProperty.js",
        "import": "./helpers/esm/defineProperty.js",
        "default": "./helpers/defineProperty.js"
      },
      "./helpers/defineProperty.js"
    ],
    "./helpers/esm/defineProperty": "./helpers/esm/defineProperty.js",
    "./helpers/extends": [
      {
        "node": "./helpers/extends.js",
        "import": "./helpers/esm/extends.js",
        "default": "./helpers/extends.js"
      },
      "./helpers/extends.js"
    ],
    "./helpers/esm/extends": "./helpers/esm/extends.js",
    "./helpers/get": [
      {
        "node": "./helpers/get.js",
        "import": "./helpers/esm/get.js",
        "default": "./helpers/get.js"
      },
      "./helpers/get.js"
    ],
    "./helpers/esm/get": "./helpers/esm/get.js",
    "./helpers/getPrototypeOf": [
      {
        "node": "./helpers/getPrototypeOf.js",
        "import": "./helpers/esm/getPrototypeOf.js",
        "default": "./helpers/getPrototypeOf.js"
      },
      "./helpers/getPrototypeOf.js"
    ],
    "./helpers/esm/getPrototypeOf": "./helpers/esm/getPrototypeOf.js",
    "./helpers/identity": [
      {
        "node": "./helpers/identity.js",
        "import": "./helpers/esm/identity.js",
        "default": "./helpers/identity.js"
      },
      "./helpers/identity.js"
    ],
    "./helpers/esm/identity": "./helpers/esm/identity.js",
    "./helpers/importDeferProxy": [
      {
        "node": "./helpers/importDeferProxy.js",
        "import": "./helpers/esm/importDeferProxy.js",
        "default": "./helpers/importDeferProxy.js"
      },
      "./helpers/importDeferProxy.js"
    ],
    "./helpers/esm/importDeferProxy": "./helpers/esm/importDeferProxy.js",
    "./helpers/inherits": [
      {
        "node": "./helpers/inherits.js",
        "import": "./helpers/esm/inherits.js",
        "default": "./helpers/inherits.js"
      },
      "./helpers/inherits.js"
    ],
    "./helpers/esm/inherits": "./helpers/esm/inherits.js",
    "./helpers/inheritsLoose": [
      {
        "node": "./helpers/inheritsLoose.js",
        "import": "./helpers/esm/inheritsLoose.js",
        "default": "./helpers/inheritsLoose.js"
      },
      "./helpers/inheritsLoose.js"
    ],
    "./helpers/esm/inheritsLoose": "./helpers/esm/inheritsLoose.js",
    "./helpers/initializerDefineProperty": [
      {
        "node": "./helpers/initializerDefineProperty.js",
        "import": "./helpers/esm/initializerDefineProperty.js",
        "default": "./helpers/initializerDefineProperty.js"
      },
      "./helpers/initializerDefineProperty.js"
    ],
    "./helpers/esm/initializerDefineProperty": "./helpers/esm/initializerDefineProperty.js",
    "./helpers/initializerWarningHelper": [
      {
        "node": "./helpers/initializerWarningHelper.js",
        "import": "./helpers/esm/initializerWarningHelper.js",
        "default": "./helpers/initializerWarningHelper.js"
      },
      "./helpers/initializerWarningHelper.js"
    ],
    "./helpers/esm/initializerWarningHelper": "./helpers/esm/initializerWarningHelper.js",
    "./helpers/instanceof": [
      {
        "node": "./helpers/instanceof.js",
        "import": "./helpers/esm/instanceof.js",
        "default": "./helpers/instanceof.js"
      },
      "./helpers/instanceof.js"
    ],
    "./helpers/esm/instanceof": "./helpers/esm/instanceof.js",
    "./helpers/interopRequireDefault": [
      {
        "node": "./helpers/interopRequireDefault.js",
        "import": "./helpers/esm/interopRequireDefault.js",
        "default": "./helpers/interopRequireDefault.js"
      },
      "./helpers/interopRequireDefault.js"
    ],
    "./helpers/esm/interopRequireDefault": "./helpers/esm/interopRequireDefault.js",
    "./helpers/interopRequireWildcard": [
      {
        "node": "./helpers/interopRequireWildcard.js",
        "import": "./helpers/esm/interopRequireWildcard.js",
        "default": "./helpers/interopRequireWildcard.js"
      },
      "./helpers/interopRequireWildcard.js"
    ],
    "./helpers/esm/interopRequireWildcard": "./helpers/esm/interopRequireWildcard.js",
    "./helpers/isNativeFunction": [
      {
        "node": "./helpers/isNativeFunction.js",
        "import": "./helpers/esm/isNativeFunction.js",
        "default": "./helpers/isNativeFunction.js"
      },
      "./helpers/isNativeFunction.js"
    ],
    "./helpers/esm/isNativeFunction": "./helpers/esm/isNativeFunction.js",
    "./helpers/isNativeReflectConstruct": [
      {
        "node": "./helpers/isNativeReflectConstruct.js",
        "import": "./helpers/esm/isNativeReflectConstruct.js",
        "default": "./helpers/isNativeReflectConstruct.js"
      },
      "./helpers/isNativeReflectConstruct.js"
    ],
    "./helpers/esm/isNativeReflectConstruct": "./helpers/esm/isNativeReflectConstruct.js",
    "./helpers/iterableToArray": [
      {
        "node": "./helpers/iterableToArray.js",
        "import": "./helpers/esm/iterableToArray.js",
        "default": "./helpers/iterableToArray.js"
      },
      "./helpers/iterableToArray.js"
    ],
    "./helpers/esm/iterableToArray": "./helpers/esm/iterableToArray.js",
    "./helpers/iterableToArrayLimit": [
      {
        "node": "./helpers/iterableToArrayLimit.js",
        "import": "./helpers/esm/iterableToArrayLimit.js",
        "default": "./helpers/iterableToArrayLimit.js"
      },
      "./helpers/iterableToArrayLimit.js"
    ],
    "./helpers/esm/iterableToArrayLimit": "./helpers/esm/iterableToArrayLimit.js",
    "./helpers/jsx": [
      {
        "node": "./helpers/jsx.js",
        "import": "./helpers/esm/jsx.js",
        "default": "./helpers/jsx.js"
      },
      "./helpers/jsx.js"
    ],
    "./helpers/esm/jsx": "./helpers/esm/jsx.js",
    "./helpers/maybeArrayLike": [
      {
        "node": "./helpers/maybeArrayLike.js",
        "import": "./helpers/esm/maybeArrayLike.js",
        "default": "./helpers/maybeArrayLike.js"
      },
      "./helpers/maybeArrayLike.js"
    ],
    "./helpers/esm/maybeArrayLike": "./helpers/esm/maybeArrayLike.js",
    "./helpers/newArrowCheck": [
      {
        "node": "./helpers/newArrowCheck.js",
        "import": "./helpers/esm/newArrowCheck.js",
        "default": "./helpers/newArrowCheck.js"
      },
      "./helpers/newArrowCheck.js"
    ],
    "./helpers/esm/newArrowCheck": "./helpers/esm/newArrowCheck.js",
    "./helpers/nonIterableRest": [
      {
        "node": "./helpers/nonIterableRest.js",
        "import": "./helpers/esm/nonIterableRest.js",
        "default": "./helpers/nonIterableRest.js"
      },
      "./helpers/nonIterableRest.js"
    ],
    "./helpers/esm/nonIterableRest": "./helpers/esm/nonIterableRest.js",
    "./helpers/nonIterableSpread": [
      {
        "node": "./helpers/nonIterableSpread.js",
        "import": "./helpers/esm/nonIterableSpread.js",
        "default": "./helpers/nonIterableSpread.js"
      },
      "./helpers/nonIterableSpread.js"
    ],
    "./helpers/esm/nonIterableSpread": "./helpers/esm/nonIterableSpread.js",
    "./helpers/nullishReceiverError": [
      {
        "node": "./helpers/nullishReceiverError.js",
        "import": "./helpers/esm/nullishReceiverError.js",
        "default": "./helpers/nullishReceiverError.js"
      },
      "./helpers/nullishReceiverError.js"
    ],
    "./helpers/esm/nullishReceiverError": "./helpers/esm/nullishReceiverError.js",
    "./helpers/objectDestructuringEmpty": [
      {
        "node": "./helpers/objectDestructuringEmpty.js",
        "import": "./helpers/esm/objectDestructuringEmpty.js",
        "default": "./helpers/objectDestructuringEmpty.js"
      },
      "./helpers/objectDestructuringEmpty.js"
    ],
    "./helpers/esm/objectDestructuringEmpty": "./helpers/esm/objectDestructuringEmpty.js",
    "./helpers/objectSpread2": [
      {
        "node": "./helpers/objectSpread2.js",
        "import": "./helpers/esm/objectSpread2.js",
        "default": "./helpers/objectSpread2.js"
      },
      "./helpers/objectSpread2.js"
    ],
    "./helpers/esm/objectSpread2": "./helpers/esm/objectSpread2.js",
    "./helpers/objectWithoutProperties": [
      {
        "node": "./helpers/objectWithoutProperties.js",
        "import": "./helpers/esm/objectWithoutProperties.js",
        "default": "./helpers/objectWithoutProperties.js"
      },
      "./helpers/objectWithoutProperties.js"
    ],
    "./helpers/esm/objectWithoutProperties": "./helpers/esm/objectWithoutProperties.js",
    "./helpers/objectWithoutPropertiesLoose": [
      {
        "node": "./helpers/objectWithoutPropertiesLoose.js",
        "import": "./helpers/esm/objectWithoutPropertiesLoose.js",
        "default": "./helpers/objectWithoutPropertiesLoose.js"
      },
      "./helpers/objectWithoutPropertiesLoose.js"
    ],
    "./helpers/esm/objectWithoutPropertiesLoose": "./helpers/esm/objectWithoutPropertiesLoose.js",
    "./helpers/possibleConstructorReturn": [
      {
        "node": "./helpers/possibleConstructorReturn.js",
        "import": "./helpers/esm/possibleConstructorReturn.js",
        "default": "./helpers/possibleConstructorReturn.js"
      },
      "./helpers/possibleConstructorReturn.js"
    ],
    "./helpers/esm/possibleConstructorReturn": "./helpers/esm/possibleConstructorReturn.js",
    "./helpers/readOnlyError": [
      {
        "node": "./helpers/readOnlyError.js",
        "import": "./helpers/esm/readOnlyError.js",
        "default": "./helpers/readOnlyError.js"
      },
      "./helpers/readOnlyError.js"
    ],
    "./helpers/esm/readOnlyError": "./helpers/esm/readOnlyError.js",
    "./helpers/regenerator": [
      {
        "node": "./helpers/regenerator.js",
        "import": "./helpers/esm/regenerator.js",
        "default": "./helpers/regenerator.js"
      },
      "./helpers/regenerator.js"
    ],
    "./helpers/esm/regenerator": "./helpers/esm/regenerator.js",
    "./helpers/regeneratorAsync": [
      {
        "node": "./helpers/regeneratorAsync.js",
        "import": "./helpers/esm/regeneratorAsync.js",
        "default": "./helpers/regeneratorAsync.js"
      },
      "./helpers/regeneratorAsync.js"
    ],
    "./helpers/esm/regeneratorAsync": "./helpers/esm/regeneratorAsync.js",
    "./helpers/regeneratorAsyncGen": [
      {
        "node": "./helpers/regeneratorAsyncGen.js",
        "import": "./helpers/esm/regeneratorAsyncGen.js",
        "default": "./helpers/regeneratorAsyncGen.js"
      },
      "./helpers/regeneratorAsyncGen.js"
    ],
    "./helpers/esm/regeneratorAsyncGen": "./helpers/esm/regeneratorAsyncGen.js",
    "./helpers/regeneratorKeys": [
      {
        "node": "./helpers/regeneratorKeys.js",
        "import": "./helpers/esm/regeneratorKeys.js",
        "default": "./helpers/regeneratorKeys.js"
      },
      "./helpers/regeneratorKeys.js"
    ],
    "./helpers/esm/regeneratorKeys": "./helpers/esm/regeneratorKeys.js",
    "./helpers/regeneratorValues": [
      {
        "node": "./helpers/regeneratorValues.js",
        "import": "./helpers/esm/regeneratorValues.js",
        "default": "./helpers/regeneratorValues.js"
      },
      "./helpers/regeneratorValues.js"
    ],
    "./helpers/esm/regeneratorValues": "./helpers/esm/regeneratorValues.js",
    "./helpers/set": [
      {
        "node": "./helpers/set.js",
        "import": "./helpers/esm/set.js",
        "default": "./helpers/set.js"
      },
      "./helpers/set.js"
    ],
    "./helpers/esm/set": "./helpers/esm/set.js",
    "./helpers/setFunctionName": [
      {
        "node": "./helpers/setFunctionName.js",
        "import": "./helpers/esm/setFunctionName.js",
        "default": "./helpers/setFunctionName.js"
      },
      "./helpers/setFunctionName.js"
    ],
    "./helpers/esm/setFunctionName": "./helpers/esm/setFunctionName.js",
    "./helpers/setPrototypeOf": [
      {
        "node": "./helpers/setPrototypeOf.js",
        "import": "./helpers/esm/setPrototypeOf.js",
        "default": "./helpers/setPrototypeOf.js"
      },
      "./helpers/setPrototypeOf.js"
    ],
    "./helpers/esm/setPrototypeOf": "./helpers/esm/setPrototypeOf.js",
    "./helpers/skipFirstGeneratorNext": [
      {
        "node": "./helpers/skipFirstGeneratorNext.js",
        "import": "./helpers/esm/skipFirstGeneratorNext.js",
        "default": "./helpers/skipFirstGeneratorNext.js"
      },
      "./helpers/skipFirstGeneratorNext.js"
    ],
    "./helpers/esm/skipFirstGeneratorNext": "./helpers/esm/skipFirstGeneratorNext.js",
    "./helpers/slicedToArray": [
      {
        "node": "./helpers/slicedToArray.js",
        "import": "./helpers/esm/slicedToArray.js",
        "default": "./helpers/slicedToArray.js"
      },
      "./helpers/slicedToArray.js"
    ],
    "./helpers/esm/slicedToArray": "./helpers/esm/slicedToArray.js",
    "./helpers/superPropBase": [
      {
        "node": "./helpers/superPropBase.js",
        "import": "./helpers/esm/superPropBase.js",
        "default": "./helpers/superPropBase.js"
      },
      "./helpers/superPropBase.js"
    ],
    "./helpers/esm/superPropBase": "./helpers/esm/superPropBase.js",
    "./helpers/superPropGet": [
      {
        "node": "./helpers/superPropGet.js",
        "import": "./helpers/esm/superPropGet.js",
        "default": "./helpers/superPropGet.js"
      },
      "./helpers/superPropGet.js"
    ],
    "./helpers/esm/superPropGet": "./helpers/esm/superPropGet.js",
    "./helpers/superPropSet": [
      {
        "node": "./helpers/superPropSet.js",
        "import": "./helpers/esm/superPropSet.js",
        "default": "./helpers/superPropSet.js"
      },
      "./helpers/superPropSet.js"
    ],
    "./helpers/esm/superPropSet": "./helpers/esm/superPropSet.js",
    "./helpers/taggedTemplateLiteral": [
      {
        "node": "./helpers/taggedTemplateLiteral.js",
        "import": "./helpers/esm/taggedTemplateLiteral.js",
        "default": "./helpers/taggedTemplateLiteral.js"
      },
      "./helpers/taggedTemplateLiteral.js"
    ],
    "./helpers/esm/taggedTemplateLiteral": "./helpers/esm/taggedTemplateLiteral.js",
    "./helpers/taggedTemplateLiteralLoose": [
      {
        "node": "./helpers/taggedTemplateLiteralLoose.js",
        "import": "./helpers/esm/taggedTemplateLiteralLoose.js",
        "default": "./helpers/taggedTemplateLiteralLoose.js"
      },
      "./helpers/taggedTemplateLiteralLoose.js"
    ],
    "./helpers/esm/taggedTemplateLiteralLoose": "./helpers/esm/taggedTemplateLiteralLoose.js",
    "./helpers/tdz": [
      {
        "node": "./helpers/tdz.js",
        "import": "./helpers/esm/tdz.js",
        "default": "./helpers/tdz.js"
      },
      "./helpers/tdz.js"
    ],
    "./helpers/esm/tdz": "./helpers/esm/tdz.js",
    "./helpers/temporalRef": [
      {
        "node": "./helpers/temporalRef.js",
        "import": "./helpers/esm/temporalRef.js",
        "default": "./helpers/temporalRef.js"
      },
      "./helpers/temporalRef.js"
    ],
    "./helpers/esm/temporalRef": "./helpers/esm/temporalRef.js",
    "./helpers/temporalUndefined": [
      {
        "node": "./helpers/temporalUndefined.js",
        "import": "./helpers/esm/temporalUndefined.js",
        "default": "./helpers/temporalUndefined.js"
      },
      "./helpers/temporalUndefined.js"
    ],
    "./helpers/esm/temporalUndefined": "./helpers/esm/temporalUndefined.js",
    "./helpers/toArray": [
      {
        "node": "./helpers/toArray.js",
        "import": "./helpers/esm/toArray.js",
        "default": "./helpers/toArray.js"
      },
      "./helpers/toArray.js"
    ],
    "./helpers/esm/toArray": "./helpers/esm/toArray.js",
    "./helpers/toConsumableArray": [
      {
        "node": "./helpers/toConsumableArray.js",
        "import": "./helpers/esm/toConsumableArray.js",
        "default": "./helpers/toConsumableArray.js"
      },
      "./helpers/toConsumableArray.js"
    ],
    "./helpers/esm/toConsumableArray": "./helpers/esm/toConsumableArray.js",
    "./helpers/toPrimitive": [
      {
        "node": "./helpers/toPrimitive.js",
        "import": "./helpers/esm/toPrimitive.js",
        "default": "./helpers/toPrimitive.js"
      },
      "./helpers/toPrimitive.js"
    ],
    "./helpers/esm/toPrimitive": "./helpers/esm/toPrimitive.js",
    "./helpers/toPropertyKey": [
      {
        "node": "./helpers/toPropertyKey.js",
        "import": "./helpers/esm/toPropertyKey.js",
        "default": "./helpers/toPropertyKey.js"
      },
      "./helpers/toPropertyKey.js"
    ],
    "./helpers/esm/toPropertyKey": "./helpers/esm/toPropertyKey.js",
    "./helpers/toSetter": [
      {
        "node": "./helpers/toSetter.js",
        "import": "./helpers/esm/toSetter.js",
        "default": "./helpers/toSetter.js"
      },
      "./helpers/toSetter.js"
    ],
    "./helpers/esm/toSetter": "./helpers/esm/toSetter.js",
    "./helpers/tsRewriteRelativeImportExtensions": [
      {
        "node": "./helpers/tsRewriteRelativeImportExtensions.js",
        "import": "./helpers/esm/tsRewriteRelativeImportExtensions.js",
        "default": "./helpers/tsRewriteRelativeImportExtensions.js"
      },
      "./helpers/tsRewriteRelativeImportExtensions.js"
    ],
    "./helpers/esm/tsRewriteRelativeImportExtensions": "./helpers/esm/tsRewriteRelativeImportExtensions.js",
    "./helpers/typeof": [
      {
        "node": "./helpers/typeof.js",
        "import": "./helpers/esm/typeof.js",
        "default": "./helpers/typeof.js"
      },
      "./helpers/typeof.js"
    ],
    "./helpers/esm/typeof": "./helpers/esm/typeof.js",
    "./helpers/unsupportedIterableToArray": [
      {
        "node": "./helpers/unsupportedIterableToArray.js",
        "import": "./helpers/esm/unsupportedIterableToArray.js",
        "default": "./helpers/unsupportedIterableToArray.js"
      },
      "./helpers/unsupportedIterableToArray.js"
    ],
    "./helpers/esm/unsupportedIterableToArray": "./helpers/esm/unsupportedIterableToArray.js",
    "./helpers/usingCtx": [
      {
        "node": "./helpers/usingCtx.js",
        "import": "./helpers/esm/usingCtx.js",
        "default": "./helpers/usingCtx.js"
      },
      "./helpers/usingCtx.js"
    ],
    "./helpers/esm/usingCtx": "./helpers/esm/usingCtx.js",
    "./helpers/wrapAsyncGenerator": [
      {
        "node": "./helpers/wrapAsyncGenerator.js",
        "import": "./helpers/esm/wrapAsyncGenerator.js",
        "default": "./helpers/wrapAsyncGenerator.js"
      },
      "./helpers/wrapAsyncGenerator.js"
    ],
    "./helpers/esm/wrapAsyncGenerator": "./helpers/esm/wrapAsyncGenerator.js",
    "./helpers/wrapNativeSuper": [
      {
        "node": "./helpers/wrapNativeSuper.js",
        "import": "./helpers/esm/wrapNativeSuper.js",
        "default": "./helpers/wrapNativeSuper.js"
      },
      "./helpers/wrapNativeSuper.js"
    ],
    "./helpers/esm/wrapNativeSuper": "./helpers/esm/wrapNativeSuper.js",
    "./helpers/wrapRegExp": [
      {
        "node": "./helpers/wrapRegExp.js",
        "import": "./helpers/esm/wrapRegExp.js",
        "default": "./helpers/wrapRegExp.js"
      },
      "./helpers/wrapRegExp.js"
    ],
    "./helpers/esm/wrapRegExp": "./helpers/esm/wrapRegExp.js",
    "./helpers/writeOnlyError": [
      {
        "node": "./helpers/writeOnlyError.js",
        "import": "./helpers/esm/writeOnlyError.js",
        "default": "./helpers/writeOnlyError.js"
      },
      "./helpers/writeOnlyError.js"
    ],
    "./helpers/esm/writeOnlyError": "./helpers/esm/writeOnlyError.js",
    "./helpers/AwaitValue": [
      {
        "node": "./helpers/AwaitValue.js",
        "import": "./helpers/esm/AwaitValue.js",
        "default": "./helpers/AwaitValue.js"
      },
      "./helpers/AwaitValue.js"
    ],
    "./helpers/esm/AwaitValue": "./helpers/esm/AwaitValue.js",
    "./helpers/applyDecs": [
      {
        "node": "./helpers/applyDecs.js",
        "import": "./helpers/esm/applyDecs.js",
        "default": "./helpers/applyDecs.js"
      },
      "./helpers/applyDecs.js"
    ],
    "./helpers/esm/applyDecs": "./helpers/esm/applyDecs.js",
    "./helpers/applyDecs2203": [
      {
        "node": "./helpers/applyDecs2203.js",
        "import": "./helpers/esm/applyDecs2203.js",
        "default": "./helpers/applyDecs2203.js"
      },
      "./helpers/applyDecs2203.js"
    ],
    "./helpers/esm/applyDecs2203": "./helpers/esm/applyDecs2203.js",
    "./helpers/applyDecs2203R": [
      {
        "node": "./helpers/applyDecs2203R.js",
        "import": "./helpers/esm/applyDecs2203R.js",
        "default": "./helpers/applyDecs2203R.js"
      },
      "./helpers/applyDecs2203R.js"
    ],
    "./helpers/esm/applyDecs2203R": "./helpers/esm/applyDecs2203R.js",
    "./helpers/applyDecs2301": [
      {
        "node": "./helpers/applyDecs2301.js",
        "import": "./helpers/esm/applyDecs2301.js",
        "default": "./helpers/applyDecs2301.js"
      },
      "./helpers/applyDecs2301.js"
    ],
    "./helpers/esm/applyDecs2301": "./helpers/esm/applyDecs2301.js",
    "./helpers/applyDecs2305": [
      {
        "node": "./helpers/applyDecs2305.js",
        "import": "./helpers/esm/applyDecs2305.js",
        "default": "./helpers/applyDecs2305.js"
      },
      "./helpers/applyDecs2305.js"
    ],
    "./helpers/esm/applyDecs2305": "./helpers/esm/applyDecs2305.js",
    "./helpers/classApplyDescriptorDestructureSet": [
      {
        "node": "./helpers/classApplyDescriptorDestructureSet.js",
        "import": "./helpers/esm/classApplyDescriptorDestructureSet.js",
        "default": "./helpers/classApplyDescriptorDestructureSet.js"
      },
      "./helpers/classApplyDescriptorDestructureSet.js"
    ],
    "./helpers/esm/classApplyDescriptorDestructureSet": "./helpers/esm/classApplyDescriptorDestructureSet.js",
    "./helpers/classApplyDescriptorGet": [
      {
        "node": "./helpers/classApplyDescriptorGet.js",
        "import": "./helpers/esm/classApplyDescriptorGet.js",
        "default": "./helpers/classApplyDescriptorGet.js"
      },
      "./helpers/classApplyDescriptorGet.js"
    ],
    "./helpers/esm/classApplyDescriptorGet": "./helpers/esm/classApplyDescriptorGet.js",
    "./helpers/classApplyDescriptorSet": [
      {
        "node": "./helpers/classApplyDescriptorSet.js",
        "import": "./helpers/esm/classApplyDescriptorSet.js",
        "default": "./helpers/classApplyDescriptorSet.js"
      },
      "./helpers/classApplyDescriptorSet.js"
    ],
    "./helpers/esm/classApplyDescriptorSet": "./helpers/esm/classApplyDescriptorSet.js",
    "./helpers/classCheckPrivateStaticAccess": [
      {
        "node": "./helpers/classCheckPrivateStaticAccess.js",
        "import": "./helpers/esm/classCheckPrivateStaticAccess.js",
        "default": "./helpers/classCheckPrivateStaticAccess.js"
      },
      "./helpers/classCheckPrivateStaticAccess.js"
    ],
    "./helpers/esm/classCheckPrivateStaticAccess": "./helpers/esm/classCheckPrivateStaticAccess.js",
    "./helpers/classCheckPrivateStaticFieldDescriptor": [
      {
        "node": "./helpers/classCheckPrivateStaticFieldDescriptor.js",
        "import": "./helpers/esm/classCheckPrivateStaticFieldDescriptor.js",
        "default": "./helpers/classCheckPrivateStaticFieldDescriptor.js"
      },
      "./helpers/classCheckPrivateStaticFieldDescriptor.js"
    ],
    "./helpers/esm/classCheckPrivateStaticFieldDescriptor": "./helpers/esm/classCheckPrivateStaticFieldDescriptor.js",
    "./helpers/classExtractFieldDescriptor": [
      {
        "node": "./helpers/classExtractFieldDescriptor.js",
        "import": "./helpers/esm/classExtractFieldDescriptor.js",
        "default": "./helpers/classExtractFieldDescriptor.js"
      },
      "./helpers/classExtractFieldDescriptor.js"
    ],
    "./helpers/esm/classExtractFieldDescriptor": "./helpers/esm/classExtractFieldDescriptor.js",
    "./helpers/classPrivateFieldDestructureSet": [
      {
        "node": "./helpers/classPrivateFieldDestructureSet.js",
        "import": "./helpers/esm/classPrivateFieldDestructureSet.js",
        "default": "./helpers/classPrivateFieldDestructureSet.js"
      },
      "./helpers/classPrivateFieldDestructureSet.js"
    ],
    "./helpers/esm/classPrivateFieldDestructureSet": "./helpers/esm/classPrivateFieldDestructureSet.js",
    "./helpers/classPrivateFieldGet": [
      {
        "node": "./helpers/classPrivateFieldGet.js",
        "import": "./helpers/esm/classPrivateFieldGet.js",
        "default": "./helpers/classPrivateFieldGet.js"
      },
      "./helpers/classPrivateFieldGet.js"
    ],
    "./helpers/esm/classPrivateFieldGet": "./helpers/esm/classPrivateFieldGet.js",
    "./helpers/classPrivateFieldSet": [
      {
        "node": "./helpers/classPrivateFieldSet.js",
        "import": "./helpers/esm/classPrivateFieldSet.js",
        "default": "./helpers/classPrivateFieldSet.js"
      },
      "./helpers/classPrivateFieldSet.js"
    ],
    "./helpers/esm/classPrivateFieldSet": "./helpers/esm/classPrivateFieldSet.js",
    "./helpers/classPrivateMethodGet": [
      {
        "node": "./helpers/classPrivateMethodGet.js",
        "import": "./helpers/esm/classPrivateMethodGet.js",
        "default": "./helpers/classPrivateMethodGet.js"
      },
      "./helpers/classPrivateMethodGet.js"
    ],
    "./helpers/esm/classPrivateMethodGet": "./helpers/esm/classPrivateMethodGet.js",
    "./helpers/classPrivateMethodSet": [
      {
        "node": "./helpers/classPrivateMethodSet.js",
        "import": "./helpers/esm/classPrivateMethodSet.js",
        "default": "./helpers/classPrivateMethodSet.js"
      },
      "./helpers/classPrivateMethodSet.js"
    ],
    "./helpers/esm/classPrivateMethodSet": "./helpers/esm/classPrivateMethodSet.js",
    "./helpers/classStaticPrivateFieldDestructureSet": [
      {
        "node": "./helpers/classStaticPrivateFieldDestructureSet.js",
        "import": "./helpers/esm/classStaticPrivateFieldDestructureSet.js",
        "default": "./helpers/classStaticPrivateFieldDestructureSet.js"
      },
      "./helpers/classStaticPrivateFieldDestructureSet.js"
    ],
    "./helpers/esm/classStaticPrivateFieldDestructureSet": "./helpers/esm/classStaticPrivateFieldDestructureSet.js",
    "./helpers/classStaticPrivateFieldSpecGet": [
      {
        "node": "./helpers/classStaticPrivateFieldSpecGet.js",
        "import": "./helpers/esm/classStaticPrivateFieldSpecGet.js",
        "default": "./helpers/classStaticPrivateFieldSpecGet.js"
      },
      "./helpers/classStaticPrivateFieldSpecGet.js"
    ],
    "./helpers/esm/classStaticPrivateFieldSpecGet": "./helpers/esm/classStaticPrivateFieldSpecGet.js",
    "./helpers/classStaticPrivateFieldSpecSet": [
      {
        "node": "./helpers/classStaticPrivateFieldSpecSet.js",
        "import": "./helpers/esm/classStaticPrivateFieldSpecSet.js",
        "default": "./helpers/classStaticPrivateFieldSpecSet.js"
      },
      "./helpers/classStaticPrivateFieldSpecSet.js"
    ],
    "./helpers/esm/classStaticPrivateFieldSpecSet": "./helpers/esm/classStaticPrivateFieldSpecSet.js",
    "./helpers/classStaticPrivateMethodSet": [
      {
        "node": "./helpers/classStaticPrivateMethodSet.js",
        "import": "./helpers/esm/classStaticPrivateMethodSet.js",
        "default": "./helpers/classStaticPrivateMethodSet.js"
      },
      "./helpers/classStaticPrivateMethodSet.js"
    ],
    "./helpers/esm/classStaticPrivateMethodSet": "./helpers/esm/classStaticPrivateMethodSet.js",
    "./helpers/defineEnumerableProperties": [
      {
        "node": "./helpers/defineEnumerableProperties.js",
        "import": "./helpers/esm/defineEnumerableProperties.js",
        "default": "./helpers/defineEnumerableProperties.js"
      },
      "./helpers/defineEnumerableProperties.js"
    ],
    "./helpers/esm/defineEnumerableProperties": "./helpers/esm/defineEnumerableProperties.js",
    "./helpers/dispose": [
      {
        "node": "./helpers/dispose.js",
        "import": "./helpers/esm/dispose.js",
        "default": "./helpers/dispose.js"
      },
      "./helpers/dispose.js"
    ],
    "./helpers/esm/dispose": "./helpers/esm/dispose.js",
    "./helpers/objectSpread": [
      {
        "node": "./helpers/objectSpread.js",
        "import": "./helpers/esm/objectSpread.js",
        "default": "./helpers/objectSpread.js"
      },
      "./helpers/objectSpread.js"
    ],
    "./helpers/esm/objectSpread": "./helpers/esm/objectSpread.js",
    "./helpers/regeneratorRuntime": [
      {
        "node": "./helpers/regeneratorRuntime.js",
        "import": "./helpers/esm/regeneratorRuntime.js",
        "default": "./helpers/regeneratorRuntime.js"
      },
      "./helpers/regeneratorRuntime.js"
    ],
    "./helpers/esm/regeneratorRuntime": "./helpers/esm/regeneratorRuntime.js",
    "./helpers/using": [
      {
        "node": "./helpers/using.js",
        "import": "./helpers/esm/using.js",
        "default": "./helpers/using.js"
      },
      "./helpers/using.js"
    ],
    "./helpers/esm/using": "./helpers/esm/using.js",
    "./package": "./package.json",
    "./package.json": "./package.json",
    "./regenerator": "./regenerator/index.js",
    "./regenerator/*.js": "./regenerator/*.js",
    "./regenerator/": "./regenerator/"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\template\package.json
============================================================
{
  "name": "@babel/template",
  "version": "7.27.2",
  "description": "Generate an AST from a string template.",
  "author": "The Babel Team (https://babel.dev/team)",
  "homepage": "https://babel.dev/docs/en/next/babel-template",
  "bugs": "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22pkg%3A%20template%22+is%3Aopen",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-template"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/code-frame": "^7.27.1",
    "@babel/parser": "^7.27.2",
    "@babel/types": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\traverse\package.json
============================================================
{
  "name": "@babel/traverse",
  "version": "7.28.4",
  "description": "The Babel Traverse module maintains the overall tree state, and is responsible for replacing, removing, and adding nodes",
  "author": "The Babel Team (https://babel.dev/team)",
  "homepage": "https://babel.dev/docs/en/next/babel-traverse",
  "bugs": "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22pkg%3A%20traverse%22+is%3Aopen",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-traverse"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/code-frame": "^7.27.1",
    "@babel/generator": "^7.28.3",
    "@babel/helper-globals": "^7.28.0",
    "@babel/parser": "^7.28.4",
    "@babel/template": "^7.27.2",
    "@babel/types": "^7.28.4",
    "debug": "^4.3.1"
  },
  "devDependencies": {
    "@babel/core": "^7.28.4",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@babel\types\package.json
============================================================
{
  "name": "@babel/types",
  "version": "7.28.4",
  "description": "Babel Types is a Lodash-esque utility library for AST nodes",
  "author": "The Babel Team (https://babel.dev/team)",
  "homepage": "https://babel.dev/docs/en/next/babel-types",
  "bugs": "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22pkg%3A%20types%22+is%3Aopen",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-types"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-string-parser": "^7.27.1",
    "@babel/helper-validator-identifier": "^7.27.1"
  },
  "devDependencies": {
    "@babel/generator": "^7.28.3",
    "@babel/parser": "^7.28.4",
    "glob": "^7.2.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs",
  "types": "./lib/index-legacy.d.ts",
  "typesVersions": {
    ">=4.1": {
      "lib/index-legacy.d.ts": [
        "lib/index.d.ts"
      ]
    }
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@bcoe\v8-coverage\dist\lib\package.json
============================================================
{
  "name": "@bcoe/v8-coverage",
  "version": "0.2.3",
  "description": "Helper functions for V8 coverage files.",
  "author": "Charles Samborski <demurgos@demurgos.net> (https://demurgos.net)",
  "license": "MIT",
  "main": "index",
  "types": "index.d.ts",
  "repository": {
    "type": "git",
    "url": "git://github.com/demurgos/v8-coverage.git"
  },
  "homepage": "https://demurgos.github.io/v8-coverage",
  "devDependencies": {
    "@types/chai": "^4.1.4",
    "@types/gulp": "^4.0.5",
    "@types/minimist": "^1.2.0",
    "@types/mocha": "^5.2.2",
    "@types/node": "^10.5.4",
    "chai": "^4.1.2",
    "codecov": "^3.0.2",
    "gulp": "^4.0.0",
    "gulp-cli": "^2.0.1",
    "minimist": "^1.2.0",
    "pre-commit": "^1.2.2",
    "ts-node": "^8.3.0",
    "turbo-gulp": "^0.20.1"
  },
  "nyc": {
    "include": [
      "build/test/lib/**/*.js",
      "build/test/lib/**/*.mjs"
    ],
    "reporter": [
      "text",
      "html"
    ],
    "extension": [
      ".mjs"
    ]
  },
  "gitHead": "529387e2bd3e0ba0b9336d80ec563aee593331e1",
  "private": false
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@bcoe\v8-coverage\package.json
============================================================
{
  "name": "@bcoe/v8-coverage",
  "version": "0.2.3",
  "description": "Helper functions for V8 coverage files.",
  "author": "Charles Samborski <demurgos@demurgos.net> (https://demurgos.net)",
  "license": "MIT",
  "main": "dist/lib/index",
  "types": "dist/lib/index.d.ts",
  "repository": {
    "type": "git",
    "url": "git://github.com/demurgos/v8-coverage.git"
  },
  "homepage": "https://demurgos.github.io/v8-coverage",
  "scripts": {
    "prepare": "gulp all:tsconfig.json && gulp dist",
    "pretest": "gulp lib:build",
    "test": "gulp test",
    "lint": "gulp :lint:fix"
  },
  "devDependencies": {
    "@types/chai": "^4.1.4",
    "@types/gulp": "^4.0.5",
    "@types/minimist": "^1.2.0",
    "@types/mocha": "^5.2.2",
    "@types/node": "^10.5.4",
    "chai": "^4.1.2",
    "codecov": "^3.0.2",
    "gulp": "^4.0.0",
    "gulp-cli": "^2.0.1",
    "minimist": "^1.2.0",
    "pre-commit": "^1.2.2",
    "ts-node": "^8.3.0",
    "turbo-gulp": "^0.20.1"
  },
  "nyc": {
    "include": [
      "build/test/lib/**/*.js",
      "build/test/lib/**/*.mjs"
    ],
    "reporter": [
      "text",
      "html"
    ],
    "extension": [
      ".mjs"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@csstools\color-helpers\package.json
============================================================
{
	"name": "@csstools/color-helpers",
	"description": "Color helpers to ease transformation between formats, gamut, etc",
	"version": "5.1.0",
	"contributors": [
		{
			"name": "Antonio Laguna",
			"email": "antonio@laguna.es",
			"url": "https://antonio.laguna.es"
		},
		{
			"name": "Romain Menke",
			"email": "romainmenke@gmail.com"
		}
	],
	"license": "MIT-0",
	"funding": [
		{
			"type": "github",
			"url": "https://github.com/sponsors/csstools"
		},
		{
			"type": "opencollective",
			"url": "https://opencollective.com/csstools"
		}
	],
	"engines": {
		"node": ">=18"
	},
	"type": "module",
	"main": "dist/index.cjs",
	"module": "dist/index.mjs",
	"exports": {
		".": {
			"import": {
				"types": "./dist/index.d.ts",
				"default": "./dist/index.mjs"
			},
			"require": {
				"default": "./dist/index.cjs"
			}
		}
	},
	"files": [
		"CHANGELOG.md",
		"LICENSE.md",
		"README.md",
		"dist"
	],
	"scripts": {},
	"homepage": "https://github.com/csstools/postcss-plugins/tree/main/packages/color-helpers#readme",
	"repository": {
		"type": "git",
		"url": "git+https://github.com/csstools/postcss-plugins.git",
		"directory": "packages/color-helpers"
	},
	"bugs": "https://github.com/csstools/postcss-plugins/issues",
	"keywords": [
		"colors",
		"css"
	]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@csstools\css-calc\package.json
============================================================
{
	"name": "@csstools/css-calc",
	"description": "Solve CSS math expressions",
	"version": "2.1.4",
	"contributors": [
		{
			"name": "Antonio Laguna",
			"email": "antonio@laguna.es",
			"url": "https://antonio.laguna.es"
		},
		{
			"name": "Romain Menke",
			"email": "romainmenke@gmail.com"
		}
	],
	"license": "MIT",
	"funding": [
		{
			"type": "github",
			"url": "https://github.com/sponsors/csstools"
		},
		{
			"type": "opencollective",
			"url": "https://opencollective.com/csstools"
		}
	],
	"engines": {
		"node": ">=18"
	},
	"type": "module",
	"main": "dist/index.cjs",
	"module": "dist/index.mjs",
	"exports": {
		".": {
			"import": {
				"types": "./dist/index.d.ts",
				"default": "./dist/index.mjs"
			},
			"require": {
				"default": "./dist/index.cjs"
			}
		}
	},
	"files": [
		"CHANGELOG.md",
		"LICENSE.md",
		"README.md",
		"dist"
	],
	"peerDependencies": {
		"@csstools/css-parser-algorithms": "^3.0.5",
		"@csstools/css-tokenizer": "^3.0.4"
	},
	"scripts": {},
	"homepage": "https://github.com/csstools/postcss-plugins/tree/main/packages/css-calc#readme",
	"repository": {
		"type": "git",
		"url": "git+https://github.com/csstools/postcss-plugins.git",
		"directory": "packages/css-calc"
	},
	"bugs": "https://github.com/csstools/postcss-plugins/issues",
	"keywords": [
		"calc",
		"css"
	]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@csstools\css-color-parser\package.json
============================================================
{
	"name": "@csstools/css-color-parser",
	"description": "Parse CSS color values",
	"version": "3.1.0",
	"contributors": [
		{
			"name": "Antonio Laguna",
			"email": "antonio@laguna.es",
			"url": "https://antonio.laguna.es"
		},
		{
			"name": "Romain Menke",
			"email": "romainmenke@gmail.com"
		}
	],
	"license": "MIT",
	"funding": [
		{
			"type": "github",
			"url": "https://github.com/sponsors/csstools"
		},
		{
			"type": "opencollective",
			"url": "https://opencollective.com/csstools"
		}
	],
	"engines": {
		"node": ">=18"
	},
	"type": "module",
	"main": "dist/index.cjs",
	"module": "dist/index.mjs",
	"exports": {
		".": {
			"import": {
				"types": "./dist/index.d.ts",
				"default": "./dist/index.mjs"
			},
			"require": {
				"default": "./dist/index.cjs"
			}
		}
	},
	"files": [
		"CHANGELOG.md",
		"LICENSE.md",
		"README.md",
		"dist"
	],
	"dependencies": {
		"@csstools/color-helpers": "^5.1.0",
		"@csstools/css-calc": "^2.1.4"
	},
	"peerDependencies": {
		"@csstools/css-parser-algorithms": "^3.0.5",
		"@csstools/css-tokenizer": "^3.0.4"
	},
	"scripts": {},
	"homepage": "https://github.com/csstools/postcss-plugins/tree/main/packages/css-color-parser#readme",
	"repository": {
		"type": "git",
		"url": "git+https://github.com/csstools/postcss-plugins.git",
		"directory": "packages/css-color-parser"
	},
	"bugs": "https://github.com/csstools/postcss-plugins/issues",
	"keywords": [
		"color",
		"css",
		"parser"
	]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@csstools\css-parser-algorithms\package.json
============================================================
{
	"name": "@csstools/css-parser-algorithms",
	"description": "Algorithms to help you parse CSS from an array of tokens.",
	"version": "3.0.5",
	"contributors": [
		{
			"name": "Antonio Laguna",
			"email": "antonio@laguna.es",
			"url": "https://antonio.laguna.es"
		},
		{
			"name": "Romain Menke",
			"email": "romainmenke@gmail.com"
		}
	],
	"license": "MIT",
	"funding": [
		{
			"type": "github",
			"url": "https://github.com/sponsors/csstools"
		},
		{
			"type": "opencollective",
			"url": "https://opencollective.com/csstools"
		}
	],
	"engines": {
		"node": ">=18"
	},
	"type": "module",
	"main": "dist/index.cjs",
	"module": "dist/index.mjs",
	"exports": {
		".": {
			"import": {
				"types": "./dist/index.d.ts",
				"default": "./dist/index.mjs"
			},
			"require": {
				"default": "./dist/index.cjs"
			}
		}
	},
	"files": [
		"CHANGELOG.md",
		"LICENSE.md",
		"README.md",
		"dist"
	],
	"peerDependencies": {
		"@csstools/css-tokenizer": "^3.0.4"
	},
	"scripts": {},
	"homepage": "https://github.com/csstools/postcss-plugins/tree/main/packages/css-parser-algorithms#readme",
	"repository": {
		"type": "git",
		"url": "git+https://github.com/csstools/postcss-plugins.git",
		"directory": "packages/css-parser-algorithms"
	},
	"bugs": "https://github.com/csstools/postcss-plugins/issues",
	"keywords": [
		"css",
		"parser"
	]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@csstools\css-syntax-patches-for-csstree\package.json
============================================================
{
	"name": "@csstools/css-syntax-patches-for-csstree",
	"description": "CSS syntax patches for CSS tree",
	"version": "1.0.14",
	"contributors": [
		{
			"name": "Antonio Laguna",
			"email": "antonio@laguna.es",
			"url": "https://antonio.laguna.es"
		},
		{
			"name": "Romain Menke",
			"email": "romainmenke@gmail.com"
		}
	],
	"license": "MIT-0",
	"funding": [
		{
			"type": "github",
			"url": "https://github.com/sponsors/csstools"
		},
		{
			"type": "opencollective",
			"url": "https://opencollective.com/csstools"
		}
	],
	"engines": {
		"node": ">=18"
	},
	"main": "dist/index.json",
	"types": "dist/index.d.ts",
	"files": [
		"CHANGELOG.md",
		"LICENSE.md",
		"README.md",
		"dist"
	],
	"peerDependencies": {
		"postcss": "^8.4"
	},
	"scripts": {},
	"homepage": "https://github.com/csstools/postcss-plugins/tree/main/packages/css-syntax-patches-for-csstree#readme",
	"repository": {
		"type": "git",
		"url": "git+https://github.com/csstools/postcss-plugins.git",
		"directory": "packages/css-syntax-patches-for-csstree"
	},
	"bugs": "https://github.com/csstools/postcss-plugins/issues",
	"keywords": [
		"css",
		"csstree",
		"syntax"
	]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@csstools\css-tokenizer\package.json
============================================================
{
	"name": "@csstools/css-tokenizer",
	"description": "Tokenize CSS",
	"version": "3.0.4",
	"contributors": [
		{
			"name": "Antonio Laguna",
			"email": "antonio@laguna.es",
			"url": "https://antonio.laguna.es"
		},
		{
			"name": "Romain Menke",
			"email": "romainmenke@gmail.com"
		}
	],
	"license": "MIT",
	"funding": [
		{
			"type": "github",
			"url": "https://github.com/sponsors/csstools"
		},
		{
			"type": "opencollective",
			"url": "https://opencollective.com/csstools"
		}
	],
	"engines": {
		"node": ">=18"
	},
	"type": "module",
	"main": "dist/index.cjs",
	"module": "dist/index.mjs",
	"exports": {
		".": {
			"import": {
				"types": "./dist/index.d.ts",
				"default": "./dist/index.mjs"
			},
			"require": {
				"default": "./dist/index.cjs"
			}
		}
	},
	"files": [
		"CHANGELOG.md",
		"LICENSE.md",
		"README.md",
		"dist"
	],
	"scripts": {},
	"homepage": "https://github.com/csstools/postcss-plugins/tree/main/packages/css-tokenizer#readme",
	"repository": {
		"type": "git",
		"url": "git+https://github.com/csstools/postcss-plugins.git",
		"directory": "packages/css-tokenizer"
	},
	"bugs": "https://github.com/csstools/postcss-plugins/issues",
	"keywords": [
		"css",
		"tokenizer"
	]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@emotion\is-prop-valid\package.json
============================================================
{
  "name": "@emotion/is-prop-valid",
  "version": "1.4.0",
  "description": "A function to check whether a prop is valid for HTML and SVG elements",
  "main": "dist/emotion-is-prop-valid.cjs.js",
  "module": "dist/emotion-is-prop-valid.esm.js",
  "types": "dist/emotion-is-prop-valid.cjs.d.ts",
  "license": "MIT",
  "repository": "https://github.com/emotion-js/emotion/tree/main/packages/is-prop-valid",
  "scripts": {
    "test:typescript": "dtslint types"
  },
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "@emotion/memoize": "^0.9.0"
  },
  "devDependencies": {
    "@definitelytyped/dtslint": "0.0.112",
    "typescript": "^5.4.5"
  },
  "files": [
    "src",
    "dist"
  ],
  "exports": {
    ".": {
      "types": {
        "import": "./dist/emotion-is-prop-valid.cjs.mjs",
        "default": "./dist/emotion-is-prop-valid.cjs.js"
      },
      "module": "./dist/emotion-is-prop-valid.esm.js",
      "import": "./dist/emotion-is-prop-valid.cjs.mjs",
      "default": "./dist/emotion-is-prop-valid.cjs.js"
    },
    "./package.json": "./package.json"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@emotion\memoize\package.json
============================================================
{
  "name": "@emotion/memoize",
  "version": "0.9.0",
  "description": "emotion's memoize utility",
  "main": "dist/emotion-memoize.cjs.js",
  "module": "dist/emotion-memoize.esm.js",
  "types": "dist/emotion-memoize.cjs.d.ts",
  "license": "MIT",
  "repository": "https://github.com/emotion-js/emotion/tree/main/packages/memoize",
  "scripts": {
    "test:typescript": "dtslint types"
  },
  "publishConfig": {
    "access": "public"
  },
  "devDependencies": {
    "@definitelytyped/dtslint": "0.0.112",
    "typescript": "^5.4.5"
  },
  "files": [
    "src",
    "dist"
  ],
  "exports": {
    ".": {
      "module": "./dist/emotion-memoize.esm.js",
      "import": "./dist/emotion-memoize.cjs.mjs",
      "default": "./dist/emotion-memoize.cjs.js"
    },
    "./package.json": "./package.json"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@emotion\stylis\package.json
============================================================
{
  "name": "@emotion/stylis",
  "version": "0.8.5",
  "description": "A custom build of Stylis",
  "main": "dist/stylis.cjs.js",
  "module": "dist/stylis.esm.js",
  "types": "types/index.d.ts",
  "license": "MIT",
  "scripts": {
    "test:typescript": "dtslint types"
  },
  "repository": "https://github.com/emotion-js/emotion/tree/master/packages/stylis",
  "publishConfig": {
    "access": "public"
  },
  "files": [
    "src",
    "dist",
    "types"
  ],
  "devDependencies": {
    "dtslint": "^0.3.0",
    "jscodeshift": "^0.5.0",
    "request": "^2.85.0",
    "request-promise-native": "^1.0.5",
    "stylis": "3.5.4"
  },
  "browser": {
    "./dist/stylis.cjs.js": "./dist/stylis.browser.cjs.js",
    "./dist/stylis.esm.js": "./dist/stylis.browser.esm.js"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@emotion\unitless\package.json
============================================================
{
  "name": "@emotion/unitless",
  "version": "0.7.5",
  "description": "An object of css properties that don't accept values with units",
  "main": "dist/unitless.cjs.js",
  "module": "dist/unitless.esm.js",
  "license": "MIT",
  "repository": "https://github.com/emotion-js/emotion/tree/master/packages/unitless",
  "publishConfig": {
    "access": "public"
  },
  "files": [
    "src",
    "dist"
  ],
  "browser": {
    "./dist/unitless.cjs.js": "./dist/unitless.browser.cjs.js",
    "./dist/unitless.esm.js": "./dist/unitless.browser.esm.js"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@esbuild\win32-x64\package.json
============================================================
{
  "name": "@esbuild/win32-x64",
  "version": "0.18.20",
  "description": "The Windows 64-bit binary for esbuild, a JavaScript bundler.",
  "repository": "https://github.com/evanw/esbuild",
  "license": "MIT",
  "preferUnplugged": true,
  "engines": {
    "node": ">=12"
  },
  "os": [
    "win32"
  ],
  "cpu": [
    "x64"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@isaacs\cliui\package.json
============================================================
{
  "name": "@isaacs/cliui",
  "version": "8.0.2",
  "description": "easily create complex multi-column command-line-interfaces",
  "main": "build/index.cjs",
  "exports": {
    ".": [
      {
        "import": "./index.mjs",
        "require": "./build/index.cjs"
      },
      "./build/index.cjs"
    ]
  },
  "type": "module",
  "module": "./index.mjs",
  "scripts": {
    "check": "standardx '**/*.ts' && standardx '**/*.js' && standardx '**/*.cjs'",
    "fix": "standardx --fix '**/*.ts' && standardx --fix '**/*.js' && standardx --fix '**/*.cjs'",
    "pretest": "rimraf build && tsc -p tsconfig.test.json && cross-env NODE_ENV=test npm run build:cjs",
    "test": "c8 mocha ./test/*.cjs",
    "test:esm": "c8 mocha ./test/**/*.mjs",
    "postest": "check",
    "coverage": "c8 report --check-coverage",
    "precompile": "rimraf build",
    "compile": "tsc",
    "postcompile": "npm run build:cjs",
    "build:cjs": "rollup -c",
    "prepare": "npm run compile"
  },
  "repository": "yargs/cliui",
  "standard": {
    "ignore": [
      "**/example/**"
    ],
    "globals": [
      "it"
    ]
  },
  "keywords": [
    "cli",
    "command-line",
    "layout",
    "design",
    "console",
    "wrap",
    "table"
  ],
  "author": "Ben Coe <ben@npmjs.com>",
  "license": "ISC",
  "dependencies": {
    "string-width": "^5.1.2",
    "string-width-cjs": "npm:string-width@^4.2.0",
    "strip-ansi": "^7.0.1",
    "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
    "wrap-ansi": "^8.1.0",
    "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
  },
  "devDependencies": {
    "@types/node": "^14.0.27",
    "@typescript-eslint/eslint-plugin": "^4.0.0",
    "@typescript-eslint/parser": "^4.0.0",
    "c8": "^7.3.0",
    "chai": "^4.2.0",
    "chalk": "^4.1.0",
    "cross-env": "^7.0.2",
    "eslint": "^7.6.0",
    "eslint-plugin-import": "^2.22.0",
    "eslint-plugin-node": "^11.1.0",
    "gts": "^3.0.0",
    "mocha": "^10.0.0",
    "rimraf": "^3.0.2",
    "rollup": "^2.23.1",
    "rollup-plugin-ts": "^3.0.2",
    "standardx": "^7.0.0",
    "typescript": "^4.0.0"
  },
  "files": [
    "build",
    "index.mjs",
    "!*.d.ts"
  ],
  "engines": {
    "node": ">=12"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@istanbuljs\load-nyc-config\node_modules\argparse\package.json
============================================================
{
  "name": "argparse",
  "description": "Very powerful CLI arguments parser. Native port of argparse - python's options parsing library",
  "version": "1.0.10",
  "keywords": [
    "cli",
    "parser",
    "argparse",
    "option",
    "args"
  ],
  "contributors": [
    "Eugene Shkuropat",
    "Paul Jacobson"
  ],
  "files": [
    "index.js",
    "lib/"
  ],
  "license": "MIT",
  "repository": "nodeca/argparse",
  "scripts": {
    "test": "make test"
  },
  "dependencies": {
    "sprintf-js": "~1.0.2"
  },
  "devDependencies": {
    "eslint": "^2.13.1",
    "istanbul": "^0.4.5",
    "mocha": "^3.1.0",
    "ndoc": "^5.0.1"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@istanbuljs\load-nyc-config\node_modules\find-up\package.json
============================================================
{
	"name": "find-up",
	"version": "4.1.0",
	"description": "Find a file or directory by walking up parent directories",
	"license": "MIT",
	"repository": "sindresorhus/find-up",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"find",
		"up",
		"find-up",
		"findup",
		"look-up",
		"look",
		"file",
		"search",
		"match",
		"package",
		"resolve",
		"parent",
		"parents",
		"folder",
		"directory",
		"walk",
		"walking",
		"path"
	],
	"dependencies": {
		"locate-path": "^5.0.0",
		"path-exists": "^4.0.0"
	},
	"devDependencies": {
		"ava": "^2.1.0",
		"is-path-inside": "^2.1.0",
		"tempy": "^0.3.0",
		"tsd": "^0.7.3",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@istanbuljs\load-nyc-config\node_modules\js-yaml\package.json
============================================================
{
  "name": "js-yaml",
  "version": "3.14.1",
  "description": "YAML 1.2 parser and serializer",
  "keywords": [
    "yaml",
    "parser",
    "serializer",
    "pyyaml"
  ],
  "homepage": "https://github.com/nodeca/js-yaml",
  "author": "Vladimir Zapparov <dervus.grim@gmail.com>",
  "contributors": [
    "Aleksey V Zapparov <ixti@member.fsf.org> (http://www.ixti.net/)",
    "Vitaly Puzrin <vitaly@rcdesign.ru> (https://github.com/puzrin)",
    "Martin Grenfell <martin.grenfell@gmail.com> (http://got-ravings.blogspot.com)"
  ],
  "license": "MIT",
  "repository": "nodeca/js-yaml",
  "files": [
    "index.js",
    "lib/",
    "bin/",
    "dist/"
  ],
  "bin": {
    "js-yaml": "bin/js-yaml.js"
  },
  "unpkg": "dist/js-yaml.min.js",
  "jsdelivr": "dist/js-yaml.min.js",
  "dependencies": {
    "argparse": "^1.0.7",
    "esprima": "^4.0.0"
  },
  "devDependencies": {
    "ansi": "^0.3.1",
    "benchmark": "^2.1.4",
    "browserify": "^16.2.2",
    "codemirror": "^5.13.4",
    "eslint": "^7.0.0",
    "fast-check": "^1.24.2",
    "istanbul": "^0.4.5",
    "mocha": "^7.1.2",
    "uglify-js": "^3.0.1"
  },
  "scripts": {
    "test": "make test"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@istanbuljs\load-nyc-config\node_modules\locate-path\package.json
============================================================
{
	"name": "locate-path",
	"version": "5.0.0",
	"description": "Get the first path that exists on disk of multiple paths",
	"license": "MIT",
	"repository": "sindresorhus/locate-path",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"locate",
		"path",
		"paths",
		"file",
		"files",
		"exists",
		"find",
		"finder",
		"search",
		"searcher",
		"array",
		"iterable",
		"iterator"
	],
	"dependencies": {
		"p-locate": "^4.1.0"
	},
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@istanbuljs\load-nyc-config\node_modules\p-limit\package.json
============================================================
{
	"name": "p-limit",
	"version": "2.3.0",
	"description": "Run multiple promise-returning & async functions with limited concurrency",
	"license": "MIT",
	"repository": "sindresorhus/p-limit",
	"funding": "https://github.com/sponsors/sindresorhus",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=6"
	},
	"scripts": {
		"test": "xo && ava && tsd-check"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"promise",
		"limit",
		"limited",
		"concurrency",
		"throttle",
		"throat",
		"rate",
		"batch",
		"ratelimit",
		"task",
		"queue",
		"async",
		"await",
		"promises",
		"bluebird"
	],
	"dependencies": {
		"p-try": "^2.0.0"
	},
	"devDependencies": {
		"ava": "^1.2.1",
		"delay": "^4.1.0",
		"in-range": "^1.0.0",
		"random-int": "^1.0.0",
		"time-span": "^2.0.0",
		"tsd-check": "^0.3.0",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@istanbuljs\load-nyc-config\node_modules\p-locate\package.json
============================================================
{
	"name": "p-locate",
	"version": "4.1.0",
	"description": "Get the first fulfilled promise that satisfies the provided testing function",
	"license": "MIT",
	"repository": "sindresorhus/p-locate",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"promise",
		"locate",
		"find",
		"finder",
		"search",
		"searcher",
		"test",
		"array",
		"collection",
		"iterable",
		"iterator",
		"race",
		"fulfilled",
		"fastest",
		"async",
		"await",
		"promises",
		"bluebird"
	],
	"dependencies": {
		"p-limit": "^2.2.0"
	},
	"devDependencies": {
		"ava": "^1.4.1",
		"delay": "^4.1.0",
		"in-range": "^1.0.0",
		"time-span": "^3.0.0",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@istanbuljs\load-nyc-config\node_modules\resolve-from\package.json
============================================================
{
	"name": "resolve-from",
	"version": "5.0.0",
	"description": "Resolve the path of a module like `require.resolve()` but from a given path",
	"license": "MIT",
	"repository": "sindresorhus/resolve-from",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"require",
		"resolve",
		"path",
		"module",
		"from",
		"like",
		"import"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@istanbuljs\load-nyc-config\package.json
============================================================
{
	"name": "@istanbuljs/load-nyc-config",
	"version": "1.1.0",
	"description": "Utility function to load nyc configuration",
	"main": "index.js",
	"scripts": {
		"pretest": "xo",
		"test": "tap",
		"snap": "npm test -- --snapshot",
		"release": "standard-version"
	},
	"engines": {
		"node": ">=8"
	},
	"license": "ISC",
	"repository": {
		"type": "git",
		"url": "git+https://github.com/istanbuljs/load-nyc-config.git"
	},
	"bugs": {
		"url": "https://github.com/istanbuljs/load-nyc-config/issues"
	},
	"homepage": "https://github.com/istanbuljs/load-nyc-config#readme",
	"dependencies": {
		"camelcase": "^5.3.1",
		"find-up": "^4.1.0",
		"get-package-type": "^0.1.0",
		"js-yaml": "^3.13.1",
		"resolve-from": "^5.0.0"
	},
	"devDependencies": {
		"semver": "^6.3.0",
		"standard-version": "^7.0.0",
		"tap": "^14.10.5",
		"xo": "^0.25.3"
	},
	"xo": {
		"ignores": [
			"test/fixtures/extends/invalid.*"
		],
		"rules": {
			"require-atomic-updates": 0,
			"capitalized-comments": 0,
			"unicorn/import-index": 0,
			"import/extensions": 0,
			"import/no-useless-path-segments": 0
		}
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@istanbuljs\schema\package.json
============================================================
{
	"name": "@istanbuljs/schema",
	"version": "0.1.3",
	"description": "Schemas describing various structures used by nyc and istanbuljs",
	"main": "index.js",
	"scripts": {
		"release": "standard-version --sign",
		"pretest": "xo",
		"test": "tap",
		"snap": "npm test -- --snapshot"
	},
	"engines": {
		"node": ">=8"
	},
	"author": "Corey Farrell",
	"license": "MIT",
	"repository": {
		"type": "git",
		"url": "git+https://github.com/istanbuljs/schema.git"
	},
	"bugs": {
		"url": "https://github.com/istanbuljs/schema/issues"
	},
	"homepage": "https://github.com/istanbuljs/schema#readme",
	"devDependencies": {
		"standard-version": "^7.0.0",
		"tap": "^14.6.7",
		"xo": "^0.25.3"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\console\package.json
============================================================
{
  "name": "@jest/console",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-console"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/types": "30.2.0",
    "@types/node": "*",
    "chalk": "^4.1.2",
    "jest-message-util": "30.2.0",
    "jest-util": "30.2.0",
    "slash": "^3.0.0"
  },
  "devDependencies": {
    "@jest/test-utils": "30.2.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\core\node_modules\ansi-styles\package.json
============================================================
{
	"name": "ansi-styles",
	"version": "5.2.0",
	"description": "ANSI escape codes for styling strings in the terminal",
	"license": "MIT",
	"repository": "chalk/ansi-styles",
	"funding": "https://github.com/chalk/ansi-styles?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"screenshot": "svg-term --command='node screenshot' --out=screenshot.svg --padding=3 --width=55 --height=3 --at=1000 --no-cursor"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"devDependencies": {
		"ava": "^2.4.0",
		"svg-term-cli": "^2.1.1",
		"tsd": "^0.14.0",
		"xo": "^0.37.1"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\core\node_modules\pretty-format\package.json
============================================================
{
  "name": "pretty-format",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/pretty-format"
  },
  "license": "MIT",
  "description": "Stringify any JavaScript value.",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "author": "James Kyle <me@thejameskyle.com>",
  "dependencies": {
    "@jest/schemas": "30.0.5",
    "ansi-styles": "^5.2.0",
    "react-is": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.23",
    "@types/react-is": "^18.3.1",
    "@types/react-test-renderer": "^18.3.1",
    "immutable": "^5.1.2",
    "jest-util": "30.2.0",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-test-renderer": "18.3.1"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\core\node_modules\react-is\package.json
============================================================
{
  "name": "react-is",
  "version": "18.3.1",
  "description": "Brand checking of React Elements.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react-is"
  },
  "keywords": [
    "react"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/facebook/react/issues"
  },
  "homepage": "https://reactjs.org/",
  "files": [
    "LICENSE",
    "README.md",
    "index.js",
    "cjs/",
    "umd/"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\core\package.json
============================================================
{
  "name": "@jest/core",
  "description": "Delightful JavaScript Testing.",
  "version": "30.2.0",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/console": "30.2.0",
    "@jest/pattern": "30.0.1",
    "@jest/reporters": "30.2.0",
    "@jest/test-result": "30.2.0",
    "@jest/transform": "30.2.0",
    "@jest/types": "30.2.0",
    "@types/node": "*",
    "ansi-escapes": "^4.3.2",
    "chalk": "^4.1.2",
    "ci-info": "^4.2.0",
    "exit-x": "^0.2.2",
    "graceful-fs": "^4.2.11",
    "jest-changed-files": "30.2.0",
    "jest-config": "30.2.0",
    "jest-haste-map": "30.2.0",
    "jest-message-util": "30.2.0",
    "jest-regex-util": "30.0.1",
    "jest-resolve": "30.2.0",
    "jest-resolve-dependencies": "30.2.0",
    "jest-runner": "30.2.0",
    "jest-runtime": "30.2.0",
    "jest-snapshot": "30.2.0",
    "jest-util": "30.2.0",
    "jest-validate": "30.2.0",
    "jest-watcher": "30.2.0",
    "micromatch": "^4.0.8",
    "pretty-format": "30.2.0",
    "slash": "^3.0.0"
  },
  "devDependencies": {
    "@jest/test-sequencer": "30.2.0",
    "@jest/test-utils": "30.2.0",
    "@types/graceful-fs": "^4.1.9",
    "@types/micromatch": "^4.0.9"
  },
  "peerDependencies": {
    "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
  },
  "peerDependenciesMeta": {
    "node-notifier": {
      "optional": true
    }
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-core"
  },
  "bugs": {
    "url": "https://github.com/jestjs/jest/issues"
  },
  "homepage": "https://jestjs.io/",
  "license": "MIT",
  "keywords": [
    "ava",
    "babel",
    "coverage",
    "easy",
    "expect",
    "facebook",
    "immersive",
    "instant",
    "jasmine",
    "jest",
    "jsdom",
    "mocha",
    "mocking",
    "painless",
    "qunit",
    "runner",
    "sandboxed",
    "snapshot",
    "tap",
    "tape",
    "test",
    "testing",
    "typescript",
    "watch"
  ],
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\diff-sequences\package.json
============================================================
{
  "name": "@jest/diff-sequences",
  "version": "30.0.1",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/diff-sequences"
  },
  "license": "MIT",
  "description": "Compare items in two sequences to find a longest common subsequence",
  "keywords": [
    "fast",
    "linear",
    "space",
    "callback",
    "diff"
  ],
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "devDependencies": {
    "@fast-check/jest": "^2.1.1",
    "benchmark": "^2.1.4",
    "diff": "^7.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "5ce865b4060189fe74cd486544816c079194a0f7"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\environment\package.json
============================================================
{
  "name": "@jest/environment",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-environment"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/fake-timers": "30.2.0",
    "@jest/types": "30.2.0",
    "@types/node": "*",
    "jest-mock": "30.2.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\environment-jsdom-abstract\package.json
============================================================
{
  "name": "@jest/environment-jsdom-abstract",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-environment-jsdom-abstract"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/environment": "30.2.0",
    "@jest/fake-timers": "30.2.0",
    "@jest/types": "30.2.0",
    "@types/jsdom": "^21.1.7",
    "@types/node": "*",
    "jest-mock": "30.2.0",
    "jest-util": "30.2.0"
  },
  "devDependencies": {
    "@jest/test-utils": "30.2.0",
    "jsdom": "^26.1.0"
  },
  "peerDependencies": {
    "canvas": "^3.0.0",
    "jsdom": "*"
  },
  "peerDependenciesMeta": {
    "canvas": {
      "optional": true
    }
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\expect\package.json
============================================================
{
  "name": "@jest/expect",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-expect"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "expect": "30.2.0",
    "jest-snapshot": "30.2.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\expect-utils\package.json
============================================================
{
  "name": "@jest/expect-utils",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/expect-utils"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/get-type": "30.1.0"
  },
  "devDependencies": {
    "immutable": "^5.1.2",
    "jest-matcher-utils": "30.2.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\fake-timers\package.json
============================================================
{
  "name": "@jest/fake-timers",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-fake-timers"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/types": "30.2.0",
    "@sinonjs/fake-timers": "^13.0.0",
    "@types/node": "*",
    "jest-message-util": "30.2.0",
    "jest-mock": "30.2.0",
    "jest-util": "30.2.0"
  },
  "devDependencies": {
    "@jest/test-utils": "30.2.0",
    "@types/sinonjs__fake-timers": "^8.1.5"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\get-type\package.json
============================================================
{
  "name": "@jest/get-type",
  "description": "A utility function to get the type of a value",
  "version": "30.1.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-get-type"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "4d5f41d0885c1d9630c81b4fd47f74ab0615e18f"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\globals\package.json
============================================================
{
  "name": "@jest/globals",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-globals"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/environment": "30.2.0",
    "@jest/expect": "30.2.0",
    "@jest/types": "30.2.0",
    "jest-mock": "30.2.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\pattern\package.json
============================================================
{
  "name": "@jest/pattern",
  "version": "30.0.1",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-pattern"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@types/node": "*",
    "jest-regex-util": "30.0.1"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "5ce865b4060189fe74cd486544816c079194a0f7"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\reporters\package.json
============================================================
{
  "name": "@jest/reporters",
  "description": "Jest's reporters",
  "version": "30.2.0",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@bcoe/v8-coverage": "^0.2.3",
    "@jest/console": "30.2.0",
    "@jest/test-result": "30.2.0",
    "@jest/transform": "30.2.0",
    "@jest/types": "30.2.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@types/node": "*",
    "chalk": "^4.1.2",
    "collect-v8-coverage": "^1.0.2",
    "exit-x": "^0.2.2",
    "glob": "^10.3.10",
    "graceful-fs": "^4.2.11",
    "istanbul-lib-coverage": "^3.0.0",
    "istanbul-lib-instrument": "^6.0.0",
    "istanbul-lib-report": "^3.0.0",
    "istanbul-lib-source-maps": "^5.0.0",
    "istanbul-reports": "^3.1.3",
    "jest-message-util": "30.2.0",
    "jest-util": "30.2.0",
    "jest-worker": "30.2.0",
    "slash": "^3.0.0",
    "string-length": "^4.0.2",
    "v8-to-istanbul": "^9.0.1"
  },
  "devDependencies": {
    "@jest/pattern": "30.0.1",
    "@jest/test-utils": "30.2.0",
    "@types/graceful-fs": "^4.1.9",
    "@types/istanbul-lib-coverage": "^2.0.6",
    "@types/istanbul-lib-instrument": "^1.7.7",
    "@types/istanbul-lib-report": "^3.0.3",
    "@types/istanbul-lib-source-maps": "^4.0.4",
    "@types/istanbul-reports": "^3.0.4",
    "@types/node-notifier": "^8.0.5",
    "jest-resolve": "30.2.0",
    "mock-fs": "^5.5.0",
    "node-notifier": "^10.0.1"
  },
  "peerDependencies": {
    "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
  },
  "peerDependenciesMeta": {
    "node-notifier": {
      "optional": true
    }
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-reporters"
  },
  "bugs": {
    "url": "https://github.com/jestjs/jest/issues"
  },
  "homepage": "https://jestjs.io/",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\schemas\package.json
============================================================
{
  "name": "@jest/schemas",
  "version": "30.0.5",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-schemas"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@sinclair/typebox": "^0.34.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "22236cf58b66039f81893537c90dee290bab427f"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\snapshot-utils\package.json
============================================================
{
  "name": "@jest/snapshot-utils",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-snapshot-utils"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/types": "30.2.0",
    "chalk": "^4.1.2",
    "graceful-fs": "^4.2.11",
    "natural-compare": "^1.4.0"
  },
  "devDependencies": {
    "@types/graceful-fs": "^4.1.9",
    "@types/natural-compare": "^1.4.3"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\source-map\package.json
============================================================
{
  "name": "@jest/source-map",
  "version": "30.0.1",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-source-map"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jridgewell/trace-mapping": "^0.3.25",
    "callsites": "^3.1.0",
    "graceful-fs": "^4.2.11"
  },
  "devDependencies": {
    "@types/graceful-fs": "^4.1.9"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "5ce865b4060189fe74cd486544816c079194a0f7"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\test-result\package.json
============================================================
{
  "name": "@jest/test-result",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-test-result"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/console": "30.2.0",
    "@jest/types": "30.2.0",
    "@types/istanbul-lib-coverage": "^2.0.6",
    "collect-v8-coverage": "^1.0.2"
  },
  "devDependencies": {
    "jest-haste-map": "30.2.0",
    "jest-resolve": "30.2.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\test-sequencer\package.json
============================================================
{
  "name": "@jest/test-sequencer",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-test-sequencer"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/test-result": "30.2.0",
    "graceful-fs": "^4.2.11",
    "jest-haste-map": "30.2.0",
    "slash": "^3.0.0"
  },
  "devDependencies": {
    "@jest/test-utils": "30.2.0",
    "@types/graceful-fs": "^4.1.9"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\transform\package.json
============================================================
{
  "name": "@jest/transform",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-transform"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@babel/core": "^7.27.4",
    "@jest/types": "30.2.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "babel-plugin-istanbul": "^7.0.1",
    "chalk": "^4.1.2",
    "convert-source-map": "^2.0.0",
    "fast-json-stable-stringify": "^2.1.0",
    "graceful-fs": "^4.2.11",
    "jest-haste-map": "30.2.0",
    "jest-regex-util": "30.0.1",
    "jest-util": "30.2.0",
    "micromatch": "^4.0.8",
    "pirates": "^4.0.7",
    "slash": "^3.0.0",
    "write-file-atomic": "^5.0.1"
  },
  "devDependencies": {
    "@jest/test-utils": "30.2.0",
    "@types/babel__core": "^7.20.5",
    "@types/convert-source-map": "^2.0.3",
    "@types/graceful-fs": "^4.1.9",
    "@types/micromatch": "^4.0.9",
    "@types/write-file-atomic": "^4.0.3",
    "dedent": "^1.6.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jest\types\package.json
============================================================
{
  "name": "@jest/types",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-types"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/pattern": "30.0.1",
    "@jest/schemas": "30.0.5",
    "@types/istanbul-lib-coverage": "^2.0.6",
    "@types/istanbul-reports": "^3.0.4",
    "@types/node": "*",
    "@types/yargs": "^17.0.33",
    "chalk": "^4.1.2"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jridgewell\gen-mapping\package.json
============================================================
{
  "name": "@jridgewell/gen-mapping",
  "version": "0.3.13",
  "description": "Generate source maps",
  "keywords": [
    "source",
    "map"
  ],
  "main": "dist/gen-mapping.umd.js",
  "module": "dist/gen-mapping.mjs",
  "types": "types/gen-mapping.d.cts",
  "files": [
    "dist",
    "src",
    "types"
  ],
  "exports": {
    ".": [
      {
        "import": {
          "types": "./types/gen-mapping.d.mts",
          "default": "./dist/gen-mapping.mjs"
        },
        "default": {
          "types": "./types/gen-mapping.d.cts",
          "default": "./dist/gen-mapping.umd.js"
        }
      },
      "./dist/gen-mapping.umd.js"
    ],
    "./package.json": "./package.json"
  },
  "scripts": {
    "benchmark": "run-s build:code benchmark:*",
    "benchmark:install": "cd benchmark && npm install",
    "benchmark:only": "node --expose-gc benchmark/index.js",
    "build": "run-s -n build:code build:types",
    "build:code": "node ../../esbuild.mjs gen-mapping.ts",
    "build:types": "run-s build:types:force build:types:emit build:types:mts",
    "build:types:force": "rimraf tsconfig.build.tsbuildinfo",
    "build:types:emit": "tsc --project tsconfig.build.json",
    "build:types:mts": "node ../../mts-types.mjs",
    "clean": "run-s -n clean:code clean:types",
    "clean:code": "tsc --build --clean tsconfig.build.json",
    "clean:types": "rimraf dist types",
    "test": "run-s -n test:types test:only test:format",
    "test:format": "prettier --check '{src,test}/**/*.ts'",
    "test:only": "mocha",
    "test:types": "eslint '{src,test}/**/*.ts'",
    "lint": "run-s -n lint:types lint:format",
    "lint:format": "npm run test:format -- --write",
    "lint:types": "npm run test:types -- --fix",
    "prepublishOnly": "npm run-s -n build test"
  },
  "homepage": "https://github.com/jridgewell/sourcemaps/tree/main/packages/gen-mapping",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jridgewell/sourcemaps.git",
    "directory": "packages/gen-mapping"
  },
  "author": "Justin Ridgewell <justin@ridgewell.name>",
  "license": "MIT",
  "dependencies": {
    "@jridgewell/sourcemap-codec": "^1.5.0",
    "@jridgewell/trace-mapping": "^0.3.24"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jridgewell\remapping\package.json
============================================================
{
  "name": "@jridgewell/remapping",
  "version": "2.3.5",
  "description": "Remap sequential sourcemaps through transformations to point at the original source code",
  "keywords": [
    "source",
    "map",
    "remap"
  ],
  "main": "dist/remapping.umd.js",
  "module": "dist/remapping.mjs",
  "types": "types/remapping.d.cts",
  "files": [
    "dist",
    "src",
    "types"
  ],
  "exports": {
    ".": [
      {
        "import": {
          "types": "./types/remapping.d.mts",
          "default": "./dist/remapping.mjs"
        },
        "default": {
          "types": "./types/remapping.d.cts",
          "default": "./dist/remapping.umd.js"
        }
      },
      "./dist/remapping.umd.js"
    ],
    "./package.json": "./package.json"
  },
  "scripts": {
    "benchmark": "run-s build:code benchmark:*",
    "benchmark:install": "cd benchmark && npm install",
    "benchmark:only": "node --expose-gc benchmark/index.js",
    "build": "run-s -n build:code build:types",
    "build:code": "node ../../esbuild.mjs remapping.ts",
    "build:types": "run-s build:types:force build:types:emit build:types:mts",
    "build:types:force": "rimraf tsconfig.build.tsbuildinfo",
    "build:types:emit": "tsc --project tsconfig.build.json",
    "build:types:mts": "node ../../mts-types.mjs",
    "clean": "run-s -n clean:code clean:types",
    "clean:code": "tsc --build --clean tsconfig.build.json",
    "clean:types": "rimraf dist types",
    "test": "run-s -n test:types test:only test:format",
    "test:format": "prettier --check '{src,test}/**/*.ts'",
    "test:only": "mocha",
    "test:types": "eslint '{src,test}/**/*.ts'",
    "lint": "run-s -n lint:types lint:format",
    "lint:format": "npm run test:format -- --write",
    "lint:types": "npm run test:types -- --fix",
    "prepublishOnly": "npm run-s -n build test"
  },
  "homepage": "https://github.com/jridgewell/sourcemaps/tree/main/packages/remapping",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jridgewell/sourcemaps.git",
    "directory": "packages/remapping"
  },
  "author": "Justin Ridgewell <justin@ridgewell.name>",
  "license": "MIT",
  "dependencies": {
    "@jridgewell/gen-mapping": "^0.3.5",
    "@jridgewell/trace-mapping": "^0.3.24"
  },
  "devDependencies": {
    "source-map": "0.6.1"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jridgewell\resolve-uri\package.json
============================================================
{
  "name": "@jridgewell/resolve-uri",
  "version": "3.1.2",
  "description": "Resolve a URI relative to an optional base URI",
  "keywords": [
    "resolve",
    "uri",
    "url",
    "path"
  ],
  "author": "Justin Ridgewell <justin@ridgewell.name>",
  "license": "MIT",
  "repository": "https://github.com/jridgewell/resolve-uri",
  "main": "dist/resolve-uri.umd.js",
  "module": "dist/resolve-uri.mjs",
  "types": "dist/types/resolve-uri.d.ts",
  "exports": {
    ".": [
      {
        "types": "./dist/types/resolve-uri.d.ts",
        "browser": "./dist/resolve-uri.umd.js",
        "require": "./dist/resolve-uri.umd.js",
        "import": "./dist/resolve-uri.mjs"
      },
      "./dist/resolve-uri.umd.js"
    ],
    "./package.json": "./package.json"
  },
  "files": [
    "dist"
  ],
  "engines": {
    "node": ">=6.0.0"
  },
  "scripts": {
    "prebuild": "rm -rf dist",
    "build": "run-s -n build:*",
    "build:rollup": "rollup -c rollup.config.js",
    "build:ts": "tsc --project tsconfig.build.json",
    "lint": "run-s -n lint:*",
    "lint:prettier": "npm run test:lint:prettier -- --write",
    "lint:ts": "npm run test:lint:ts -- --fix",
    "pretest": "run-s build:rollup",
    "test": "run-s -n test:lint test:only",
    "test:debug": "mocha --inspect-brk",
    "test:lint": "run-s -n test:lint:*",
    "test:lint:prettier": "prettier --check '{src,test}/**/*.ts'",
    "test:lint:ts": "eslint '{src,test}/**/*.ts'",
    "test:only": "mocha",
    "test:coverage": "c8 mocha",
    "test:watch": "mocha --watch",
    "prepublishOnly": "npm run preversion",
    "preversion": "run-s test build"
  },
  "devDependencies": {
    "@jridgewell/resolve-uri-latest": "npm:@jridgewell/resolve-uri@*",
    "@rollup/plugin-typescript": "8.3.0",
    "@typescript-eslint/eslint-plugin": "5.10.0",
    "@typescript-eslint/parser": "5.10.0",
    "c8": "7.11.0",
    "eslint": "8.7.0",
    "eslint-config-prettier": "8.3.0",
    "mocha": "9.2.0",
    "npm-run-all": "4.1.5",
    "prettier": "2.5.1",
    "rollup": "2.66.0",
    "typescript": "4.5.5"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jridgewell\sourcemap-codec\package.json
============================================================
{
  "name": "@jridgewell/sourcemap-codec",
  "version": "1.5.5",
  "description": "Encode/decode sourcemap mappings",
  "keywords": [
    "sourcemap",
    "vlq"
  ],
  "main": "dist/sourcemap-codec.umd.js",
  "module": "dist/sourcemap-codec.mjs",
  "types": "types/sourcemap-codec.d.cts",
  "files": [
    "dist",
    "src",
    "types"
  ],
  "exports": {
    ".": [
      {
        "import": {
          "types": "./types/sourcemap-codec.d.mts",
          "default": "./dist/sourcemap-codec.mjs"
        },
        "default": {
          "types": "./types/sourcemap-codec.d.cts",
          "default": "./dist/sourcemap-codec.umd.js"
        }
      },
      "./dist/sourcemap-codec.umd.js"
    ],
    "./package.json": "./package.json"
  },
  "scripts": {
    "benchmark": "run-s build:code benchmark:*",
    "benchmark:install": "cd benchmark && npm install",
    "benchmark:only": "node --expose-gc benchmark/index.js",
    "build": "run-s -n build:code build:types",
    "build:code": "node ../../esbuild.mjs sourcemap-codec.ts",
    "build:types": "run-s build:types:force build:types:emit build:types:mts",
    "build:types:force": "rimraf tsconfig.build.tsbuildinfo",
    "build:types:emit": "tsc --project tsconfig.build.json",
    "build:types:mts": "node ../../mts-types.mjs",
    "clean": "run-s -n clean:code clean:types",
    "clean:code": "tsc --build --clean tsconfig.build.json",
    "clean:types": "rimraf dist types",
    "test": "run-s -n test:types test:only test:format",
    "test:format": "prettier --check '{src,test}/**/*.ts'",
    "test:only": "mocha",
    "test:types": "eslint '{src,test}/**/*.ts'",
    "lint": "run-s -n lint:types lint:format",
    "lint:format": "npm run test:format -- --write",
    "lint:types": "npm run test:types -- --fix",
    "prepublishOnly": "npm run-s -n build test"
  },
  "homepage": "https://github.com/jridgewell/sourcemaps/tree/main/packages/sourcemap-codec",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jridgewell/sourcemaps.git",
    "directory": "packages/sourcemap-codec"
  },
  "author": "Justin Ridgewell <justin@ridgewell.name>",
  "license": "MIT"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@jridgewell\trace-mapping\package.json
============================================================
{
  "name": "@jridgewell/trace-mapping",
  "version": "0.3.31",
  "description": "Trace the original position through a source map",
  "keywords": [
    "source",
    "map"
  ],
  "main": "dist/trace-mapping.umd.js",
  "module": "dist/trace-mapping.mjs",
  "types": "types/trace-mapping.d.cts",
  "files": [
    "dist",
    "src",
    "types"
  ],
  "exports": {
    ".": [
      {
        "import": {
          "types": "./types/trace-mapping.d.mts",
          "default": "./dist/trace-mapping.mjs"
        },
        "default": {
          "types": "./types/trace-mapping.d.cts",
          "default": "./dist/trace-mapping.umd.js"
        }
      },
      "./dist/trace-mapping.umd.js"
    ],
    "./package.json": "./package.json"
  },
  "scripts": {
    "benchmark": "run-s build:code benchmark:*",
    "benchmark:install": "cd benchmark && npm install",
    "benchmark:only": "node --expose-gc benchmark/index.mjs",
    "build": "run-s -n build:code build:types",
    "build:code": "node ../../esbuild.mjs trace-mapping.ts",
    "build:types": "run-s build:types:force build:types:emit build:types:mts",
    "build:types:force": "rimraf tsconfig.build.tsbuildinfo",
    "build:types:emit": "tsc --project tsconfig.build.json",
    "build:types:mts": "node ../../mts-types.mjs",
    "clean": "run-s -n clean:code clean:types",
    "clean:code": "tsc --build --clean tsconfig.build.json",
    "clean:types": "rimraf dist types",
    "test": "run-s -n test:types test:only test:format",
    "test:format": "prettier --check '{src,test}/**/*.ts'",
    "test:only": "mocha",
    "test:types": "eslint '{src,test}/**/*.ts'",
    "lint": "run-s -n lint:types lint:format",
    "lint:format": "npm run test:format -- --write",
    "lint:types": "npm run test:types -- --fix",
    "prepublishOnly": "npm run-s -n build test"
  },
  "homepage": "https://github.com/jridgewell/sourcemaps/tree/main/packages/trace-mapping",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jridgewell/sourcemaps.git",
    "directory": "packages/trace-mapping"
  },
  "author": "Justin Ridgewell <justin@ridgewell.name>",
  "license": "MIT",
  "dependencies": {
    "@jridgewell/resolve-uri": "^3.1.0",
    "@jridgewell/sourcemap-codec": "^1.4.14"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@pkgjs\parseargs\package.json
============================================================
{
  "name": "@pkgjs/parseargs",
  "version": "0.11.0",
  "description": "Polyfill of future proposal for `util.parseArgs()`",
  "engines": {
    "node": ">=14"
  },
  "main": "index.js",
  "exports": {
    ".": "./index.js",
    "./package.json": "./package.json"
  },
  "scripts": {
    "coverage": "c8 --check-coverage tape 'test/*.js'",
    "test": "c8 tape 'test/*.js'",
    "posttest": "eslint .",
    "fix": "npm run posttest -- --fix"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:pkgjs/parseargs.git"
  },
  "keywords": [],
  "author": "",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/pkgjs/parseargs/issues"
  },
  "homepage": "https://github.com/pkgjs/parseargs#readme",
  "devDependencies": {
    "c8": "^7.10.0",
    "eslint": "^8.2.0",
    "eslint-plugin-node-core": "iansu/eslint-plugin-node-core",
    "tape": "^5.2.2"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@pkgr\core\package.json
============================================================
{
  "name": "@pkgr/core",
  "version": "0.2.9",
  "type": "module",
  "description": "Shared core module for `@pkgr` packages or any package else",
  "repository": "git+https://github.com/un-ts/pkgr.git",
  "homepage": "https://github.com/un-ts/pkgr/blob/master/packages/core",
  "author": "JounQin <admin@1stg.me> (https://www.1stG.me)",
  "funding": "https://opencollective.com/pkgr",
  "license": "MIT",
  "engines": {
    "node": "^12.20.0 || ^14.18.0 || >=16.0.0"
  },
  "main": "./lib/index.cjs",
  "types": "./index.d.cts",
  "module": "./lib/index.js",
  "exports": {
    ".": {
      "import": {
        "types": "./lib/index.d.ts",
        "default": "./lib/index.js"
      },
      "require": {
        "types": "./index.d.cts",
        "default": "./lib/index.cjs"
      }
    },
    "./package.json": "./package.json"
  },
  "files": [
    "index.d.cts",
    "lib"
  ],
  "publishConfig": {
    "access": "public"
  },
  "sideEffects": false
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@polka\url\package.json
============================================================
{
  "version": "1.0.0-next.29",
  "name": "@polka/url",
  "repository": "lukeed/polka",
  "description": "Super fast, memoized `req.url` parser",
  "module": "build.mjs",
  "types": "index.d.ts",
  "main": "build.js",
  "license": "MIT",
  "exports": {
    ".": {
      "types": "./index.d.ts",
      "import": "./build.mjs",
      "require": "./build.js"
    },
    "./package.json": "./package.json"
  },
  "files": [
    "build.*",
    "index.d.*"
  ],
  "author": {
    "name": "Luke Edwards",
    "email": "luke@lukeed.com",
    "url": "https://lukeed.com"
  },
  "publishConfig": {
    "access": "public"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@remix-run\router\package.json
============================================================
{
  "name": "@remix-run/router",
  "version": "1.23.0",
  "description": "Nested/Data-driven/Framework-agnostic Routing",
  "keywords": [
    "remix",
    "router",
    "location"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/remix-run/react-router",
    "directory": "packages/router"
  },
  "license": "MIT",
  "author": "Remix Software <hello@remix.run>",
  "sideEffects": false,
  "main": "./dist/router.cjs.js",
  "unpkg": "./dist/router.umd.min.js",
  "module": "./dist/router.js",
  "types": "./dist/index.d.ts",
  "files": [
    "dist/",
    "*.ts",
    "CHANGELOG.md"
  ],
  "engines": {
    "node": ">=14.0.0"
  },
  "publishConfig": {
    "access": "public"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@rollup\rollup-win32-x64-gnu\package.json
============================================================
{
  "name": "@rollup/rollup-win32-x64-gnu",
  "version": "4.52.5",
  "os": [
    "win32"
  ],
  "cpu": [
    "x64"
  ],
  "files": [
    "rollup.win32-x64-gnu.node"
  ],
  "description": "Native bindings for Rollup",
  "author": "Lukas Taegert-Atkinson",
  "homepage": "https://rollupjs.org/",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rollup/rollup.git"
  },
  "main": "./rollup.win32-x64-gnu.node"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@rollup\rollup-win32-x64-msvc\package.json
============================================================
{
  "name": "@rollup/rollup-win32-x64-msvc",
  "version": "4.52.5",
  "os": [
    "win32"
  ],
  "cpu": [
    "x64"
  ],
  "files": [
    "rollup.win32-x64-msvc.node"
  ],
  "description": "Native bindings for Rollup",
  "author": "Lukas Taegert-Atkinson",
  "homepage": "https://rollupjs.org/",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rollup/rollup.git"
  },
  "main": "./rollup.win32-x64-msvc.node"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@sinclair\typebox\compiler\package.json
============================================================
{
  "main": "../build/cjs/compiler/index.js",
  "types": "../build/cjs/compiler/index.d.ts"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@sinclair\typebox\errors\package.json
============================================================
{
  "main": "../build/cjs/errors/index.js",
  "types": "../build/cjs/errors/index.d.ts"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@sinclair\typebox\parser\package.json
============================================================
{
  "main": "../build/cjs/parser/index.js",
  "types": "../build/cjs/parser/index.d.ts"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@sinclair\typebox\syntax\package.json
============================================================
{
  "main": "../build/cjs/syntax/index.js",
  "types": "../build/cjs/syntax/index.d.ts"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@sinclair\typebox\system\package.json
============================================================
{
  "main": "../build/cjs/system/index.js",
  "types": "../build/cjs/system/index.d.ts"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@sinclair\typebox\type\package.json
============================================================
{
  "main": "../build/cjs/type/index.js",
  "types": "../build/cjs/type/index.d.ts"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@sinclair\typebox\value\package.json
============================================================
{
  "main": "../build/cjs/value/index.js",
  "types": "../build/cjs/value/index.d.ts"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@sinclair\typebox\package.json
============================================================
{
  "name": "@sinclair/typebox",
  "version": "0.34.41",
  "description": "Json Schema Type Builder with Static Type Resolution for TypeScript",
  "keywords": [
    "typescript",
    "json-schema",
    "validate",
    "typecheck"
  ],
  "author": "sinclairzx81",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/sinclairzx81/typebox"
  },
  "scripts": {
    "test": "echo test"
  },
  "types": "./build/cjs/index.d.ts",
  "main": "./build/cjs/index.js",
  "module": "./build/esm/index.mjs",
  "esm.sh": {
    "bundle": false
  },
  "sideEffects": [
    "./build/esm/type/registry/format.mjs",
    "./build/esm/type/registry/type.mjs",
    "./build/esm/type/system/policy.mjs",
    "./build/cjs/type/registry/format.js",
    "./build/cjs/type/registry/type.js",
    "./build/cjs/type/system/policy.js"
  ],
  "exports": {
    ".": {
      "require": {
        "types": "./build/cjs/index.d.ts",
        "default": "./build/cjs/index.js"
      },
      "import": {
        "types": "./build/esm/index.d.mts",
        "default": "./build/esm/index.mjs"
      }
    },
    "./compiler": {
      "require": {
        "types": "./build/cjs/compiler/index.d.ts",
        "default": "./build/cjs/compiler/index.js"
      },
      "import": {
        "types": "./build/esm/compiler/index.d.mts",
        "default": "./build/esm/compiler/index.mjs"
      }
    },
    "./errors": {
      "require": {
        "types": "./build/cjs/errors/index.d.ts",
        "default": "./build/cjs/errors/index.js"
      },
      "import": {
        "types": "./build/esm/errors/index.d.mts",
        "default": "./build/esm/errors/index.mjs"
      }
    },
    "./parser": {
      "require": {
        "types": "./build/cjs/parser/index.d.ts",
        "default": "./build/cjs/parser/index.js"
      },
      "import": {
        "types": "./build/esm/parser/index.d.mts",
        "default": "./build/esm/parser/index.mjs"
      }
    },
    "./syntax": {
      "require": {
        "types": "./build/cjs/syntax/index.d.ts",
        "default": "./build/cjs/syntax/index.js"
      },
      "import": {
        "types": "./build/esm/syntax/index.d.mts",
        "default": "./build/esm/syntax/index.mjs"
      }
    },
    "./system": {
      "require": {
        "types": "./build/cjs/system/index.d.ts",
        "default": "./build/cjs/system/index.js"
      },
      "import": {
        "types": "./build/esm/system/index.d.mts",
        "default": "./build/esm/system/index.mjs"
      }
    },
    "./type": {
      "require": {
        "types": "./build/cjs/type/index.d.ts",
        "default": "./build/cjs/type/index.js"
      },
      "import": {
        "types": "./build/esm/type/index.d.mts",
        "default": "./build/esm/type/index.mjs"
      }
    },
    "./value": {
      "require": {
        "types": "./build/cjs/value/index.d.ts",
        "default": "./build/cjs/value/index.js"
      },
      "import": {
        "types": "./build/esm/value/index.d.mts",
        "default": "./build/esm/value/index.mjs"
      }
    }
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@sinonjs\commons\package.json
============================================================
{
  "name": "@sinonjs/commons",
  "version": "3.0.1",
  "description": "Simple functions shared among the sinon end user libraries",
  "main": "lib/index.js",
  "types": "./types/index.d.ts",
  "scripts": {
    "build": "rm -rf types && tsc",
    "lint": "eslint .",
    "precommit": "lint-staged",
    "test": "mocha --recursive -R dot \"lib/**/*.test.js\"",
    "test-check-coverage": "npm run test-coverage && nyc check-coverage --branches 100 --functions 100 --lines 100",
    "test-coverage": "nyc --reporter text --reporter html --reporter lcovonly npm run test",
    "prepublishOnly": "npm run build",
    "prettier:check": "prettier --check '**/*.{js,css,md}'",
    "prettier:write": "prettier --write '**/*.{js,css,md}'",
    "preversion": "npm run test-check-coverage",
    "version": "changes --commits --footer",
    "postversion": "git push --follow-tags && npm publish",
    "prepare": "husky install"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/sinonjs/commons.git"
  },
  "files": [
    "lib",
    "types"
  ],
  "author": "",
  "license": "BSD-3-Clause",
  "bugs": {
    "url": "https://github.com/sinonjs/commons/issues"
  },
  "homepage": "https://github.com/sinonjs/commons#readme",
  "lint-staged": {
    "*.{js,css,md}": "prettier --check",
    "*.js": "eslint"
  },
  "devDependencies": {
    "@sinonjs/eslint-config": "^4.0.6",
    "@sinonjs/eslint-plugin-no-prototype-methods": "^0.1.0",
    "@sinonjs/referee-sinon": "^10.1.0",
    "@studio/changes": "^2.2.0",
    "husky": "^6.0.0",
    "jsverify": "0.8.4",
    "knuth-shuffle": "^1.0.8",
    "lint-staged": "^13.0.3",
    "mocha": "^10.1.0",
    "nyc": "^15.1.0",
    "prettier": "^2.7.1",
    "typescript": "^4.8.4"
  },
  "dependencies": {
    "type-detect": "4.0.8"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@sinonjs\fake-timers\package.json
============================================================
{
  "name": "@sinonjs/fake-timers",
  "description": "Fake JavaScript timers",
  "version": "13.0.5",
  "homepage": "https://github.com/sinonjs/fake-timers",
  "author": "Christian Johansen",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/sinonjs/fake-timers.git"
  },
  "bugs": {
    "mail": "christian@cjohansen.no",
    "url": "https://github.com/sinonjs/fake-timers/issues"
  },
  "license": "BSD-3-Clause",
  "scripts": {
    "lint": "eslint .",
    "test-node": "mocha --timeout 200 test/ integration-test/ -R dot --check-leaks",
    "test-headless": "mochify --driver puppeteer",
    "test-check-coverage": "npm run test-coverage && nyc check-coverage",
    "test-cloud": "npm run test-edge && npm run test-firefox && npm run test-safari",
    "test-edge": "BROWSER_NAME=MicrosoftEdge mochify --config mochify.webdriver.js",
    "test-firefox": "BROWSER_NAME=firefox mochify --config mochify.webdriver.js",
    "test-safari": "BROWSER_NAME=safari mochify --config mochify.webdriver.js",
    "test-coverage": "nyc -x mochify.webdriver.js -x coverage --all --reporter text --reporter html --reporter lcovonly npm run test-node",
    "test": "npm run test-node && npm run test-headless",
    "prettier:check": "prettier --check '**/*.{js,css,md}'",
    "prettier:write": "prettier --write '**/*.{js,css,md}'",
    "preversion": "./scripts/preversion.sh",
    "version": "./scripts/version.sh",
    "postversion": "./scripts/postversion.sh",
    "prepare": "husky"
  },
  "lint-staged": {
    "*.{js,css,md}": "prettier --check",
    "*.js": "eslint"
  },
  "mochify": {
    "reporter": "dot",
    "timeout": 10000,
    "bundle": "esbuild --bundle --sourcemap=inline --define:process.env.NODE_DEBUG=\"\"",
    "bundle_stdin": "require",
    "spec": "test/**/*-test.js"
  },
  "files": [
    "src/"
  ],
  "devDependencies": {
    "@mochify/cli": "^0.4.1",
    "@mochify/driver-puppeteer": "^0.4.0",
    "@mochify/driver-webdriver": "^0.2.1",
    "@sinonjs/eslint-config": "^5.0.3",
    "@sinonjs/referee-sinon": "12.0.0",
    "esbuild": "^0.23.1",
    "husky": "^9.1.5",
    "jsdom": "24.1.1",
    "lint-staged": "15.2.9",
    "mocha": "10.7.3",
    "nyc": "17.0.0",
    "prettier": "3.3.3"
  },
  "main": "./src/fake-timers-src.js",
  "dependencies": {
    "@sinonjs/commons": "^3.0.1"
  },
  "nyc": {
    "branches": 85,
    "lines": 92,
    "functions": 92,
    "statements": 92,
    "exclude": [
      "**/*-test.js",
      "coverage/**",
      "types/**",
      "fake-timers.js"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@standard-schema\spec\package.json
============================================================
{
  "name": "@standard-schema/spec",
  "description": "A standard interface for TypeScript schema validation libraries",
  "version": "1.0.0",
  "license": "MIT",
  "author": "Colin McDonnell",
  "homepage": "https://standardschema.dev",
  "repository": {
    "type": "git",
    "url": "https://github.com/standard-schema/standard-schema"
  },
  "keywords": [
    "typescript",
    "schema",
    "validation",
    "standard",
    "interface"
  ],
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      },
      "require": {
        "types": "./dist/index.d.cts",
        "default": "./dist/index.cjs"
      }
    }
  },
  "sideEffects": false,
  "files": [
    "dist"
  ],
  "publishConfig": {
    "access": "public"
  },
  "devDependencies": {
    "tsup": "^8.3.0",
    "typescript": "^5.6.2"
  },
  "scripts": {
    "lint": "pnpm biome lint ./src",
    "format": "pnpm biome format --write ./src",
    "check": "pnpm biome check ./src",
    "build": "tsup"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@testing-library\dom\dist\config.js
============================================================
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configure = configure;
exports.getConfig = getConfig;
exports.runWithExpensiveErrorDiagnosticsDisabled = runWithExpensiveErrorDiagnosticsDisabled;
var _prettyDom = require("./pretty-dom");
// It would be cleaner for this to live inside './queries', but
// other parts of the code assume that all exports from
// './queries' are query functions.
let config = {
  testIdAttribute: 'data-testid',
  asyncUtilTimeout: 1000,
  // asyncWrapper and advanceTimersWrapper is to support React's async `act` function.
  // forcing react-testing-library to wrap all async functions would've been
  // a total nightmare (consider wrapping every findBy* query and then also
  // updating `within` so those would be wrapped too. Total nightmare).
  // so we have this config option that's really only intended for
  // react-testing-library to use. For that reason, this feature will remain
  // undocumented.
  asyncWrapper: cb => cb(),
  unstable_advanceTimersWrapper: cb => cb(),
  eventWrapper: cb => cb(),
  // default value for the `hidden` option in `ByRole` queries
  defaultHidden: false,
  // default value for the `ignore` option in `ByText` queries
  defaultIgnore: 'script, style',
  // showOriginalStackTrace flag to show the full error stack traces for async errors
  showOriginalStackTrace: false,
  // throw errors w/ suggestions for better queries. Opt in so off by default.
  throwSuggestions: false,
  // called when getBy* queries fail. (message, container) => Error
  getElementError(message, container) {
    const prettifiedDOM = (0, _prettyDom.prettyDOM)(container);
    const error = new Error([message, `Ignored nodes: comments, ${config.defaultIgnore}\n${prettifiedDOM}`].filter(Boolean).join('\n\n'));
    error.name = 'TestingLibraryElementError';
    return error;
  },
  _disableExpensiveErrorDiagnostics: false,
  computedStyleSupportsPseudoElements: false
};
function runWithExpensiveErrorDiagnosticsDisabled(callback) {
  try {
    config._disableExpensiveErrorDiagnostics = true;
    return callback();
  } finally {
    config._disableExpensiveErrorDiagnostics = false;
  }
}
function configure(newConfig) {
  if (typeof newConfig === 'function') {
    // Pass the existing config out to the provided function
    // and accept a delta in return
    newConfig = newConfig(config);
  }

  // Merge the incoming config delta
  config = {
    ...config,
    ...newConfig
  };
}
function getConfig() {
  return config;
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@testing-library\dom\package.json
============================================================
{
  "name": "@testing-library/dom",
  "version": "10.4.1",
  "description": "Simple and complete DOM testing utilities that encourage good testing practices.",
  "main": "dist/index.js",
  "types": "types/index.d.ts",
  "module": "dist/@testing-library/dom.esm.js",
  "umd:main": "dist/@testing-library/dom.umd.js",
  "source": "src/index.js",
  "keywords": [
    "testing",
    "ui",
    "dom",
    "jsdom",
    "unit",
    "integration",
    "functional",
    "end-to-end",
    "e2e"
  ],
  "author": "Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)",
  "license": "MIT",
  "engines": {
    "node": ">=18"
  },
  "browserslist": [
    "and_chr 103",
    "and_ff 101",
    "and_qq 10.4",
    "and_uc 12.12",
    "android 103",
    "chrome 102",
    "edge 102",
    "firefox 91",
    "ios_saf 12.2-12.5",
    "kaios 2.5",
    "op_mini all",
    "op_mob 64",
    "opera 88",
    "safari 15.5",
    "samsung 17.0",
    "samsung 16.0",
    "node 18.0"
  ],
  "scripts": {
    "build": "kcd-scripts build  --no-ts-defs --ignore \"**/__tests__/**,**/__node_tests__/**,**/__mocks__/**\" && kcd-scripts build --no-ts-defs --bundle --no-clean",
    "format": "kcd-scripts format",
    "install:csb": "npm install",
    "lint": "kcd-scripts lint",
    "setup": "npm install && npm run validate -s",
    "test": "kcd-scripts test",
    "test:debug": "node --inspect-brk ./node_modules/.bin/jest --watch --runInBand",
    "test:update": "npm test -- --updateSnapshot --coverage",
    "validate": "kcd-scripts validate",
    "typecheck": "kcd-scripts typecheck --build types"
  },
  "files": [
    "dist",
    "types/*.d.ts"
  ],
  "dependencies": {
    "@babel/code-frame": "^7.10.4",
    "@babel/runtime": "^7.12.5",
    "@types/aria-query": "^5.0.1",
    "aria-query": "5.3.0",
    "dom-accessibility-api": "^0.5.9",
    "lz-string": "^1.5.0",
    "picocolors": "1.1.1",
    "pretty-format": "^27.0.2"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^5.11.6",
    "browserslist": "4.21.8",
    "caniuse-lite": "1.0.30001502",
    "jest-in-case": "^1.0.2",
    "jest-snapshot-serializer-ansi": "^1.0.0",
    "jest-watch-select-projects": "^2.0.0",
    "jsdom": "20.0.0",
    "kcd-scripts": "^13.0.0",
    "typescript": "^4.1.2"
  },
  "overrides": {
    "@babel/helper-compilation-targets": "7.24.7",
    "browserslist": "4.21.8",
    "caniuse-lite": "1.0.30001502"
  },
  "eslintConfig": {
    "extends": [
      "./node_modules/kcd-scripts/eslint.js",
      "plugin:import/typescript"
    ],
    "parserOptions": {
      "ecmaVersion": 2020
    },
    "rules": {
      "@typescript-eslint/prefer-optional-chain": "off",
      "@typescript-eslint/no-explicit-any": "off",
      "@typescript-eslint/no-unsafe-member-access": "off",
      "@typescript-eslint/no-unnecessary-boolean-literal-compare": "off",
      "@typescript-eslint/prefer-includes": "off",
      "import/prefer-default-export": "off",
      "import/no-unassigned-import": "off",
      "import/no-useless-path-segments": "off",
      "no-console": "off"
    }
  },
  "eslintIgnore": [
    "node_modules",
    "coverage",
    "dist"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/testing-library/dom-testing-library"
  },
  "bugs": {
    "url": "https://github.com/testing-library/dom-testing-library/issues"
  },
  "homepage": "https://github.com/testing-library/dom-testing-library#readme"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@testing-library\jest-dom\node_modules\dom-accessibility-api\package.json
============================================================
{
	"name": "dom-accessibility-api",
	"description": "Implements https://w3c.github.io/accname/",
	"version": "0.6.3",
	"main": "dist/index.js",
	"module": "dist/index.mjs",
	"type": "commonjs",
	"exports": {
		"types": "./dist/index.d.ts",
		"import": "./dist/index.mjs",
		"require": "./dist/index.js"
	},
	"license": "MIT",
	"repository": {
		"type": "git",
		"url": "https://github.com/eps1lon/dom-accessibility-api.git"
	},
	"files": [
		"dist/"
	],
	"scripts": {
		"build": "yarn build:clean && yarn build:source && yarn build:source:cjs && yarn build:types",
		"build:clean": "rimraf dist",
		"build:source": "cross-env BABEL_ENV=esm babel sources --extensions \".ts\" --ignore \"**/__tests__/**/*\" --out-dir dist/ --out-file-extension=.mjs --source-maps",
		"build:source:cjs": "cross-env BABEL_ENV=cjs babel sources --extensions \".ts\" --ignore \"**/__tests__/**/*\" --out-dir dist/ --out-file-extension=.js --source-maps",
		"build:types": "tsc -p tsconfig.json --emitDeclarationOnly",
		"format": "prettier \"**/*.{json,js,md,ts,yml}\" --write --ignore-path .prettierignore",
		"lint": "eslint --report-unused-disable-directives \"{scripts,sources}/**/*.{js,ts}\"",
		"release": "yarn build && yarn changeset publish",
		"test": "jest --config scripts/jest/jest.config.js",
		"test:ci": "jest --ci --config scripts/jest/jest.ci.config.js --runInBand",
		"test:coverage": "jest --config scripts/jest/jest.coverage.config.js",
		"test:types": "tsc -p tsconfig.json --noEmit",
		"test:wpt:jsdom": "mocha tests/wpt-jsdom/run-wpts.js",
		"test:wpt:browser": "concurrently --success first --kill-others \"yarn test:wpt:browser:run\" \"yarn test:wpt:browser:server\"",
		"test:wpt:browser:run": "cypress run --project tests",
		"test:wpt:browser:server": "serve tests/wpt",
		"test:wpt:browser:open": "cypress open --project tests",
		"wpt:init": "git submodule update --init --recursive",
		"wpt:reset": "rimraf ./tests/wpt && yarn wpt:init",
		"wpt:update": "git submodule update --recursive --remote && cd tests/wpt && python wpt.py manifest --path ../wpt-jsdom/wpt-manifest.json"
	},
	"devDependencies": {
		"@babel/cli": "^7.14.3",
		"@babel/core": "^7.14.3",
		"@babel/plugin-proposal-class-properties": "^7.13.0",
		"@babel/preset-env": "^7.14.4",
		"@babel/preset-typescript": "^7.13.0",
		"@changesets/changelog-github": "^0.4.0",
		"@changesets/cli": "^2.16.0",
		"@testing-library/dom": "^9.0.0",
		"@types/jest": "^29.0.0",
		"@types/node": "18.17.17",
		"@typescript-eslint/eslint-plugin": "^6.0.0",
		"@typescript-eslint/parser": "^6.0.0",
		"concurrently": "^8.0.0",
		"cross-env": "^7.0.3",
		"cypress": "^12.0.0",
		"eslint": "^7.27.0",
		"eslint-plugin-jest": "^27.0.0",
		"jest": "^29.0.0",
		"jest-diff": "^29.0.0",
		"jest-environment-jsdom": "^29.0.0",
		"jest-junit": "^16.0.0",
		"js-yaml": "^4.1.0",
		"jsdom": "^20.0.0",
		"minimatch": "^9.0.0",
		"mocha": "^10.0.0",
		"mocha-sugar-free": "^1.4.0",
		"prettier": "^3.0.0",
		"q": "^1.5.1",
		"request": "^2.88",
		"request-promise-native": "^1.0.9",
		"rimraf": "^5.0.0",
		"serve": "^14.0.0",
		"typescript": "^5.0.0"
	},
	"resolutions": {
		"@types/node": "18.17.17"
	},
	"prettier": {
		"useTabs": true
	},
	"keywords": [
		"accessibility",
		"ARIA",
		"accname"
	],
	"publishConfig": {
		"access": "public"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@testing-library\jest-dom\package.json
============================================================
{
  "name": "@testing-library/jest-dom",
  "version": "6.9.1",
  "description": "Custom jest matchers to test the state of the DOM",
  "main": "dist/index.js",
  "module": "dist/index.mjs",
  "exports": {
    ".": {
      "require": {
        "types": "./types/index.d.ts",
        "default": "./dist/index.js"
      },
      "import": {
        "types": "./types/index.d.ts",
        "default": "./dist/index.mjs"
      }
    },
    "./jest-globals": {
      "require": {
        "types": "./types/jest-globals.d.ts",
        "default": "./dist/jest-globals.js"
      },
      "import": {
        "types": "./types/jest-globals.d.ts",
        "default": "./dist/jest-globals.mjs"
      }
    },
    "./matchers": {
      "require": {
        "types": "./types/matchers-standalone.d.ts",
        "default": "./dist/matchers.js"
      },
      "import": {
        "types": "./types/matchers-standalone.d.ts",
        "default": "./dist/matchers.mjs"
      }
    },
    "./vitest": {
      "require": {
        "types": "./types/vitest.d.ts",
        "default": "./dist/vitest.js"
      },
      "import": {
        "types": "./types/vitest.d.ts",
        "default": "./dist/vitest.mjs"
      }
    },
    "./package.json": "./package.json"
  },
  "types": "types/index.d.ts",
  "engines": {
    "node": ">=14",
    "npm": ">=6",
    "yarn": ">=1"
  },
  "scripts": {
    "build": "rollup -c",
    "format": "kcd-scripts format",
    "lint": "kcd-scripts lint",
    "setup": "npm install && npm run validate -s",
    "test": "kcd-scripts test",
    "test:update": "npm test -- --updateSnapshot --coverage",
    "test:types": "tsc -p types/__tests__/jest && tsc -p types/__tests__/jest-globals && tsc -p types/__tests__/vitest && tsc -p types/__tests__/bun",
    "validate": "kcd-scripts validate && npm run test:types"
  },
  "files": [
    "dist",
    "types",
    "*.d.ts",
    "jest-globals.js",
    "matchers.js",
    "vitest.js"
  ],
  "keywords": [
    "testing",
    "dom",
    "jest",
    "jsdom"
  ],
  "author": "Ernesto Garcia <gnapse@gmail.com> (http://gnapse.github.io)",
  "license": "MIT",
  "dependencies": {
    "@adobe/css-tools": "^4.4.0",
    "aria-query": "^5.0.0",
    "css.escape": "^1.5.1",
    "dom-accessibility-api": "^0.6.3",
    "picocolors": "^1.1.1",
    "redent": "^3.0.0"
  },
  "devDependencies": {
    "@jest/globals": "^29.6.2",
    "@rollup/plugin-commonjs": "^25.0.4",
    "@types/bun": "latest",
    "@types/web": "latest",
    "expect": "^29.6.2",
    "jest-environment-jsdom-sixteen": "^1.0.3",
    "jest-watch-select-projects": "^2.0.0",
    "jsdom": "^16.2.1",
    "kcd-scripts": "^14.0.0",
    "pretty-format": "^25.1.0",
    "rollup": "^3.28.1",
    "rollup-plugin-delete": "^2.0.0",
    "typescript": "^5.1.6",
    "vitest": "^0.34.1"
  },
  "eslintConfig": {
    "extends": "./node_modules/kcd-scripts/eslint.js",
    "parserOptions": {
      "sourceType": "module",
      "ecmaVersion": 2020
    },
    "rules": {
      "no-invalid-this": "off"
    },
    "overrides": [
      {
        "files": [
          "src/__tests__/*.js"
        ],
        "rules": {
          "max-lines-per-function": "off"
        }
      },
      {
        "files": [
          "**/*.d.ts"
        ],
        "rules": {
          "@typescript-eslint/no-empty-interface": "off",
          "@typescript-eslint/no-explicit-any": "off",
          "@typescript-eslint/no-invalid-void-type": "off",
          "@typescript-eslint/no-unused-vars": "off",
          "@typescript-eslint/triple-slash-reference": "off"
        }
      }
    ]
  },
  "eslintIgnore": [
    "node_modules",
    "coverage",
    "dist",
    "types/__tests__"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/testing-library/jest-dom"
  },
  "bugs": {
    "url": "https://github.com/testing-library/jest-dom/issues"
  },
  "homepage": "https://github.com/testing-library/jest-dom#readme"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@testing-library\react\dist\config.js
============================================================
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configure = configure;
exports.getConfig = getConfig;
var _dom = require("@testing-library/dom");
let configForRTL = {
  reactStrictMode: false
};
function getConfig() {
  return {
    ...(0, _dom.getConfig)(),
    ...configForRTL
  };
}
function configure(newConfig) {
  if (typeof newConfig === 'function') {
    // Pass the existing config out to the provided function
    // and accept a delta in return
    newConfig = newConfig(getConfig());
  }
  const {
    reactStrictMode,
    ...configForDTL
  } = newConfig;
  (0, _dom.configure)(configForDTL);
  configForRTL = {
    ...configForRTL,
    reactStrictMode
  };
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@testing-library\react\package.json
============================================================
{
  "name": "@testing-library/react",
  "version": "16.3.0",
  "description": "Simple and complete React DOM testing utilities that encourage good testing practices.",
  "main": "dist/index.js",
  "types": "types/index.d.ts",
  "module": "dist/@testing-library/react.esm.js",
  "engines": {
    "node": ">=18"
  },
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "npm-run-all --parallel build:main build:bundle:main build:bundle:pure",
    "build:bundle:main": "dotenv -e .bundle.main.env kcd-scripts build -- --bundle --no-clean",
    "build:bundle:pure": "dotenv -e .bundle.main.env -e .bundle.pure.env kcd-scripts build -- --bundle --no-clean",
    "build:main": "kcd-scripts build --no-clean",
    "format": "kcd-scripts format",
    "install:csb": "npm install",
    "lint": "kcd-scripts lint",
    "setup": "npm install && npm run validate -s",
    "test": "kcd-scripts test",
    "test:update": "npm test -- --updateSnapshot --coverage",
    "typecheck": "kcd-scripts typecheck --build types",
    "validate": "kcd-scripts validate"
  },
  "files": [
    "dist",
    "dont-cleanup-after-each.js",
    "pure.js",
    "pure.d.ts",
    "types/*.d.ts"
  ],
  "keywords": [
    "testing",
    "react",
    "ui",
    "dom",
    "jsdom",
    "unit",
    "integration",
    "functional",
    "end-to-end",
    "e2e"
  ],
  "author": "Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)",
  "license": "MIT",
  "dependencies": {
    "@babel/runtime": "^7.12.5"
  },
  "devDependencies": {
    "@testing-library/dom": "^10.0.0",
    "@testing-library/jest-dom": "^5.11.6",
    "@types/react": "^19.0.0",
    "@types/react-dom": "^19.0.0",
    "chalk": "^4.1.2",
    "dotenv-cli": "^4.0.0",
    "jest-diff": "^29.7.0",
    "kcd-scripts": "^13.0.0",
    "npm-run-all": "^4.1.5",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "rimraf": "^3.0.2",
    "typescript": "^4.1.2"
  },
  "peerDependencies": {
    "@testing-library/dom": "^10.0.0",
    "@types/react": "^18.0.0 || ^19.0.0",
    "@types/react-dom": "^18.0.0 || ^19.0.0",
    "react": "^18.0.0 || ^19.0.0",
    "react-dom": "^18.0.0 || ^19.0.0"
  },
  "peerDependenciesMeta": {
    "@types/react": {
      "optional": true
    },
    "@types/react-dom": {
      "optional": true
    }
  },
  "eslintConfig": {
    "extends": "./node_modules/kcd-scripts/eslint.js",
    "parserOptions": {
      "ecmaVersion": 2022
    },
    "globals": {
      "globalThis": "readonly"
    },
    "rules": {
      "react/prop-types": "off",
      "react/no-adjacent-inline-elements": "off",
      "import/no-unassigned-import": "off",
      "import/named": "off",
      "testing-library/no-container": "off",
      "testing-library/no-debugging-utils": "off",
      "testing-library/no-dom-import": "off",
      "testing-library/no-unnecessary-act": "off",
      "testing-library/prefer-explicit-assert": "off",
      "testing-library/prefer-find-by": "off",
      "testing-library/prefer-user-event": "off"
    }
  },
  "eslintIgnore": [
    "node_modules",
    "coverage",
    "dist",
    "*.d.ts"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/testing-library/react-testing-library"
  },
  "bugs": {
    "url": "https://github.com/testing-library/react-testing-library/issues"
  },
  "homepage": "https://github.com/testing-library/react-testing-library#readme"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@testing-library\user-event\dist\cjs\setup\api.js
============================================================
'use strict';

var click = require('../convenience/click.js');
var hover = require('../convenience/hover.js');
var tab = require('../convenience/tab.js');
var index = require('../keyboard/index.js');
var copy = require('../clipboard/copy.js');
var cut = require('../clipboard/cut.js');
var paste = require('../clipboard/paste.js');
var index$1 = require('../pointer/index.js');
var clear = require('../utility/clear.js');
var selectOptions = require('../utility/selectOptions.js');
var type = require('../utility/type.js');
var upload = require('../utility/upload.js');

const userEventApi = {
    click: click.click,
    dblClick: click.dblClick,
    tripleClick: click.tripleClick,
    hover: hover.hover,
    unhover: hover.unhover,
    tab: tab.tab,
    keyboard: index.keyboard,
    copy: copy.copy,
    cut: cut.cut,
    paste: paste.paste,
    pointer: index$1.pointer,
    clear: clear.clear,
    deselectOptions: selectOptions.deselectOptions,
    selectOptions: selectOptions.selectOptions,
    type: type.type,
    upload: upload.upload
};

exports.userEventApi = userEventApi;

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@testing-library\user-event\dist\cjs\package.json
============================================================
{
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@testing-library\user-event\dist\esm\setup\api.js
============================================================
import { click, dblClick, tripleClick } from '../convenience/click.js';
import { hover, unhover } from '../convenience/hover.js';
import { tab } from '../convenience/tab.js';
import { keyboard } from '../keyboard/index.js';
import { copy } from '../clipboard/copy.js';
import { cut } from '../clipboard/cut.js';
import { paste } from '../clipboard/paste.js';
import { pointer } from '../pointer/index.js';
import { clear } from '../utility/clear.js';
import { deselectOptions, selectOptions } from '../utility/selectOptions.js';
import { type } from '../utility/type.js';
import { upload } from '../utility/upload.js';

const userEventApi = {
    click,
    dblClick,
    tripleClick,
    hover,
    unhover,
    tab,
    keyboard,
    copy,
    cut,
    paste,
    pointer,
    clear,
    deselectOptions,
    selectOptions,
    type,
    upload
};

export { userEventApi };

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@testing-library\user-event\dist\esm\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@testing-library\user-event\package.json
============================================================
{
  "name": "@testing-library/user-event",
  "version": "14.6.1",
  "description": "Fire events the same way the user does",
  "keywords": [
    "react-testing-library",
    "dom-testing-library",
    "react",
    "testing"
  ],
  "author": "Giorgio Polvara <polvara@gmail.com>",
  "license": "MIT",
  "engines": {
    "node": ">=12",
    "npm": ">=6"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/testing-library/user-event"
  },
  "bugs": {
    "url": "https://github.com/testing-library/user-event/issues"
  },
  "homepage": "https://github.com/testing-library/user-event#readme",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "scripts ts-build2 --cjs --target es2019",
    "lint": "kcd-scripts lint",
    "setup": "npm install && npm run validate -s",
    "setup:env": "node --experimental-import-meta-resolve scripts/setup.js",
    "test": "kcd-scripts test",
    "test:jest": "kcd-scripts test",
    "test:toolbox": "NODE_OPTIONS='--experimental-vm-modules --experimental-modules --experimental-import-meta-resolve' node scripts/test.js",
    "test:debug": "kcd-scripts --inspect-brk test --runInBand",
    "test:update": "npm test -- --updateSnapshot --coverage",
    "validate": "kcd-scripts typecheck"
  },
  "devDependencies": {
    "@esbuild-plugins/node-modules-polyfill": "^0.2.2",
    "@ph.fritsche/scripts-config": "^2.4.0",
    "@ph.fritsche/toolbox": "^1.0.0-alpha.11",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^5.16.3",
    "@testing-library/react": "^16.1.0",
    "@types/jest-in-case": "^1.0.3",
    "@types/react": "^18.0.25",
    "@types/sinonjs__fake-timers": "^8.1.2",
    "css.escape": "^1.5.1",
    "esbuild": "^0.19.10",
    "esbuild-plugin-globals": "^0.2.0",
    "eslint-import-resolver-typescript": "^3.5.2",
    "eslint-plugin-local-rules": "^1.3.2",
    "expect": "^28.1.3",
    "is-ci": "^3.0.1",
    "istanbul-lib-coverage": "^3.2.0",
    "istanbul-lib-report": "^3.0.0",
    "istanbul-lib-source-maps": "^4.0.1",
    "istanbul-reports": "^3.1.5",
    "jest-in-case": "^1.0.2",
    "jest-mock": "^28.1.3",
    "jest-serializer-ansi": "^1.0.3",
    "jsdom": "^20.0.3",
    "kcd-scripts": "^12.1.0",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "shared-scripts": "^1.5.1",
    "ts-node": "^10.9.1",
    "typescript": "^4.9.3"
  },
  "peerDependencies": {
    "@testing-library/dom": ">=7.21.4"
  },
  "dependencies": {},
  "main": "./dist/cjs/index.js",
  "module": "./dist/esm/index.js",
  "types": "./dist/types/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/types/index.d.ts",
      "require": "./dist/cjs/index.js",
      "default": "./dist/esm/index.js"
    },
    "./dist/cjs/*.js": {
      "types": "./dist/types/*.d.ts",
      "import": "./dist/esm/*.js",
      "default": "./dist/cjs/*.js"
    },
    "./dist/esm/*.js": {
      "types": "./dist/types/*.d.ts",
      "default": "./dist/esm/*.js",
      "require": "./dist/cjs/*.js"
    }
  },
  "typesVersions": {
    "*": {
      "dist/types/*": [
        "./dist/types/*"
      ],
      "dist/cjs/*.js": [
        "./dist/types/*.d.ts"
      ],
      "dist/esm/*.js": [
        "./dist/types/*.d.ts"
      ],
      "*": [
        "./dist/types/*.d.ts"
      ]
    }
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\aria-query\package.json
============================================================
{
    "name": "@types/aria-query",
    "version": "5.0.4",
    "description": "TypeScript definitions for aria-query",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/aria-query",
    "license": "MIT",
    "contributors": [
        {
            "name": "Sebastian Silbermann",
            "githubUsername": "eps1lon",
            "url": "https://github.com/eps1lon"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/aria-query"
    },
    "scripts": {},
    "dependencies": {},
    "typesPublisherContentHash": "df81e762ea003d46edaa1ce65e6e72487611400664e3105baa1610186c630902",
    "typeScriptVersion": "4.5"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\babel__core\package.json
============================================================
{
    "name": "@types/babel__core",
    "version": "7.20.5",
    "description": "TypeScript definitions for @babel/core",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/babel__core",
    "license": "MIT",
    "contributors": [
        {
            "name": "Troy Gerwien",
            "githubUsername": "yortus",
            "url": "https://github.com/yortus"
        },
        {
            "name": "Marvin Hagemeister",
            "githubUsername": "marvinhagemeister",
            "url": "https://github.com/marvinhagemeister"
        },
        {
            "name": "Melvin Groenhoff",
            "githubUsername": "mgroenhoff",
            "url": "https://github.com/mgroenhoff"
        },
        {
            "name": "Jessica Franco",
            "githubUsername": "Jessidhia",
            "url": "https://github.com/Jessidhia"
        },
        {
            "name": "Ifiok Jr.",
            "githubUsername": "ifiokjr",
            "url": "https://github.com/ifiokjr"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/babel__core"
    },
    "scripts": {},
    "dependencies": {
        "@babel/parser": "^7.20.7",
        "@babel/types": "^7.20.7",
        "@types/babel__generator": "*",
        "@types/babel__template": "*",
        "@types/babel__traverse": "*"
    },
    "typesPublisherContentHash": "3ece429b02ff9f70503a5644f2b303b04d10e6da7940c91a9eff5e52f2c76b91",
    "typeScriptVersion": "4.5"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\babel__generator\package.json
============================================================
{
    "name": "@types/babel__generator",
    "version": "7.27.0",
    "description": "TypeScript definitions for @babel/generator",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/babel__generator",
    "license": "MIT",
    "contributors": [
        {
            "name": "Troy Gerwien",
            "githubUsername": "yortus",
            "url": "https://github.com/yortus"
        },
        {
            "name": "Melvin Groenhoff",
            "githubUsername": "mgroenhoff",
            "url": "https://github.com/mgroenhoff"
        },
        {
            "name": "Cameron Yan",
            "githubUsername": "khell",
            "url": "https://github.com/khell"
        },
        {
            "name": "Lyanbin",
            "githubUsername": "Lyanbin",
            "url": "https://github.com/Lyanbin"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/babel__generator"
    },
    "scripts": {},
    "dependencies": {
        "@babel/types": "^7.0.0"
    },
    "peerDependencies": {},
    "typesPublisherContentHash": "b5c7deac65dbd6ab9b313d1d71c86afe4383b881dcb4e3b3ac51dab07b8f95fb",
    "typeScriptVersion": "5.1"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\babel__template\package.json
============================================================
{
    "name": "@types/babel__template",
    "version": "7.4.4",
    "description": "TypeScript definitions for @babel/template",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/babel__template",
    "license": "MIT",
    "contributors": [
        {
            "name": "Troy Gerwien",
            "githubUsername": "yortus",
            "url": "https://github.com/yortus"
        },
        {
            "name": "Marvin Hagemeister",
            "githubUsername": "marvinhagemeister",
            "url": "https://github.com/marvinhagemeister"
        },
        {
            "name": "Melvin Groenhoff",
            "githubUsername": "mgroenhoff",
            "url": "https://github.com/mgroenhoff"
        },
        {
            "name": "ExE Boss",
            "githubUsername": "ExE-Boss",
            "url": "https://github.com/ExE-Boss"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/babel__template"
    },
    "scripts": {},
    "dependencies": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0"
    },
    "typesPublisherContentHash": "5730d754b4d1fcd41676b093f9e32b340c749c4d37b126dfa312e394467e86c6",
    "typeScriptVersion": "4.5"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\babel__traverse\package.json
============================================================
{
    "name": "@types/babel__traverse",
    "version": "7.28.0",
    "description": "TypeScript definitions for @babel/traverse",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/babel__traverse",
    "license": "MIT",
    "contributors": [
        {
            "name": "Troy Gerwien",
            "githubUsername": "yortus",
            "url": "https://github.com/yortus"
        },
        {
            "name": "Marvin Hagemeister",
            "githubUsername": "marvinhagemeister",
            "url": "https://github.com/marvinhagemeister"
        },
        {
            "name": "Ryan Petrich",
            "githubUsername": "rpetrich",
            "url": "https://github.com/rpetrich"
        },
        {
            "name": "Melvin Groenhoff",
            "githubUsername": "mgroenhoff",
            "url": "https://github.com/mgroenhoff"
        },
        {
            "name": "Dean L.",
            "githubUsername": "dlgrit",
            "url": "https://github.com/dlgrit"
        },
        {
            "name": "Ifiok Jr.",
            "githubUsername": "ifiokjr",
            "url": "https://github.com/ifiokjr"
        },
        {
            "name": "ExE Boss",
            "githubUsername": "ExE-Boss",
            "url": "https://github.com/ExE-Boss"
        },
        {
            "name": "Daniel Tschinder",
            "githubUsername": "danez",
            "url": "https://github.com/danez"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/babel__traverse"
    },
    "scripts": {},
    "dependencies": {
        "@babel/types": "^7.28.2"
    },
    "peerDependencies": {},
    "typesPublisherContentHash": "f8bf439253873b2b30a22c425df086f130320cf70d832d84412e82a51e410680",
    "typeScriptVersion": "5.1"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\chai\package.json
============================================================
{
    "name": "@types/chai",
    "version": "5.2.3",
    "description": "TypeScript definitions for chai",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/chai",
    "license": "MIT",
    "contributors": [
        {
            "name": "Bart van der Schoor",
            "githubUsername": "Bartvds",
            "url": "https://github.com/Bartvds"
        },
        {
            "name": "Andrew Brown",
            "githubUsername": "AGBrown",
            "url": "https://github.com/AGBrown"
        },
        {
            "name": "Olivier Chevet",
            "githubUsername": "olivr70",
            "url": "https://github.com/olivr70"
        },
        {
            "name": "Matt Wistrand",
            "githubUsername": "mwistrand",
            "url": "https://github.com/mwistrand"
        },
        {
            "name": "Shaun Luttin",
            "githubUsername": "shaunluttin",
            "url": "https://github.com/shaunluttin"
        },
        {
            "name": "Satana Charuwichitratana",
            "githubUsername": "micksatana",
            "url": "https://github.com/micksatana"
        },
        {
            "name": "Erik Schierboom",
            "githubUsername": "ErikSchierboom",
            "url": "https://github.com/ErikSchierboom"
        },
        {
            "name": "Bogdan Paranytsia",
            "githubUsername": "bparan",
            "url": "https://github.com/bparan"
        },
        {
            "name": "CXuesong",
            "githubUsername": "CXuesong",
            "url": "https://github.com/CXuesong"
        },
        {
            "name": "Joey Kilpatrick",
            "githubUsername": "joeykilpatrick",
            "url": "https://github.com/joeykilpatrick"
        }
    ],
    "type": "module",
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/chai"
    },
    "scripts": {},
    "dependencies": {
        "@types/deep-eql": "*",
        "assertion-error": "^2.0.1"
    },
    "peerDependencies": {},
    "typesPublisherContentHash": "d9d83f1594f42010e624e46e4c8cfeee284bdd04cb05eb0730aec14140f2a833",
    "typeScriptVersion": "5.2"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\deep-eql\package.json
============================================================
{
    "name": "@types/deep-eql",
    "version": "4.0.2",
    "description": "TypeScript definitions for deep-eql",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/deep-eql",
    "license": "MIT",
    "contributors": [
        {
            "name": "Rodrigo Pietnechuk",
            "githubUsername": "ghnoob",
            "url": "https://github.com/ghnoob"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/deep-eql"
    },
    "scripts": {},
    "dependencies": {},
    "typesPublisherContentHash": "3b8981ce557947fc00ca08cbd93b4206bfc0943360956867381a0a3f6b1eabf5",
    "typeScriptVersion": "4.5"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\estree\package.json
============================================================
{
    "name": "@types/estree",
    "version": "1.0.8",
    "description": "TypeScript definitions for estree",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/estree",
    "license": "MIT",
    "contributors": [
        {
            "name": "RReverser",
            "githubUsername": "RReverser",
            "url": "https://github.com/RReverser"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/estree"
    },
    "scripts": {},
    "dependencies": {},
    "peerDependencies": {},
    "typesPublisherContentHash": "7a167b6e4a4d9f6e9a2cb9fd3fc45c885f89cbdeb44b3e5961bb057a45c082fd",
    "typeScriptVersion": "5.1",
    "nonNpm": true
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\istanbul-lib-coverage\package.json
============================================================
{
    "name": "@types/istanbul-lib-coverage",
    "version": "2.0.6",
    "description": "TypeScript definitions for istanbul-lib-coverage",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/istanbul-lib-coverage",
    "license": "MIT",
    "contributors": [
        {
            "name": "Jason Cheatham",
            "githubUsername": "jason0x43",
            "url": "https://github.com/jason0x43"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/istanbul-lib-coverage"
    },
    "scripts": {},
    "dependencies": {},
    "typesPublisherContentHash": "36c823c8b3f66dab91254b0f7299de71768ad8836bfbfcaa062409dd86fbbd61",
    "typeScriptVersion": "4.5"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\istanbul-lib-report\package.json
============================================================
{
    "name": "@types/istanbul-lib-report",
    "version": "3.0.3",
    "description": "TypeScript definitions for istanbul-lib-report",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/istanbul-lib-report",
    "license": "MIT",
    "contributors": [
        {
            "name": "Jason Cheatham",
            "githubUsername": "jason0x43",
            "url": "https://github.com/jason0x43"
        },
        {
            "name": "Zacharias Björngren",
            "githubUsername": "zache",
            "url": "https://github.com/zache"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/istanbul-lib-report"
    },
    "scripts": {},
    "dependencies": {
        "@types/istanbul-lib-coverage": "*"
    },
    "typesPublisherContentHash": "7036cfd1108c02c3ceec9ffab2cbc424c76e2cafd694c550037d808bf66e3946",
    "typeScriptVersion": "4.5"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\istanbul-reports\package.json
============================================================
{
    "name": "@types/istanbul-reports",
    "version": "3.0.4",
    "description": "TypeScript definitions for istanbul-reports",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/istanbul-reports",
    "license": "MIT",
    "contributors": [
        {
            "name": "Jason Cheatham",
            "githubUsername": "jason0x43",
            "url": "https://github.com/jason0x43"
        },
        {
            "name": "Elena Shcherbakova",
            "githubUsername": "not-a-doctor",
            "url": "https://github.com/not-a-doctor"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/istanbul-reports"
    },
    "scripts": {},
    "dependencies": {
        "@types/istanbul-lib-report": "*"
    },
    "typesPublisherContentHash": "27b4219ea922d9218dd987cb99b49d7fc77c568322e7102565050323987fa6db",
    "typeScriptVersion": "4.5"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\jsdom\package.json
============================================================
{
    "name": "@types/jsdom",
    "version": "21.1.7",
    "description": "TypeScript definitions for jsdom",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/jsdom",
    "license": "MIT",
    "contributors": [
        {
            "name": "Leonard Thieu",
            "githubUsername": "leonard-thieu",
            "url": "https://github.com/leonard-thieu"
        },
        {
            "name": "Johan Palmfjord",
            "githubUsername": "palmfjord",
            "url": "https://github.com/palmfjord"
        },
        {
            "name": "ExE Boss",
            "githubUsername": "ExE-Boss",
            "url": "https://github.com/ExE-Boss"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "exports": {
        ".": {
            "types": "./index.d.ts"
        },
        "./package.json": "./package.json"
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/jsdom"
    },
    "scripts": {},
    "dependencies": {
        "@types/node": "*",
        "@types/tough-cookie": "*",
        "parse5": "^7.0.0"
    },
    "typesPublisherContentHash": "ff2b3302adf7f1ae40db6101f0c6d5f7ba972ee3864ae371e975f9545d93d8bb",
    "typeScriptVersion": "4.7"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\node\package.json
============================================================
{
    "name": "@types/node",
    "version": "24.9.1",
    "description": "TypeScript definitions for node",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/node",
    "license": "MIT",
    "contributors": [
        {
            "name": "Microsoft TypeScript",
            "githubUsername": "Microsoft",
            "url": "https://github.com/Microsoft"
        },
        {
            "name": "Alberto Schiabel",
            "githubUsername": "jkomyno",
            "url": "https://github.com/jkomyno"
        },
        {
            "name": "Andrew Makarov",
            "githubUsername": "r3nya",
            "url": "https://github.com/r3nya"
        },
        {
            "name": "Benjamin Toueg",
            "githubUsername": "btoueg",
            "url": "https://github.com/btoueg"
        },
        {
            "name": "David Junger",
            "githubUsername": "touffy",
            "url": "https://github.com/touffy"
        },
        {
            "name": "Mohsen Azimi",
            "githubUsername": "mohsen1",
            "url": "https://github.com/mohsen1"
        },
        {
            "name": "Nikita Galkin",
            "githubUsername": "galkin",
            "url": "https://github.com/galkin"
        },
        {
            "name": "Sebastian Silbermann",
            "githubUsername": "eps1lon",
            "url": "https://github.com/eps1lon"
        },
        {
            "name": "Wilco Bakker",
            "githubUsername": "WilcoBakker",
            "url": "https://github.com/WilcoBakker"
        },
        {
            "name": "Marcin Kopacz",
            "githubUsername": "chyzwar",
            "url": "https://github.com/chyzwar"
        },
        {
            "name": "Trivikram Kamat",
            "githubUsername": "trivikr",
            "url": "https://github.com/trivikr"
        },
        {
            "name": "Junxiao Shi",
            "githubUsername": "yoursunny",
            "url": "https://github.com/yoursunny"
        },
        {
            "name": "Ilia Baryshnikov",
            "githubUsername": "qwelias",
            "url": "https://github.com/qwelias"
        },
        {
            "name": "ExE Boss",
            "githubUsername": "ExE-Boss",
            "url": "https://github.com/ExE-Boss"
        },
        {
            "name": "Piotr Błażejewicz",
            "githubUsername": "peterblazejewicz",
            "url": "https://github.com/peterblazejewicz"
        },
        {
            "name": "Anna Henningsen",
            "githubUsername": "addaleax",
            "url": "https://github.com/addaleax"
        },
        {
            "name": "Victor Perin",
            "githubUsername": "victorperin",
            "url": "https://github.com/victorperin"
        },
        {
            "name": "NodeJS Contributors",
            "githubUsername": "NodeJS",
            "url": "https://github.com/NodeJS"
        },
        {
            "name": "Linus Unnebäck",
            "githubUsername": "LinusU",
            "url": "https://github.com/LinusU"
        },
        {
            "name": "wafuwafu13",
            "githubUsername": "wafuwafu13",
            "url": "https://github.com/wafuwafu13"
        },
        {
            "name": "Matteo Collina",
            "githubUsername": "mcollina",
            "url": "https://github.com/mcollina"
        },
        {
            "name": "Dmitry Semigradsky",
            "githubUsername": "Semigradsky",
            "url": "https://github.com/Semigradsky"
        },
        {
            "name": "René",
            "githubUsername": "Renegade334",
            "url": "https://github.com/Renegade334"
        },
        {
            "name": "Yagiz Nizipli",
            "githubUsername": "anonrig",
            "url": "https://github.com/anonrig"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "typesVersions": {
        "<=5.6": {
            "*": [
                "ts5.6/*"
            ]
        },
        "<=5.7": {
            "*": [
                "ts5.7/*"
            ]
        }
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/node"
    },
    "scripts": {},
    "dependencies": {
        "undici-types": "~7.16.0"
    },
    "peerDependencies": {},
    "typesPublisherContentHash": "1410dcf2b880c650896be220e8be57672e66a772bb4d7d1b2604ce690f70f9ef",
    "typeScriptVersion": "5.2"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\react\package.json
============================================================
{
    "name": "@types/react",
    "version": "19.2.2",
    "description": "TypeScript definitions for react",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react",
    "license": "MIT",
    "contributors": [
        {
            "name": "Asana",
            "url": "https://asana.com"
        },
        {
            "name": "AssureSign",
            "url": "http://www.assuresign.com"
        },
        {
            "name": "Microsoft",
            "url": "https://microsoft.com"
        },
        {
            "name": "John Reilly",
            "githubUsername": "johnnyreilly",
            "url": "https://github.com/johnnyreilly"
        },
        {
            "name": "Benoit Benezech",
            "githubUsername": "bbenezech",
            "url": "https://github.com/bbenezech"
        },
        {
            "name": "Patricio Zavolinsky",
            "githubUsername": "pzavolinsky",
            "url": "https://github.com/pzavolinsky"
        },
        {
            "name": "Eric Anderson",
            "githubUsername": "ericanderson",
            "url": "https://github.com/ericanderson"
        },
        {
            "name": "Dovydas Navickas",
            "githubUsername": "DovydasNavickas",
            "url": "https://github.com/DovydasNavickas"
        },
        {
            "name": "Josh Rutherford",
            "githubUsername": "theruther4d",
            "url": "https://github.com/theruther4d"
        },
        {
            "name": "Guilherme Hübner",
            "githubUsername": "guilhermehubner",
            "url": "https://github.com/guilhermehubner"
        },
        {
            "name": "Ferdy Budhidharma",
            "githubUsername": "ferdaber",
            "url": "https://github.com/ferdaber"
        },
        {
            "name": "Johann Rakotoharisoa",
            "githubUsername": "jrakotoharisoa",
            "url": "https://github.com/jrakotoharisoa"
        },
        {
            "name": "Olivier Pascal",
            "githubUsername": "pascaloliv",
            "url": "https://github.com/pascaloliv"
        },
        {
            "name": "Martin Hochel",
            "githubUsername": "hotell",
            "url": "https://github.com/hotell"
        },
        {
            "name": "Frank Li",
            "githubUsername": "franklixuefei",
            "url": "https://github.com/franklixuefei"
        },
        {
            "name": "Jessica Franco",
            "githubUsername": "Jessidhia",
            "url": "https://github.com/Jessidhia"
        },
        {
            "name": "Saransh Kataria",
            "githubUsername": "saranshkataria",
            "url": "https://github.com/saranshkataria"
        },
        {
            "name": "Kanitkorn Sujautra",
            "githubUsername": "lukyth",
            "url": "https://github.com/lukyth"
        },
        {
            "name": "Sebastian Silbermann",
            "githubUsername": "eps1lon",
            "url": "https://github.com/eps1lon"
        },
        {
            "name": "Kyle Scully",
            "githubUsername": "zieka",
            "url": "https://github.com/zieka"
        },
        {
            "name": "Cong Zhang",
            "githubUsername": "dancerphil",
            "url": "https://github.com/dancerphil"
        },
        {
            "name": "Dimitri Mitropoulos",
            "githubUsername": "dimitropoulos",
            "url": "https://github.com/dimitropoulos"
        },
        {
            "name": "JongChan Choi",
            "githubUsername": "disjukr",
            "url": "https://github.com/disjukr"
        },
        {
            "name": "Victor Magalhães",
            "githubUsername": "vhfmag",
            "url": "https://github.com/vhfmag"
        },
        {
            "name": "Priyanshu Rav",
            "githubUsername": "priyanshurav",
            "url": "https://github.com/priyanshurav"
        },
        {
            "name": "Dmitry Semigradsky",
            "githubUsername": "Semigradsky",
            "url": "https://github.com/Semigradsky"
        },
        {
            "name": "Matt Pocock",
            "githubUsername": "mattpocock",
            "url": "https://github.com/mattpocock"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "typesVersions": {
        "<=5.0": {
            "*": [
                "ts5.0/*"
            ]
        }
    },
    "exports": {
        ".": {
            "types@<=5.0": {
                "default": "./ts5.0/index.d.ts"
            },
            "types": {
                "default": "./index.d.ts"
            }
        },
        "./canary": {
            "types@<=5.0": {
                "default": "./ts5.0/canary.d.ts"
            },
            "types": {
                "default": "./canary.d.ts"
            }
        },
        "./compiler-runtime": {
            "types": {
                "default": "./compiler-runtime.d.ts"
            }
        },
        "./experimental": {
            "types@<=5.0": {
                "default": "./ts5.0/experimental.d.ts"
            },
            "types": {
                "default": "./experimental.d.ts"
            }
        },
        "./jsx-runtime": {
            "types@<=5.0": {
                "default": "./ts5.0/jsx-runtime.d.ts"
            },
            "types": {
                "default": "./jsx-runtime.d.ts"
            }
        },
        "./jsx-dev-runtime": {
            "types@<=5.0": {
                "default": "./ts5.0/jsx-dev-runtime.d.ts"
            },
            "types": {
                "default": "./jsx-dev-runtime.d.ts"
            }
        },
        "./package.json": "./package.json"
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/react"
    },
    "scripts": {},
    "dependencies": {
        "csstype": "^3.0.2"
    },
    "peerDependencies": {},
    "typesPublisherContentHash": "68c52e24d44da5913d4220a0dd3380ca866be4e58a724ee668fa152a7b358e72",
    "typeScriptVersion": "5.2"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\react-dom\package.json
============================================================
{
    "name": "@types/react-dom",
    "version": "19.2.2",
    "description": "TypeScript definitions for react-dom",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react-dom",
    "license": "MIT",
    "contributors": [
        {
            "name": "Asana",
            "url": "https://asana.com"
        },
        {
            "name": "AssureSign",
            "url": "http://www.assuresign.com"
        },
        {
            "name": "Microsoft",
            "url": "https://microsoft.com"
        },
        {
            "name": "MartynasZilinskas",
            "githubUsername": "MartynasZilinskas",
            "url": "https://github.com/MartynasZilinskas"
        },
        {
            "name": "Josh Rutherford",
            "githubUsername": "theruther4d",
            "url": "https://github.com/theruther4d"
        },
        {
            "name": "Jessica Franco",
            "githubUsername": "Jessidhia",
            "url": "https://github.com/Jessidhia"
        },
        {
            "name": "Sebastian Silbermann",
            "githubUsername": "eps1lon",
            "url": "https://github.com/eps1lon"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "exports": {
        ".": {
            "types": {
                "default": "./index.d.ts"
            }
        },
        "./client": {
            "types": {
                "default": "./client.d.ts"
            }
        },
        "./canary": {
            "types": {
                "default": "./canary.d.ts"
            }
        },
        "./server": {
            "types": {
                "default": "./server.d.ts"
            }
        },
        "./server.browser": {
            "types": {
                "default": "./server.browser.d.ts"
            }
        },
        "./server.bun": {
            "types": {
                "default": "./server.bun.d.ts"
            }
        },
        "./server.edge": {
            "types": {
                "default": "./server.edge.d.ts"
            }
        },
        "./server.node": {
            "types": {
                "default": "./server.node.d.ts"
            }
        },
        "./static": {
            "types": {
                "default": "./static.d.ts"
            }
        },
        "./static.browser": {
            "types": {
                "default": "./static.browser.d.ts"
            }
        },
        "./static.edge": {
            "types": {
                "default": "./static.edge.d.ts"
            }
        },
        "./static.node": {
            "types": {
                "default": "./static.node.d.ts"
            }
        },
        "./experimental": {
            "types": {
                "default": "./experimental.d.ts"
            }
        },
        "./test-utils": {
            "types": {
                "default": "./test-utils/index.d.ts"
            }
        },
        "./package.json": "./package.json"
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/react-dom"
    },
    "scripts": {},
    "dependencies": {},
    "peerDependencies": {
        "@types/react": "^19.2.0"
    },
    "typesPublisherContentHash": "c53ce9136571cc445e6417c69b996c17d5dd25855b71a504b8202c58d92d3d98",
    "typeScriptVersion": "5.2"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\stack-utils\package.json
============================================================
{
    "name": "@types/stack-utils",
    "version": "2.0.3",
    "description": "TypeScript definitions for stack-utils",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/stack-utils",
    "license": "MIT",
    "contributors": [
        {
            "name": "BendingBender",
            "githubUsername": "BendingBender",
            "url": "https://github.com/BendingBender"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/stack-utils"
    },
    "scripts": {},
    "dependencies": {},
    "typesPublisherContentHash": "ab51d155e7946b0b0e0edab741811a35172a48de2674195feb31eaaf7bf992b7",
    "typeScriptVersion": "4.5"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\tough-cookie\package.json
============================================================
{
    "name": "@types/tough-cookie",
    "version": "4.0.5",
    "description": "TypeScript definitions for tough-cookie",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/tough-cookie",
    "license": "MIT",
    "contributors": [
        {
            "name": "Leonard Thieu",
            "githubUsername": "leonard-thieu",
            "url": "https://github.com/leonard-thieu"
        },
        {
            "name": "LiJinyao",
            "githubUsername": "LiJinyao",
            "url": "https://github.com/LiJinyao"
        },
        {
            "name": "Michael Wei",
            "githubUsername": "no2chem",
            "url": "https://github.com/no2chem"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/tough-cookie"
    },
    "scripts": {},
    "dependencies": {},
    "typesPublisherContentHash": "adafa53ff34d3665a708d3ab1af232a46d4efb906d46f48d7d0cd3206c987a58",
    "typeScriptVersion": "4.5"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\yargs\package.json
============================================================
{
    "name": "@types/yargs",
    "version": "17.0.33",
    "description": "TypeScript definitions for yargs",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/yargs",
    "license": "MIT",
    "contributors": [
        {
            "name": "Martin Poelstra",
            "githubUsername": "poelstra",
            "url": "https://github.com/poelstra"
        },
        {
            "name": "Mizunashi Mana",
            "githubUsername": "mizunashi-mana",
            "url": "https://github.com/mizunashi-mana"
        },
        {
            "name": "Jeffery Grajkowski",
            "githubUsername": "pushplay",
            "url": "https://github.com/pushplay"
        },
        {
            "name": "Jimi (Dimitris) Charalampidis",
            "githubUsername": "JimiC",
            "url": "https://github.com/JimiC"
        },
        {
            "name": "Steffen Viken Valvåg",
            "githubUsername": "steffenvv",
            "url": "https://github.com/steffenvv"
        },
        {
            "name": "Emily Marigold Klassen",
            "githubUsername": "forivall",
            "url": "https://github.com/forivall"
        },
        {
            "name": "ExE Boss",
            "githubUsername": "ExE-Boss",
            "url": "https://github.com/ExE-Boss"
        },
        {
            "name": "Aankhen",
            "githubUsername": "Aankhen",
            "url": "https://github.com/Aankhen"
        },
        {
            "name": "Ben Coe",
            "githubUsername": "bcoe",
            "url": "https://github.com/bcoe"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "exports": {
        ".": {
            "types": {
                "import": "./index.d.mts",
                "default": "./index.d.ts"
            }
        },
        "./helpers": {
            "types": {
                "import": "./helpers.d.mts",
                "default": "./helpers.d.ts"
            }
        },
        "./yargs": {
            "types": {
                "default": "./yargs.d.ts"
            }
        },
        "./package.json": "./package.json"
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/yargs"
    },
    "scripts": {},
    "dependencies": {
        "@types/yargs-parser": "*"
    },
    "typesPublisherContentHash": "7b837c3dffe16c68f89717a71a88af716d72acc79790394e14f9cafa6be33a2f",
    "typeScriptVersion": "4.8"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@types\yargs-parser\package.json
============================================================
{
    "name": "@types/yargs-parser",
    "version": "21.0.3",
    "description": "TypeScript definitions for yargs-parser",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/yargs-parser",
    "license": "MIT",
    "contributors": [
        {
            "name": "Miles Johnson",
            "githubUsername": "milesj",
            "url": "https://github.com/milesj"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/yargs-parser"
    },
    "scripts": {},
    "dependencies": {},
    "typesPublisherContentHash": "c8ba48d493937115b81658ba71ff9ae3452d2f1b86a9fea357703f8745fa34d7",
    "typeScriptVersion": "4.5"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@ungap\structured-clone\cjs\package.json
============================================================
{"type":"commonjs"}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@ungap\structured-clone\package.json
============================================================
{
  "name": "@ungap/structured-clone",
  "version": "1.3.0",
  "description": "A structuredClone polyfill",
  "main": "./cjs/index.js",
  "scripts": {
    "build": "npm run cjs && npm run rollup:json && npm run test",
    "cjs": "ascjs esm cjs",
    "coverage": "c8 report --reporter=text-lcov > ./coverage/lcov.info",
    "rollup:json": "rollup --config rollup/json.config.js",
    "test": "c8 node test/index.js"
  },
  "keywords": [
    "recursion",
    "structured",
    "clone",
    "algorithm"
  ],
  "author": "Andrea Giammarchi",
  "license": "ISC",
  "devDependencies": {
    "@rollup/plugin-node-resolve": "^16.0.0",
    "@rollup/plugin-terser": "^0.4.4",
    "ascjs": "^6.0.3",
    "c8": "^10.1.3",
    "coveralls": "^3.1.1",
    "rollup": "^4.31.0"
  },
  "module": "./esm/index.js",
  "type": "module",
  "sideEffects": false,
  "exports": {
    ".": {
      "import": "./esm/index.js",
      "default": "./cjs/index.js"
    },
    "./json": {
      "import": "./esm/json.js",
      "default": "./cjs/json.js"
    },
    "./package.json": "./package.json"
  },
  "directories": {
    "test": "test"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ungap/structured-clone.git"
  },
  "bugs": {
    "url": "https://github.com/ungap/structured-clone/issues"
  },
  "homepage": "https://github.com/ungap/structured-clone#readme"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@unrs\resolver-binding-win32-x64-msvc\package.json
============================================================
{
  "name": "@unrs/resolver-binding-win32-x64-msvc",
  "version": "1.11.1",
  "cpu": [
    "x64"
  ],
  "main": "resolver.win32-x64-msvc.node",
  "files": [
    "resolver.win32-x64-msvc.node"
  ],
  "description": "UnRS Resolver Node API with PNP support",
  "author": "JounQin <admin@1stg.me> (https://www.1stG.me)",
  "homepage": "https://github.com/unrs/unrs-resolver#readme",
  "license": "MIT",
  "publishConfig": {
    "registry": "https://registry.npmjs.org",
    "access": "public"
  },
  "repository": "git+https://github.com/unrs/unrs-resolver.git",
  "os": [
    "win32"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@vitejs\plugin-react\package.json
============================================================
{
  "name": "@vitejs/plugin-react",
  "version": "3.1.0",
  "license": "MIT",
  "author": "Evan You",
  "contributors": [
    "Alec Larson",
    "Arnaud Barré"
  ],
  "files": [
    "dist"
  ],
  "main": "./dist/index.cjs",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    }
  },
  "scripts": {
    "dev": "unbuild --stub",
    "build": "unbuild && pnpm run patch-cjs && tsx scripts/copyRefreshUtils.ts",
    "patch-cjs": "tsx ../../scripts/patchCJS.ts",
    "prepublishOnly": "npm run build"
  },
  "engines": {
    "node": "^14.18.0 || >=16.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitejs/vite-plugin-react.git",
    "directory": "packages/plugin-react"
  },
  "bugs": {
    "url": "https://github.com/vitejs/vite-plugin-react/issues"
  },
  "homepage": "https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react#readme",
  "dependencies": {
    "@babel/core": "^7.20.12",
    "@babel/plugin-transform-react-jsx-self": "^7.18.6",
    "@babel/plugin-transform-react-jsx-source": "^7.19.6",
    "magic-string": "^0.27.0",
    "react-refresh": "^0.14.0"
  },
  "peerDependencies": {
    "vite": "^4.1.0-beta.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@vitest\expect\package.json
============================================================
{
  "name": "@vitest/expect",
  "type": "module",
  "version": "4.0.1",
  "description": "Jest's expect matchers as a Chai plugin",
  "license": "MIT",
  "funding": "https://opencollective.com/vitest",
  "homepage": "https://github.com/vitest-dev/vitest/tree/main/packages/expect#readme",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitest-dev/vitest.git",
    "directory": "packages/expect"
  },
  "bugs": {
    "url": "https://github.com/vitest-dev/vitest/issues"
  },
  "sideEffects": false,
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    },
    "./*": "./*"
  },
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": [
    "dist"
  ],
  "dependencies": {
    "@standard-schema/spec": "^1.0.0",
    "@types/chai": "^5.2.2",
    "chai": "^6.0.1",
    "tinyrainbow": "^3.0.3",
    "@vitest/spy": "4.0.1",
    "@vitest/utils": "4.0.1"
  },
  "devDependencies": {
    "@vitest/runner": "4.0.1"
  },
  "scripts": {
    "build": "premove dist && rollup -c",
    "dev": "rollup -c --watch"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@vitest\pretty-format\package.json
============================================================
{
  "name": "@vitest/pretty-format",
  "type": "module",
  "version": "4.0.1",
  "description": "Fork of pretty-format with support for ESM",
  "license": "MIT",
  "funding": "https://opencollective.com/vitest",
  "homepage": "https://github.com/vitest-dev/vitest/tree/main/packages/utils#readme",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitest-dev/vitest.git",
    "directory": "packages/pretty-format"
  },
  "bugs": {
    "url": "https://github.com/vitest-dev/vitest/issues"
  },
  "sideEffects": false,
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    },
    "./*": "./*"
  },
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": [
    "*.d.ts",
    "dist"
  ],
  "dependencies": {
    "tinyrainbow": "^3.0.3"
  },
  "devDependencies": {
    "@types/react-is": "^19.0.0",
    "react-is": "^19.1.1",
    "react-is-18": "npm:react-is@18.3.1"
  },
  "scripts": {
    "build": "premove dist && rollup -c",
    "dev": "rollup -c --watch"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@vitest\runner\package.json
============================================================
{
  "name": "@vitest/runner",
  "type": "module",
  "version": "4.0.1",
  "description": "Vitest test runner",
  "license": "MIT",
  "funding": "https://opencollective.com/vitest",
  "homepage": "https://github.com/vitest-dev/vitest/tree/main/packages/runner#readme",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitest-dev/vitest.git",
    "directory": "packages/runner"
  },
  "bugs": {
    "url": "https://github.com/vitest-dev/vitest/issues"
  },
  "sideEffects": true,
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    },
    "./utils": {
      "types": "./dist/utils.d.ts",
      "default": "./dist/utils.js"
    },
    "./types": {
      "types": "./dist/types.d.ts",
      "default": "./dist/types.js"
    },
    "./*": "./*"
  },
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": [
    "*.d.ts",
    "dist"
  ],
  "dependencies": {
    "pathe": "^2.0.3",
    "@vitest/utils": "4.0.1"
  },
  "scripts": {
    "build": "premove dist && rollup -c",
    "dev": "rollup -c --watch"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@vitest\snapshot\node_modules\magic-string\package.json
============================================================
{
	"name": "magic-string",
	"version": "0.30.19",
	"type": "commonjs",
	"packageManager": "pnpm@10.15.1",
	"description": "Modify strings, generate sourcemaps",
	"keywords": [
		"string",
		"string manipulation",
		"sourcemap",
		"templating",
		"transpilation"
	],
	"repository": {
		"type": "git",
		"url": "https://github.com/rich-harris/magic-string.git"
	},
	"license": "MIT",
	"author": "Rich Harris",
	"main": "./dist/magic-string.cjs.js",
	"module": "./dist/magic-string.es.mjs",
	"sideEffects": false,
	"jsnext:main": "./dist/magic-string.es.mjs",
	"types": "./dist/magic-string.cjs.d.ts",
	"exports": {
		"./package.json": "./package.json",
		".": {
			"import": "./dist/magic-string.es.mjs",
			"require": "./dist/magic-string.cjs.js"
		}
	},
	"files": [
		"dist/*",
		"index.d.ts",
		"README.md"
	],
	"scripts": {
		"build": "rollup -c",
		"changelog": "conventional-changelog -p angular -i CHANGELOG.md -s",
		"format": "prettier --single-quote --print-width 100 --use-tabs --write .",
		"lint": "eslint src test && publint",
		"lint:fix": "eslint src test --fix",
		"prepare": "npm run build",
		"prepublishOnly": "npm run lint && rm -rf dist && npm test",
		"release": "bumpp -x \"npm run changelog\" --all --commit --tag --push && npm publish",
		"pretest": "npm run build",
		"test": "vitest run",
		"test:dev": "vitest",
		"bench": "npm run build && node benchmark/index.mjs",
		"watch": "rollup -cw"
	},
	"devDependencies": {
		"@eslint/js": "^9.35.0",
		"@rollup/plugin-node-resolve": "^16.0.1",
		"@rollup/plugin-replace": "^6.0.2",
		"benchmark": "^2.1.4",
		"bumpp": "^10.2.3",
		"conventional-changelog-cli": "^5.0.0",
		"eslint": "^9.35.0",
		"prettier": "^3.6.2",
		"publint": "^0.3.12",
		"rollup": "^4.50.1",
		"source-map-js": "^1.2.1",
		"source-map-support": "^0.5.21",
		"vitest": "^3.2.4"
	},
	"dependencies": {
		"@jridgewell/sourcemap-codec": "^1.5.5"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@vitest\snapshot\package.json
============================================================
{
  "name": "@vitest/snapshot",
  "type": "module",
  "version": "4.0.1",
  "description": "Vitest snapshot manager",
  "license": "MIT",
  "funding": "https://opencollective.com/vitest",
  "homepage": "https://github.com/vitest-dev/vitest/tree/main/packages/snapshot#readme",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitest-dev/vitest.git",
    "directory": "packages/snapshot"
  },
  "bugs": {
    "url": "https://github.com/vitest-dev/vitest/issues"
  },
  "sideEffects": false,
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    },
    "./environment": {
      "types": "./dist/environment.d.ts",
      "default": "./dist/environment.js"
    },
    "./manager": {
      "types": "./dist/manager.d.ts",
      "default": "./dist/manager.js"
    },
    "./*": "./*"
  },
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": [
    "*.d.ts",
    "dist"
  ],
  "dependencies": {
    "magic-string": "^0.30.19",
    "pathe": "^2.0.3",
    "@vitest/pretty-format": "4.0.1"
  },
  "devDependencies": {
    "@types/natural-compare": "^1.4.3",
    "natural-compare": "^1.4.0",
    "@vitest/utils": "4.0.1"
  },
  "scripts": {
    "build": "premove dist && rollup -c",
    "dev": "rollup -c --watch"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@vitest\spy\package.json
============================================================
{
  "name": "@vitest/spy",
  "type": "module",
  "version": "4.0.1",
  "description": "Lightweight Jest compatible spy implementation",
  "license": "MIT",
  "funding": "https://opencollective.com/vitest",
  "homepage": "https://github.com/vitest-dev/vitest/tree/main/packages/spy#readme",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitest-dev/vitest.git",
    "directory": "packages/spy"
  },
  "bugs": {
    "url": "https://github.com/vitest-dev/vitest/issues"
  },
  "sideEffects": false,
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    },
    "./*": "./*"
  },
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "premove dist && rollup -c",
    "dev": "rollup -c --watch"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@vitest\ui\package.json
============================================================
{
  "name": "@vitest/ui",
  "type": "module",
  "version": "4.0.1",
  "description": "UI for Vitest",
  "license": "MIT",
  "funding": "https://opencollective.com/vitest",
  "homepage": "https://github.com/vitest-dev/vitest/tree/main/packages/ui#readme",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitest-dev/vitest.git",
    "directory": "packages/ui"
  },
  "bugs": {
    "url": "https://github.com/vitest-dev/vitest/issues"
  },
  "sideEffects": false,
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    },
    "./reporter": {
      "types": "./reporter.d.ts",
      "default": "./dist/reporter.js"
    },
    "./*": "./*"
  },
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": [
    "*.d.ts",
    "dist"
  ],
  "peerDependencies": {
    "vitest": "4.0.1"
  },
  "dependencies": {
    "fflate": "^0.8.2",
    "flatted": "^3.3.3",
    "pathe": "^2.0.3",
    "sirv": "^3.0.2",
    "tinyglobby": "^0.2.15",
    "tinyrainbow": "^3.0.3",
    "@vitest/utils": "4.0.1"
  },
  "devDependencies": {
    "@faker-js/faker": "^10.0.0",
    "@iconify-json/carbon": "^1.2.13",
    "@iconify-json/logos": "^1.2.9",
    "@types/codemirror": "^5.60.16",
    "@types/d3-force": "^3.0.10",
    "@types/d3-selection": "^3.0.11",
    "@types/ws": "^8.18.1",
    "@unocss/reset": "^66.5.1",
    "@vitejs/plugin-vue": "^6.0.1",
    "@vue/test-utils": "^2.4.6",
    "@vueuse/core": "^12.8.2",
    "ansi-to-html": "^0.7.2",
    "birpc": "^2.5.0",
    "codemirror": "^5.65.18",
    "codemirror-theme-vars": "^0.1.2",
    "d3-graph-controller": "^3.1.2",
    "floating-vue": "^5.2.2",
    "mime": "^4.1.0",
    "rollup": "^4.52.0",
    "splitpanes": "^3.2.0",
    "typescript": "^5.9.3",
    "unocss": "^66.5.1",
    "vite": "^5.0.0",
    "vite-plugin-pages": "^0.33.1",
    "vitest-browser-vue": "2.0.0-beta.1",
    "vue": "^3.5.21",
    "vue-router": "^4.5.1",
    "vue-tsc": "^3.1.1",
    "vue-virtual-scroller": "2.0.0-beta.8",
    "@vitest/browser-playwright": "4.0.1",
    "@vitest/runner": "4.0.1",
    "@vitest/ws-client": "4.0.1"
  },
  "scripts": {
    "build": "premove dist && pnpm build:node && pnpm build:client",
    "build:client": "vite build",
    "build:node": "rollup -c",
    "typecheck": "tsc --noEmit",
    "typecheck:client": "vue-tsc --noEmit",
    "dev:client": "vite",
    "dev": "rollup -c --watch --watch.include 'node/**'",
    "dev:ui": "pnpm run --stream '/^(dev|dev:client)$/'",
    "test:ui": "vitest --browser"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\@vitest\utils\package.json
============================================================
{
  "name": "@vitest/utils",
  "type": "module",
  "version": "4.0.1",
  "description": "Shared Vitest utility functions",
  "license": "MIT",
  "funding": "https://opencollective.com/vitest",
  "homepage": "https://github.com/vitest-dev/vitest/tree/main/packages/utils#readme",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitest-dev/vitest.git",
    "directory": "packages/utils"
  },
  "bugs": {
    "url": "https://github.com/vitest-dev/vitest/issues"
  },
  "sideEffects": false,
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    },
    "./diff": {
      "types": "./dist/diff.d.ts",
      "default": "./dist/diff.js"
    },
    "./resolver": {
      "types": "./dist/resolver.d.ts",
      "default": "./dist/resolver.js"
    },
    "./error": {
      "types": "./dist/error.d.ts",
      "default": "./dist/error.js"
    },
    "./helpers": {
      "types": "./dist/helpers.d.ts",
      "default": "./dist/helpers.js"
    },
    "./offset": {
      "types": "./dist/offset.d.ts",
      "default": "./dist/offset.js"
    },
    "./constants": {
      "types": "./dist/constants.d.ts",
      "default": "./dist/constants.js"
    },
    "./timers": {
      "types": "./dist/timers.d.ts",
      "default": "./dist/timers.js"
    },
    "./display": {
      "types": "./dist/display.d.ts",
      "default": "./dist/display.js"
    },
    "./highlight": {
      "types": "./dist/highlight.d.ts",
      "default": "./dist/highlight.js"
    },
    "./source-map": {
      "types": "./dist/source-map.d.ts",
      "default": "./dist/source-map.js"
    },
    "./serialize": {
      "types": "./dist/serialize.d.ts",
      "default": "./dist/serialize.js"
    },
    "./*": "./*"
  },
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "typesVersions": {
    "*": {
      "source-map": [
        "dist/source-map.d.ts"
      ]
    }
  },
  "files": [
    "*.d.ts",
    "dist"
  ],
  "dependencies": {
    "tinyrainbow": "^3.0.3",
    "@vitest/pretty-format": "4.0.1"
  },
  "devDependencies": {
    "@jridgewell/trace-mapping": "0.3.31",
    "@types/estree": "^1.0.8",
    "diff-sequences": "^29.6.3",
    "loupe": "^3.2.1",
    "tinyhighlight": "^0.3.2"
  },
  "scripts": {
    "build": "premove dist && rollup -c",
    "dev": "rollup -c --watch"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\agent-base\package.json
============================================================
{
  "name": "agent-base",
  "version": "7.1.4",
  "description": "Turn a function into an `http.Agent` instance",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": [
    "dist"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/TooTallNate/proxy-agents.git",
    "directory": "packages/agent-base"
  },
  "keywords": [
    "http",
    "agent",
    "base",
    "barebones",
    "https"
  ],
  "author": "Nathan Rajlich <nathan@tootallnate.net> (http://n8.io/)",
  "license": "MIT",
  "devDependencies": {
    "@types/debug": "^4.1.7",
    "@types/jest": "^29.5.1",
    "@types/node": "^14.18.45",
    "@types/semver": "^7.3.13",
    "@types/ws": "^6.0.4",
    "async-listen": "^3.0.0",
    "jest": "^29.5.0",
    "ts-jest": "^29.1.0",
    "typescript": "^5.0.4",
    "ws": "^5.2.4",
    "tsconfig": "0.0.0"
  },
  "engines": {
    "node": ">= 14"
  },
  "scripts": {
    "build": "tsc",
    "test": "jest --env node --verbose --bail",
    "lint": "eslint . --ext .ts",
    "pack": "node ../../scripts/pack.mjs"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\ansi-escapes\package.json
============================================================
{
	"name": "ansi-escapes",
	"version": "4.3.2",
	"description": "ANSI escape codes for manipulating the terminal",
	"license": "MIT",
	"repository": "sindresorhus/ansi-escapes",
	"funding": "https://github.com/sponsors/sindresorhus",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"escapes",
		"formatting",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text",
		"vt100",
		"sequence",
		"control",
		"code",
		"codes",
		"cursor",
		"iterm",
		"iterm2"
	],
	"dependencies": {
		"type-fest": "^0.21.3"
	},
	"devDependencies": {
		"@types/node": "^13.7.7",
		"ava": "^2.1.0",
		"tsd": "^0.14.0",
		"xo": "^0.25.3"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\ansi-regex\package.json
============================================================
{
	"name": "ansi-regex",
	"version": "5.0.1",
	"description": "Regular expression for matching ANSI escape codes",
	"license": "MIT",
	"repository": "chalk/ansi-regex",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"view-supported": "node fixtures/view-codes.js"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"command-line",
		"text",
		"regex",
		"regexp",
		"re",
		"match",
		"test",
		"find",
		"pattern"
	],
	"devDependencies": {
		"ava": "^2.4.0",
		"tsd": "^0.9.0",
		"xo": "^0.25.3"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\ansi-styles\package.json
============================================================
{
	"name": "ansi-styles",
	"version": "4.3.0",
	"description": "ANSI escape codes for styling strings in the terminal",
	"license": "MIT",
	"repository": "chalk/ansi-styles",
	"funding": "https://github.com/chalk/ansi-styles?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"screenshot": "svg-term --command='node screenshot' --out=screenshot.svg --padding=3 --width=55 --height=3 --at=1000 --no-cursor"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"dependencies": {
		"color-convert": "^2.0.1"
	},
	"devDependencies": {
		"@types/color-convert": "^1.9.0",
		"ava": "^2.3.0",
		"svg-term-cli": "^2.1.1",
		"tsd": "^0.11.0",
		"xo": "^0.25.3"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\anymatch\package.json
============================================================
{
  "name": "anymatch",
  "version": "3.1.3",
  "description": "Matches strings against configurable strings, globs, regular expressions, and/or functions",
  "files": [
    "index.js",
    "index.d.ts"
  ],
  "dependencies": {
    "normalize-path": "^3.0.0",
    "picomatch": "^2.0.4"
  },
  "author": {
    "name": "Elan Shanker",
    "url": "https://github.com/es128"
  },
  "license": "ISC",
  "homepage": "https://github.com/micromatch/anymatch",
  "repository": {
    "type": "git",
    "url": "https://github.com/micromatch/anymatch"
  },
  "keywords": [
    "match",
    "any",
    "string",
    "file",
    "fs",
    "list",
    "glob",
    "regex",
    "regexp",
    "regular",
    "expression",
    "function"
  ],
  "scripts": {
    "test": "nyc mocha",
    "mocha": "mocha"
  },
  "devDependencies": {
    "mocha": "^6.1.3",
    "nyc": "^14.0.0"
  },
  "engines": {
    "node": ">= 8"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\aria-query\package.json
============================================================
{
  "name": "aria-query",
  "version": "5.3.0",
  "description": "Programmatic access to the ARIA specification",
  "main": "lib/index.js",
  "files": [
    "lib"
  ],
  "scripts": {
    "build": "rimraf lib && babel src --out-dir lib",
    "flow": "flow",
    "lint": "eslint  --config .eslintrc src __tests__ scripts",
    "lint:fix": "npm run lint -- --fix",
    "prepublishOnly": "npm run build",
    "pretest": "npm run lint:fix && npm run flow",
    "test": "npm run jest",
    "test:ci": "npm run jest -- --ci --runInBand",
    "jest": "jest --coverage __tests__/**/*",
    "output_as_hack": "babel-node ./scripts/output_as_hack.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/A11yance/aria-query.git"
  },
  "keywords": [
    "accessibility",
    "ARIA"
  ],
  "author": "Jesse Beach <splendidnoise@gmail.com>",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/A11yance/aria-query/issues"
  },
  "homepage": "https://github.com/A11yance/aria-query#readme",
  "devDependencies": {
    "@babel/cli": "^7.19.3",
    "@babel/core": "^7.19.6",
    "@babel/eslint-parser": "^7.19.1",
    "@babel/node": "^7.22.5",
    "@babel/preset-env": "^7.19.4",
    "@babel/preset-flow": "^7.18.6",
    "babel-jest": "^29.2.1",
    "commander": "^9.4.1",
    "eslint": "^8.26.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-plugin-flowtype": "^8.0.3",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-jest": "^27.1.3",
    "expect": "^29.2.1",
    "flow-bin": "^0.191.0",
    "jest": "^29.2.1",
    "minimist": "^1.2.7",
    "rimraf": "^3.0.2"
  },
  "jest": {
    "coverageReporters": [
      "lcov"
    ],
    "coverageDirectory": "reports",
    "roots": [
      "<rootDir>/__tests__"
    ]
  },
  "browserslist": [
    ">0.2%",
    "not dead",
    "not op_mini all",
    "ie 11"
  ],
  "dependencies": {
    "dequal": "^2.0.3"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\assertion-error\package.json
============================================================
{
  "name": "assertion-error",
  "version": "2.0.1",
  "description": "Error constructor for test and validation frameworks that implements standardized AssertionError specification.",
  "author": "Jake Luer <jake@qualiancy.com> (http://qualiancy.com)",
  "license": "MIT",
  "types": "./index.d.ts",
  "keywords": [
    "test",
    "assertion",
    "assertion-error"
  ],
  "repository": {
    "type": "git",
    "url": "git@github.com:chaijs/assertion-error.git"
  },
  "engines": {
    "node": ">=12"
  },
  "files": [
    "index.d.ts"
  ],
  "type": "module",
  "module": "index.js",
  "main": "index.js",
  "scripts": {
    "build": "deno bundle mod.ts > index.js",
    "pretest": "rm -rf coverage/",
    "test": "deno test --coverage=coverage",
    "posttest": "deno coverage coverage --lcov > coverage/lcov.info && lcov --summary coverage/lcov.info"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\asynckit\package.json
============================================================
{
  "name": "asynckit",
  "version": "0.4.0",
  "description": "Minimal async jobs utility library, with streams support",
  "main": "index.js",
  "scripts": {
    "clean": "rimraf coverage",
    "lint": "eslint *.js lib/*.js test/*.js",
    "test": "istanbul cover --reporter=json tape -- 'test/test-*.js' | tap-spec",
    "win-test": "tape test/test-*.js",
    "browser": "browserify -t browserify-istanbul test/lib/browserify_adjustment.js test/test-*.js | obake --coverage | tap-spec",
    "report": "istanbul report",
    "size": "browserify index.js | size-table asynckit",
    "debug": "tape test/test-*.js"
  },
  "pre-commit": [
    "clean",
    "lint",
    "test",
    "browser",
    "report",
    "size"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/alexindigo/asynckit.git"
  },
  "keywords": [
    "async",
    "jobs",
    "parallel",
    "serial",
    "iterator",
    "array",
    "object",
    "stream",
    "destroy",
    "terminate",
    "abort"
  ],
  "author": "Alex Indigo <iam@alexindigo.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/alexindigo/asynckit/issues"
  },
  "homepage": "https://github.com/alexindigo/asynckit#readme",
  "devDependencies": {
    "browserify": "^13.0.0",
    "browserify-istanbul": "^2.0.0",
    "coveralls": "^2.11.9",
    "eslint": "^2.9.0",
    "istanbul": "^0.4.3",
    "obake": "^0.1.2",
    "phantomjs-prebuilt": "^2.1.7",
    "pre-commit": "^1.1.3",
    "reamde": "^1.1.0",
    "rimraf": "^2.5.2",
    "size-table": "^0.2.0",
    "tap-spec": "^4.1.1",
    "tape": "^4.5.1"
  },
  "dependencies": {}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\axios\package.json
============================================================
{
  "name": "axios",
  "version": "1.12.2",
  "description": "Promise based HTTP client for the browser and node.js",
  "main": "index.js",
  "exports": {
    ".": {
      "types": {
        "require": "./index.d.cts",
        "default": "./index.d.ts"
      },
      "react-native": {
        "require": "./dist/browser/axios.cjs",
        "default": "./dist/esm/axios.js"
      },
      "browser": {
        "require": "./dist/browser/axios.cjs",
        "default": "./index.js"
      },
      "default": {
        "require": "./dist/node/axios.cjs",
        "default": "./index.js"
      }
    },
    "./lib/adapters/http.js": "./lib/adapters/http.js",
    "./lib/adapters/xhr.js": "./lib/adapters/xhr.js",
    "./unsafe/*": "./lib/*",
    "./unsafe/core/settle.js": "./lib/core/settle.js",
    "./unsafe/core/buildFullPath.js": "./lib/core/buildFullPath.js",
    "./unsafe/helpers/isAbsoluteURL.js": "./lib/helpers/isAbsoluteURL.js",
    "./unsafe/helpers/buildURL.js": "./lib/helpers/buildURL.js",
    "./unsafe/helpers/combineURLs.js": "./lib/helpers/combineURLs.js",
    "./unsafe/adapters/http.js": "./lib/adapters/http.js",
    "./unsafe/adapters/xhr.js": "./lib/adapters/xhr.js",
    "./unsafe/utils.js": "./lib/utils.js",
    "./package.json": "./package.json",
    "./dist/browser/axios.cjs": "./dist/browser/axios.cjs",
    "./dist/node/axios.cjs": "./dist/node/axios.cjs"
  },
  "type": "module",
  "types": "index.d.ts",
  "scripts": {
    "test": "npm run test:node && npm run test:browser && npm run test:package",
    "test:node": "npm run test:mocha",
    "test:browser": "npm run test:karma",
    "test:package": "npm run test:eslint && npm run test:dtslint && npm run test:exports",
    "test:eslint": "node bin/ssl_hotfix.js eslint lib/**/*.js",
    "test:dtslint": "dtslint --localTs node_modules/typescript/lib",
    "test:mocha": "node bin/ssl_hotfix.js mocha test/unit/**/*.js --timeout 30000 --exit",
    "test:exports": "node bin/ssl_hotfix.js mocha test/module/test.js --timeout 30000 --exit",
    "test:karma": "node ./bin/run-karma-tests.js",
    "test:karma:firefox": "node bin/ssl_hotfix.js cross-env LISTEN_ADDR=:: Browsers=Firefox karma start karma.conf.cjs --single-run",
    "test:karma:server": "node bin/ssl_hotfix.js cross-env karma start karma.conf.cjs",
    "test:build:version": "node ./bin/check-build-version.js",
    "start": "node ./sandbox/server.js",
    "preversion": "gulp version",
    "version": "npm run build && git add package.json",
    "prepublishOnly": "npm run test:build:version",
    "postpublish": "git push && git push --tags",
    "build": "gulp clear && cross-env NODE_ENV=production rollup -c -m",
    "examples": "node ./examples/server.js",
    "coveralls": "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
    "fix": "eslint --fix lib/**/*.js",
    "prepare": "husky install && npm run prepare:hooks",
    "prepare:hooks": "npx husky set .husky/commit-msg \"npx commitlint --edit $1\"",
    "release:dry": "release-it --dry-run --no-npm",
    "release:info": "release-it --release-version",
    "release:beta:no-npm": "release-it --preRelease=beta --no-npm",
    "release:beta": "release-it --preRelease=beta",
    "release:no-npm": "release-it --no-npm",
    "release:changelog:fix": "node ./bin/injectContributorsList.js && git add CHANGELOG.md",
    "release": "release-it"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/axios/axios.git"
  },
  "keywords": [
    "xhr",
    "http",
    "ajax",
    "promise",
    "node"
  ],
  "author": "Matt Zabriskie",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/axios/axios/issues"
  },
  "homepage": "https://axios-http.com",
  "devDependencies": {
    "@babel/core": "^7.23.9",
    "@babel/preset-env": "^7.23.9",
    "@commitlint/cli": "^17.8.1",
    "@commitlint/config-conventional": "^17.8.1",
    "@release-it/conventional-changelog": "^5.1.1",
    "@rollup/plugin-alias": "^5.1.0",
    "@rollup/plugin-babel": "^5.3.1",
    "@rollup/plugin-commonjs": "^15.1.0",
    "@rollup/plugin-json": "^4.1.0",
    "@rollup/plugin-multi-entry": "^4.1.0",
    "@rollup/plugin-node-resolve": "^9.0.0",
    "abortcontroller-polyfill": "^1.7.5",
    "auto-changelog": "^2.4.0",
    "body-parser": "^1.20.2",
    "chalk": "^5.3.0",
    "coveralls": "^3.1.1",
    "cross-env": "^7.0.3",
    "dev-null": "^0.1.1",
    "dtslint": "^4.2.1",
    "es6-promise": "^4.2.8",
    "eslint": "^8.56.0",
    "express": "^4.18.2",
    "formdata-node": "^5.0.1",
    "formidable": "^2.1.2",
    "fs-extra": "^10.1.0",
    "get-stream": "^3.0.0",
    "gulp": "^4.0.2",
    "handlebars": "^4.7.8",
    "husky": "^8.0.3",
    "istanbul-instrumenter-loader": "^3.0.1",
    "jasmine-core": "^2.99.1",
    "karma": "^6.3.17",
    "karma-chrome-launcher": "^3.2.0",
    "karma-firefox-launcher": "^2.1.2",
    "karma-jasmine": "^1.1.2",
    "karma-jasmine-ajax": "^0.1.13",
    "karma-rollup-preprocessor": "^7.0.8",
    "karma-safari-launcher": "^1.0.0",
    "karma-sauce-launcher": "^4.3.6",
    "karma-sinon": "^1.0.5",
    "karma-sourcemap-loader": "^0.3.8",
    "memoizee": "^0.4.15",
    "minimist": "^1.2.8",
    "mocha": "^10.3.0",
    "multer": "^1.4.4",
    "pacote": "^20.0.0",
    "pretty-bytes": "^6.1.1",
    "release-it": "^15.11.0",
    "rollup": "^2.79.1",
    "rollup-plugin-auto-external": "^2.0.0",
    "rollup-plugin-bundle-size": "^1.0.3",
    "rollup-plugin-terser": "^7.0.2",
    "sinon": "^4.5.0",
    "stream-throttle": "^0.1.3",
    "string-replace-async": "^3.0.2",
    "tar-stream": "^3.1.7",
    "terser-webpack-plugin": "^4.2.3",
    "typescript": "^4.9.5"
  },
  "browser": {
    "./lib/adapters/http.js": "./lib/helpers/null.js",
    "./lib/platform/node/index.js": "./lib/platform/browser/index.js",
    "./lib/platform/node/classes/FormData.js": "./lib/helpers/null.js"
  },
  "react-native": {
    "./lib/adapters/http.js": "./lib/helpers/null.js",
    "./lib/platform/node/index.js": "./lib/platform/browser/index.js",
    "./lib/platform/node/classes/FormData.js": "./lib/helpers/null.js"
  },
  "jsdelivr": "dist/axios.min.js",
  "unpkg": "dist/axios.min.js",
  "typings": "./index.d.ts",
  "dependencies": {
    "follow-redirects": "^1.15.6",
    "form-data": "^4.0.4",
    "proxy-from-env": "^1.1.0"
  },
  "bundlesize": [
    {
      "path": "./dist/axios.min.js",
      "threshold": "5kB"
    }
  ],
  "contributors": [
    "Matt Zabriskie (https://github.com/mzabriskie)",
    "Dmitriy Mozgovoy (https://github.com/DigitalBrainJS)",
    "Nick Uraltsev (https://github.com/nickuraltsev)",
    "Jay (https://github.com/jasonsaayman)",
    "Emily Morehouse (https://github.com/emilyemorehouse)",
    "Rubén Norte (https://github.com/rubennorte)",
    "Justin Beckwith (https://github.com/JustinBeckwith)",
    "Martti Laine (https://github.com/codeclown)",
    "Xianming Zhong (https://github.com/chinesedfan)",
    "Remco Haszing (https://github.com/remcohaszing)",
    "Rikki Gibson (https://github.com/RikkiGibson)",
    "Willian Agostini (https://github.com/WillianAgostini)",
    "Yasu Flores (https://github.com/yasuf)"
  ],
  "sideEffects": false,
  "release-it": {
    "git": {
      "commitMessage": "chore(release): v${version}",
      "push": true,
      "commit": true,
      "tag": true,
      "requireCommits": false,
      "requireCleanWorkingDir": false
    },
    "github": {
      "release": true,
      "draft": true
    },
    "npm": {
      "publish": false,
      "ignoreVersion": false
    },
    "plugins": {
      "@release-it/conventional-changelog": {
        "preset": "angular",
        "infile": "CHANGELOG.md",
        "header": "# Changelog"
      }
    },
    "hooks": {
      "before:init": "npm test",
      "after:bump": "gulp version --bump ${version} && npm run build && npm run test:build:version",
      "before:release": "npm run release:changelog:fix && git add ./package-lock.json",
      "after:release": "echo Successfully released ${name} v${version} to ${repo.repository}."
    }
  },
  "commitlint": {
    "rules": {
      "header-max-length": [
        2,
        "always",
        130
      ]
    },
    "extends": [
      "@commitlint/config-conventional"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\babel-jest\package.json
============================================================
{
  "name": "babel-jest",
  "description": "Jest plugin to use babel for transformation.",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/babel-jest"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/transform": "30.2.0",
    "@types/babel__core": "^7.20.5",
    "babel-plugin-istanbul": "^7.0.1",
    "babel-preset-jest": "30.2.0",
    "chalk": "^4.1.2",
    "graceful-fs": "^4.2.11",
    "slash": "^3.0.0"
  },
  "devDependencies": {
    "@babel-8/core": "npm:@babel/core@8.0.0-beta.1",
    "@babel/core": "^7.27.4",
    "@jest/test-utils": "30.2.0",
    "@types/graceful-fs": "^4.1.9"
  },
  "peerDependencies": {
    "@babel/core": "^7.11.0 || ^8.0.0-0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\babel-plugin-istanbul\package.json
============================================================
{
  "name": "babel-plugin-istanbul",
  "version": "7.0.1",
  "author": "Thai Pangsakulyanont @dtinth",
  "license": "BSD-3-Clause",
  "description": "A babel plugin that adds istanbul instrumentation to ES6 code",
  "main": "lib/index.js",
  "files": [
    "lib"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.0.0",
    "@istanbuljs/load-nyc-config": "^1.0.0",
    "@istanbuljs/schema": "^0.1.3",
    "istanbul-lib-instrument": "^6.0.2",
    "test-exclude": "^6.0.0"
  },
  "devDependencies": {
    "@babel/cli": "^7.24.1",
    "@babel/core": "^7.24.1",
    "@babel/plugin-transform-block-scoping": "^7.24.1",
    "@babel/plugin-transform-modules-commonjs": "^7.24.1",
    "@babel/register": "^7.23.7",
    "chai": "^4.2.0",
    "coveralls": "^3.1.1",
    "cross-env": "^7.0.3",
    "mocha": "^6.2.2",
    "nyc": "^15.0.0",
    "pmock": "^0.2.3",
    "standard": "^14.3.1"
  },
  "workspaces": [
    "test/babel-8"
  ],
  "scripts": {
    "coverage": "nyc report --reporter=text-lcov | coveralls",
    "release": "babel src --out-dir lib",
    "pretest": "standard && npm run release",
    "test": "cross-env NODE_ENV=test nyc --reporter=lcov --reporter=text mocha --timeout 5000 test/*.js",
    "prepublishOnly": "npm test && npm run release"
  },
  "standard": {
    "ignore": [
      "fixtures/*.js"
    ]
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/istanbuljs/babel-plugin-istanbul.git"
  },
  "keywords": [
    "istanbul",
    "babel",
    "plugin",
    "instrumentation"
  ],
  "nyc": {
    "include": [
      "src/*.js",
      "fixtures/should-cover.js"
    ],
    "require": [
      "@babel/register"
    ],
    "sourceMap": false,
    "instrument": false
  },
  "bugs": {
    "url": "https://github.com/istanbuljs/babel-plugin-istanbul/issues"
  },
  "homepage": "https://github.com/istanbuljs/babel-plugin-istanbul#readme",
  "engines": {
    "node": ">=12"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\babel-plugin-jest-hoist\package.json
============================================================
{
  "name": "babel-plugin-jest-hoist",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/babel-plugin-jest-hoist"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@types/babel__core": "^7.20.5"
  },
  "devDependencies": {
    "@babel-8/core": "npm:@babel/core@8.0.0-beta.1",
    "@babel-8/preset-react": "npm:@babel/preset-react@8.0.0-beta.1",
    "@babel-8/preset-typescript": "npm:@babel/preset-typescript@8.0.0-beta.1",
    "@babel/core": "^7.27.4",
    "@babel/preset-react": "^7.27.1",
    "@babel/preset-typescript": "^7.27.1",
    "@babel/types": "^7.27.3",
    "@prettier/sync": "^0.5.5",
    "@types/babel__template": "^7.4.4",
    "@types/babel__traverse": "^7.20.7",
    "@types/node": "*",
    "babel-plugin-tester": "^11.0.4",
    "prettier": "^3.0.3"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\babel-plugin-polyfill-corejs2\package.json
============================================================
{
  "name": "babel-plugin-polyfill-corejs2",
  "version": "0.4.14",
  "description": "A Babel plugin to inject imports to core-js@2 polyfills",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel-polyfills.git",
    "directory": "packages/babel-plugin-polyfill-corejs2"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "exports": {
    ".": [
      {
        "import": "./esm/index.mjs",
        "default": "./lib/index.js"
      },
      "./lib/index.js"
    ],
    "./package.json": "./package.json"
  },
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/compat-data": "^7.27.7",
    "@babel/helper-define-polyfill-provider": "^0.6.5",
    "semver": "^6.3.1"
  },
  "devDependencies": {
    "@babel/core": "^7.27.7",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-transform-for-of": "^7.27.1",
    "@babel/plugin-transform-modules-commonjs": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.4.0 || ^8.0.0-0 <8.0.0"
  },
  "gitHead": "fddd6fc6e7c3c41b1234d82e53faf5de832bbf2b"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\babel-plugin-polyfill-corejs3\package.json
============================================================
{
  "name": "babel-plugin-polyfill-corejs3",
  "version": "0.13.0",
  "description": "A Babel plugin to inject imports to core-js@3 polyfills",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel-polyfills.git",
    "directory": "packages/babel-plugin-polyfill-corejs3"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "exports": {
    ".": [
      {
        "import": "./esm/index.mjs",
        "default": "./lib/index.js"
      },
      "./lib/index.js"
    ],
    "./package.json": "./package.json"
  },
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-define-polyfill-provider": "^0.6.5",
    "core-js-compat": "^3.43.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.7",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-proposal-decorators": "^7.27.1",
    "@babel/plugin-transform-class-properties": "^7.27.1",
    "@babel/plugin-transform-classes": "^7.27.7",
    "@babel/plugin-transform-for-of": "^7.27.1",
    "@babel/plugin-transform-modules-commonjs": "^7.27.1",
    "@babel/plugin-transform-runtime": "^7.27.4",
    "@babel/plugin-transform-spread": "^7.27.1",
    "core-js": "^3.43.0",
    "core-js-pure": "^3.43.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.4.0 || ^8.0.0-0 <8.0.0"
  },
  "gitHead": "fddd6fc6e7c3c41b1234d82e53faf5de832bbf2b"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\babel-plugin-polyfill-regenerator\package.json
============================================================
{
  "name": "babel-plugin-polyfill-regenerator",
  "version": "0.6.5",
  "description": "A Babel plugin to inject imports to regenerator-runtime",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel-polyfills.git",
    "directory": "packages/babel-plugin-polyfill-regenerator"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "exports": {
    ".": [
      {
        "import": "./esm/index.mjs",
        "default": "./lib/index.js"
      },
      "./lib/index.js"
    ],
    "./package.json": "./package.json"
  },
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-define-polyfill-provider": "^0.6.5"
  },
  "devDependencies": {
    "@babel/core": "^7.27.7",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-transform-regenerator": "~7.14.5",
    "regenerator-runtime": "^0.14.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.4.0 || ^8.0.0-0 <8.0.0"
  },
  "gitHead": "fddd6fc6e7c3c41b1234d82e53faf5de832bbf2b"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\babel-plugin-styled-components\package.json
============================================================
{
  "version": "2.1.4",
  "name": "babel-plugin-styled-components",
  "description": "Improve the debugging experience and add server-side rendering support to styled-components",
  "repository": "styled-components/babel-plugin-styled-components",
  "homepage": "https://styled-components.com/docs/tooling#babel-plugin",
  "contributors": [
    "Vladimir Danchenkov <vladimir.danchenkov@gmail.com>",
    "Max Stoiber <contact@mxstbr.com>",
    "Phil Pluckthun <phil@kitten.sh>",
    "Evan Jacobs <probablyup@gmail.com>"
  ],
  "main": "lib/index.js",
  "files": [
    "lib",
    "LICENSE.md",
    "README.md"
  ],
  "license": "MIT",
  "devDependencies": {
    "@babel/cli": "^7.22.5",
    "@babel/core": "^7.22.5",
    "@babel/plugin-proposal-class-properties": "^7.18.6",
    "@babel/plugin-transform-modules-commonjs": "^7.22.5",
    "@babel/preset-env": "^7.22.5",
    "babel-test": "^0.2.4",
    "jest": "^29.5.0",
    "jest-file-snapshot": "^0.5.0",
    "prettier": "^2.8.8",
    "rimraf": "^5.0.1",
    "styled-components": "^6.0.0-rc.6"
  },
  "dependencies": {
    "@babel/helper-annotate-as-pure": "^7.22.5",
    "@babel/helper-module-imports": "^7.22.5",
    "@babel/plugin-syntax-jsx": "^7.22.5",
    "lodash": "^4.17.21",
    "picomatch": "^2.3.1"
  },
  "peerDependencies": {
    "styled-components": ">= 2"
  },
  "scripts": {
    "clean": "rimraf lib",
    "style": "prettier --write src/**/*.js",
    "build": "babel src -d lib",
    "test": "jest",
    "test:watch": "yarn test -- --watch",
    "prepublish": "yarn clean && yarn build"
  },
  "keywords": [
    "styled-components",
    "css-in-js",
    "babel-plugin",
    "server-side rendering",
    "ssr",
    "displayName"
  ],
  "jest": {
    "testEnvironment": "node",
    "snapshotSerializers": [
      "<rootDir>/test/whitespaceTrimmingSerializer.js"
    ],
    "watchPathIgnorePatterns": [
      "fixtures\\/[^/]+\\/(output|error)\\.js"
    ]
  },
  "packageManager": "yarn@3.5.0"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\babel-preset-current-node-syntax\package.json
============================================================
{
  "name": "babel-preset-current-node-syntax",
  "version": "1.2.0",
  "description": "A Babel preset that enables parsing of proposals supported by the current Node.js version.",
  "main": "src/index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/nicolo-ribaudo/babel-preset-current-node-syntax.git"
  },
  "author": {
    "name": "Nicolò Ribaudo",
    "url": "https://github.com/nicolo-ribaudo"
  },
  "scripts": {
    "test": "node ./test/index.js"
  },
  "dependencies": {
    "@babel/plugin-syntax-async-generators": "^7.8.4",
    "@babel/plugin-syntax-bigint": "^7.8.3",
    "@babel/plugin-syntax-class-properties": "^7.12.13",
    "@babel/plugin-syntax-class-static-block": "^7.14.5",
    "@babel/plugin-syntax-import-attributes": "^7.24.7",
    "@babel/plugin-syntax-import-meta": "^7.10.4",
    "@babel/plugin-syntax-json-strings": "^7.8.3",
    "@babel/plugin-syntax-logical-assignment-operators": "^7.10.4",
    "@babel/plugin-syntax-nullish-coalescing-operator": "^7.8.3",
    "@babel/plugin-syntax-numeric-separator": "^7.10.4",
    "@babel/plugin-syntax-object-rest-spread": "^7.8.3",
    "@babel/plugin-syntax-optional-catch-binding": "^7.8.3",
    "@babel/plugin-syntax-optional-chaining": "^7.8.3",
    "@babel/plugin-syntax-private-property-in-object": "^7.14.5",
    "@babel/plugin-syntax-top-level-await": "^7.14.5"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0 || ^8.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "7.25.2",
    "@babel/core-8": "npm:@babel/core@^8.0.0-beta.1",
    "@babel/parser-7.0.0": "npm:@babel/parser@7.0.0",
    "@babel/parser-7.12.0": "npm:@babel/parser@7.12.0",
    "@babel/parser-7.22.0": "npm:@babel/parser@7.22.0",
    "@babel/parser-7.9.0": "npm:@babel/parser@7.9.0"
  },
  "license": "MIT"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\babel-preset-jest\package.json
============================================================
{
  "name": "babel-preset-jest",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/babel-preset-jest"
  },
  "license": "MIT",
  "main": "./index.js",
  "exports": {
    ".": "./index.js",
    "./package.json": "./package.json"
  },
  "dependencies": {
    "babel-plugin-jest-hoist": "30.2.0",
    "babel-preset-current-node-syntax": "^1.2.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.11.0 || ^8.0.0-beta.1"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\balanced-match\package.json
============================================================
{
  "name": "balanced-match",
  "description": "Match balanced character pairs, like \"{\" and \"}\"",
  "version": "1.0.2",
  "repository": {
    "type": "git",
    "url": "git://github.com/juliangruber/balanced-match.git"
  },
  "homepage": "https://github.com/juliangruber/balanced-match",
  "main": "index.js",
  "scripts": {
    "test": "tape test/test.js",
    "bench": "matcha test/bench.js"
  },
  "devDependencies": {
    "matcha": "^0.7.0",
    "tape": "^4.6.0"
  },
  "keywords": [
    "match",
    "regexp",
    "test",
    "balanced",
    "parse"
  ],
  "author": {
    "name": "Julian Gruber",
    "email": "mail@juliangruber.com",
    "url": "http://juliangruber.com"
  },
  "license": "MIT",
  "testling": {
    "files": "test/*.js",
    "browsers": [
      "ie/8..latest",
      "firefox/20..latest",
      "firefox/nightly",
      "chrome/25..latest",
      "chrome/canary",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\baseline-browser-mapping\package.json
============================================================
{
  "name": "baseline-browser-mapping",
  "main": "./dist/index.cjs",
  "version": "2.8.19",
  "description": "A library for obtaining browser versions with their maximum supported Baseline feature set and Widely Available status.",
  "exports": {
    ".": {
      "require": "./dist/index.cjs",
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    },
    "./legacy": {
      "require": "./dist/index.cjs",
      "types": "./dist/index.d.ts"
    }
  },
  "jsdelivr": "./dist/index.js",
  "files": [
    "dist/*",
    "!dist/scripts/*",
    "LICENSE.txt",
    "README.md"
  ],
  "types": "./dist/index.d.ts",
  "type": "module",
  "bin": {
    "baseline-browser-mapping": "./dist/cli.js"
  },
  "scripts": {
    "fix-cli-permissions": "output=$(npx baseline-browser-mapping 2>&1); path=$(printf '%s\n' \"$output\" | sed -n 's/^sh: \\(.*\\): Permission denied$/\\1/p'); if [ -n \"$path\" ]; then echo \"Permission denied for: $path\"; echo \"Removing $path ...\"; rm -rf \"$path\"; else echo \"$output\"; fi",
    "test:format": "npx prettier --check .",
    "test:lint": "npx eslint .",
    "test:bcb": "mkdir test-bcb && cd test-bcb && npm init -y && npm i ../../baseline-browser-mapping browserslist browserslist-config-baseline &&jq '. += {\"browserslist\":[\"extends browserslist-config-baseline\"]}' package.json >p && mv p package.json && npx browserslist && cd ../ && rm -rf test-bcb",
    "test:browserslist": "mkdir test-browserslist && cd test-browserslist && npm init -y && npm i ../../baseline-browser-mapping browserslist &&jq '. += {\"browserslist\":[\"baseline widely available with downstream\"]}' package.json >p && mv p package.json && npx browserslist && cd ../ && rm -rf test-browserslist",
    "test:jasmine": "npx jasmine",
    "test": "npm run build && npm run fix-cli-permissions && rm -rf test-browserslist test-bcb && npm run test:format && npm run test:lint && npx jasmine && npm run test:browserslist && npm run test:bcb",
    "build": "rm -rf dist; npx prettier . --write; rollup -c; rm -rf ./dist/scripts/expose-data.d.ts ./dist/cli.d.ts",
    "refresh-downstream": "npx tsx scripts/refresh-downstream.ts",
    "refresh-static": "npx tsx scripts/refresh-static.ts",
    "update-data-file": "npx tsx scripts/update-data-file.ts; npx prettier ./src/data/data.js --write",
    "update-data-dependencies": "npm i @mdn/browser-compat-data@latest web-features@latest -D",
    "check-data-changes": "git diff --name-only | grep -q '^src/data/data.js$' && echo 'changes-available=TRUE' || echo 'changes-available=FALSE'"
  },
  "license": "Apache-2.0",
  "devDependencies": {
    "@mdn/browser-compat-data": "^7.1.14",
    "@rollup/plugin-terser": "^0.4.4",
    "@rollup/plugin-typescript": "^12.1.3",
    "@types/node": "^22.15.17",
    "eslint-plugin-new-with-error": "^5.0.0",
    "jasmine": "^5.8.0",
    "jasmine-spec-reporter": "^7.0.0",
    "prettier": "^3.5.3",
    "rollup": "^4.44.0",
    "tslib": "^2.8.1",
    "typescript": "^5.7.2",
    "typescript-eslint": "^8.35.0",
    "web-features": "^3.6.0"
  },
  "repository": "git+https://github.com/web-platform-dx/baseline-browser-mapping.git"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\bidi-js\package.json
============================================================
{
  "name": "bidi-js",
  "version": "1.0.3",
  "description": "A JavaScript implementation of the Unicode Bidirectional Algorithm",
  "main": "dist/bidi.js",
  "module": "dist/bidi.mjs",
  "repository": {
    "type": "git",
    "url": "https://github.com/lojjic/bidi-js.git"
  },
  "scripts": {
    "build": "rollup -c rollup.config.js",
    "test": "npx babel-node --plugins @babel/plugin-transform-modules-commonjs test/runTestsOnSrc.js",
    "test-build": "node test/runTestsOnBuild.js"
  },
  "author": "Jason Johnston",
  "license": "MIT",
  "devDependencies": {
    "@babel/cli": "^7.13.16",
    "@babel/core": "^7.14.0",
    "@babel/node": "^7.13.13",
    "@babel/plugin-transform-modules-commonjs": "^7.13.8",
    "@babel/preset-env": "^7.14.0",
    "@rollup/plugin-babel": "^5.3.0",
    "@rollup/plugin-buble": "^0.21.3",
    "node-fetch": "^2.6.1",
    "rollup": "^2.45.1",
    "rollup-plugin-terser": "^7.0.2"
  },
  "files": [
    "/dist",
    "/src",
    "/LICENSE.txt",
    "/README.md"
  ],
  "dependencies": {
    "require-from-string": "^2.0.2"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\brace-expansion\package.json
============================================================
{
  "name": "brace-expansion",
  "description": "Brace expansion as known from sh/bash",
  "version": "1.1.12",
  "repository": {
    "type": "git",
    "url": "git://github.com/juliangruber/brace-expansion.git"
  },
  "homepage": "https://github.com/juliangruber/brace-expansion",
  "main": "index.js",
  "scripts": {
    "test": "tape test/*.js",
    "gentest": "bash test/generate.sh",
    "bench": "matcha test/perf/bench.js"
  },
  "dependencies": {
    "balanced-match": "^1.0.0",
    "concat-map": "0.0.1"
  },
  "devDependencies": {
    "matcha": "^0.7.0",
    "tape": "^4.6.0"
  },
  "keywords": [],
  "author": {
    "name": "Julian Gruber",
    "email": "mail@juliangruber.com",
    "url": "http://juliangruber.com"
  },
  "license": "MIT",
  "testling": {
    "files": "test/*.js",
    "browsers": [
      "ie/8..latest",
      "firefox/20..latest",
      "firefox/nightly",
      "chrome/25..latest",
      "chrome/canary",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  },
  "publishConfig": {
    "tag": "1.x"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\braces\package.json
============================================================
{
  "name": "braces",
  "description": "Bash-like brace expansion, implemented in JavaScript. Safer than other brace expansion libs, with complete support for the Bash 4.3 braces specification, without sacrificing speed.",
  "version": "3.0.3",
  "homepage": "https://github.com/micromatch/braces",
  "author": "Jon Schlinkert (https://github.com/jonschlinkert)",
  "contributors": [
    "Brian Woodward (https://twitter.com/doowb)",
    "Elan Shanker (https://github.com/es128)",
    "Eugene Sharygin (https://github.com/eush77)",
    "hemanth.hm (http://h3manth.com)",
    "Jon Schlinkert (http://twitter.com/jonschlinkert)"
  ],
  "repository": "micromatch/braces",
  "bugs": {
    "url": "https://github.com/micromatch/braces/issues"
  },
  "license": "MIT",
  "files": [
    "index.js",
    "lib"
  ],
  "main": "index.js",
  "engines": {
    "node": ">=8"
  },
  "scripts": {
    "test": "mocha",
    "benchmark": "node benchmark"
  },
  "dependencies": {
    "fill-range": "^7.1.1"
  },
  "devDependencies": {
    "ansi-colors": "^3.2.4",
    "bash-path": "^2.0.1",
    "gulp-format-md": "^2.0.0",
    "mocha": "^6.1.1"
  },
  "keywords": [
    "alpha",
    "alphabetical",
    "bash",
    "brace",
    "braces",
    "expand",
    "expansion",
    "filepath",
    "fill",
    "fs",
    "glob",
    "globbing",
    "letter",
    "match",
    "matches",
    "matching",
    "number",
    "numerical",
    "path",
    "range",
    "ranges",
    "sh"
  ],
  "verb": {
    "toc": false,
    "layout": "default",
    "tasks": [
      "readme"
    ],
    "lint": {
      "reflinks": true
    },
    "plugins": [
      "gulp-format-md"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\browserslist\package.json
============================================================
{
  "name": "browserslist",
  "version": "4.26.3",
  "description": "Share target browsers between different front-end tools, like Autoprefixer, Stylelint and babel-env-preset",
  "keywords": [
    "caniuse",
    "browsers",
    "target"
  ],
  "funding": [
    {
      "type": "opencollective",
      "url": "https://opencollective.com/browserslist"
    },
    {
      "type": "tidelift",
      "url": "https://tidelift.com/funding/github/npm/browserslist"
    },
    {
      "type": "github",
      "url": "https://github.com/sponsors/ai"
    }
  ],
  "author": "Andrey Sitnik <andrey@sitnik.ru>",
  "license": "MIT",
  "repository": "browserslist/browserslist",
  "dependencies": {
    "baseline-browser-mapping": "^2.8.9",
    "caniuse-lite": "^1.0.30001746",
    "electron-to-chromium": "^1.5.227",
    "node-releases": "^2.0.21",
    "update-browserslist-db": "^1.1.3"
  },
  "engines": {
    "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
  },
  "bin": {
    "browserslist": "cli.js"
  },
  "types": "./index.d.ts",
  "browser": {
    "./node.js": "./browser.js",
    "path": false
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\bser\package.json
============================================================
{
  "name": "bser",
  "version": "2.1.1",
  "description": "JavaScript implementation of the BSER Binary Serialization",
  "main": "index.js",
  "directories": {
    "test": "test"
  },
  "scripts": {
    "test": "node test/bser.js"
  },
  "files": [
    "index.js"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/watchman"
  },
  "keywords": [
    "bser",
    "binary",
    "protocol"
  ],
  "author": "Wez Furlong <wez@fb.com> (http://wezfurlong.org)",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/facebook/watchman/issues"
  },
  "homepage": "https://facebook.github.io/watchman/docs/bser.html",
  "dependencies": {
    "node-int64": "^0.4.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\buffer-from\package.json
============================================================
{
  "name": "buffer-from",
  "version": "1.1.2",
  "license": "MIT",
  "repository": "LinusU/buffer-from",
  "files": [
    "index.js"
  ],
  "scripts": {
    "test": "standard && node test"
  },
  "devDependencies": {
    "standard": "^12.0.1"
  },
  "keywords": [
    "buffer",
    "buffer from"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\call-bind-apply-helpers\package.json
============================================================
{
	"name": "call-bind-apply-helpers",
	"version": "1.0.2",
	"description": "Helper functions around Function call/apply/bind, for use in `call-bind`",
	"main": "index.js",
	"exports": {
		".": "./index.js",
		"./actualApply": "./actualApply.js",
		"./applyBind": "./applyBind.js",
		"./functionApply": "./functionApply.js",
		"./functionCall": "./functionCall.js",
		"./reflectApply": "./reflectApply.js",
		"./package.json": "./package.json"
	},
	"scripts": {
		"prepack": "npmignore --auto --commentLines=auto",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"prepublishOnly": "safe-publish-latest",
		"prelint": "evalmd README.md",
		"lint": "eslint --ext=.js,.mjs .",
		"postlint": "tsc -p . && attw -P",
		"pretest": "npm run lint",
		"tests-only": "nyc tape 'test/**/*.js'",
		"test": "npm run tests-only",
		"posttest": "npx npm@'>=10.2' audit --production",
		"version": "auto-changelog && git add CHANGELOG.md",
		"postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
	},
	"repository": {
		"type": "git",
		"url": "git+https://github.com/ljharb/call-bind-apply-helpers.git"
	},
	"author": "Jordan Harband <ljharb@gmail.com>",
	"license": "MIT",
	"bugs": {
		"url": "https://github.com/ljharb/call-bind-apply-helpers/issues"
	},
	"homepage": "https://github.com/ljharb/call-bind-apply-helpers#readme",
	"dependencies": {
		"es-errors": "^1.3.0",
		"function-bind": "^1.1.2"
	},
	"devDependencies": {
		"@arethetypeswrong/cli": "^0.17.3",
		"@ljharb/eslint-config": "^21.1.1",
		"@ljharb/tsconfig": "^0.2.3",
		"@types/for-each": "^0.3.3",
		"@types/function-bind": "^1.1.10",
		"@types/object-inspect": "^1.13.0",
		"@types/tape": "^5.8.1",
		"auto-changelog": "^2.5.0",
		"encoding": "^0.1.13",
		"es-value-fixtures": "^1.7.1",
		"eslint": "=8.8.0",
		"evalmd": "^0.0.19",
		"for-each": "^0.3.5",
		"has-strict-mode": "^1.1.0",
		"in-publish": "^2.0.1",
		"npmignore": "^0.3.1",
		"nyc": "^10.3.2",
		"object-inspect": "^1.13.4",
		"safe-publish-latest": "^2.0.0",
		"tape": "^5.9.0",
		"typescript": "next"
	},
	"testling": {
		"files": "test/index.js"
	},
	"auto-changelog": {
		"output": "CHANGELOG.md",
		"template": "keepachangelog",
		"unreleased": false,
		"commitLimit": false,
		"backfillLimit": false,
		"hideCredit": true
	},
	"publishConfig": {
		"ignore": [
			".github/workflows"
		]
	},
	"engines": {
		"node": ">= 0.4"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\callsites\package.json
============================================================
{
	"name": "callsites",
	"version": "3.1.0",
	"description": "Get callsites from the V8 stack trace API",
	"license": "MIT",
	"repository": "sindresorhus/callsites",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=6"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"stacktrace",
		"v8",
		"callsite",
		"callsites",
		"stack",
		"trace",
		"function",
		"file",
		"line",
		"debug"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\camelcase\package.json
============================================================
{
	"name": "camelcase",
	"version": "5.3.1",
	"description": "Convert a dash/dot/underscore/space separated string to camelCase or PascalCase: `foo-bar` → `fooBar`",
	"license": "MIT",
	"repository": "sindresorhus/camelcase",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=6"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"camelcase",
		"camel-case",
		"camel",
		"case",
		"dash",
		"hyphen",
		"dot",
		"underscore",
		"separator",
		"string",
		"text",
		"convert",
		"pascalcase",
		"pascal-case"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.1",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\camelize\package.json
============================================================
{
	"name": "camelize",
	"version": "1.0.1",
	"description": "recursively transform key strings to camel-case",
	"main": "index.js",
	"devDependencies": {
		"@ljharb/eslint-config": "^21.0.0",
		"aud": "^2.0.1",
		"auto-changelog": "^2.4.0",
		"eslint": "=8.8.0",
		"in-publish": "^2.0.1",
		"npmignore": "^0.3.0",
		"safe-publish-latest": "^2.0.0",
		"tape": "^5.6.1"
	},
	"scripts": {
		"prepack": "npmignore --auto --commentLines=autogenerated",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"prepublishOnly": "safe-publish-latest",
		"lint": "eslint --ext=js,mjs .",
		"pretest": "npm run lint",
		"tests-only": "tape 'test/**/*.js'",
		"test": "npm run tests-only",
		"posttest": "aud --production",
		"version": "auto-changelog && git add CHANGELOG.md",
		"postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
	},
	"repository": {
		"type": "git",
		"url": "git://github.com/ljharb/camelize.git"
	},
	"homepage": "https://github.com/ljharb/camelize",
	"keywords": [
		"camel-case",
		"json",
		"transform"
	],
	"testling": {
		"files": "test/*.js",
		"browsers": {
			"iexplore": [
				"6.0",
				"7.0",
				"8.0",
				"9.0"
			],
			"chrome": [
				"20.0"
			],
			"firefox": [
				"10.0",
				"15.0"
			],
			"safari": [
				"5.1"
			],
			"opera": [
				"12.0"
			]
		}
	},
	"author": {
		"name": "James Halliday",
		"email": "mail@substack.net",
		"url": "http://substack.net"
	},
	"funding": {
		"url": "https://github.com/sponsors/ljharb"
	},
	"license": "MIT",
	"auto-changelog": {
		"output": "CHANGELOG.md",
		"template": "keepachangelog",
		"unreleased": false,
		"commitLimit": false,
		"backfillLimit": false,
		"hideCredit": true
	},
	"publishConfig": {
		"ignore": [
			".github/workflows"
		]
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\caniuse-lite\package.json
============================================================
{
  "name": "caniuse-lite",
  "version": "1.0.30001751",
  "description": "A smaller version of caniuse-db, with only the essentials!",
  "main": "dist/unpacker/index.js",
  "files": [
    "data",
    "dist"
  ],
  "keywords": [
    "support"
  ],
  "author": {
    "name": "Ben Briggs",
    "email": "beneb.info@gmail.com",
    "url": "http://beneb.info"
  },
  "repository": "browserslist/caniuse-lite",
  "funding": [
    {
      "type": "opencollective",
      "url": "https://opencollective.com/browserslist"
    },
    {
      "type": "tidelift",
      "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
    },
    {
      "type": "github",
      "url": "https://github.com/sponsors/ai"
    }
  ],
  "license": "CC-BY-4.0"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\chai\package.json
============================================================
{
  "author": "Jake Luer <jake@alogicalparadox.com>",
  "name": "chai",
  "type": "module",
  "description": "BDD/TDD assertion library for node.js and the browser. Test framework agnostic.",
  "keywords": [
    "test",
    "assertion",
    "assert",
    "testing",
    "chai"
  ],
  "files": [
    "index.js",
    "register-*.js"
  ],
  "homepage": "http://chaijs.com",
  "license": "MIT",
  "contributors": [
    "Jake Luer <jake@alogicalparadox.com>",
    "Domenic Denicola <domenic@domenicdenicola.com> (http://domenicdenicola.com)",
    "Veselin Todorov <hi@vesln.com>",
    "John Firebaugh <john.firebaugh@gmail.com>"
  ],
  "version": "6.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/chaijs/chai"
  },
  "bugs": {
    "url": "https://github.com/chaijs/chai/issues"
  },
  "main": "./index.js",
  "scripts": {
    "build": "esbuild --bundle --format=esm --keep-names --outfile=index.js lib/chai.js",
    "prebuild": "npm run clean",
    "format": "prettier --write lib",
    "pretest": "npm run lint",
    "test": "npm run test-node && npm run test-chrome",
    "test-node": "c8 --99 --check-coverage mocha --require ./test/bootstrap/index.js test/*.js",
    "test-chrome": "web-test-runner --playwright",
    "lint": "npm run lint:js && npm run lint:format",
    "lint:js": "eslint lib/",
    "lint:format": "prettier --check lib",
    "lint:types": "tsc",
    "clean": "rm -rf index.js coverage/"
  },
  "engines": {
    "node": ">=18"
  },
  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "@rollup/plugin-commonjs": "^25.0.7",
    "@web/dev-server-rollup": "^0.6.1",
    "@web/test-runner": "^0.18.0",
    "@web/test-runner-playwright": "^0.11.0",
    "assertion-error": "^2.0.1",
    "c8": "^10.1.3",
    "check-error": "^2.1.1",
    "deep-eql": "^5.0.1",
    "esbuild": "^0.25.9",
    "eslint": "^8.56.0",
    "eslint-plugin-jsdoc": "^48.0.4",
    "globals": "^16.3.0",
    "loupe": "^3.1.0",
    "mocha": "^10.2.0",
    "pathval": "^2.0.0",
    "prettier": "^3.4.2",
    "typescript": "~5.7.3"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\chalk\package.json
============================================================
{
	"name": "chalk",
	"version": "4.1.2",
	"description": "Terminal string styling done right",
	"license": "MIT",
	"repository": "chalk/chalk",
	"funding": "https://github.com/chalk/chalk?sponsor=1",
	"main": "source",
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && nyc ava && tsd",
		"bench": "matcha benchmark.js"
	},
	"files": [
		"source",
		"index.d.ts"
	],
	"keywords": [
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"str",
		"ansi",
		"style",
		"styles",
		"tty",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"dependencies": {
		"ansi-styles": "^4.1.0",
		"supports-color": "^7.1.0"
	},
	"devDependencies": {
		"ava": "^2.4.0",
		"coveralls": "^3.0.7",
		"execa": "^4.0.0",
		"import-fresh": "^3.1.0",
		"matcha": "^0.7.0",
		"nyc": "^15.0.0",
		"resolve-from": "^5.0.0",
		"tsd": "^0.7.4",
		"xo": "^0.28.2"
	},
	"xo": {
		"rules": {
			"unicorn/prefer-string-slice": "off",
			"unicorn/prefer-includes": "off",
			"@typescript-eslint/member-ordering": "off",
			"no-redeclare": "off",
			"unicorn/string-content": "off",
			"unicorn/better-regex": "off"
		}
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\char-regex\package.json
============================================================
{
	"name": "char-regex",
	"version": "1.0.2",
	"description": "A regex to match any full character, considering weird character ranges.",
	"repository": "https://github.com/Richienb/char-regex.git",
	"author": "Richie Bendall <richiebendall@gmail.com>",
	"license": "MIT",
	"main": "index.js",
	"files": [
		"index.js",
		"index.d.ts"
	],
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"lint": "xo",
		"test": "yarn lint && ava"
	},
	"keywords": [
		"character",
		"regex",
		"match",
		"split",
		"length"
	],
	"dependencies": {},
	"devDependencies": {
		"@babel/core": "^7.8.4",
		"@babel/plugin-proposal-unicode-property-regex": "^7.8.3",
		"array-uniq": "^2.1.0",
		"ava": "^3.0.0",
		"emoji.json": "^12.1.1",
		"eslint-config-richienb": "^0.3.0",
		"unicode-chars": "^1.0.1",
		"xo": "^0.25.3"
	},
	"resolutions": {
		"eslint": "^6.8.0"
	},
	"xo": {
		"extends": "richienb/node"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\ci-info\package.json
============================================================
{
  "name": "ci-info",
  "version": "4.3.1",
  "description": "Get details about the current Continuous Integration environment",
  "main": "index.js",
  "typings": "index.d.ts",
  "type": "commonjs",
  "author": "Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)",
  "license": "MIT",
  "repository": "github:watson/ci-info",
  "bugs": "https://github.com/watson/ci-info/issues",
  "homepage": "https://github.com/watson/ci-info",
  "contributors": [
    {
      "name": "Sibiraj",
      "url": "https://github.com/sibiraj-s"
    }
  ],
  "funding": [
    {
      "type": "github",
      "url": "https://github.com/sponsors/sibiraj-s"
    }
  ],
  "keywords": [
    "ci",
    "continuous",
    "integration",
    "test",
    "detect"
  ],
  "files": [
    "vendors.json",
    "index.js",
    "index.d.ts",
    "CHANGELOG.md"
  ],
  "scripts": {
    "build": "node sort-vendors.js && node create-typings.js",
    "lint:fix": "standard --fix",
    "test": "standard && node test.js",
    "prepare": "husky install || true"
  },
  "devDependencies": {
    "clear-module": "^4.1.2",
    "husky": "^9.1.7",
    "publint": "^0.3.12",
    "standard": "^17.1.2",
    "tape": "^5.9.0"
  },
  "engines": {
    "node": ">=8"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\cjs-module-lexer\package.json
============================================================
{
  "name": "cjs-module-lexer",
  "version": "2.1.0",
  "description": "Lexes CommonJS modules, returning their named exports metadata",
  "main": "lexer.js",
  "exports": {
    "import": {
      "types": "./lexer.d.mts",
      "default": "./dist/lexer.mjs"
    },
    "default": "./lexer.js"
  },
  "types": "lexer.d.ts",
  "scripts": {
    "test-js": "mocha -b -u tdd test/*.js",
    "test-wasm": "cross-env WASM=1 mocha -b -u tdd test/*.js",
    "test-wasm-sync": "cross-env WASM_SYNC=1 mocha -b -u tdd test/*.js",
    "test": "npm run test-wasm ; npm run test-wasm-sync ; npm run test-js",
    "bench": "node --expose-gc bench/index.mjs",
    "build": "node build.js ; babel dist/lexer.mjs -o dist/lexer.js ; terser dist/lexer.js -o dist/lexer.js",
    "build-wasm": "make lib/lexer.wasm ; node build.js",
    "prepublishOnly": "make && npm run build",
    "footprint": "npm run build && cat dist/lexer.js | gzip -9f | wc -c"
  },
  "author": "Guy Bedford",
  "license": "MIT",
  "devDependencies": {
    "@babel/cli": "^7.5.5",
    "@babel/core": "^7.5.5",
    "@babel/plugin-transform-modules-commonjs": "^7.5.0",
    "cross-env": "^7.0.3",
    "kleur": "^2.0.2",
    "mocha": "^9.1.3",
    "terser": "^4.1.4"
  },
  "files": [
    "dist",
    "lexer.d.ts"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nodejs/cjs-module-lexer.git"
  },
  "bugs": {
    "url": "https://github.com/nodejs/cjs-module-lexer/issues"
  },
  "homepage": "https://github.com/nodejs/cjs-module-lexer#readme"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\cliui\node_modules\emoji-regex\package.json
============================================================
{
  "name": "emoji-regex",
  "version": "8.0.0",
  "description": "A regular expression to match all Emoji-only symbols as per the Unicode Standard.",
  "homepage": "https://mths.be/emoji-regex",
  "main": "index.js",
  "types": "index.d.ts",
  "keywords": [
    "unicode",
    "regex",
    "regexp",
    "regular expressions",
    "code points",
    "symbols",
    "characters",
    "emoji"
  ],
  "license": "MIT",
  "author": {
    "name": "Mathias Bynens",
    "url": "https://mathiasbynens.be/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mathiasbynens/emoji-regex.git"
  },
  "bugs": "https://github.com/mathiasbynens/emoji-regex/issues",
  "files": [
    "LICENSE-MIT.txt",
    "index.js",
    "index.d.ts",
    "text.js",
    "es2015/index.js",
    "es2015/text.js"
  ],
  "scripts": {
    "build": "rm -rf -- es2015; babel src -d .; NODE_ENV=es2015 babel src -d ./es2015; node script/inject-sequences.js",
    "test": "mocha",
    "test:watch": "npm run test -- --watch"
  },
  "devDependencies": {
    "@babel/cli": "^7.2.3",
    "@babel/core": "^7.3.4",
    "@babel/plugin-proposal-unicode-property-regex": "^7.2.0",
    "@babel/preset-env": "^7.3.4",
    "mocha": "^6.0.2",
    "regexgen": "^1.3.0",
    "unicode-12.0.0": "^0.7.9"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\cliui\node_modules\string-width\package.json
============================================================
{
	"name": "string-width",
	"version": "4.2.3",
	"description": "Get the visual width of a string - the number of columns required to display it",
	"license": "MIT",
	"repository": "sindresorhus/string-width",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"string",
		"character",
		"unicode",
		"width",
		"visual",
		"column",
		"columns",
		"fullwidth",
		"full-width",
		"full",
		"ansi",
		"escape",
		"codes",
		"cli",
		"command-line",
		"terminal",
		"console",
		"cjk",
		"chinese",
		"japanese",
		"korean",
		"fixed-width"
	],
	"dependencies": {
		"emoji-regex": "^8.0.0",
		"is-fullwidth-code-point": "^3.0.0",
		"strip-ansi": "^6.0.1"
	},
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.1",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\cliui\node_modules\strip-ansi\package.json
============================================================
{
	"name": "strip-ansi",
	"version": "6.0.1",
	"description": "Strip ANSI escape codes from a string",
	"license": "MIT",
	"repository": "chalk/strip-ansi",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"strip",
		"trim",
		"remove",
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"dependencies": {
		"ansi-regex": "^5.0.1"
	},
	"devDependencies": {
		"ava": "^2.4.0",
		"tsd": "^0.10.0",
		"xo": "^0.25.3"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\cliui\node_modules\wrap-ansi\package.json
============================================================
{
	"name": "wrap-ansi",
	"version": "7.0.0",
	"description": "Wordwrap a string with ANSI escape codes",
	"license": "MIT",
	"repository": "chalk/wrap-ansi",
	"funding": "https://github.com/chalk/wrap-ansi?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && nyc ava"
	},
	"files": [
		"index.js"
	],
	"keywords": [
		"wrap",
		"break",
		"wordwrap",
		"wordbreak",
		"linewrap",
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"dependencies": {
		"ansi-styles": "^4.0.0",
		"string-width": "^4.1.0",
		"strip-ansi": "^6.0.0"
	},
	"devDependencies": {
		"ava": "^2.1.0",
		"chalk": "^4.0.0",
		"coveralls": "^3.0.3",
		"has-ansi": "^4.0.0",
		"nyc": "^15.0.1",
		"xo": "^0.29.1"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\cliui\package.json
============================================================
{
  "name": "cliui",
  "version": "8.0.1",
  "description": "easily create complex multi-column command-line-interfaces",
  "main": "build/index.cjs",
  "exports": {
    ".": [
      {
        "import": "./index.mjs",
        "require": "./build/index.cjs"
      },
      "./build/index.cjs"
    ]
  },
  "type": "module",
  "module": "./index.mjs",
  "scripts": {
    "check": "standardx '**/*.ts' && standardx '**/*.js' && standardx '**/*.cjs'",
    "fix": "standardx --fix '**/*.ts' && standardx --fix '**/*.js' && standardx --fix '**/*.cjs'",
    "pretest": "rimraf build && tsc -p tsconfig.test.json && cross-env NODE_ENV=test npm run build:cjs",
    "test": "c8 mocha ./test/*.cjs",
    "test:esm": "c8 mocha ./test/esm/cliui-test.mjs",
    "postest": "check",
    "coverage": "c8 report --check-coverage",
    "precompile": "rimraf build",
    "compile": "tsc",
    "postcompile": "npm run build:cjs",
    "build:cjs": "rollup -c",
    "prepare": "npm run compile"
  },
  "repository": "yargs/cliui",
  "standard": {
    "ignore": [
      "**/example/**"
    ],
    "globals": [
      "it"
    ]
  },
  "keywords": [
    "cli",
    "command-line",
    "layout",
    "design",
    "console",
    "wrap",
    "table"
  ],
  "author": "Ben Coe <ben@npmjs.com>",
  "license": "ISC",
  "dependencies": {
    "string-width": "^4.2.0",
    "strip-ansi": "^6.0.1",
    "wrap-ansi": "^7.0.0"
  },
  "devDependencies": {
    "@types/node": "^14.0.27",
    "@typescript-eslint/eslint-plugin": "^4.0.0",
    "@typescript-eslint/parser": "^4.0.0",
    "c8": "^7.3.0",
    "chai": "^4.2.0",
    "chalk": "^4.1.0",
    "cross-env": "^7.0.2",
    "eslint": "^7.6.0",
    "eslint-plugin-import": "^2.22.0",
    "eslint-plugin-node": "^11.1.0",
    "gts": "^3.0.0",
    "mocha": "^10.0.0",
    "rimraf": "^3.0.2",
    "rollup": "^2.23.1",
    "rollup-plugin-ts": "^3.0.2",
    "standardx": "^7.0.0",
    "typescript": "^4.0.0"
  },
  "files": [
    "build",
    "index.mjs",
    "!*.d.ts"
  ],
  "engines": {
    "node": ">=12"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\co\package.json
============================================================
{
  "name": "co",
  "version": "4.6.0",
  "description": "generator async control flow goodness",
  "keywords": [
    "async",
    "flow",
    "generator",
    "coro",
    "coroutine"
  ],
  "devDependencies": {
    "browserify": "^10.0.0",
    "istanbul-harmony": "0",
    "mocha": "^2.0.0",
    "mz": "^1.0.2"
  },
  "scripts": {
    "test": "mocha --harmony",
    "test-cov": "node --harmony node_modules/.bin/istanbul cover ./node_modules/.bin/_mocha -- --reporter dot",
    "test-travis": "node --harmony node_modules/.bin/istanbul cover ./node_modules/.bin/_mocha --report lcovonly -- --reporter dot",
    "prepublish": "npm run browserify",
    "browserify": "browserify index.js -o ./co-browser.js -s co"
  },
  "files": [
    "index.js"
  ],
  "license": "MIT",
  "repository": "tj/co",
  "engines": {
    "iojs": ">= 1.0.0",
    "node": ">= 0.12.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\collect-v8-coverage\package.json
============================================================
{
  "name": "collect-v8-coverage",
  "version": "1.0.3",
  "main": "index.js",
  "types": "index.d.ts",
  "repository": "SimenB/collect-v8-coverage",
  "files": [
    "CHANGELOG.md",
    "index.js",
    "index.d.ts"
  ],
  "license": "MIT",
  "devDependencies": {
    "@commitlint/cli": "^19.0.0",
    "@commitlint/config-conventional": "^19.0.0",
    "@semantic-release/changelog": "^6.0.0",
    "@semantic-release/git": "^10.0.0",
    "husky": "^9.0.0",
    "lint-staged": "^15.0.0",
    "prettier": "^3.0.0",
    "semantic-release": "^25.0.0"
  },
  "prettier": {
    "singleQuote": true,
    "trailingComma": "all"
  },
  "lint-staged": {
    "*.{js,ts,md,json}": "prettier --write"
  },
  "commitlint": {
    "extends": [
      "@commitlint/config-conventional"
    ]
  },
  "release": {
    "plugins": [
      "@semantic-release/commit-analyzer",
      "@semantic-release/release-notes-generator",
      "@semantic-release/changelog",
      "@semantic-release/npm",
      "@semantic-release/git",
      "@semantic-release/github"
    ]
  },
  "scripts": {
    "prepare": "husky"
  },
  "packageManager": "yarn@4.10.3"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\color-convert\package.json
============================================================
{
  "name": "color-convert",
  "description": "Plain color conversion functions",
  "version": "2.0.1",
  "author": "Heather Arthur <fayearthur@gmail.com>",
  "license": "MIT",
  "repository": "Qix-/color-convert",
  "scripts": {
    "pretest": "xo",
    "test": "node test/basic.js"
  },
  "engines": {
    "node": ">=7.0.0"
  },
  "keywords": [
    "color",
    "colour",
    "convert",
    "converter",
    "conversion",
    "rgb",
    "hsl",
    "hsv",
    "hwb",
    "cmyk",
    "ansi",
    "ansi16"
  ],
  "files": [
    "index.js",
    "conversions.js",
    "route.js"
  ],
  "xo": {
    "rules": {
      "default-case": 0,
      "no-inline-comments": 0,
      "operator-linebreak": 0
    }
  },
  "devDependencies": {
    "chalk": "^2.4.2",
    "xo": "^0.24.0"
  },
  "dependencies": {
    "color-name": "~1.1.4"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\color-name\package.json
============================================================
{
  "name": "color-name",
  "version": "1.1.4",
  "description": "A list of color names and its values",
  "main": "index.js",
  "files": [
    "index.js"
  ],
  "scripts": {
    "test": "node test.js"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:colorjs/color-name.git"
  },
  "keywords": [
    "color-name",
    "color",
    "color-keyword",
    "keyword"
  ],
  "author": "DY <dfcreative@gmail.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/colorjs/color-name/issues"
  },
  "homepage": "https://github.com/colorjs/color-name"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\combined-stream\package.json
============================================================
{
  "author": "Felix Geisendörfer <felix@debuggable.com> (http://debuggable.com/)",
  "name": "combined-stream",
  "description": "A stream that emits multiple other streams one after another.",
  "version": "1.0.8",
  "homepage": "https://github.com/felixge/node-combined-stream",
  "repository": {
    "type": "git",
    "url": "git://github.com/felixge/node-combined-stream.git"
  },
  "main": "./lib/combined_stream",
  "scripts": {
    "test": "node test/run.js"
  },
  "engines": {
    "node": ">= 0.8"
  },
  "dependencies": {
    "delayed-stream": "~1.0.0"
  },
  "devDependencies": {
    "far": "~0.0.7"
  },
  "license": "MIT"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\concat-map\package.json
============================================================
{
    "name" : "concat-map",
    "description" : "concatenative mapdashery",
    "version" : "0.0.1",
    "repository" : {
        "type" : "git",
        "url" : "git://github.com/substack/node-concat-map.git"
    },
    "main" : "index.js",
    "keywords" : [
        "concat",
        "concatMap",
        "map",
        "functional",
        "higher-order"
    ],
    "directories" : {
        "example" : "example",
        "test" : "test"
    },
    "scripts" : {
        "test" : "tape test/*.js"
    },
    "devDependencies" : {
        "tape" : "~2.4.0"
    },
    "license" : "MIT",
    "author" : {
        "name" : "James Halliday",
        "email" : "mail@substack.net",
        "url" : "http://substack.net"
    },
    "testling" : {
        "files" : "test/*.js",
        "browsers" : {
            "ie" : [ 6, 7, 8, 9 ],
            "ff" : [ 3.5, 10, 15.0 ],
            "chrome" : [ 10, 22 ],
            "safari" : [ 5.1 ],
            "opera" : [ 12 ]
        }
    }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\convert-source-map\package.json
============================================================
{
  "name": "convert-source-map",
  "version": "2.0.0",
  "description": "Converts a source-map from/to  different formats and allows adding/changing properties.",
  "main": "index.js",
  "scripts": {
    "test": "tap test/*.js --color"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/thlorenz/convert-source-map.git"
  },
  "homepage": "https://github.com/thlorenz/convert-source-map",
  "devDependencies": {
    "inline-source-map": "~0.6.2",
    "tap": "~9.0.0"
  },
  "keywords": [
    "convert",
    "sourcemap",
    "source",
    "map",
    "browser",
    "debug"
  ],
  "author": {
    "name": "Thorsten Lorenz",
    "email": "thlorenz@gmx.de",
    "url": "http://thlorenz.com"
  },
  "license": "MIT",
  "engine": {
    "node": ">=4"
  },
  "files": [
    "index.js"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\core-js-compat\package.json
============================================================
{
  "name": "core-js-compat",
  "version": "3.46.0",
  "type": "commonjs",
  "description": "core-js compat",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/zloirock/core-js.git",
    "directory": "packages/core-js-compat"
  },
  "homepage": "https://core-js.io",
  "bugs": {
    "url": "https://github.com/zloirock/core-js/issues"
  },
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/core-js"
  },
  "license": "MIT",
  "author": {
    "name": "Denis Pushkarev",
    "email": "zloirock@zloirock.ru",
    "url": "http://zloirock.ru"
  },
  "sideEffects": false,
  "main": "index.js",
  "types": "index.d.ts",
  "dependencies": {
    "browserslist": "^4.26.3"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\cross-spawn\package.json
============================================================
{
  "name": "cross-spawn",
  "version": "7.0.6",
  "description": "Cross platform child_process#spawn and child_process#spawnSync",
  "keywords": [
    "spawn",
    "spawnSync",
    "windows",
    "cross-platform",
    "path-ext",
    "shebang",
    "cmd",
    "execute"
  ],
  "author": "André Cruz <andre@moxy.studio>",
  "homepage": "https://github.com/moxystudio/node-cross-spawn",
  "repository": {
    "type": "git",
    "url": "git@github.com:moxystudio/node-cross-spawn.git"
  },
  "license": "MIT",
  "main": "index.js",
  "files": [
    "lib"
  ],
  "scripts": {
    "lint": "eslint .",
    "test": "jest --env node --coverage",
    "prerelease": "npm t && npm run lint",
    "release": "standard-version",
    "postrelease": "git push --follow-tags origin HEAD && npm publish"
  },
  "husky": {
    "hooks": {
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS",
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "*.js": [
      "eslint --fix",
      "git add"
    ]
  },
  "commitlint": {
    "extends": [
      "@commitlint/config-conventional"
    ]
  },
  "dependencies": {
    "path-key": "^3.1.0",
    "shebang-command": "^2.0.0",
    "which": "^2.0.1"
  },
  "devDependencies": {
    "@commitlint/cli": "^8.1.0",
    "@commitlint/config-conventional": "^8.1.0",
    "babel-core": "^6.26.3",
    "babel-jest": "^24.9.0",
    "babel-preset-moxy": "^3.1.0",
    "eslint": "^5.16.0",
    "eslint-config-moxy": "^7.1.0",
    "husky": "^3.0.5",
    "jest": "^24.9.0",
    "lint-staged": "^9.2.5",
    "mkdirp": "^0.5.1",
    "rimraf": "^3.0.0",
    "standard-version": "^9.5.0"
  },
  "engines": {
    "node": ">= 8"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\css-color-keywords\package.json
============================================================
{
  "name": "css-color-keywords",
  "version": "1.0.0",
  "description": "A list of all CSS color keywords.",
  "keywords": [
    "css",
    "color",
    "keywords",
    "list"
  ],
  "license": "ISC",
  "author": "Jakob Krigovsky <jakob@krigovsky.com>",
  "files": [
    "colors.json",
    "index.js"
  ],
  "repository": "sonicdoe/css-color-keywords",
  "scripts": {
    "test": "standard && node test.js"
  },
  "devDependencies": {
    "standard": "^8.6.0"
  },
  "engines": {
    "node": ">=4"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\css-to-react-native\package.json
============================================================
{
  "name": "css-to-react-native",
  "version": "3.2.0",
  "description": "Convert CSS text to a React Native stylesheet object",
  "main": "index.js",
  "types": "index.d.ts",
  "scripts": {
    "build": "rollup ./src/index.js -o index.js --f cjs && babel index.js -o index.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "lint": "eslint src",
    "prepublish": "npm run build",
    "precommit": "lint-staged",
    "lint-staged": "lint-staged"
  },
  "files": [
    "index.js",
    "index.d.ts",
    "src"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/styled-components/css-to-react-native.git"
  },
  "keywords": [
    "styled-components",
    "React",
    "ReactNative",
    "styles",
    "CSS"
  ],
  "author": "Jacob Parker",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/styled-components/css-to-react-native/issues"
  },
  "homepage": "https://github.com/styled-components/css-to-react-native#readme",
  "jest": {
    "testURL": "http://localhost"
  },
  "devDependencies": {
    "@babel/cli": "^7.6.2",
    "@babel/preset-env": "^7.6.2",
    "eslint": "^4.17.0",
    "eslint-config-airbnb-base": "^12.1.0",
    "eslint-config-prettier": "^2.9.0",
    "eslint-plugin-import": "^2.8.0",
    "eslint-plugin-prettier": "^2.6.0",
    "jest": "^24.9.0",
    "lint-staged": "^6.1.0",
    "prettier": "^1.18.2",
    "rollup": "^1.22.0"
  },
  "dependencies": {
    "camelize": "^1.0.0",
    "css-color-keywords": "^1.0.0",
    "postcss-value-parser": "^4.0.2"
  },
  "lint-staged": {
    "*.js": [
      "eslint --fix",
      "git add"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\css-tree\package.json
============================================================
{
  "name": "css-tree",
  "version": "3.1.0",
  "description": "A tool set for CSS: fast detailed parser (CSS → AST), walker (AST traversal), generator (AST → CSS) and lexer (validation and matching) based on specs and browser implementations",
  "author": "Roman Dvornov <rdvornov@gmail.com> (https://github.com/lahmatiy)",
  "license": "MIT",
  "repository": "csstree/csstree",
  "keywords": [
    "css",
    "ast",
    "tokenizer",
    "parser",
    "walker",
    "lexer",
    "generator",
    "utils",
    "syntax",
    "validation"
  ],
  "type": "module",
  "module": "./lib/index.js",
  "main": "./cjs/index.cjs",
  "exports": {
    ".": {
      "import": "./lib/index.js",
      "require": "./cjs/index.cjs"
    },
    "./dist/*": "./dist/*.js",
    "./package.json": "./package.json",
    "./tokenizer": {
      "import": "./lib/tokenizer/index.js",
      "require": "./cjs/tokenizer/index.cjs"
    },
    "./parser": {
      "import": "./lib/parser/index.js",
      "require": "./cjs/parser/index.cjs"
    },
    "./selector-parser": {
      "import": "./lib/parser/parse-selector.js",
      "require": "./cjs/parser/parse-selector.cjs"
    },
    "./generator": {
      "import": "./lib/generator/index.js",
      "require": "./cjs/generator/index.cjs"
    },
    "./walker": {
      "import": "./lib/walker/index.js",
      "require": "./cjs/walker/index.cjs"
    },
    "./convertor": {
      "import": "./lib/convertor/index.js",
      "require": "./cjs/convertor/index.cjs"
    },
    "./lexer": {
      "import": "./lib/lexer/index.js",
      "require": "./cjs/lexer/index.cjs"
    },
    "./definition-syntax": {
      "import": "./lib/definition-syntax/index.js",
      "require": "./cjs/definition-syntax/index.cjs"
    },
    "./definition-syntax-data": {
      "import": "./lib/data.js",
      "require": "./cjs/data.cjs"
    },
    "./definition-syntax-data-patch": {
      "import": "./lib/data-patch.js",
      "require": "./cjs/data-patch.cjs"
    },
    "./utils": {
      "import": "./lib/utils/index.js",
      "require": "./cjs/utils/index.cjs"
    }
  },
  "browser": {
    "./cjs/data.cjs": "./dist/data.cjs",
    "./cjs/version.cjs": "./dist/version.cjs",
    "./lib/data.js": "./dist/data.js",
    "./lib/version.js": "./dist/version.js"
  },
  "unpkg": "dist/csstree.esm.js",
  "jsdelivr": "dist/csstree.esm.js",
  "scripts": {
    "watch": "npm run build -- --watch",
    "build": "npm run bundle && npm run esm-to-cjs --",
    "build-and-test": "npm run build && npm run test:dist && npm run test:cjs",
    "bundle": "node scripts/bundle",
    "bundle-and-test": "npm run bundle && npm run test:dist",
    "esm-to-cjs": "node scripts/esm-to-cjs.cjs",
    "esm-to-cjs-and-test": "npm run esm-to-cjs && npm run test:cjs",
    "lint": "eslint lib scripts && node scripts/review-syntax-patch --lint && node scripts/update-docs --lint",
    "lint-and-test": "npm run lint && npm test",
    "update:docs": "node scripts/update-docs",
    "review:syntax-patch": "node scripts/review-syntax-patch",
    "test": "mocha lib/__tests --require lib/__tests/helpers/setup.js --reporter progress",
    "test:cjs": "mocha cjs/__tests --require lib/__tests/helpers/setup.js --reporter progress",
    "test:dist": "mocha dist/__tests --reporter progress",
    "coverage": "c8 --exclude lib/__tests --reporter=lcovonly npm test",
    "prepublishOnly": "npm run lint-and-test && npm run build-and-test"
  },
  "dependencies": {
    "mdn-data": "2.12.2",
    "source-map-js": "^1.0.1"
  },
  "devDependencies": {
    "c8": "^7.12.0",
    "clap": "^2.0.1",
    "esbuild": "^0.24.0",
    "eslint": "^8.4.1",
    "json-to-ast": "^2.1.0",
    "mocha": "^9.2.2",
    "rollup": "^2.79.2"
  },
  "engines": {
    "node": "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0"
  },
  "files": [
    "data",
    "dist",
    "cjs",
    "!cjs/__tests",
    "lib",
    "!lib/__tests"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\css.escape\package.json
============================================================
{
	"name": "css.escape",
	"version": "1.5.1",
	"description": "A robust polyfill for the `CSS.escape` utility method as defined in CSSOM.",
	"homepage": "https://mths.be/cssescape",
	"main": "css.escape.js",
	"keywords": [
		"string",
		"unicode",
		"identifier",
		"css",
		"cssom",
		"polyfill"
	],
	"license": "MIT",
	"author": {
		"name": "Mathias Bynens",
		"url": "https://mathiasbynens.be/"
	},
	"repository": {
		"type": "git",
		"url": "https://github.com/mathiasbynens/CSS.escape.git"
	},
	"bugs": "https://github.com/mathiasbynens/CSS.escape/issues",
	"files": [
		"LICENSE-MIT.txt",
		"css.escape.js"
	],
	"scripts": {
		"test": "node tests/tests.js",
		"cover": "istanbul cover --report html --verbose --dir coverage tests/tests.js",
		"coveralls": "istanbul cover --verbose --dir coverage tests/tests.js && coveralls < coverage/lcov.info; rm -rf coverage/lcov*"
	},
	"devDependencies": {
		"coveralls": "^2.11.4",
		"istanbul": "^0.4.1"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\cssstyle\package.json
============================================================
{
  "name": "cssstyle",
  "description": "CSSStyleDeclaration Object Model implementation",
  "keywords": [
    "CSS",
    "CSSStyleDeclaration",
    "StyleSheet"
  ],
  "version": "5.3.1",
  "homepage": "https://github.com/jsdom/cssstyle",
  "maintainers": [
    {
      "name": "Jon Sakas",
      "email": "jon.sakas@gmail.com",
      "url": "https://jon.sakas.co/"
    },
    {
      "name": "Rafał Ruciński",
      "email": "fatfisz@gmail.com",
      "url": "https://fatfisz.com"
    }
  ],
  "contributors": [
    {
      "name": "Chad Walker",
      "email": "chad@chad-cat-lore-eddie.com",
      "url": "https://github.com/chad3814"
    }
  ],
  "repository": "jsdom/cssstyle",
  "bugs": "https://github.com/jsdom/cssstyle/issues",
  "directories": {
    "lib": "./lib"
  },
  "files": [
    "lib/"
  ],
  "main": "./lib/CSSStyleDeclaration.js",
  "dependencies": {
    "@asamuzakjp/css-color": "^4.0.3",
    "@csstools/css-syntax-patches-for-csstree": "^1.0.14",
    "css-tree": "^3.1.0"
  },
  "devDependencies": {
    "@babel/generator": "^7.28.0",
    "@babel/parser": "^7.28.0",
    "@babel/traverse": "^7.28.0",
    "@babel/types": "^7.28.2",
    "@domenic/eslint-config": "^4.0.1",
    "@webref/css": "^6.23.6",
    "eslint": "^9.32.0",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-prettier": "^5.5.3",
    "globals": "^16.3.0",
    "npm-run-all": "^4.1.5",
    "prettier": "^3.6.2",
    "resolve": "^1.22.10"
  },
  "scripts": {
    "download": "node ./scripts/downloadLatestProperties.mjs",
    "generate": "run-p generate:*",
    "generate:implemented_properties": "node ./scripts/generateImplementedProperties.mjs",
    "generate:properties": "node ./scripts/generateProperties.js",
    "lint": "npm run generate && eslint --max-warnings 0",
    "lint:fix": "eslint --fix --max-warnings 0",
    "prepublishOnly": "npm run lint && npm run test",
    "test": "npm run generate && node --test",
    "test-ci": "npm run lint && npm run test"
  },
  "license": "MIT",
  "engines": {
    "node": ">=20"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\csstype\package.json
============================================================
{
  "name": "csstype",
  "version": "3.1.3",
  "main": "",
  "types": "index.d.ts",
  "description": "Strict TypeScript and Flow types for style based on MDN data",
  "repository": "https://github.com/frenic/csstype",
  "author": "Fredrik Nicol <fredrik.nicol@gmail.com>",
  "license": "MIT",
  "devDependencies": {
    "@types/chokidar": "^2.1.3",
    "@types/css-tree": "^2.3.1",
    "@types/jest": "^29.5.0",
    "@types/jsdom": "^21.1.1",
    "@types/node": "^16.18.23",
    "@types/prettier": "^2.7.2",
    "@types/request": "^2.48.8",
    "@types/turndown": "^5.0.1",
    "@typescript-eslint/eslint-plugin": "^5.57.0",
    "@typescript-eslint/parser": "^5.57.0",
    "chalk": "^4.1.2",
    "chokidar": "^3.5.3",
    "eslint": "^8.37.0",
    "css-tree": "^2.3.1",
    "eslint-config-prettier": "^8.8.0",
    "eslint-plugin-prettier": "^4.2.1",
    "fast-glob": "^3.2.12",
    "flow-bin": "^0.203.1",
    "jest": "^29.5.0",
    "jsdom": "^21.1.1",
    "mdn-browser-compat-data": "git+https://github.com/mdn/browser-compat-data.git#1bf44517bd08de735e9ec20dbfe8e86c96341054",
    "mdn-data": "git+https://github.com/mdn/data.git#7f0c865a3c4b5d891285c93308ee5c25cb5cfee8",
    "prettier": "^2.8.7",
    "request": "^2.88.2",
    "ts-jest": "^29.0.5",
    "ts-node": "^10.9.1",
    "turndown": "^7.1.2",
    "typescript": "~5.0.3"
  },
  "scripts": {
    "prepublish": "npm install --prefix __tests__ && npm install --prefix __tests__/__fixtures__",
    "prepublishOnly": "tsc && npm run test:src && npm run build && ts-node --files prepublish.ts",
    "update": "ts-node --files update.ts",
    "build": "ts-node --files build.ts --start",
    "watch": "ts-node --files build.ts --watch",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx --fix",
    "pretty": "prettier --write build.ts **/*.{ts,js,json,md}",
    "lazy": "tsc && npm run lint",
    "test": "jest --runInBand",
    "test:src": "jest src.*.ts",
    "test:dist": "jest dist.*.ts --runInBand"
  },
  "files": [
    "index.d.ts",
    "index.js.flow"
  ],
  "keywords": [
    "css",
    "style",
    "typescript",
    "flow",
    "typings",
    "types",
    "definitions"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\data-urls\package.json
============================================================
{
  "name": "data-urls",
  "description": "Parses data: URLs",
  "keywords": [
    "data url",
    "data uri",
    "data:",
    "http",
    "fetch",
    "whatwg"
  ],
  "version": "6.0.0",
  "author": "Domenic Denicola <d@domenic.me> (https://domenic.me/)",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jsdom/data-urls.git"
  },
  "main": "lib/parser.js",
  "files": [
    "lib/"
  ],
  "scripts": {
    "test": "node --test",
    "coverage": "c8 node --test --experimental-test-coverage",
    "lint": "eslint .",
    "pretest": "node scripts/get-latest-platform-tests.js"
  },
  "dependencies": {
    "whatwg-mimetype": "^4.0.0",
    "whatwg-url": "^15.0.0"
  },
  "devDependencies": {
    "@domenic/eslint-config": "^4.0.1",
    "c8": "^10.1.3",
    "eslint": "^9.35.0",
    "globals": "^16.4.0"
  },
  "engines": {
    "node": ">=20"
  },
  "c8": {
    "reporter": [
      "text",
      "html"
    ],
    "exclude": [
      "scripts/",
      "test/"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\debug\package.json
============================================================
{
  "name": "debug",
  "version": "4.4.3",
  "repository": {
    "type": "git",
    "url": "git://github.com/debug-js/debug.git"
  },
  "description": "Lightweight debugging utility for Node.js and the browser",
  "keywords": [
    "debug",
    "log",
    "debugger"
  ],
  "files": [
    "src",
    "LICENSE",
    "README.md"
  ],
  "author": "Josh Junon (https://github.com/qix-)",
  "contributors": [
    "TJ Holowaychuk <tj@vision-media.ca>",
    "Nathan Rajlich <nathan@tootallnate.net> (http://n8.io)",
    "Andrew Rhyne <rhyneandrew@gmail.com>"
  ],
  "license": "MIT",
  "scripts": {
    "lint": "xo",
    "test": "npm run test:node && npm run test:browser && npm run lint",
    "test:node": "mocha test.js test.node.js",
    "test:browser": "karma start --single-run",
    "test:coverage": "cat ./coverage/lcov.info | coveralls"
  },
  "dependencies": {
    "ms": "^2.1.3"
  },
  "devDependencies": {
    "brfs": "^2.0.1",
    "browserify": "^16.2.3",
    "coveralls": "^3.0.2",
    "karma": "^3.1.4",
    "karma-browserify": "^6.0.0",
    "karma-chrome-launcher": "^2.2.0",
    "karma-mocha": "^1.3.0",
    "mocha": "^5.2.0",
    "mocha-lcov-reporter": "^1.2.0",
    "sinon": "^14.0.0",
    "xo": "^0.23.0"
  },
  "peerDependenciesMeta": {
    "supports-color": {
      "optional": true
    }
  },
  "main": "./src/index.js",
  "browser": "./src/browser.js",
  "engines": {
    "node": ">=6.0"
  },
  "xo": {
    "rules": {
      "import/extensions": "off"
    }
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\decimal.js\package.json
============================================================
{
  "name": "decimal.js",
  "description": "An arbitrary-precision Decimal type for JavaScript.",
  "version": "10.6.0",
  "keywords": [
    "arbitrary",
    "precision",
    "arithmetic",
    "big",
    "number",
    "decimal",
    "float",
    "biginteger",
    "bigdecimal",
    "bignumber",
    "bigint",
    "bignum"
  ],
  "repository" : {
    "type": "git",
    "url": "https://github.com/MikeMcl/decimal.js.git"
  },
  "main": "decimal",
  "module": "decimal.mjs",
  "browser": "decimal.js",
  "exports": {
    ".": {
      "types": "./decimal.d.ts",
      "import": "./decimal.mjs",
      "require": "./decimal.js"
    },
    "./decimal.mjs": "./decimal.mjs",
    "./decimal.js": "./decimal.js",
    "./package.json": "./package.json",
    "./decimal": {
      "types": "./decimal.d.ts",
      "import": "./decimal.mjs",
      "require": "./decimal.js"
    }
  },
  "author": {
    "name": "Michael Mclaughlin",
    "email": "M8ch88l@gmail.com"
  },
  "license": "MIT",
  "scripts": {
    "test": "node ./test/test.js"
  },
  "types": "decimal.d.ts",
  "files": [
    "decimal.js",
    "decimal.mjs",
    "decimal.d.ts"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\dedent\package.json
============================================================
{
  "name": "dedent",
  "version": "1.7.0",
  "description": "A string tag that strips indentation from multi-line strings. ⬅️",
  "keywords": [
    "dedent",
    "tag",
    "multi-line string",
    "es6"
  ],
  "homepage": "https://github.com/dmnd/dedent",
  "bugs": {
    "url": "https://github.com/dmnd/dedent/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/dmnd/dedent"
  },
  "license": "MIT",
  "author": {
    "name": "Desmond Brand",
    "email": "dmnd@desmondbrand.com",
    "url": "http://desmondbrand.com"
  },
  "type": "commonjs",
  "exports": {
    ".": {
      "types": {
        "import": "./dist/dedent.d.mts",
        "require": "./dist/dedent.d.ts"
      },
      "import": "./dist/dedent.mjs",
      "require": "./dist/dedent.js"
    }
  },
  "main": "./dist/dedent.js",
  "module": "./dist/dedent.mjs",
  "types": "./dist/dedent.d.mts",
  "files": [
    "dist/",
    "macro.js",
    "package.json",
    "LICENSE.md",
    "README.md"
  ],
  "lint-staged": {
    "*": "prettier --ignore-unknown --write"
  },
  "devDependencies": {
    "@babel/cli": "^7.21.5",
    "@babel/preset-env": "^7.23.3",
    "@babel/preset-typescript": "^7.23.3",
    "@release-it/conventional-changelog": "^8.0.1",
    "@types/babel-plugin-macros": "^3.1.0",
    "@types/eslint": "^8.44.7",
    "@types/jest": "^29.5.3",
    "@typescript-eslint/eslint-plugin": "^6.10.0",
    "@typescript-eslint/parser": "^6.10.0",
    "babel-plugin-add-module-exports": "^1.0.4",
    "babel-plugin-tester": "^11.0.4",
    "console-fail-test": "^0.2.3",
    "cspell": "^8.0.0",
    "eslint": "^8.53.0",
    "eslint-plugin-deprecation": "^2.0.0",
    "eslint-plugin-eslint-comments": "^3.2.0",
    "eslint-plugin-jest": "^27.6.0",
    "eslint-plugin-jsdoc": "^46.9.0",
    "eslint-plugin-jsonc": "^2.10.0",
    "eslint-plugin-markdown": "^3.0.1",
    "eslint-plugin-n": "^16.3.1",
    "eslint-plugin-no-only-tests": "^3.1.0",
    "eslint-plugin-perfectionist": "^2.3.0",
    "eslint-plugin-regexp": "^2.1.1",
    "eslint-plugin-yml": "^1.10.0",
    "husky": "^8.0.3",
    "jest": "^29.7.0",
    "jsonc-eslint-parser": "^2.4.0",
    "knip": "^2.41.0",
    "lint-staged": "^15.1.0",
    "markdownlint": "^0.31.1",
    "markdownlint-cli": "^0.37.0",
    "npm-package-json-lint": "^7.1.0",
    "npm-package-json-lint-config-default": "^6.0.0",
    "prettier": "^3.0.3",
    "prettier-plugin-curly": "^0.1.3",
    "prettier-plugin-packagejson": "^2.4.6",
    "release-it": "^17.0.0",
    "should-semantic-release": "^0.2.1",
    "tsup": "^7.2.0",
    "typescript": "^5.2.2",
    "yaml-eslint-parser": "^1.2.2"
  },
  "peerDependencies": {
    "babel-plugin-macros": "^3.1.0"
  },
  "peerDependenciesMeta": {
    "babel-plugin-macros": {
      "optional": true
    }
  },
  "packageManager": "pnpm@8.7.0",
  "scripts": {
    "build": "pnpm build:legacy && pnpm build:modern && pnpm build:types",
    "build:legacy": "BABEL_ENV=legacy babel src/dedent.ts --out-file dist/dedent.js",
    "build:modern": "BABEL_ENV=modern babel src/dedent.ts --out-file dist/dedent.mjs",
    "build:types": "tsup src/dedent.ts --dts-only",
    "format": "prettier \"**/*\" --ignore-unknown",
    "lint": "eslint . .*js --max-warnings 0 --report-unused-disable-directives",
    "lint:knip": "knip",
    "lint:md": "markdownlint \"**/*.md\" \".github/**/*.md\"",
    "lint:package-json": "npmPkgJsonLint .",
    "lint:packages": "pnpm dedupe --check",
    "lint:spelling": "cspell \"**\" \".github/**/*\"",
    "should-semantic-release": "should-semantic-release --verbose",
    "test": "jest",
    "tsc": "tsc"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\deepmerge\package.json
============================================================
{
  "name": "deepmerge",
  "description": "A library for deep (recursive) merging of Javascript objects",
  "keywords": [
    "merge",
    "deep",
    "extend",
    "copy",
    "clone",
    "recursive"
  ],
  "version": "4.3.1",
  "homepage": "https://github.com/TehShrike/deepmerge",
  "repository": {
    "type": "git",
    "url": "git://github.com/TehShrike/deepmerge.git"
  },
  "main": "dist/cjs.js",
  "engines": {
    "node": ">=0.10.0"
  },
  "scripts": {
    "build": "rollup -c",
    "test": "npm run build && tape test/*.js && jsmd readme.md && npm run test:typescript",
    "test:typescript": "tsc --noEmit test/typescript.ts && ts-node test/typescript.ts",
    "size": "npm run build && uglifyjs --compress --mangle -- ./dist/umd.js | gzip -c | wc -c"
  },
  "devDependencies": {
    "@types/node": "^8.10.54",
    "is-mergeable-object": "1.1.0",
    "is-plain-object": "^5.0.0",
    "jsmd": "^1.0.2",
    "rollup": "^1.23.1",
    "rollup-plugin-commonjs": "^10.1.0",
    "rollup-plugin-node-resolve": "^5.2.0",
    "tape": "^4.11.0",
    "ts-node": "7.0.1",
    "typescript": "=2.2.2",
    "uglify-js": "^3.6.1"
  },
  "license": "MIT"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\delayed-stream\package.json
============================================================
{
  "author": "Felix Geisendörfer <felix@debuggable.com> (http://debuggable.com/)",
  "contributors": [
    "Mike Atkins <apeherder@gmail.com>"
  ],
  "name": "delayed-stream",
  "description": "Buffers events from a stream until you are ready to handle them.",
  "license": "MIT",
  "version": "1.0.0",
  "homepage": "https://github.com/felixge/node-delayed-stream",
  "repository": {
    "type": "git",
    "url": "git://github.com/felixge/node-delayed-stream.git"
  },
  "main": "./lib/delayed_stream",
  "engines": {
    "node": ">=0.4.0"
  },
  "scripts": {
    "test": "make test"
  },
  "dependencies": {},
  "devDependencies": {
    "fake": "0.2.0",
    "far": "0.0.1"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\dequal\package.json
============================================================
{
  "name": "dequal",
  "version": "2.0.3",
  "repository": "lukeed/dequal",
  "description": "A tiny (304B to 489B) utility for check for deep equality",
  "unpkg": "dist/index.min.js",
  "module": "dist/index.mjs",
  "main": "dist/index.js",
  "types": "index.d.ts",
  "license": "MIT",
  "author": {
    "name": "Luke Edwards",
    "email": "luke.edwards05@gmail.com",
    "url": "https://lukeed.com"
  },
  "engines": {
    "node": ">=6"
  },
  "scripts": {
    "build": "bundt",
    "pretest": "npm run build",
    "postbuild": "echo \"lite\" | xargs -n1 cp -v index.d.ts",
    "test": "uvu -r esm test"
  },
  "files": [
    "*.d.ts",
    "dist",
    "lite"
  ],
  "exports": {
    ".": {
      "types": "./index.d.ts",
      "import": "./dist/index.mjs",
      "require": "./dist/index.js"
    },
    "./lite": {
      "types": "./index.d.ts",
      "import": "./lite/index.mjs",
      "require": "./lite/index.js"
    },
    "./package.json": "./package.json"
  },
  "modes": {
    "lite": "src/lite.js",
    "default": "src/index.js"
  },
  "keywords": [
    "deep",
    "deep-equal",
    "equality"
  ],
  "devDependencies": {
    "bundt": "1.0.2",
    "esm": "3.2.25",
    "uvu": "0.3.2"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\detect-newline\package.json
============================================================
{
	"name": "detect-newline",
	"version": "3.1.0",
	"description": "Detect the dominant newline character of a string",
	"license": "MIT",
	"repository": "sindresorhus/detect-newline",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"newline",
		"linebreak",
		"line-break",
		"line",
		"lf",
		"crlf",
		"eol",
		"linefeed",
		"character",
		"char"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\dom-accessibility-api\package.json
============================================================
{
	"name": "dom-accessibility-api",
	"description": "Implements https://w3c.github.io/accname/",
	"version": "0.5.16",
	"main": "dist/index.js",
	"module": "dist/index.mjs",
	"type": "commonjs",
	"exports": {
		"import": "./dist/index.mjs",
		"require": "./dist/index.js"
	},
	"license": "MIT",
	"repository": {
		"type": "git",
		"url": "https://github.com/eps1lon/dom-accessibility-api.git"
	},
	"files": [
		".browserslistrc",
		"dist/"
	],
	"scripts": {
		"build": "yarn build:clean && yarn build:source && yarn build:source:cjs && yarn build:types",
		"build:clean": "rimraf dist",
		"build:source": "cross-env BABEL_ENV=esm babel sources --extensions \".ts\" --ignore \"**/__tests__/**/*\" --out-dir dist/ --out-file-extension=.mjs --source-maps",
		"build:source:cjs": "cross-env BABEL_ENV=cjs babel sources --extensions \".ts\" --ignore \"**/__tests__/**/*\" --out-dir dist/ --out-file-extension=.js --source-maps",
		"build:types": "tsc -p tsconfig.json --emitDeclarationOnly",
		"format": "prettier \"**/*.{json,js,md,ts,yml}\" --write --ignore-path .prettierignore",
		"lint": "eslint --report-unused-disable-directives \"{scripts,sources}/**/*.{js,ts}\"",
		"release": "yarn build && yarn changeset publish",
		"test": "jest --config scripts/jest/jest.config.js",
		"test:ci": "jest --ci --config scripts/jest/jest.ci.config.js --runInBand",
		"test:coverage": "jest --config scripts/jest/jest.coverage.config.js",
		"test:types": "tsc -p tsconfig.json --noEmit",
		"test:wpt:jsdom": "mocha tests/wpt-jsdom/run-wpts.js",
		"test:wpt:browser": "concurrently --success first --kill-others \"yarn test:wpt:browser:run\" \"yarn test:wpt:browser:server\"",
		"test:wpt:browser:run": "cypress run --project tests",
		"test:wpt:browser:server": "serve tests/wpt",
		"test:wpt:browser:open": "cypress open --project tests",
		"wpt:init": "git submodule update --init --recursive",
		"wpt:reset": "rimraf ./tests/wpt && yarn wpt:init",
		"wpt:update": "git submodule update --recursive --remote && cd tests/wpt && python wpt.py manifest --path ../wpt-jsdom/wpt-manifest.json"
	},
	"devDependencies": {
		"@babel/cli": "^7.14.3",
		"@babel/core": "^7.14.3",
		"@babel/plugin-proposal-class-properties": "^7.13.0",
		"@babel/preset-env": "^7.14.4",
		"@babel/preset-typescript": "^7.13.0",
		"@changesets/changelog-github": "^0.4.0",
		"@changesets/cli": "^2.16.0",
		"@testing-library/dom": "^8.0.0",
		"@types/jest": "^29.0.0",
		"@typescript-eslint/eslint-plugin": "^5.0.0",
		"@typescript-eslint/parser": "^5.0.0",
		"concurrently": "^7.0.0",
		"cross-env": "^7.0.3",
		"cypress": "^12.0.0",
		"eslint": "^7.27.0",
		"eslint-plugin-jest": "^27.0.0",
		"jest": "^29.0.0",
		"jest-diff": "^29.0.0",
		"jest-environment-jsdom": "^29.0.0",
		"jest-junit": "^15.0.0",
		"js-yaml": "^4.1.0",
		"jsdom": "^20.0.0",
		"minimatch": "^6.0.0",
		"mocha": "^10.0.0",
		"mocha-sugar-free": "^1.4.0",
		"prettier": "^2.3.0",
		"q": "^1.5.1",
		"request": "^2.88",
		"request-promise-native": "^1.0.9",
		"rimraf": "^4.0.0",
		"serve": "^14.0.0",
		"typescript": "^4.3.2"
	},
	"resolutions": {
		"**/kind-of": "^6.0.3",
		"**/minimist": "^1.2.2"
	},
	"prettier": {
		"useTabs": true
	},
	"keywords": [
		"accessibility",
		"ARIA",
		"accname"
	],
	"publishConfig": {
		"access": "public"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\dunder-proto\package.json
============================================================
{
	"name": "dunder-proto",
	"version": "1.0.1",
	"description": "If available, the `Object.prototype.__proto__` accessor and mutator, call-bound",
	"main": false,
	"exports": {
		"./get": "./get.js",
		"./set": "./set.js",
		"./package.json": "./package.json"
	},
	"sideEffects": false,
	"scripts": {
		"prepack": "npmignore --auto --commentLines=autogenerated",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"prepublishOnly": "safe-publish-latest",
		"prelint": "evalmd README.md",
		"lint": "eslint --ext=.js,.mjs .",
		"postlint": "tsc -p . && attw -P",
		"pretest": "npm run lint",
		"tests-only": "nyc tape 'test/**/*.js'",
		"test": "npm run tests-only",
		"posttest": "npx npm@'>= 10.2' audit --production",
		"version": "auto-changelog && git add CHANGELOG.md",
		"postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
	},
	"repository": {
		"type": "git",
		"url": "git+https://github.com/es-shims/dunder-proto.git"
	},
	"author": "Jordan Harband <ljharb@gmail.com>",
	"license": "MIT",
	"bugs": {
		"url": "https://github.com/es-shims/dunder-proto/issues"
	},
	"homepage": "https://github.com/es-shims/dunder-proto#readme",
	"dependencies": {
		"call-bind-apply-helpers": "^1.0.1",
		"es-errors": "^1.3.0",
		"gopd": "^1.2.0"
	},
	"devDependencies": {
		"@arethetypeswrong/cli": "^0.17.1",
		"@ljharb/eslint-config": "^21.1.1",
		"@ljharb/tsconfig": "^0.2.2",
		"@types/tape": "^5.7.0",
		"auto-changelog": "^2.5.0",
		"encoding": "^0.1.13",
		"eslint": "=8.8.0",
		"evalmd": "^0.0.19",
		"in-publish": "^2.0.1",
		"npmignore": "^0.3.1",
		"nyc": "^10.3.2",
		"safe-publish-latest": "^2.0.0",
		"tape": "^5.9.0",
		"typescript": "next"
	},
	"auto-changelog": {
		"output": "CHANGELOG.md",
		"template": "keepachangelog",
		"unreleased": false,
		"commitLimit": false,
		"backfillLimit": false,
		"hideCredit": true
	},
	"testling": {
		"files": "test/index.js"
	},
	"publishConfig": {
		"ignore": [
			".github/workflows"
		]
	},
	"engines": {
		"node": ">= 0.4"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\eastasianwidth\package.json
============================================================
{
  "name": "eastasianwidth",
  "version": "0.2.0",
  "description": "Get East Asian Width from a character.",
  "main": "eastasianwidth.js",
  "files": [
    "eastasianwidth.js"
  ],
  "scripts": {
    "test": "mocha"
  },
  "repository": "git://github.com/komagata/eastasianwidth.git",
  "author": "Masaki Komagata",
  "license": "MIT",
  "devDependencies": {
    "mocha": "~1.9.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\electron-to-chromium\package.json
============================================================
{
  "name": "electron-to-chromium",
  "version": "1.5.238",
  "description": "Provides a list of electron-to-chromium version mappings",
  "main": "index.js",
  "files": [
    "versions.js",
    "full-versions.js",
    "chromium-versions.js",
    "full-chromium-versions.js",
    "versions.json",
    "full-versions.json",
    "chromium-versions.json",
    "full-chromium-versions.json",
    "LICENSE"
  ],
  "scripts": {
    "build": "node build.mjs",
    "update": "node automated-update.js",
    "test": "nyc ava --verbose",
    "report": "nyc report --reporter=text-lcov > coverage.lcov && codecov"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/kilian/electron-to-chromium/"
  },
  "keywords": [
    "electron",
    "chrome",
    "chromium",
    "browserslist",
    "browserlist"
  ],
  "author": "Kilian Valkhof",
  "license": "ISC",
  "devDependencies": {
    "ava": "^5.1.1",
    "codecov": "^3.8.2",
    "compare-versions": "^6.0.0-rc.1",
    "node-fetch": "^3.3.0",
    "nyc": "^15.1.0",
    "shelljs": "^0.8.5"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\emittery\package.json
============================================================
{
	"name": "emittery",
	"version": "0.13.1",
	"description": "Simple and modern async event emitter",
	"license": "MIT",
	"repository": "sindresorhus/emittery",
	"funding": "https://github.com/sindresorhus/emittery?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=12"
	},
	"scripts": {
		"test": "xo && nyc ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts",
		"maps.js"
	],
	"keywords": [
		"event",
		"emitter",
		"eventemitter",
		"events",
		"async",
		"emit",
		"on",
		"once",
		"off",
		"listener",
		"subscribe",
		"unsubscribe",
		"pubsub",
		"tiny",
		"addlistener",
		"addeventlistener",
		"dispatch",
		"dispatcher",
		"observer",
		"trigger",
		"await",
		"promise",
		"typescript",
		"ts",
		"typed"
	],
	"devDependencies": {
		"@types/node": "^15.6.1",
		"ava": "^2.4.0",
		"delay": "^4.3.0",
		"nyc": "^15.0.0",
		"p-event": "^4.1.0",
		"tsd": "^0.19.1",
		"xo": "^0.39.0"
	},
	"nyc": {
		"reporter": [
			"html",
			"lcov",
			"text"
		]
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\emoji-regex\package.json
============================================================
{
  "name": "emoji-regex",
  "version": "9.2.2",
  "description": "A regular expression to match all Emoji-only symbols as per the Unicode Standard.",
  "homepage": "https://mths.be/emoji-regex",
  "main": "index.js",
  "types": "index.d.ts",
  "keywords": [
    "unicode",
    "regex",
    "regexp",
    "regular expressions",
    "code points",
    "symbols",
    "characters",
    "emoji"
  ],
  "license": "MIT",
  "author": {
    "name": "Mathias Bynens",
    "url": "https://mathiasbynens.be/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mathiasbynens/emoji-regex.git"
  },
  "bugs": "https://github.com/mathiasbynens/emoji-regex/issues",
  "files": [
    "LICENSE-MIT.txt",
    "index.js",
    "index.d.ts",
    "RGI_Emoji.js",
    "RGI_Emoji.d.ts",
    "text.js",
    "text.d.ts",
    "es2015"
  ],
  "scripts": {
    "build": "rm -rf -- es2015; babel src -d .; NODE_ENV=es2015 babel src es2015_types -D -d ./es2015; node script/inject-sequences.js",
    "test": "mocha",
    "test:watch": "npm run test -- --watch"
  },
  "devDependencies": {
    "@babel/cli": "^7.4.4",
    "@babel/core": "^7.4.4",
    "@babel/plugin-proposal-unicode-property-regex": "^7.4.4",
    "@babel/preset-env": "^7.4.4",
    "@unicode/unicode-13.0.0": "^1.0.3",
    "mocha": "^6.1.4",
    "regexgen": "^1.3.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\entities\dist\commonjs\package.json
============================================================
{
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\entities\dist\esm\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\entities\package.json
============================================================
{
    "name": "entities",
    "version": "6.0.1",
    "description": "Encode & decode XML and HTML entities with ease & speed",
    "keywords": [
        "html entities",
        "entity decoder",
        "entity encoding",
        "html decoding",
        "html encoding",
        "xml decoding",
        "xml encoding"
    ],
    "repository": {
        "type": "git",
        "url": "git://github.com/fb55/entities.git"
    },
    "funding": "https://github.com/fb55/entities?sponsor=1",
    "license": "BSD-2-Clause",
    "author": "Felix Boehm <me@feedic.com>",
    "sideEffects": false,
    "type": "module",
    "exports": {
        ".": {
            "import": {
                "types": "./dist/esm/index.d.ts",
                "default": "./dist/esm/index.js"
            },
            "require": {
                "types": "./dist/commonjs/index.d.ts",
                "default": "./dist/commonjs/index.js"
            }
        },
        "./decode": {
            "import": {
                "types": "./dist/esm/decode.d.ts",
                "default": "./dist/esm/decode.js"
            },
            "require": {
                "types": "./dist/commonjs/decode.d.ts",
                "default": "./dist/commonjs/decode.js"
            }
        },
        "./escape": {
            "import": {
                "types": "./dist/esm/escape.d.ts",
                "default": "./dist/esm/escape.js"
            },
            "require": {
                "types": "./dist/commonjs/escape.d.ts",
                "default": "./dist/commonjs/escape.js"
            }
        }
    },
    "main": "./dist/commonjs/index.js",
    "module": "./dist/esm/index.js",
    "types": "./dist/commonjs/index.d.ts",
    "files": [
        "decode.js",
        "decode.d.ts",
        "escape.js",
        "escape.d.ts",
        "dist",
        "src"
    ],
    "scripts": {
        "build:docs": "typedoc --hideGenerator src/index.ts",
        "build:encode-trie": "node --import=tsx scripts/write-encode-map.ts",
        "build:trie": "node --import=tsx scripts/write-decode-map.ts",
        "format": "npm run format:es && npm run format:prettier",
        "format:es": "npm run lint:es -- --fix",
        "format:prettier": "npm run prettier -- --write",
        "lint": "npm run lint:es && npm run lint:ts && npm run lint:prettier",
        "lint:es": "eslint . --ignore-path .gitignore",
        "lint:prettier": "npm run prettier -- --check",
        "lint:ts": "tsc --noEmit",
        "prepublishOnly": "tshy",
        "prettier": "prettier '**/*.{ts,md,json,yml}'",
        "test": "npm run test:vi && npm run lint",
        "test:vi": "vitest run"
    },
    "prettier": {
        "proseWrap": "always",
        "tabWidth": 4
    },
    "devDependencies": {
        "@types/node": "^22.15.30",
        "@typescript-eslint/eslint-plugin": "^8.33.1",
        "@typescript-eslint/parser": "^8.33.1",
        "@vitest/coverage-v8": "^2.1.8",
        "eslint": "^8.57.1",
        "eslint-config-prettier": "^10.1.5",
        "eslint-plugin-n": "^17.19.0",
        "eslint-plugin-unicorn": "^56.0.1",
        "prettier": "^3.5.3",
        "tshy": "^3.0.2",
        "tsx": "^4.19.4",
        "typedoc": "^0.28.5",
        "typescript": "^5.8.3",
        "vitest": "^2.0.2"
    },
    "engines": {
        "node": ">=0.12"
    },
    "tshy": {
        "exclude": [
            "**/*.spec.ts",
            "**/__fixtures__/*",
            "**/__tests__/*",
            "**/__snapshots__/*"
        ],
        "exports": {
            ".": "./src/index.ts",
            "./decode": "./src/decode.ts",
            "./escape": "./src/escape.ts"
        }
    }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\error-ex\package.json
============================================================
{
  "name": "error-ex",
  "description": "Easy error subclassing and stack customization",
  "version": "1.3.4",
  "maintainers": [
    "Josh Junon <i.am.qix@gmail.com> (github.com/qix-)",
    "Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)"
  ],
  "keywords": [
    "error",
    "errors",
    "extend",
    "extending",
    "extension",
    "subclass",
    "stack",
    "custom"
  ],
  "license": "MIT",
  "scripts": {
    "pretest": "xo",
    "test": "mocha --compilers coffee:coffee-script/register"
  },
  "xo": {
    "rules": {
      "operator-linebreak": [
        0
      ]
    }
  },
  "repository": "qix-/node-error-ex",
  "files": [
    "index.js"
  ],
  "devDependencies": {
    "coffee-script": "^1.9.3",
    "coveralls": "^2.11.2",
    "istanbul": "^0.3.17",
    "mocha": "^2.2.5",
    "should": "^7.0.1",
    "xo": "^0.7.1"
  },
  "dependencies": {
    "is-arrayish": "^0.2.1"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\es-define-property\package.json
============================================================
{
	"name": "es-define-property",
	"version": "1.0.1",
	"description": "`Object.defineProperty`, but not IE 8's broken one.",
	"main": "index.js",
	"types": "./index.d.ts",
	"exports": {
		".": "./index.js",
		"./package.json": "./package.json"
	},
	"sideEffects": false,
	"scripts": {
		"prepack": "npmignore --auto --commentLines=autogenerated",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"prepublishOnly": "safe-publish-latest",
		"prelint": "evalmd README.md",
		"lint": "eslint --ext=js,mjs .",
		"postlint": "tsc -p .",
		"pretest": "npm run lint",
		"tests-only": "nyc tape 'test/**/*.js'",
		"test": "npm run tests-only",
		"posttest": "npx npm@'>= 10.2' audit --production",
		"version": "auto-changelog && git add CHANGELOG.md",
		"postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
	},
	"repository": {
		"type": "git",
		"url": "git+https://github.com/ljharb/es-define-property.git"
	},
	"keywords": [
		"javascript",
		"ecmascript",
		"object",
		"define",
		"property",
		"defineProperty",
		"Object.defineProperty"
	],
	"author": "Jordan Harband <ljharb@gmail.com>",
	"license": "MIT",
	"bugs": {
		"url": "https://github.com/ljharb/es-define-property/issues"
	},
	"homepage": "https://github.com/ljharb/es-define-property#readme",
	"devDependencies": {
		"@ljharb/eslint-config": "^21.1.1",
		"@ljharb/tsconfig": "^0.2.2",
		"@types/gopd": "^1.0.3",
		"@types/tape": "^5.6.5",
		"auto-changelog": "^2.5.0",
		"encoding": "^0.1.13",
		"eslint": "^8.8.0",
		"evalmd": "^0.0.19",
		"gopd": "^1.2.0",
		"in-publish": "^2.0.1",
		"npmignore": "^0.3.1",
		"nyc": "^10.3.2",
		"safe-publish-latest": "^2.0.0",
		"tape": "^5.9.0",
		"typescript": "next"
	},
	"engines": {
		"node": ">= 0.4"
	},
	"testling": {
		"files": "test/index.js"
	},
	"auto-changelog": {
		"output": "CHANGELOG.md",
		"template": "keepachangelog",
		"unreleased": false,
		"commitLimit": false,
		"backfillLimit": false,
		"hideCredit": true
	},
	"publishConfig": {
		"ignore": [
			".github/workflows"
		]
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\es-errors\package.json
============================================================
{
	"name": "es-errors",
	"version": "1.3.0",
	"description": "A simple cache for a few of the JS Error constructors.",
	"main": "index.js",
	"exports": {
		".": "./index.js",
		"./eval": "./eval.js",
		"./range": "./range.js",
		"./ref": "./ref.js",
		"./syntax": "./syntax.js",
		"./type": "./type.js",
		"./uri": "./uri.js",
		"./package.json": "./package.json"
	},
	"sideEffects": false,
	"scripts": {
		"prepack": "npmignore --auto --commentLines=autogenerated",
		"prepublishOnly": "safe-publish-latest",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"pretest": "npm run lint",
		"test": "npm run tests-only",
		"tests-only": "nyc tape 'test/**/*.js'",
		"posttest": "aud --production",
		"prelint": "evalmd README.md",
		"lint": "eslint --ext=js,mjs .",
		"postlint": "tsc -p . && eclint check $(git ls-files | xargs find 2> /dev/null | grep -vE 'node_modules|\\.git' | grep -v dist/)",
		"version": "auto-changelog && git add CHANGELOG.md",
		"postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
	},
	"repository": {
		"type": "git",
		"url": "git+https://github.com/ljharb/es-errors.git"
	},
	"keywords": [
		"javascript",
		"ecmascript",
		"error",
		"typeerror",
		"syntaxerror",
		"rangeerror"
	],
	"author": "Jordan Harband <ljharb@gmail.com>",
	"license": "MIT",
	"bugs": {
		"url": "https://github.com/ljharb/es-errors/issues"
	},
	"homepage": "https://github.com/ljharb/es-errors#readme",
	"devDependencies": {
		"@ljharb/eslint-config": "^21.1.0",
		"@types/tape": "^5.6.4",
		"aud": "^2.0.4",
		"auto-changelog": "^2.4.0",
		"eclint": "^2.8.1",
		"eslint": "^8.8.0",
		"evalmd": "^0.0.19",
		"in-publish": "^2.0.1",
		"npmignore": "^0.3.1",
		"nyc": "^10.3.2",
		"safe-publish-latest": "^2.0.0",
		"tape": "^5.7.4",
		"typescript": "next"
	},
	"auto-changelog": {
		"output": "CHANGELOG.md",
		"template": "keepachangelog",
		"unreleased": false,
		"commitLimit": false,
		"backfillLimit": false,
		"hideCredit": true
	},
	"publishConfig": {
		"ignore": [
			".github/workflows"
		]
	},
	"engines": {
		"node": ">= 0.4"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\es-module-lexer\package.json
============================================================
{
  "name": "es-module-lexer",
  "version": "1.7.0",
  "description": "Lexes ES modules returning their import/export metadata",
  "main": "dist/lexer.cjs",
  "module": "dist/lexer.js",
  "types": "types/lexer.d.ts",
  "exports": {
    ".": {
      "types": "./types/lexer.d.ts",
      "module": "./dist/lexer.js",
      "import": "./dist/lexer.js",
      "require": "./dist/lexer.cjs"
    },
    "./js": {
      "types": "./types/lexer.d.ts",
      "default": "./dist/lexer.asm.js"
    }
  },
  "scripts": {
    "build": "npm install -g chomp ; chomp build",
    "test": "npm install -g chomp ; chomp test"
  },
  "author": "Guy Bedford",
  "license": "MIT",
  "devDependencies": {
    "@babel/cli": "^7.5.5",
    "@babel/core": "^7.5.5",
    "@babel/plugin-transform-modules-commonjs": "^7.5.0",
    "@swc/cli": "^0.1.57",
    "@swc/core": "^1.2.224",
    "@types/node": "^18.7.1",
    "kleur": "^2.0.2",
    "mocha": "^5.2.0",
    "terser": "^5.19.4",
    "typescript": "^4.7.4"
  },
  "files": [
    "dist",
    "types",
    "lexer.js"
  ],
  "type": "module",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/guybedford/es-module-lexer.git"
  },
  "bugs": {
    "url": "https://github.com/guybedford/es-module-lexer/issues"
  },
  "homepage": "https://github.com/guybedford/es-module-lexer#readme",
  "directories": {
    "lib": "lib",
    "test": "test"
  },
  "keywords": []
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\es-object-atoms\package.json
============================================================
{
	"name": "es-object-atoms",
	"version": "1.1.1",
	"description": "ES Object-related atoms: Object, ToObject, RequireObjectCoercible",
	"main": "index.js",
	"exports": {
		".": "./index.js",
		"./RequireObjectCoercible": "./RequireObjectCoercible.js",
		"./isObject": "./isObject.js",
		"./ToObject": "./ToObject.js",
		"./package.json": "./package.json"
	},
	"sideEffects": false,
	"scripts": {
		"prepack": "npmignore --auto --commentLines=autogenerated",
		"prepublishOnly": "safe-publish-latest",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"pretest": "npm run lint",
		"test": "npm run tests-only",
		"tests-only": "nyc tape 'test/**/*.js'",
		"posttest": "npx npm@\">= 10.2\" audit --production",
		"prelint": "evalmd README.md",
		"lint": "eslint --ext=js,mjs .",
		"postlint": "tsc -p . && eclint check $(git ls-files | xargs find 2> /dev/null | grep -vE 'node_modules|\\.git' | grep -v dist/)",
		"version": "auto-changelog && git add CHANGELOG.md",
		"postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
	},
	"repository": {
		"type": "git",
		"url": "git+https://github.com/ljharb/es-object-atoms.git"
	},
	"keywords": [
		"javascript",
		"ecmascript",
		"object",
		"toobject",
		"coercible"
	],
	"author": "Jordan Harband <ljharb@gmail.com>",
	"license": "MIT",
	"bugs": {
		"url": "https://github.com/ljharb/es-object-atoms/issues"
	},
	"homepage": "https://github.com/ljharb/es-object-atoms#readme",
	"dependencies": {
		"es-errors": "^1.3.0"
	},
	"devDependencies": {
		"@ljharb/eslint-config": "^21.1.1",
		"@ljharb/tsconfig": "^0.2.3",
		"@types/tape": "^5.8.1",
		"auto-changelog": "^2.5.0",
		"eclint": "^2.8.1",
		"encoding": "^0.1.13",
		"eslint": "^8.8.0",
		"evalmd": "^0.0.19",
		"in-publish": "^2.0.1",
		"npmignore": "^0.3.1",
		"nyc": "^10.3.2",
		"safe-publish-latest": "^2.0.0",
		"tape": "^5.9.0",
		"typescript": "next"
	},
	"auto-changelog": {
		"output": "CHANGELOG.md",
		"template": "keepachangelog",
		"unreleased": false,
		"commitLimit": false,
		"backfillLimit": false,
		"hideCredit": true
	},
	"publishConfig": {
		"ignore": [
			".github/workflows"
		]
	},
	"engines": {
		"node": ">= 0.4"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\es-set-tostringtag\package.json
============================================================
{
	"name": "es-set-tostringtag",
	"version": "2.1.0",
	"description": "A helper to optimistically set Symbol.toStringTag, when possible.",
	"main": "index.js",
	"exports": {
		".": "./index.js",
		"./package.json": "./package.json"
	},
	"sideEffects": false,
	"scripts": {
		"prepack": "npmignore --auto --commentLines=autogenerated",
		"prepublishOnly": "safe-publish-latest",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"prelint": "evalmd README.md",
		"lint": "eslint --ext=js,mjs .",
		"postlint": "tsc -p . && attw -P",
		"pretest": "npm run lint",
		"tests-only": "nyc tape 'test/**/*.js'",
		"test": "npm run tests-only",
		"posttest": "npx npm@\">= 10.2\" audit --production",
		"version": "auto-changelog && git add CHANGELOG.md",
		"postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
	},
	"repository": {
		"type": "git",
		"url": "git+https://github.com/es-shims/es-set-tostringtag.git"
	},
	"author": "Jordan Harband <ljharb@gmail.com>",
	"license": "MIT",
	"bugs": {
		"url": "https://github.com/es-shims/es-set-tostringtag/issues"
	},
	"homepage": "https://github.com/es-shims/es-set-tostringtag#readme",
	"devDependencies": {
		"@arethetypeswrong/cli": "^0.17.2",
		"@ljharb/eslint-config": "^21.1.1",
		"@ljharb/tsconfig": "^0.2.3",
		"@types/get-intrinsic": "^1.2.3",
		"@types/has-symbols": "^1.0.2",
		"@types/tape": "^5.8.0",
		"auto-changelog": "^2.5.0",
		"encoding": "^0.1.13",
		"eslint": "=8.8.0",
		"evalmd": "^0.0.19",
		"in-publish": "^2.0.1",
		"npmignore": "^0.3.1",
		"nyc": "^10.3.2",
		"safe-publish-latest": "^2.0.0",
		"tape": "^5.9.0",
		"typescript": "next"
	},
	"dependencies": {
		"es-errors": "^1.3.0",
		"get-intrinsic": "^1.2.6",
		"has-tostringtag": "^1.0.2",
		"hasown": "^2.0.2"
	},
	"engines": {
		"node": ">= 0.4"
	},
	"auto-changelog": {
		"output": "CHANGELOG.md",
		"template": "keepachangelog",
		"unreleased": false,
		"commitLimit": false,
		"backfillLimit": false,
		"hideCredit": true
	},
	"testling": {
		"files": "./test/index.js"
	},
	"publishConfig": {
		"ignore": [
			".github/workflows"
		]
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\esbuild\package.json
============================================================
{
  "name": "esbuild",
  "version": "0.18.20",
  "description": "An extremely fast JavaScript and CSS bundler and minifier.",
  "repository": "https://github.com/evanw/esbuild",
  "scripts": {
    "postinstall": "node install.js"
  },
  "main": "lib/main.js",
  "types": "lib/main.d.ts",
  "engines": {
    "node": ">=12"
  },
  "bin": {
    "esbuild": "bin/esbuild"
  },
  "optionalDependencies": {
    "@esbuild/android-arm": "0.18.20",
    "@esbuild/android-arm64": "0.18.20",
    "@esbuild/android-x64": "0.18.20",
    "@esbuild/darwin-arm64": "0.18.20",
    "@esbuild/darwin-x64": "0.18.20",
    "@esbuild/freebsd-arm64": "0.18.20",
    "@esbuild/freebsd-x64": "0.18.20",
    "@esbuild/linux-arm": "0.18.20",
    "@esbuild/linux-arm64": "0.18.20",
    "@esbuild/linux-ia32": "0.18.20",
    "@esbuild/linux-loong64": "0.18.20",
    "@esbuild/linux-mips64el": "0.18.20",
    "@esbuild/linux-ppc64": "0.18.20",
    "@esbuild/linux-riscv64": "0.18.20",
    "@esbuild/linux-s390x": "0.18.20",
    "@esbuild/linux-x64": "0.18.20",
    "@esbuild/netbsd-x64": "0.18.20",
    "@esbuild/openbsd-x64": "0.18.20",
    "@esbuild/sunos-x64": "0.18.20",
    "@esbuild/win32-arm64": "0.18.20",
    "@esbuild/win32-ia32": "0.18.20",
    "@esbuild/win32-x64": "0.18.20"
  },
  "license": "MIT"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\escalade\package.json
============================================================
{
  "name": "escalade",
  "version": "3.2.0",
  "repository": "lukeed/escalade",
  "description": "A tiny (183B to 210B) and fast utility to ascend parent directories",
  "module": "dist/index.mjs",
  "main": "dist/index.js",
  "types": "index.d.ts",
  "license": "MIT",
  "author": {
    "name": "Luke Edwards",
    "email": "luke.edwards05@gmail.com",
    "url": "https://lukeed.com"
  },
  "exports": {
    ".": [
      {
        "import": {
          "types": "./index.d.mts",
          "default": "./dist/index.mjs"
        },
        "require": {
          "types": "./index.d.ts",
          "default": "./dist/index.js"
        }
      },
      "./dist/index.js"
    ],
    "./sync": [
      {
        "import": {
          "types": "./sync/index.d.mts",
          "default": "./sync/index.mjs"
        },
        "require": {
          "types": "./sync/index.d.ts",
          "default": "./sync/index.js"
        }
      },
      "./sync/index.js"
    ]
  },
  "files": [
    "*.d.mts",
    "*.d.ts",
    "dist",
    "sync"
  ],
  "modes": {
    "sync": "src/sync.js",
    "default": "src/async.js"
  },
  "engines": {
    "node": ">=6"
  },
  "scripts": {
    "build": "bundt",
    "pretest": "npm run build",
    "test": "uvu -r esm test -i fixtures"
  },
  "keywords": [
    "find",
    "parent",
    "parents",
    "directory",
    "search",
    "walk"
  ],
  "devDependencies": {
    "bundt": "1.1.1",
    "esm": "3.2.25",
    "uvu": "0.3.3"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\esprima\package.json
============================================================
{
  "name": "esprima",
  "description": "ECMAScript parsing infrastructure for multipurpose analysis",
  "homepage": "http://esprima.org",
  "main": "dist/esprima.js",
  "bin": {
    "esparse": "./bin/esparse.js",
    "esvalidate": "./bin/esvalidate.js"
  },
  "version": "4.0.1",
  "files": [
    "bin",
    "dist/esprima.js"
  ],
  "engines": {
    "node": ">=4"
  },
  "author": {
    "name": "Ariya Hidayat",
    "email": "ariya.hidayat@gmail.com"
  },
  "maintainers": [
    {
      "name": "Ariya Hidayat",
      "email": "ariya.hidayat@gmail.com",
      "web": "http://ariya.ofilabs.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/jquery/esprima.git"
  },
  "bugs": {
    "url": "https://github.com/jquery/esprima/issues"
  },
  "license": "BSD-2-Clause",
  "devDependencies": {
    "codecov.io": "~0.1.6",
    "escomplex-js": "1.2.0",
    "everything.js": "~1.0.3",
    "glob": "~7.1.0",
    "istanbul": "~0.4.0",
    "json-diff": "~0.3.1",
    "karma": "~1.3.0",
    "karma-chrome-launcher": "~2.0.0",
    "karma-detect-browsers": "~2.2.3",
    "karma-edge-launcher": "~0.2.0",
    "karma-firefox-launcher": "~1.0.0",
    "karma-ie-launcher": "~1.0.0",
    "karma-mocha": "~1.3.0",
    "karma-safari-launcher": "~1.0.0",
    "karma-safaritechpreview-launcher": "~0.0.4",
    "karma-sauce-launcher": "~1.1.0",
    "lodash": "~3.10.1",
    "mocha": "~3.2.0",
    "node-tick-processor": "~0.0.2",
    "regenerate": "~1.3.2",
    "temp": "~0.8.3",
    "tslint": "~5.1.0",
    "typescript": "~2.3.2",
    "typescript-formatter": "~5.1.3",
    "unicode-8.0.0": "~0.7.0",
    "webpack": "~1.14.0"
  },
  "keywords": [
    "ast",
    "ecmascript",
    "esprima",
    "javascript",
    "parser",
    "syntax"
  ],
  "scripts": {
    "check-version": "node test/check-version.js",
    "tslint": "tslint src/*.ts",
    "code-style": "tsfmt --verify src/*.ts && tsfmt --verify test/*.js",
    "format-code": "tsfmt -r src/*.ts && tsfmt -r test/*.js",
    "complexity": "node test/check-complexity.js",
    "static-analysis": "npm run check-version && npm run tslint && npm run code-style && npm run complexity",
    "hostile-env-tests": "node test/hostile-environment-tests.js",
    "unit-tests": "node test/unit-tests.js",
    "api-tests": "mocha -R dot test/api-tests.js",
    "grammar-tests": "node test/grammar-tests.js",
    "regression-tests": "node test/regression-tests.js",
    "all-tests": "npm run verify-line-ending && npm run generate-fixtures && npm run unit-tests && npm run api-tests && npm run grammar-tests && npm run regression-tests && npm run hostile-env-tests",
    "verify-line-ending": "node test/verify-line-ending.js",
    "generate-fixtures": "node tools/generate-fixtures.js",
    "browser-tests": "npm run compile && npm run generate-fixtures && cd test && karma start --single-run",
    "saucelabs-evergreen": "cd test && karma start saucelabs-evergreen.conf.js",
    "saucelabs-safari": "cd test && karma start saucelabs-safari.conf.js",
    "saucelabs-ie": "cd test && karma start saucelabs-ie.conf.js",
    "saucelabs": "npm run saucelabs-evergreen && npm run saucelabs-ie && npm run saucelabs-safari",
    "analyze-coverage": "istanbul cover test/unit-tests.js",
    "check-coverage": "istanbul check-coverage --statement 100 --branch 100 --function 100",
    "dynamic-analysis": "npm run analyze-coverage && npm run check-coverage",
    "compile": "tsc -p src/ && webpack && node tools/fixupbundle.js",
    "test": "npm run compile && npm run all-tests && npm run static-analysis && npm run dynamic-analysis",
    "prepublish": "npm run compile",
    "profile": "node --prof test/profile.js && mv isolate*.log v8.log && node-tick-processor",
    "benchmark-parser": "node -expose_gc test/benchmark-parser.js",
    "benchmark-tokenizer": "node --expose_gc test/benchmark-tokenizer.js",
    "benchmark": "npm run benchmark-parser && npm run benchmark-tokenizer",
    "codecov": "istanbul report cobertura && codecov < ./coverage/cobertura-coverage.xml",
    "downstream": "node test/downstream.js",
    "travis": "npm test",
    "circleci": "npm test && npm run codecov && npm run downstream",
    "appveyor": "npm run compile && npm run all-tests && npm run browser-tests",
    "droneio": "npm run compile && npm run all-tests && npm run saucelabs",
    "generate-regex": "node tools/generate-identifier-regex.js",
    "generate-xhtml-entities": "node tools/generate-xhtml-entities.js"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\estree-walker\package.json
============================================================
{
	"name": "estree-walker",
	"description": "Traverse an ESTree-compliant AST",
	"version": "3.0.3",
	"private": false,
	"author": "Rich Harris",
	"license": "MIT",
	"repository": {
		"type": "git",
		"url": "https://github.com/Rich-Harris/estree-walker"
	},
	"type": "module",
	"module": "./src/index.js",
	"exports": {
		"./package.json": "./package.json",
		".": {
			"types": "./types/index.d.ts",
			"import": "./src/index.js"
		}
	},
	"types": "types/index.d.ts",
	"scripts": {
		"prepublishOnly": "tsc && npm test",
		"test": "uvu test"
	},
	"dependencies": {
		"@types/estree": "^1.0.0"
	},
	"devDependencies": {
		"typescript": "^4.9.0",
		"uvu": "^0.5.1"
	},
	"files": [
		"src",
		"types",
		"README.md"
	]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\esutils\package.json
============================================================
{
  "name": "esutils",
  "description": "utility box for ECMAScript language tools",
  "homepage": "https://github.com/estools/esutils",
  "main": "lib/utils.js",
  "version": "2.0.3",
  "engines": {
    "node": ">=0.10.0"
  },
  "directories": {
    "lib": "./lib"
  },
  "files": [
    "LICENSE.BSD",
    "README.md",
    "lib"
  ],
  "maintainers": [
    {
      "name": "Yusuke Suzuki",
      "email": "utatane.tea@gmail.com",
      "web": "http://github.com/Constellation"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/estools/esutils.git"
  },
  "devDependencies": {
    "chai": "~1.7.2",
    "coffee-script": "~1.6.3",
    "jshint": "2.6.3",
    "mocha": "~2.2.1",
    "regenerate": "~1.3.1",
    "unicode-9.0.0": "~0.7.0"
  },
  "license": "BSD-2-Clause",
  "scripts": {
    "test": "npm run-script lint && npm run-script unit-test",
    "lint": "jshint lib/*.js",
    "unit-test": "mocha --compilers coffee:coffee-script -R spec",
    "generate-regex": "node tools/generate-identifier-regex.js"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\execa\node_modules\signal-exit\package.json
============================================================
{
  "name": "signal-exit",
  "version": "3.0.7",
  "description": "when you want to fire an event no matter how a process exits.",
  "main": "index.js",
  "scripts": {
    "test": "tap",
    "snap": "tap",
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags"
  },
  "files": [
    "index.js",
    "signals.js"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/tapjs/signal-exit.git"
  },
  "keywords": [
    "signal",
    "exit"
  ],
  "author": "Ben Coe <ben@npmjs.com>",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/tapjs/signal-exit/issues"
  },
  "homepage": "https://github.com/tapjs/signal-exit",
  "devDependencies": {
    "chai": "^3.5.0",
    "coveralls": "^3.1.1",
    "nyc": "^15.1.0",
    "standard-version": "^9.3.1",
    "tap": "^15.1.1"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\execa\package.json
============================================================
{
	"name": "execa",
	"version": "5.1.1",
	"description": "Process execution for humans",
	"license": "MIT",
	"repository": "sindresorhus/execa",
	"funding": "https://github.com/sindresorhus/execa?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && nyc ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts",
		"lib"
	],
	"keywords": [
		"exec",
		"child",
		"process",
		"execute",
		"fork",
		"execfile",
		"spawn",
		"file",
		"shell",
		"bin",
		"binary",
		"binaries",
		"npm",
		"path",
		"local"
	],
	"dependencies": {
		"cross-spawn": "^7.0.3",
		"get-stream": "^6.0.0",
		"human-signals": "^2.1.0",
		"is-stream": "^2.0.0",
		"merge-stream": "^2.0.0",
		"npm-run-path": "^4.0.1",
		"onetime": "^5.1.2",
		"signal-exit": "^3.0.3",
		"strip-final-newline": "^2.0.0"
	},
	"devDependencies": {
		"@types/node": "^14.14.10",
		"ava": "^2.4.0",
		"get-node": "^11.0.1",
		"is-running": "^2.1.0",
		"nyc": "^15.1.0",
		"p-event": "^4.2.0",
		"tempfile": "^3.0.0",
		"tsd": "^0.13.1",
		"xo": "^0.35.0"
	},
	"nyc": {
		"reporter": [
			"text",
			"lcov"
		],
		"exclude": [
			"**/fixtures/**",
			"**/test.js",
			"**/test/**"
		]
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\exit-x\package.json
============================================================
{
  "name": "exit-x",
  "description": "A replacement for process.exit that ensures stdio are fully drained before exiting.",
  "version": "0.2.2",
  "homepage": "https://github.com/gruntjs/node-exit-x",
  "author": "Grunt Development Team (https://gruntjs.com/development-team)",
  "repository": {
    "type": "git",
    "url": "git://github.com/gruntjs/node-exit-x.git"
  },
  "bugs": {
    "url": "https://github.com/gruntjs/node-exit-x/issues"
  },
  "license": "MIT",
  "main": "lib/exit.js",
  "types": "lib/exit.d.ts",
  "engines": {
    "node": ">= 0.8.0"
  },
  "scripts": {
    "test": "grunt nodeunit"
  },
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-cli": "^1.5.0",
    "grunt-contrib-jshint": "~0.6.4",
    "grunt-contrib-nodeunit": "~0.2.0",
    "grunt-contrib-watch": "~0.5.3",
    "which": "~1.0.5"
  },
  "keywords": [
    "exit",
    "process",
    "stdio",
    "stdout",
    "stderr",
    "drain",
    "flush",
    "3584"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\expect\package.json
============================================================
{
  "name": "expect",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/expect"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json",
    "./build/matchers": "./build/matchers.js",
    "./build/toThrowMatchers": "./build/toThrowMatchers.js"
  },
  "dependencies": {
    "@jest/expect-utils": "30.2.0",
    "@jest/get-type": "30.1.0",
    "jest-matcher-utils": "30.2.0",
    "jest-message-util": "30.2.0",
    "jest-mock": "30.2.0",
    "jest-util": "30.2.0"
  },
  "devDependencies": {
    "@fast-check/jest": "^2.1.1",
    "@jest/test-utils": "30.2.0",
    "chalk": "^4.1.2",
    "immutable": "^5.1.2"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\expect-type\package.json
============================================================
{
  "name": "expect-type",
  "version": "1.2.2",
  "engines": {
    "node": ">=12.0.0"
  },
  "keywords": [
    "typescript",
    "type-check",
    "assert",
    "types",
    "typings",
    "test",
    "testing"
  ],
  "homepage": "https://github.com/mmkal/expect-type#readme",
  "repository": {
    "type": "git",
    "url": "https://github.com/mmkal/expect-type.git"
  },
  "license": "Apache-2.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist",
    "*.md"
  ],
  "devDependencies": {
    "@arethetypeswrong/cli": "0.17.3",
    "@types/node": "^22.0.0",
    "@typescript/native-preview": "7.0.0-dev.20250527.1",
    "@vitest/ui": "^3.0.0",
    "eslint": "^8.57.0",
    "eslint-plugin-mmkal": "0.9.0",
    "np": "^10.2.0",
    "pkg-pr-new": "0.0.39",
    "strip-ansi": "7.1.0",
    "ts-morph": "23.0.0",
    "typescript": "5.8.3",
    "vitest": "^3.0.0"
  },
  "scripts": {
    "eslint": "eslint --max-warnings 0",
    "lint": "tsc && pnpm eslint .",
    "type-check": "tsc",
    "build": "tsc -p tsconfig.lib.json",
    "arethetypeswrong": "attw --pack",
    "test": "vitest run"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\fast-json-stable-stringify\package.json
============================================================
{
  "name": "fast-json-stable-stringify",
  "version": "2.1.0",
  "description": "deterministic `JSON.stringify()` - a faster version of substack's json-stable-strigify without jsonify",
  "main": "index.js",
  "types": "index.d.ts",
  "dependencies": {},
  "devDependencies": {
    "benchmark": "^2.1.4",
    "coveralls": "^3.0.0",
    "eslint": "^6.7.0",
    "fast-stable-stringify": "latest",
    "faster-stable-stringify": "latest",
    "json-stable-stringify": "latest",
    "nyc": "^14.1.0",
    "pre-commit": "^1.2.2",
    "tape": "^4.11.0"
  },
  "scripts": {
    "eslint": "eslint index.js test",
    "test-spec": "tape test/*.js",
    "test": "npm run eslint && nyc npm run test-spec"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/epoberezkin/fast-json-stable-stringify.git"
  },
  "homepage": "https://github.com/epoberezkin/fast-json-stable-stringify",
  "keywords": [
    "json",
    "stringify",
    "deterministic",
    "hash",
    "stable"
  ],
  "author": {
    "name": "James Halliday",
    "email": "mail@substack.net",
    "url": "http://substack.net"
  },
  "license": "MIT",
  "nyc": {
    "exclude": [
      "test",
      "node_modules"
    ],
    "reporter": [
      "lcov",
      "text-summary"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\fb-watchman\package.json
============================================================
{
  "name": "fb-watchman",
  "version": "2.0.2",
  "description": "Bindings for the Watchman file watching service",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "git@github.com:facebook/watchman.git"
  },
  "keywords": [
    "facebook",
    "watchman",
    "file",
    "watch",
    "watcher",
    "watching",
    "fs.watch",
    "fswatcher",
    "fs",
    "glob",
    "utility"
  ],
  "author": "Wez Furlong <wez@fb.com> (http://wezfurlong.org)",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/facebook/watchman/issues"
  },
  "homepage": "https://facebook.github.io/watchman/",
  "files": [
    "index.js"
  ],
  "dependencies": {
    "bser": "2.1.1"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\fflate\package.json
============================================================
{
  "name": "fflate",
  "version": "0.8.2",
  "description": "High performance (de)compression in an 8kB package",
  "main": "./lib/index.cjs",
  "module": "./esm/browser.js",
  "types": "./lib/index.d.ts",
  "unpkg": "./umd/index.js",
  "jsdelivr": "./umd/index.js",
  "browser": {
    "./lib/node-worker.cjs": "./lib/worker.cjs"
  },
  "exports": {
    ".": {
      "node": {
        "import": {
          "types": "./esm/index.d.mts",
          "default": "./esm/index.mjs"
        },
        "require": {
          "types": "./lib/node.d.cts",
          "default": "./lib/node.cjs"
        }
      },
      "import": {
        "types": "./esm/browser.d.ts",
        "default": "./esm/browser.js"
      },
      "require": {
        "types": "./lib/browser.d.cts",
        "default": "./lib/browser.cjs"
      }
    },
    "./node": {
      "import": {
        "types": "./esm/index.d.mts",
        "default": "./esm/index.mjs"
      },
      "require": {
        "types": "./lib/node.d.cts",
        "default": "./lib/node.cjs"
      }
    },
    "./browser": {
      "import": {
        "types": "./esm/browser.d.ts",
        "default": "./esm/browser.js"
      },
      "require": {
        "types": "./lib/browser.d.cts",
        "default": "./lib/browser.cjs"
      }
    }
  },
  "targets": {
    "main": false,
    "module": false,
    "browser": false,
    "types": false
  },
  "sideEffects": false,
  "homepage": "https://101arrowz.github.io/fflate",
  "repository": "https://github.com/101arrowz/fflate",
  "bugs": {
    "email": "arjunbarrett@gmail.com",
    "url": "https://github.com/101arrowz/fflate/issues"
  },
  "author": "Arjun Barrett <arjunbarrett@gmail.com>",
  "license": "MIT",
  "keywords": [
    "gzip",
    "gunzip",
    "deflate",
    "inflate",
    "compression",
    "decompression",
    "zlib",
    "pako",
    "jszip",
    "browser",
    "node.js",
    "tiny",
    "fast",
    "zip",
    "unzip",
    "non-blocking"
  ],
  "scripts": {
    "build": "npm run build:lib && npm run build:docs && npm run build:demo",
    "script": "node -r ts-node/register scripts/$SC.ts",
    "build:lib": "tsc && tsc --project tsconfig.esm.json && npm run build:rewrite && npm run build:umd",
    "build:umd": "SC=buildUMD npm run script",
    "build:rewrite": "SC=rewriteBuilds npm run script",
    "build:demo": "tsc --project tsconfig.demo.json && parcel build demo/index.html --no-cache --public-url \"./\" && SC=cpGHPages npm run script",
    "build:docs": "typedoc --plugin typedoc-plugin-markdown --hideBreadcrumbs --readme none --disableSources --excludePrivate --excludeProtected --githubPages false --out docs/ src/index.ts",
    "test": "TS_NODE_PROJECT=test/tsconfig.json uvu -b -r ts-node/register test",
    "prepack": "npm run build && npm run test"
  },
  "devDependencies": {
    "@parcel/service-worker": "^2.9.3",
    "@types/node": "^14.11.2",
    "@types/pako": "*",
    "@types/react": "^18.2.21",
    "@types/react-dom": "^18.2.7",
    "jszip": "^3.5.0",
    "pako": "*",
    "parcel": "^2.9.3",
    "preact": "^10.17.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "simple-git": "^3.19.1",
    "terser": "^5.3.8",
    "tiny-inflate": "*",
    "ts-node": "^10.9.1",
    "typedoc": "^0.25.0",
    "typedoc-plugin-markdown": "^3.16.0",
    "typescript": "^5.2.2",
    "uvu": "^0.3.3",
    "uzip": "*"
  },
  "alias": {
    "react": "preact/compat",
    "react-dom": "preact/compat",
    "buffer": false,
    "process": false
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\fill-range\package.json
============================================================
{
  "name": "fill-range",
  "description": "Fill in a range of numbers or letters, optionally passing an increment or `step` to use, or create a regex-compatible range with `options.toRegex`",
  "version": "7.1.1",
  "homepage": "https://github.com/jonschlinkert/fill-range",
  "author": "Jon Schlinkert (https://github.com/jonschlinkert)",
  "contributors": [
    "Edo Rivai (edo.rivai.nl)",
    "Jon Schlinkert (http://twitter.com/jonschlinkert)",
    "Paul Miller (paulmillr.com)",
    "Rouven Weßling (www.rouvenwessling.de)",
    "(https://github.com/wtgtybhertgeghgtwtg)"
  ],
  "repository": "jonschlinkert/fill-range",
  "bugs": {
    "url": "https://github.com/jonschlinkert/fill-range/issues"
  },
  "license": "MIT",
  "files": [
    "index.js"
  ],
  "main": "index.js",
  "engines": {
    "node": ">=8"
  },
  "scripts": {
    "lint": "eslint --cache --cache-location node_modules/.cache/.eslintcache --report-unused-disable-directives --ignore-path .gitignore .",
    "mocha": "mocha --reporter dot",
    "test": "npm run lint && npm run mocha",
    "test:ci": "npm run test:cover",
    "test:cover": "nyc npm run mocha"
  },
  "dependencies": {
    "to-regex-range": "^5.0.1"
  },
  "devDependencies": {
    "gulp-format-md": "^2.0.0",
    "mocha": "^6.1.1",
    "nyc": "^15.1.0"
  },
  "keywords": [
    "alpha",
    "alphabetical",
    "array",
    "bash",
    "brace",
    "expand",
    "expansion",
    "fill",
    "glob",
    "match",
    "matches",
    "matching",
    "number",
    "numerical",
    "range",
    "ranges",
    "regex",
    "sh"
  ],
  "verb": {
    "toc": false,
    "layout": "default",
    "tasks": [
      "readme"
    ],
    "plugins": [
      "gulp-format-md"
    ],
    "lint": {
      "reflinks": true
    }
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\flatted\cjs\package.json
============================================================
{"type":"commonjs"}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\flatted\package.json
============================================================
{
  "name": "flatted",
  "version": "3.3.3",
  "description": "A super light and fast circular JSON parser.",
  "unpkg": "min.js",
  "main": "./cjs/index.js",
  "scripts": {
    "build": "npm run cjs && npm run rollup:esm && npm run rollup:es && npm run rollup:babel && npm run min && npm run test && npm run size",
    "cjs": "ascjs esm cjs",
    "rollup:es": "rollup --config rollup/es.config.js && sed -i.bck 's/^var /self./' es.js && rm -rf es.js.bck",
    "rollup:esm": "rollup --config rollup/esm.config.js",
    "rollup:babel": "rollup --config rollup/babel.config.js && sed -i.bck 's/^var /self./' index.js && rm -rf index.js.bck",
    "min": "terser index.js -c -m -o min.js",
    "size": "cat index.js | wc -c;cat min.js | wc -c;gzip -c9 min.js | wc -c;cat min.js | brotli | wc -c; cat es.js | brotli | wc -c; cat esm.js | brotli | wc -c",
    "test": "c8 node test/index.js",
    "test:php": "php php/test.php",
    "test:py": "python python/test.py",
    "ts": "tsc -p .",
    "coverage": "mkdir -p ./coverage; c8 report --reporter=text-lcov > ./coverage/lcov.info"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/WebReflection/flatted.git"
  },
  "files": [
    "LICENSE",
    "README.md",
    "cjs/",
    "es.js",
    "esm.js",
    "esm/",
    "index.js",
    "min.js",
    "php/flatted.php",
    "python/flatted.py",
    "types/"
  ],
  "keywords": [
    "circular",
    "JSON",
    "fast",
    "parser",
    "minimal"
  ],
  "author": "Andrea Giammarchi",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/WebReflection/flatted/issues"
  },
  "homepage": "https://github.com/WebReflection/flatted#readme",
  "devDependencies": {
    "@babel/core": "^7.26.9",
    "@babel/preset-env": "^7.26.9",
    "@rollup/plugin-babel": "^6.0.4",
    "@rollup/plugin-terser": "^0.4.4",
    "@ungap/structured-clone": "^1.3.0",
    "ascjs": "^6.0.3",
    "c8": "^10.1.3",
    "circular-json": "^0.5.9",
    "circular-json-es6": "^2.0.2",
    "jsan": "^3.1.14",
    "rollup": "^4.34.8",
    "terser": "^5.39.0",
    "typescript": "^5.7.3"
  },
  "module": "./esm/index.js",
  "type": "module",
  "exports": {
    ".": {
      "types": "./types/index.d.ts",
      "import": "./esm/index.js",
      "default": "./cjs/index.js"
    },
    "./esm": "./esm.js",
    "./package.json": "./package.json"
  },
  "types": "./types/index.d.ts"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\follow-redirects\package.json
============================================================
{
  "name": "follow-redirects",
  "version": "1.15.11",
  "description": "HTTP and HTTPS modules that follow redirects.",
  "license": "MIT",
  "main": "index.js",
  "files": [
    "*.js"
  ],
  "engines": {
    "node": ">=4.0"
  },
  "scripts": {
    "lint": "eslint *.js test",
    "test": "nyc mocha"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/follow-redirects/follow-redirects.git"
  },
  "homepage": "https://github.com/follow-redirects/follow-redirects",
  "bugs": {
    "url": "https://github.com/follow-redirects/follow-redirects/issues"
  },
  "keywords": [
    "http",
    "https",
    "url",
    "redirect",
    "client",
    "location",
    "utility"
  ],
  "author": "Ruben Verborgh <ruben@verborgh.org> (https://ruben.verborgh.org/)",
  "contributors": [
    "Olivier Lalonde <olalonde@gmail.com> (http://www.syskall.com)",
    "James Talmage <james@talmage.io>"
  ],
  "funding": [
    {
      "type": "individual",
      "url": "https://github.com/sponsors/RubenVerborgh"
    }
  ],
  "peerDependenciesMeta": {
    "debug": {
      "optional": true
    }
  },
  "devDependencies": {
    "concat-stream": "^2.0.0",
    "eslint": "^5.16.0",
    "express": "^4.16.4",
    "lolex": "^3.1.0",
    "mocha": "^6.0.2",
    "nyc": "^14.1.1"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\foreground-child\dist\commonjs\package.json
============================================================
{
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\foreground-child\dist\esm\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\foreground-child\package.json
============================================================
{
  "name": "foreground-child",
  "version": "3.3.1",
  "description": "Run a child as if it's the foreground process. Give it stdio. Exit when it exits.",
  "main": "./dist/commonjs/index.js",
  "types": "./dist/commonjs/index.d.ts",
  "exports": {
    "./watchdog": {
      "import": {
        "types": "./dist/esm/watchdog.d.ts",
        "default": "./dist/esm/watchdog.js"
      },
      "require": {
        "types": "./dist/commonjs/watchdog.d.ts",
        "default": "./dist/commonjs/watchdog.js"
      }
    },
    "./proxy-signals": {
      "import": {
        "types": "./dist/esm/proxy-signals.d.ts",
        "default": "./dist/esm/proxy-signals.js"
      },
      "require": {
        "types": "./dist/commonjs/proxy-signals.d.ts",
        "default": "./dist/commonjs/proxy-signals.js"
      }
    },
    "./package.json": "./package.json",
    ".": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.js"
      }
    }
  },
  "files": [
    "dist"
  ],
  "engines": {
    "node": ">=14"
  },
  "dependencies": {
    "cross-spawn": "^7.0.6",
    "signal-exit": "^4.0.1"
  },
  "scripts": {
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags",
    "prepare": "tshy",
    "pretest": "npm run prepare",
    "presnap": "npm run prepare",
    "test": "tap",
    "snap": "tap",
    "format": "prettier --write . --log-level warn",
    "typedoc": "typedoc --tsconfig .tshy/esm.json ./src/*.ts"
  },
  "prettier": {
    "experimentalTernaries": true,
    "semi": false,
    "printWidth": 75,
    "tabWidth": 2,
    "useTabs": false,
    "singleQuote": true,
    "jsxSingleQuote": false,
    "bracketSameLine": true,
    "arrowParens": "avoid",
    "endOfLine": "lf"
  },
  "tap": {
    "typecheck": true
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/tapjs/foreground-child.git"
  },
  "author": "Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)",
  "license": "ISC",
  "devDependencies": {
    "@types/cross-spawn": "^6.0.2",
    "@types/node": "^18.15.11",
    "@types/tap": "^15.0.8",
    "prettier": "^3.3.2",
    "tap": "^21.1.0",
    "tshy": "^3.0.2",
    "typedoc": "^0.24.2",
    "typescript": "^5.0.2"
  },
  "funding": {
    "url": "https://github.com/sponsors/isaacs"
  },
  "tshy": {
    "exports": {
      "./watchdog": "./src/watchdog.ts",
      "./proxy-signals": "./src/proxy-signals.ts",
      "./package.json": "./package.json",
      ".": "./src/index.ts"
    }
  },
  "type": "module",
  "module": "./dist/esm/index.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\form-data\package.json
============================================================
{
  "author": "Felix Geisendörfer <felix@debuggable.com> (http://debuggable.com/)",
  "name": "form-data",
  "description": "A library to create readable \"multipart/form-data\" streams. Can be used to submit forms and file uploads to other web applications.",
  "version": "4.0.4",
  "repository": {
    "type": "git",
    "url": "git://github.com/form-data/form-data.git"
  },
  "main": "./lib/form_data",
  "browser": "./lib/browser",
  "typings": "./index.d.ts",
  "scripts": {
    "pretest": "npm run lint",
    "pretests-only": "rimraf coverage test/tmp",
    "tests-only": "istanbul cover test/run.js",
    "posttests-only": "istanbul report lcov text",
    "test": "npm run tests-only",
    "posttest": "npx npm@'>=10.2' audit --production",
    "lint": "eslint --ext=js,mjs .",
    "report": "istanbul report lcov text",
    "ci-lint": "is-node-modern 8 && npm run lint || is-node-not-modern 8",
    "ci-test": "npm run tests-only && npm run browser && npm run report",
    "predebug": "rimraf coverage test/tmp",
    "debug": "verbose=1 ./test/run.js",
    "browser": "browserify -t browserify-istanbul test/run-browser.js | obake --coverage",
    "check": "istanbul check-coverage coverage/coverage*.json",
    "files": "pkgfiles --sort=name",
    "get-version": "node -e \"console.log(require('./package.json').version)\"",
    "update-readme": "sed -i.bak 's/\\/master\\.svg/\\/v'$(npm --silent run get-version)'.svg/g' README.md",
    "postupdate-readme": "mv README.md.bak READ.ME.md.bak",
    "restore-readme": "mv READ.ME.md.bak README.md",
    "prepublish": "not-in-publish || npm run prepublishOnly",
    "prepack": "npm run update-readme",
    "postpack": "npm run restore-readme",
    "version": "auto-changelog && git add CHANGELOG.md",
    "postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
  },
  "engines": {
    "node": ">= 6"
  },
  "dependencies": {
    "asynckit": "^0.4.0",
    "combined-stream": "^1.0.8",
    "es-set-tostringtag": "^2.1.0",
    "hasown": "^2.0.2",
    "mime-types": "^2.1.12"
  },
  "devDependencies": {
    "@ljharb/eslint-config": "^21.2.0",
    "auto-changelog": "^2.5.0",
    "browserify": "^13.3.0",
    "browserify-istanbul": "^2.0.0",
    "coveralls": "^3.1.1",
    "cross-spawn": "^6.0.6",
    "eslint": "=8.8.0",
    "fake": "^0.2.2",
    "far": "^0.0.7",
    "formidable": "^1.2.6",
    "in-publish": "^2.0.1",
    "is-node-modern": "^1.0.0",
    "istanbul": "^0.4.5",
    "obake": "^0.1.2",
    "pkgfiles": "^2.3.2",
    "pre-commit": "^1.2.2",
    "predict-v8-randomness": "^1.0.35",
    "puppeteer": "^1.20.0",
    "request": "~2.87.0",
    "rimraf": "^2.7.1",
    "semver": "^6.3.1",
    "tape": "^5.9.0"
  },
  "license": "MIT",
  "auto-changelog": {
    "output": "CHANGELOG.md",
    "template": "keepachangelog",
    "unreleased": false,
    "commitLimit": false,
    "backfillLimit": false,
    "hideCredit": true
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\fs.realpath\package.json
============================================================
{
  "name": "fs.realpath",
  "version": "1.0.0",
  "description": "Use node's fs.realpath, but fall back to the JS implementation if the native one fails",
  "main": "index.js",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "test": "tap test/*.js --cov"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/isaacs/fs.realpath.git"
  },
  "keywords": [
    "realpath",
    "fs",
    "polyfill"
  ],
  "author": "Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)",
  "license": "ISC",
  "files": [
    "old.js",
    "index.js"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\function-bind\package.json
============================================================
{
  "name": "function-bind",
  "version": "1.1.2",
  "description": "Implementation of Function.prototype.bind",
  "keywords": [
    "function",
    "bind",
    "shim",
    "es5"
  ],
  "author": "Raynos <raynos2@gmail.com>",
  "repository": {
    "type": "git",
    "url": "https://github.com/Raynos/function-bind.git"
  },
  "funding": {
    "url": "https://github.com/sponsors/ljharb"
  },
  "main": "index",
  "homepage": "https://github.com/Raynos/function-bind",
  "contributors": [
    {
      "name": "Raynos"
    },
    {
      "name": "Jordan Harband",
      "url": "https://github.com/ljharb"
    }
  ],
  "bugs": {
    "url": "https://github.com/Raynos/function-bind/issues",
    "email": "raynos2@gmail.com"
  },
  "devDependencies": {
    "@ljharb/eslint-config": "^21.1.0",
    "aud": "^2.0.3",
    "auto-changelog": "^2.4.0",
    "eslint": "=8.8.0",
    "in-publish": "^2.0.1",
    "npmignore": "^0.3.0",
    "nyc": "^10.3.2",
    "safe-publish-latest": "^2.0.0",
    "tape": "^5.7.1"
  },
  "license": "MIT",
  "scripts": {
    "prepublishOnly": "safe-publish-latest",
    "prepublish": "not-in-publish || npm run prepublishOnly",
    "prepack": "npmignore --auto --commentLines=autogenerated",
    "pretest": "npm run lint",
    "test": "npm run tests-only",
    "posttest": "aud --production",
    "tests-only": "nyc tape 'test/**/*.js'",
    "lint": "eslint --ext=js,mjs .",
    "version": "auto-changelog && git add CHANGELOG.md",
    "postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
  },
  "testling": {
    "files": "test/index.js",
    "browsers": [
      "ie/8..latest",
      "firefox/16..latest",
      "firefox/nightly",
      "chrome/22..latest",
      "chrome/canary",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  },
  "auto-changelog": {
    "output": "CHANGELOG.md",
    "template": "keepachangelog",
    "unreleased": false,
    "commitLimit": false,
    "backfillLimit": false,
    "hideCredit": true
  },
  "publishConfig": {
    "ignore": [
      ".github/workflows"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\gensync\package.json
============================================================
{
  "name": "gensync",
  "version": "1.0.0-beta.2",
  "license": "MIT",
  "description": "Allows users to use generators in order to write common functions that can be both sync or async.",
  "main": "index.js",
  "author": "Logan Smyth <loganfsmyth@gmail.com>",
  "homepage": "https://github.com/loganfsmyth/gensync",
  "repository": {
    "type": "git",
    "url": "https://github.com/loganfsmyth/gensync.git"
  },
  "scripts": {
    "test": "jest"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "keywords": [
    "async",
    "sync",
    "generators",
    "async-await",
    "callbacks"
  ],
  "devDependencies": {
    "babel-core": "^6.26.3",
    "babel-preset-env": "^1.6.1",
    "eslint": "^4.19.1",
    "eslint-config-prettier": "^2.9.0",
    "eslint-plugin-node": "^6.0.1",
    "eslint-plugin-prettier": "^2.6.0",
    "flow-bin": "^0.71.0",
    "jest": "^22.4.3",
    "prettier": "^1.12.1"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\get-caller-file\package.json
============================================================
{
  "name": "get-caller-file",
  "version": "2.0.5",
  "description": "",
  "main": "index.js",
  "directories": {
    "test": "tests"
  },
  "files": [
    "index.js",
    "index.js.map",
    "index.d.ts"
  ],
  "scripts": {
    "prepare": "tsc",
    "test": "mocha test",
    "test:debug": "mocha test"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/stefanpenner/get-caller-file.git"
  },
  "author": "Stefan Penner",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/stefanpenner/get-caller-file/issues"
  },
  "homepage": "https://github.com/stefanpenner/get-caller-file#readme",
  "devDependencies": {
    "@types/chai": "^4.1.7",
    "@types/ensure-posix-path": "^1.0.0",
    "@types/mocha": "^5.2.6",
    "@types/node": "^11.10.5",
    "chai": "^4.1.2",
    "ensure-posix-path": "^1.0.1",
    "mocha": "^5.2.0",
    "typescript": "^3.3.3333"
  },
  "engines": {
    "node": "6.* || 8.* || >= 10.*"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\get-intrinsic\package.json
============================================================
{
	"name": "get-intrinsic",
	"version": "1.3.0",
	"description": "Get and robustly cache all JS language-level intrinsics at first require time",
	"main": "index.js",
	"exports": {
		".": "./index.js",
		"./package.json": "./package.json"
	},
	"sideEffects": false,
	"scripts": {
		"prepack": "npmignore --auto --commentLines=autogenerated",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"prepublishOnly": "safe-publish-latest",
		"prelint": "evalmd README.md",
		"lint": "eslint --ext=.js,.mjs .",
		"pretest": "npm run lint",
		"tests-only": "nyc tape 'test/**/*.js'",
		"test": "npm run tests-only",
		"posttest": "npx npm@'>= 10.2' audit --production",
		"version": "auto-changelog && git add CHANGELOG.md",
		"postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
	},
	"repository": {
		"type": "git",
		"url": "git+https://github.com/ljharb/get-intrinsic.git"
	},
	"keywords": [
		"javascript",
		"ecmascript",
		"es",
		"js",
		"intrinsic",
		"getintrinsic",
		"es-abstract"
	],
	"author": "Jordan Harband <ljharb@gmail.com>",
	"funding": {
		"url": "https://github.com/sponsors/ljharb"
	},
	"license": "MIT",
	"bugs": {
		"url": "https://github.com/ljharb/get-intrinsic/issues"
	},
	"homepage": "https://github.com/ljharb/get-intrinsic#readme",
	"dependencies": {
		"call-bind-apply-helpers": "^1.0.2",
		"es-define-property": "^1.0.1",
		"es-errors": "^1.3.0",
		"es-object-atoms": "^1.1.1",
		"function-bind": "^1.1.2",
		"get-proto": "^1.0.1",
		"gopd": "^1.2.0",
		"has-symbols": "^1.1.0",
		"hasown": "^2.0.2",
		"math-intrinsics": "^1.1.0"
	},
	"devDependencies": {
		"@ljharb/eslint-config": "^21.1.1",
		"auto-changelog": "^2.5.0",
		"call-bound": "^1.0.3",
		"encoding": "^0.1.13",
		"es-abstract": "^1.23.9",
		"es-value-fixtures": "^1.7.1",
		"eslint": "=8.8.0",
		"evalmd": "^0.0.19",
		"for-each": "^0.3.5",
		"make-async-function": "^1.0.0",
		"make-async-generator-function": "^1.0.0",
		"make-generator-function": "^2.0.0",
		"mock-property": "^1.1.0",
		"npmignore": "^0.3.1",
		"nyc": "^10.3.2",
		"object-inspect": "^1.13.4",
		"safe-publish-latest": "^2.0.0",
		"tape": "^5.9.0"
	},
	"auto-changelog": {
		"output": "CHANGELOG.md",
		"template": "keepachangelog",
		"unreleased": false,
		"commitLimit": false,
		"backfillLimit": false,
		"hideCredit": true
	},
	"testling": {
		"files": "test/GetIntrinsic.js"
	},
	"publishConfig": {
		"ignore": [
			".github/workflows"
		]
	},
	"engines": {
		"node": ">= 0.4"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\get-package-type\package.json
============================================================
{
	"name": "get-package-type",
	"version": "0.1.0",
	"description": "Determine the `package.json#type` which applies to a location",
	"type": "module",
	"main": "index.cjs",
	"exports": "./index.cjs",
	"scripts": {
		"pretest": "if-ver -ge 10 || exit 0; cfware-lint .",
		"tests-only": "nyc -s node test.cjs",
		"test": "npm run -s tests-only",
		"posttest": "nyc report --check-coverage"
	},
	"engines": {
		"node": ">=8.0.0"
	},
	"author": "Corey Farrell",
	"license": "MIT",
	"repository": {
		"type": "git",
		"url": "git+https://github.com/cfware/get-package-type.git"
	},
	"bugs": {
		"url": "https://github.com/cfware/get-package-type/issues"
	},
	"homepage": "https://github.com/cfware/get-package-type#readme",
	"dependencies": {},
	"devDependencies": {
		"@cfware/lint": "^1.4.3",
		"@cfware/nyc": "^0.7.0",
		"if-ver": "^1.1.0",
		"libtap": "^0.3.0",
		"nyc": "^15.0.1"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\get-proto\package.json
============================================================
{
	"name": "get-proto",
	"version": "1.0.1",
	"description": "Robustly get the [[Prototype]] of an object",
	"main": "index.js",
	"exports": {
		".": "./index.js",
		"./Reflect.getPrototypeOf": "./Reflect.getPrototypeOf.js",
		"./Object.getPrototypeOf": "./Object.getPrototypeOf.js",
		"./package.json": "./package.json"
	},
	"scripts": {
		"prepack": "npmignore --auto --commentLines=autogenerated",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"prepublishOnly": "safe-publish-latest",
		"pretest": "npm run --silent lint",
		"test": "npm run tests-only",
		"posttest": "npx npm@\">=10.2\" audit --production",
		"tests-only": "nyc tape 'test/**/*.js'",
		"prelint": "evalmd README.md",
		"lint": "eslint --ext=js,mjs .",
		"postlint": "tsc && attw -P",
		"version": "auto-changelog && git add CHANGELOG.md",
		"postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
	},
	"repository": {
		"type": "git",
		"url": "git+https://github.com/ljharb/get-proto.git"
	},
	"keywords": [
		"get",
		"proto",
		"prototype",
		"getPrototypeOf",
		"[[Prototype]]"
	],
	"author": "Jordan Harband <ljharb@gmail.com>",
	"license": "MIT",
	"bugs": {
		"url": "https://github.com/ljharb/get-proto/issues"
	},
	"homepage": "https://github.com/ljharb/get-proto#readme",
	"dependencies": {
		"dunder-proto": "^1.0.1",
		"es-object-atoms": "^1.0.0"
	},
	"devDependencies": {
		"@arethetypeswrong/cli": "^0.17.2",
		"@ljharb/eslint-config": "^21.1.1",
		"@ljharb/tsconfig": "^0.2.3",
		"@types/tape": "^5.8.0",
		"auto-changelog": "^2.5.0",
		"eslint": "=8.8.0",
		"evalmd": "^0.0.19",
		"in-publish": "^2.0.1",
		"npmignore": "^0.3.1",
		"nyc": "^10.3.2",
		"safe-publish-latest": "^2.0.0",
		"tape": "^5.9.0",
		"typescript": "next"
	},
	"engines": {
		"node": ">= 0.4"
	},
	"auto-changelog": {
		"output": "CHANGELOG.md",
		"template": "keepachangelog",
		"unreleased": false,
		"commitLimit": false,
		"backfillLimit": false,
		"hideCredit": true
	},
	"publishConfig": {
		"ignore": [
			".github/workflows"
		]
	},
	"testling": {
		"files": "test/index.js"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\get-stream\package.json
============================================================
{
	"name": "get-stream",
	"version": "6.0.1",
	"description": "Get a stream as a string, buffer, or array",
	"license": "MIT",
	"repository": "sindresorhus/get-stream",
	"funding": "https://github.com/sponsors/sindresorhus",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts",
		"buffer-stream.js"
	],
	"keywords": [
		"get",
		"stream",
		"promise",
		"concat",
		"string",
		"text",
		"buffer",
		"read",
		"data",
		"consume",
		"readable",
		"readablestream",
		"array",
		"object"
	],
	"devDependencies": {
		"@types/node": "^14.0.27",
		"ava": "^2.4.0",
		"into-stream": "^5.0.0",
		"tsd": "^0.13.1",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\glob\dist\commonjs\package.json
============================================================
{
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\glob\dist\esm\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\glob\node_modules\brace-expansion\package.json
============================================================
{
  "name": "brace-expansion",
  "description": "Brace expansion as known from sh/bash",
  "version": "2.0.2",
  "repository": {
    "type": "git",
    "url": "git://github.com/juliangruber/brace-expansion.git"
  },
  "homepage": "https://github.com/juliangruber/brace-expansion",
  "main": "index.js",
  "scripts": {
    "test": "tape test/*.js",
    "gentest": "bash test/generate.sh",
    "bench": "matcha test/perf/bench.js"
  },
  "dependencies": {
    "balanced-match": "^1.0.0"
  },
  "devDependencies": {
    "@c4312/matcha": "^1.3.1",
    "tape": "^4.6.0"
  },
  "keywords": [],
  "author": {
    "name": "Julian Gruber",
    "email": "mail@juliangruber.com",
    "url": "http://juliangruber.com"
  },
  "license": "MIT",
  "testling": {
    "files": "test/*.js",
    "browsers": [
      "ie/8..latest",
      "firefox/20..latest",
      "firefox/nightly",
      "chrome/25..latest",
      "chrome/canary",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  },
  "publishConfig": {
    "tag": "2.x"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\glob\node_modules\minimatch\dist\commonjs\package.json
============================================================
{
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\glob\node_modules\minimatch\dist\esm\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\glob\node_modules\minimatch\package.json
============================================================
{
  "author": "Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me)",
  "name": "minimatch",
  "description": "a glob matcher in javascript",
  "version": "9.0.5",
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/minimatch.git"
  },
  "main": "./dist/commonjs/index.js",
  "types": "./dist/commonjs/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.js"
      }
    }
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags",
    "prepare": "tshy",
    "pretest": "npm run prepare",
    "presnap": "npm run prepare",
    "test": "tap",
    "snap": "tap",
    "format": "prettier --write . --loglevel warn",
    "benchmark": "node benchmark/index.js",
    "typedoc": "typedoc --tsconfig tsconfig-esm.json ./src/*.ts"
  },
  "prettier": {
    "semi": false,
    "printWidth": 80,
    "tabWidth": 2,
    "useTabs": false,
    "singleQuote": true,
    "jsxSingleQuote": false,
    "bracketSameLine": true,
    "arrowParens": "avoid",
    "endOfLine": "lf"
  },
  "engines": {
    "node": ">=16 || 14 >=14.17"
  },
  "dependencies": {
    "brace-expansion": "^2.0.1"
  },
  "devDependencies": {
    "@types/brace-expansion": "^1.1.0",
    "@types/node": "^18.15.11",
    "@types/tap": "^15.0.8",
    "eslint-config-prettier": "^8.6.0",
    "mkdirp": "1",
    "prettier": "^2.8.2",
    "tap": "^18.7.2",
    "ts-node": "^10.9.1",
    "tshy": "^1.12.0",
    "typedoc": "^0.23.21",
    "typescript": "^4.9.3"
  },
  "funding": {
    "url": "https://github.com/sponsors/isaacs"
  },
  "license": "ISC",
  "tshy": {
    "exports": {
      "./package.json": "./package.json",
      ".": "./src/index.ts"
    }
  },
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\glob\package.json
============================================================
{
  "author": "Isaac Z. Schlueter <i@izs.me> (https://blog.izs.me/)",
  "publishConfig": {
    "tag": "legacy-v10"
  },
  "name": "glob",
  "description": "the most correct and second fastest glob implementation in JavaScript",
  "version": "10.4.5",
  "type": "module",
  "tshy": {
    "main": true,
    "exports": {
      "./package.json": "./package.json",
      ".": "./src/index.ts"
    }
  },
  "bin": "./dist/esm/bin.mjs",
  "main": "./dist/commonjs/index.js",
  "types": "./dist/commonjs/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.js"
      }
    }
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/node-glob.git"
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags",
    "prepare": "tshy",
    "pretest": "npm run prepare",
    "presnap": "npm run prepare",
    "test": "tap",
    "snap": "tap",
    "format": "prettier --write . --log-level warn",
    "typedoc": "typedoc --tsconfig .tshy/esm.json ./src/*.ts",
    "prepublish": "npm run benchclean",
    "profclean": "rm -f v8.log profile.txt",
    "test-regen": "npm run profclean && TEST_REGEN=1 node --no-warnings --loader ts-node/esm test/00-setup.ts",
    "prebench": "npm run prepare",
    "bench": "bash benchmark.sh",
    "preprof": "npm run prepare",
    "prof": "bash prof.sh",
    "benchclean": "node benchclean.cjs"
  },
  "prettier": {
    "experimentalTernaries": true,
    "semi": false,
    "printWidth": 75,
    "tabWidth": 2,
    "useTabs": false,
    "singleQuote": true,
    "jsxSingleQuote": false,
    "bracketSameLine": true,
    "arrowParens": "avoid",
    "endOfLine": "lf"
  },
  "dependencies": {
    "foreground-child": "^3.1.0",
    "jackspeak": "^3.1.2",
    "minimatch": "^9.0.4",
    "minipass": "^7.1.2",
    "package-json-from-dist": "^1.0.0",
    "path-scurry": "^1.11.1"
  },
  "devDependencies": {
    "@types/node": "^20.11.30",
    "memfs": "^3.4.13",
    "mkdirp": "^3.0.1",
    "prettier": "^3.2.5",
    "rimraf": "^5.0.7",
    "sync-content": "^1.0.2",
    "tap": "^19.0.0",
    "tshy": "^1.14.0",
    "typedoc": "^0.25.12"
  },
  "tap": {
    "before": "test/00-setup.ts"
  },
  "license": "ISC",
  "funding": {
    "url": "https://github.com/sponsors/isaacs"
  },
  "module": "./dist/esm/index.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\gopd\package.json
============================================================
{
	"name": "gopd",
	"version": "1.2.0",
	"description": "`Object.getOwnPropertyDescriptor`, but accounts for IE's broken implementation.",
	"main": "index.js",
	"exports": {
		".": "./index.js",
		"./gOPD": "./gOPD.js",
		"./package.json": "./package.json"
	},
	"sideEffects": false,
	"scripts": {
		"prepack": "npmignore --auto --commentLines=autogenerated",
		"prepublishOnly": "safe-publish-latest",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"prelint": "tsc -p . && attw -P",
		"lint": "eslint --ext=js,mjs .",
		"postlint": "evalmd README.md",
		"pretest": "npm run lint",
		"tests-only": "tape 'test/**/*.js'",
		"test": "npm run tests-only",
		"posttest": "npx npm@'>=10.2' audit --production",
		"version": "auto-changelog && git add CHANGELOG.md",
		"postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
	},
	"repository": {
		"type": "git",
		"url": "git+https://github.com/ljharb/gopd.git"
	},
	"keywords": [
		"ecmascript",
		"javascript",
		"getownpropertydescriptor",
		"property",
		"descriptor"
	],
	"author": "Jordan Harband <ljharb@gmail.com>",
	"funding": {
		"url": "https://github.com/sponsors/ljharb"
	},
	"license": "MIT",
	"bugs": {
		"url": "https://github.com/ljharb/gopd/issues"
	},
	"homepage": "https://github.com/ljharb/gopd#readme",
	"devDependencies": {
		"@arethetypeswrong/cli": "^0.17.0",
		"@ljharb/eslint-config": "^21.1.1",
		"@ljharb/tsconfig": "^0.2.0",
		"@types/tape": "^5.6.5",
		"auto-changelog": "^2.5.0",
		"encoding": "^0.1.13",
		"eslint": "=8.8.0",
		"evalmd": "^0.0.19",
		"in-publish": "^2.0.1",
		"npmignore": "^0.3.1",
		"safe-publish-latest": "^2.0.0",
		"tape": "^5.9.0",
		"typescript": "next"
	},
	"auto-changelog": {
		"output": "CHANGELOG.md",
		"template": "keepachangelog",
		"unreleased": false,
		"commitLimit": false,
		"backfillLimit": false,
		"hideCredit": true
	},
	"publishConfig": {
		"ignore": [
			".github/workflows"
		]
	},
	"engines": {
		"node": ">= 0.4"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\graceful-fs\package.json
============================================================
{
  "name": "graceful-fs",
  "description": "A drop-in replacement for fs, making various improvements.",
  "version": "4.2.11",
  "repository": {
    "type": "git",
    "url": "https://github.com/isaacs/node-graceful-fs"
  },
  "main": "graceful-fs.js",
  "directories": {
    "test": "test"
  },
  "scripts": {
    "preversion": "npm test",
    "postversion": "npm publish",
    "postpublish": "git push origin --follow-tags",
    "test": "nyc --silent node test.js | tap -c -",
    "posttest": "nyc report"
  },
  "keywords": [
    "fs",
    "module",
    "reading",
    "retry",
    "retries",
    "queue",
    "error",
    "errors",
    "handling",
    "EMFILE",
    "EAGAIN",
    "EINVAL",
    "EPERM",
    "EACCESS"
  ],
  "license": "ISC",
  "devDependencies": {
    "import-fresh": "^2.0.0",
    "mkdirp": "^0.5.0",
    "rimraf": "^2.2.8",
    "tap": "^16.3.4"
  },
  "files": [
    "fs.js",
    "graceful-fs.js",
    "legacy-streams.js",
    "polyfills.js",
    "clone.js"
  ],
  "tap": {
    "reporter": "classic"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\harmony-reflect\package.json
============================================================
{
  "name": "harmony-reflect",
  "version": "1.6.2",
  "description": "ES5 shim for ES6 (ECMAScript 6) Reflect and Proxy objects",
  "main": "reflect.js",
  "keywords": [
    "reflection",
    "proxies",
    "proxy",
    "reflect",
    "harmony",
    "es6"
  ],
  "license": "(Apache-2.0 OR MPL-1.1)",
  "homepage": "https://github.com/tvcutsem/harmony-reflect",
  "typings": "index.d.ts",
  "repository" : {
    "type" : "git",
    "url" : "https://tvcutsem@github.com/tvcutsem/harmony-reflect.git"
  } 
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\has-flag\package.json
============================================================
{
	"name": "has-flag",
	"version": "4.0.0",
	"description": "Check if argv has a specific flag",
	"license": "MIT",
	"repository": "sindresorhus/has-flag",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"has",
		"check",
		"detect",
		"contains",
		"find",
		"flag",
		"cli",
		"command-line",
		"argv",
		"process",
		"arg",
		"args",
		"argument",
		"arguments",
		"getopt",
		"minimist",
		"optimist"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\has-symbols\package.json
============================================================
{
	"name": "has-symbols",
	"version": "1.1.0",
	"description": "Determine if the JS environment has Symbol support. Supports spec, or shams.",
	"main": "index.js",
	"scripts": {
		"prepack": "npmignore --auto --commentLines=autogenerated",
		"prepublishOnly": "safe-publish-latest",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"pretest": "npm run --silent lint",
		"test": "npm run tests-only",
		"posttest": "npx npm@'>=10.2' audit --production",
		"tests-only": "npm run test:stock && npm run test:shams",
		"test:stock": "nyc node test",
		"test:staging": "nyc node --harmony --es-staging test",
		"test:shams": "npm run --silent test:shams:getownpropertysymbols && npm run --silent test:shams:corejs",
		"test:shams:corejs": "nyc node test/shams/core-js.js",
		"test:shams:getownpropertysymbols": "nyc node test/shams/get-own-property-symbols.js",
		"lint": "eslint --ext=js,mjs .",
		"postlint": "tsc -p . && attw -P",
		"version": "auto-changelog && git add CHANGELOG.md",
		"postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
	},
	"repository": {
		"type": "git",
		"url": "git://github.com/inspect-js/has-symbols.git"
	},
	"keywords": [
		"Symbol",
		"symbols",
		"typeof",
		"sham",
		"polyfill",
		"native",
		"core-js",
		"ES6"
	],
	"author": {
		"name": "Jordan Harband",
		"email": "ljharb@gmail.com",
		"url": "http://ljharb.codes"
	},
	"contributors": [
		{
			"name": "Jordan Harband",
			"email": "ljharb@gmail.com",
			"url": "http://ljharb.codes"
		}
	],
	"funding": {
		"url": "https://github.com/sponsors/ljharb"
	},
	"license": "MIT",
	"bugs": {
		"url": "https://github.com/ljharb/has-symbols/issues"
	},
	"homepage": "https://github.com/ljharb/has-symbols#readme",
	"devDependencies": {
		"@arethetypeswrong/cli": "^0.17.0",
		"@ljharb/eslint-config": "^21.1.1",
		"@ljharb/tsconfig": "^0.2.0",
		"@types/core-js": "^2.5.8",
		"@types/tape": "^5.6.5",
		"auto-changelog": "^2.5.0",
		"core-js": "^2.6.12",
		"encoding": "^0.1.13",
		"eslint": "=8.8.0",
		"get-own-property-symbols": "^0.9.5",
		"in-publish": "^2.0.1",
		"npmignore": "^0.3.1",
		"nyc": "^10.3.2",
		"safe-publish-latest": "^2.0.0",
		"tape": "^5.9.0",
		"typescript": "next"
	},
	"testling": {
		"files": "test/index.js",
		"browsers": [
			"iexplore/6.0..latest",
			"firefox/3.0..6.0",
			"firefox/15.0..latest",
			"firefox/nightly",
			"chrome/4.0..10.0",
			"chrome/20.0..latest",
			"chrome/canary",
			"opera/10.0..latest",
			"opera/next",
			"safari/4.0..latest",
			"ipad/6.0..latest",
			"iphone/6.0..latest",
			"android-browser/4.2"
		]
	},
	"engines": {
		"node": ">= 0.4"
	},
	"auto-changelog": {
		"output": "CHANGELOG.md",
		"template": "keepachangelog",
		"unreleased": false,
		"commitLimit": false,
		"backfillLimit": false,
		"hideCredit": true
	},
	"publishConfig": {
		"ignore": [
			".github/workflows",
			"types"
		]
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\has-tostringtag\package.json
============================================================
{
	"name": "has-tostringtag",
	"version": "1.0.2",
	"author": {
		"name": "Jordan Harband",
		"email": "ljharb@gmail.com",
		"url": "http://ljharb.codes"
	},
	"funding": {
		"url": "https://github.com/sponsors/ljharb"
	},
	"contributors": [
		{
			"name": "Jordan Harband",
			"email": "ljharb@gmail.com",
			"url": "http://ljharb.codes"
		}
	],
	"description": "Determine if the JS environment has `Symbol.toStringTag` support. Supports spec, or shams.",
	"license": "MIT",
	"main": "index.js",
	"types": "./index.d.ts",
	"exports": {
		".": [
			{
				"types": "./index.d.ts",
				"default": "./index.js"
			},
			"./index.js"
		],
		"./shams": [
			{
				"types": "./shams.d.ts",
				"default": "./shams.js"
			},
			"./shams.js"
		],
		"./package.json": "./package.json"
	},
	"scripts": {
		"prepack": "npmignore --auto --commentLines=autogenerated",
		"prepublishOnly": "safe-publish-latest",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"pretest": "npm run --silent lint",
		"test": "npm run tests-only",
		"posttest": "aud --production",
		"tests-only": "npm run test:stock && npm run test:shams",
		"test:stock": "nyc node test",
		"test:staging": "nyc node --harmony --es-staging test",
		"test:shams": "npm run --silent test:shams:getownpropertysymbols && npm run --silent test:shams:corejs",
		"test:shams:corejs": "nyc node test/shams/core-js.js",
		"test:shams:getownpropertysymbols": "nyc node test/shams/get-own-property-symbols.js",
		"lint": "eslint --ext=js,mjs .",
		"version": "auto-changelog && git add CHANGELOG.md",
		"postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
	},
	"repository": {
		"type": "git",
		"url": "git+https://github.com/inspect-js/has-tostringtag.git"
	},
	"bugs": {
		"url": "https://github.com/inspect-js/has-tostringtag/issues"
	},
	"homepage": "https://github.com/inspect-js/has-tostringtag#readme",
	"keywords": [
		"javascript",
		"ecmascript",
		"symbol",
		"symbols",
		"tostringtag",
		"Symbol.toStringTag"
	],
	"devDependencies": {
		"@ljharb/eslint-config": "^21.1.0",
		"@types/has-symbols": "^1.0.2",
		"@types/tape": "^5.6.4",
		"aud": "^2.0.4",
		"auto-changelog": "^2.4.0",
		"core-js": "^2.6.12",
		"eslint": "=8.8.0",
		"get-own-property-symbols": "^0.9.5",
		"in-publish": "^2.0.1",
		"npmignore": "^0.3.1",
		"nyc": "^10.3.2",
		"safe-publish-latest": "^2.0.0",
		"tape": "^5.7.4",
		"typescript": "next"
	},
	"engines": {
		"node": ">= 0.4"
	},
	"auto-changelog": {
		"output": "CHANGELOG.md",
		"template": "keepachangelog",
		"unreleased": false,
		"commitLimit": false,
		"backfillLimit": false,
		"hideCredit": true
	},
	"publishConfig": {
		"ignore": [
			".github/workflows"
		]
	},
	"dependencies": {
		"has-symbols": "^1.0.3"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\hasown\package.json
============================================================
{
	"name": "hasown",
	"version": "2.0.2",
	"description": "A robust, ES3 compatible, \"has own property\" predicate.",
	"main": "index.js",
	"exports": {
		".": "./index.js",
		"./package.json": "./package.json"
	},
	"types": "index.d.ts",
	"sideEffects": false,
	"scripts": {
		"prepack": "npmignore --auto --commentLines=autogenerated",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"prepublishOnly": "safe-publish-latest",
		"prelint": "evalmd README.md",
		"lint": "eslint --ext=js,mjs .",
		"postlint": "npm run tsc",
		"pretest": "npm run lint",
		"tsc": "tsc -p .",
		"posttsc": "attw -P",
		"tests-only": "nyc tape 'test/**/*.js'",
		"test": "npm run tests-only",
		"posttest": "aud --production",
		"version": "auto-changelog && git add CHANGELOG.md",
		"postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
	},
	"repository": {
		"type": "git",
		"url": "git+https://github.com/inspect-js/hasOwn.git"
	},
	"keywords": [
		"has",
		"hasOwnProperty",
		"hasOwn",
		"has-own",
		"own",
		"has",
		"property",
		"in",
		"javascript",
		"ecmascript"
	],
	"author": "Jordan Harband <ljharb@gmail.com>",
	"license": "MIT",
	"bugs": {
		"url": "https://github.com/inspect-js/hasOwn/issues"
	},
	"homepage": "https://github.com/inspect-js/hasOwn#readme",
	"dependencies": {
		"function-bind": "^1.1.2"
	},
	"devDependencies": {
		"@arethetypeswrong/cli": "^0.15.1",
		"@ljharb/eslint-config": "^21.1.0",
		"@ljharb/tsconfig": "^0.2.0",
		"@types/function-bind": "^1.1.10",
		"@types/mock-property": "^1.0.2",
		"@types/tape": "^5.6.4",
		"aud": "^2.0.4",
		"auto-changelog": "^2.4.0",
		"eslint": "=8.8.0",
		"evalmd": "^0.0.19",
		"in-publish": "^2.0.1",
		"mock-property": "^1.0.3",
		"npmignore": "^0.3.1",
		"nyc": "^10.3.2",
		"safe-publish-latest": "^2.0.0",
		"tape": "^5.7.5",
		"typescript": "next"
	},
	"engines": {
		"node": ">= 0.4"
	},
	"testling": {
		"files": "test/index.js"
	},
	"auto-changelog": {
		"output": "CHANGELOG.md",
		"template": "keepachangelog",
		"unreleased": false,
		"commitLimit": false,
		"backfillLimit": false,
		"hideCredit": true
	},
	"publishConfig": {
		"ignore": [
			".github/workflows",
			"test"
		]
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\hoist-non-react-statics\node_modules\react-is\package.json
============================================================
{
  "name": "react-is",
  "version": "16.13.1",
  "description": "Brand checking of React Elements.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react-is"
  },
  "keywords": [
    "react"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/facebook/react/issues"
  },
  "homepage": "https://reactjs.org/",
  "files": [
    "LICENSE",
    "README.md",
    "build-info.json",
    "index.js",
    "cjs/",
    "umd/"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\hoist-non-react-statics\package.json
============================================================
{
  "name": "hoist-non-react-statics",
  "version": "3.3.2",
  "description": "Copies non-react specific statics from a child component to a parent component",
  "main": "dist/hoist-non-react-statics.cjs.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/mridgway/hoist-non-react-statics.git"
  },
  "files": [
    "src",
    "dist",
    "index.d.ts"
  ],
  "scripts": {
    "lint": "eslint src",
    "build": "rimraf dist && rollup -c",
    "test": "nyc mocha tests/unit/ --recursive --reporter spec --require=@babel/register",
    "coverage": "nyc report --reporter=text-lcov | coveralls",
    "prepublish": "npm test"
  },
  "author": "Michael Ridgway <mcridgway@gmail.com>",
  "license": "BSD-3-Clause",
  "dependencies": {
    "react-is": "^16.7.0"
  },
  "devDependencies": {
    "@babel/core": "^7.5.0",
    "@babel/plugin-proposal-class-properties": "^7.5.0",
    "@babel/preset-env": "^7.5.0",
    "@babel/preset-react": "^7.0.0",
    "@babel/register": "^7.4.4",
    "chai": "^4.2.0",
    "coveralls": "^2.11.1",
    "create-react-class": "^15.5.3",
    "eslint": "^4.13.1",
    "mocha": "^6.1.4",
    "nyc": "^14.1.1",
    "pre-commit": "^1.0.7",
    "prop-types": "^15.6.2",
    "react": "^16.7.0",
    "rimraf": "^2.6.2",
    "rollup": "^1.16.6",
    "rollup-plugin-babel": "^4.3.3",
    "rollup-plugin-commonjs": "^10.0.1",
    "rollup-plugin-node-resolve": "^5.2.0",
    "rollup-plugin-terser": "^5.1.1"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/"
  },
  "keywords": [
    "react"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\html-encoding-sniffer\package.json
============================================================
{
  "name": "html-encoding-sniffer",
  "description": "Sniff the encoding from a HTML byte stream",
  "keywords": [
    "encoding",
    "html"
  ],
  "version": "4.0.0",
  "author": "Domenic Denicola <d@domenic.me> (https://domenic.me/)",
  "license": "MIT",
  "repository": "jsdom/html-encoding-sniffer",
  "main": "lib/html-encoding-sniffer.js",
  "files": [
    "lib/"
  ],
  "scripts": {
    "test": "node --test",
    "lint": "eslint ."
  },
  "dependencies": {
    "whatwg-encoding": "^3.1.1"
  },
  "devDependencies": {
    "@domenic/eslint-config": "^3.0.0",
    "eslint": "^8.53.0"
  },
  "engines": {
    "node": ">=18"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\html-escaper\cjs\package.json
============================================================
{"type":"commonjs"}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\html-escaper\test\package.json
============================================================
{"type":"commonjs"}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\html-escaper\package.json
============================================================
{
  "name": "html-escaper",
  "version": "2.0.2",
  "description": "fast and safe way to escape and unescape &<>'\" chars",
  "main": "./cjs/index.js",
  "unpkg": "min.js",
  "scripts": {
    "build": "npm run cjs && npm run rollup && npm run minify && npm test && npm run size",
    "cjs": "ascjs esm cjs",
    "coveralls": "cat ./coverage/lcov.info | coveralls",
    "minify": "uglifyjs index.js --comments=/^!/ --compress --mangle -o min.js",
    "rollup": "rollup --config rollup.config.js",
    "size": "cat index.js | wc -c;cat min.js | wc -c;gzip -c min.js | wc -c",
    "test": "istanbul cover ./test/index.js"
  },
  "module": "./esm/index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/WebReflection/html-escaper.git"
  },
  "keywords": [
    "html",
    "escape",
    "encode",
    "unescape",
    "decode",
    "entities"
  ],
  "author": "Andrea Giammarchi",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/WebReflection/html-escaper/issues"
  },
  "homepage": "https://github.com/WebReflection/html-escaper",
  "devDependencies": {
    "ascjs": "^3.1.2",
    "coveralls": "^3.0.11",
    "istanbul": "^0.4.5",
    "rollup": "^2.1.0",
    "uglify-js": "^3.8.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\html-parse-stringify\package.json
============================================================
{
  "name": "html-parse-stringify",
  "description": "Parses well-formed HTML (meaning all tags closed) into an AST and back. quickly.",
  "version": "3.0.1",
  "author": "Henrik Joreteg <henrik@joreteg.com>",
  "bugs": {
    "url": "https://github.com/henrikjoreteg/html-parse-stringify/issues"
  },
  "dependencies": {
    "void-elements": "3.1.0"
  },
  "devDependencies": {
    "esm": "3.2.25",
    "microbundle": "0.12.2",
    "prettier": "2.0.5",
    "tap-spec": "2.1.2",
    "tape": "5.0.1"
  },
  "files": [
    "dist"
  ],
  "homepage": "https://github.com/henrikjoreteg/html-parse-stringify",
  "keywords": [
    "ast",
    "html",
    "parse",
    "stringify"
  ],
  "license": "MIT",
  "main": "dist/html-parse-stringify.js",
  "module": "dist/html-parse-stringify.module.js",
  "source": "src/index.js",
  "unpkg": "dist/html-parse-stringify.umd.js",
  "prettier": {
    "arrowParens": "avoid",
    "singleQuote": true,
    "semi": false
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/henrikjoreteg/html-parse-stringify"
  },
  "scripts": {
    "build": "microbundle",
    "format": "prettier --write .",
    "prebuild": "rm -rf dist",
    "prepublish": "npm run build",
    "test": "tape -r esm test/* | tap-spec"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\http-proxy-agent\package.json
============================================================
{
  "name": "http-proxy-agent",
  "version": "7.0.2",
  "description": "An HTTP(s) proxy `http.Agent` implementation for HTTP",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": [
    "dist"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/TooTallNate/proxy-agents.git",
    "directory": "packages/http-proxy-agent"
  },
  "keywords": [
    "http",
    "proxy",
    "endpoint",
    "agent"
  ],
  "author": "Nathan Rajlich <nathan@tootallnate.net> (http://n8.io/)",
  "license": "MIT",
  "dependencies": {
    "agent-base": "^7.1.0",
    "debug": "^4.3.4"
  },
  "devDependencies": {
    "@types/debug": "^4.1.7",
    "@types/jest": "^29.5.1",
    "@types/node": "^14.18.45",
    "async-listen": "^3.0.0",
    "jest": "^29.5.0",
    "ts-jest": "^29.1.0",
    "typescript": "^5.0.4",
    "proxy": "2.1.1",
    "tsconfig": "0.0.0"
  },
  "engines": {
    "node": ">= 14"
  },
  "scripts": {
    "build": "tsc",
    "test": "jest --env node --verbose --bail",
    "lint": "eslint . --ext .ts",
    "pack": "node ../../scripts/pack.mjs"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\https-proxy-agent\package.json
============================================================
{
  "name": "https-proxy-agent",
  "version": "7.0.6",
  "description": "An HTTP(s) proxy `http.Agent` implementation for HTTPS",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": [
    "dist"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/TooTallNate/proxy-agents.git",
    "directory": "packages/https-proxy-agent"
  },
  "keywords": [
    "https",
    "proxy",
    "endpoint",
    "agent"
  ],
  "author": "Nathan Rajlich <nathan@tootallnate.net> (http://n8.io/)",
  "license": "MIT",
  "dependencies": {
    "agent-base": "^7.1.2",
    "debug": "4"
  },
  "devDependencies": {
    "@types/async-retry": "^1.4.5",
    "@types/debug": "4",
    "@types/jest": "^29.5.1",
    "@types/node": "^14.18.45",
    "async-listen": "^3.0.0",
    "async-retry": "^1.3.3",
    "jest": "^29.5.0",
    "ts-jest": "^29.1.0",
    "typescript": "^5.0.4",
    "proxy": "2.2.0",
    "tsconfig": "0.0.0"
  },
  "engines": {
    "node": ">= 14"
  },
  "scripts": {
    "build": "tsc",
    "test": "jest --env node --verbose --bail test/test.ts",
    "test-e2e": "jest --env node --verbose --bail test/e2e.test.ts",
    "lint": "eslint --ext .ts",
    "pack": "node ../../scripts/pack.mjs"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\human-signals\package.json
============================================================
{
  "name": "human-signals",
  "version": "2.1.0",
  "main": "build/src/main.js",
  "files": [
    "build/src",
    "!~"
  ],
  "scripts": {
    "test": "gulp test"
  },
  "husky": {
    "hooks": {
      "pre-push": "gulp check --full"
    }
  },
  "description": "Human-friendly process signals",
  "keywords": [
    "signal",
    "signals",
    "handlers",
    "error-handling",
    "errors",
    "interrupts",
    "sigterm",
    "sigint",
    "irq",
    "process",
    "exit",
    "exit-code",
    "status",
    "operating-system",
    "es6",
    "javascript",
    "linux",
    "macos",
    "windows",
    "nodejs"
  ],
  "license": "Apache-2.0",
  "homepage": "https://git.io/JeluP",
  "repository": "ehmicky/human-signals",
  "bugs": {
    "url": "https://github.com/ehmicky/human-signals/issues"
  },
  "author": "ehmicky <ehmicky@gmail.com> (https://github.com/ehmicky)",
  "directories": {
    "lib": "src",
    "test": "test"
  },
  "types": "build/src/main.d.ts",
  "dependencies": {},
  "devDependencies": {
    "@ehmicky/dev-tasks": "^0.31.9",
    "ajv": "^6.12.0",
    "ava": "^3.5.0",
    "gulp": "^4.0.2",
    "husky": "^4.2.3",
    "test-each": "^2.0.0"
  },
  "engines": {
    "node": ">=10.17.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\i18next\dist\esm\package.json
============================================================
{"type":"module","version":"22.5.1"}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\i18next\package.json
============================================================
{
  "name": "i18next",
  "version": "22.5.1",
  "description": "i18next internationalization framework",
  "main": "./dist/cjs/i18next.js",
  "module": "./dist/esm/i18next.js",
  "types": "./index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./index.d.ts",
      "import": "./dist/esm/i18next.js",
      "require": "./dist/cjs/i18next.js"
    }
  },
  "keywords": [
    "i18next",
    "internationalization",
    "i18n",
    "translation",
    "localization",
    "l10n",
    "globalization",
    "gettext"
  ],
  "homepage": "https://www.i18next.com",
  "bugs": "https://github.com/i18next/i18next/issues",
  "repository": {
    "type": "git",
    "url": "https://github.com/i18next/i18next.git"
  },
  "funding": [
    {
      "type": "individual",
      "url": "https://locize.com"
    },
    {
      "type": "individual",
      "url": "https://locize.com/i18next.html"
    },
    {
      "type": "individual",
      "url": "https://www.i18next.com/how-to/faq#i18next-is-awesome.-how-can-i-support-the-project"
    }
  ],
  "dependencies": {
    "@babel/runtime": "^7.20.6"
  },
  "devDependencies": {
    "@babel/core": "^7.20.5",
    "@babel/plugin-proposal-async-generator-functions": "^7.20.1",
    "@babel/plugin-transform-modules-commonjs": "^7.19.6",
    "@babel/plugin-transform-runtime": "^7.19.6",
    "@babel/polyfill": "^7.2.5",
    "@babel/preset-env": "^7.20.2",
    "@babel/preset-react": "^7.18.6",
    "@babel/register": "^7.18.9",
    "@rollup/plugin-babel": "^5.2.2",
    "@rollup/plugin-commonjs": "^17.0.0",
    "@rollup/plugin-node-resolve": "^11.0.0",
    "@babel/eslint-parser": "^7.19.1",
    "babelify": "^10.0.0",
    "browserify": "17.0.0",
    "browserify-istanbul": "3.0.1",
    "chai": "4.3.7",
    "coveralls": "3.1.1",
    "cpy-cli": "^4.2.0",
    "dtslint": "^0.4.2",
    "eslint": "8.32.0",
    "eslint-config-airbnb": "19.0.4",
    "eslint-config-prettier": "^8.6.0",
    "eslint-plugin-import": "2.27.5",
    "eslint-plugin-jsx-a11y": "6.7.1",
    "eslint-plugin-react": "7.32.1",
    "gh-release": "6.0.4",
    "husky": "^7.0.2",
    "i18next-browser-languagedetector": "7.0.1",
    "i18next-fs-backend": "2.1.0",
    "i18next-http-backend": "2.1.0",
    "i18next-localstorage-cache": "1.1.1",
    "i18next-sprintf-postprocessor": "0.2.2",
    "karma": "6.4.1",
    "karma-browserify": "8.1.0",
    "karma-chai": "0.1.0",
    "karma-chrome-launcher": "3.1.1",
    "karma-cli": "2.0.0",
    "karma-coverage": "2.2.0",
    "karma-coveralls": "2.1.0",
    "karma-mocha": "2.0.1",
    "karma-rollup-preprocessor": "7.0.8",
    "karma-sinon": "1.0.5",
    "karma-spec-reporter": "0.0.34",
    "lint-staged": "^11.1.2",
    "mocha": "10.1.0",
    "nyc": "^15.1.0",
    "prettier": "^2.8.0",
    "rimraf": "3.0.2",
    "rollup": "^2.79.1",
    "rollup-plugin-terser": "^5.3.0",
    "sinon": "11.1.2",
    "tslint": "^5.20.1",
    "typescript": "^4.9.3",
    "watchify": "4.0.0"
  },
  "scripts": {
    "pretest": "npm run test:typescript && npm run test:typescript:customtypes && npm run test:typescript:noninterop",
    "lint": "eslint src",
    "test": "npm run lint && npm run test:new && npm run test:compat",
    "test:new": "karma start karma.conf.js --singleRun",
    "test:compat": "karma start karma.backward.conf.js --singleRun",
    "test:typescript": "tslint --project tsconfig.json",
    "test:typescript:customtypes": "tslint --project test/typescript/custom-types/tsconfig.json",
    "test:typescript:noninterop": "tslint --project tsconfig.nonEsModuleInterop.json",
    "tdd": "karma start karma.conf.js",
    "tdd:compat": "karma start karma.backward.conf.js",
    "build": "rimraf dist && rollup -c && echo '{\"type\":\"module\"}' > dist/esm/package.json && cpy \"./dist/umd/*.js\" ./",
    "fix_dist_package": "node -e 'console.log(`{\"type\":\"module\",\"version\":\"${process.env.npm_package_version}\"}`)' > dist/esm/package.json",
    "preversion": "npm run test && npm run build && git push",
    "postversion": "npm run fix_dist_package && git push && git push --tags && npm run release",
    "prettier": "prettier --write \"{,**/}*.{ts,tsx,js,json,md}\"",
    "prepare": "husky install",
    "release": "gh-release"
  },
  "author": "Jan Mühlemann <jan.muehlemann@gmail.com> (https://github.com/jamuhl)",
  "license": "MIT",
  "lint-staged": {
    "*.{ts,tsx,js,json,md}": "prettier --write"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\iconv-lite\package.json
============================================================
{
    "name": "iconv-lite",
    "description": "Convert character encodings in pure javascript.",
    "version": "0.6.3",
    "license": "MIT",
    "keywords": [
        "iconv",
        "convert",
        "charset",
        "icu"
    ],
    "author": "Alexander Shtuchkin <ashtuchkin@gmail.com>",
    "main": "./lib/index.js",
    "typings": "./lib/index.d.ts",
    "homepage": "https://github.com/ashtuchkin/iconv-lite",
    "bugs": "https://github.com/ashtuchkin/iconv-lite/issues",
    "repository": {
        "type": "git",
        "url": "git://github.com/ashtuchkin/iconv-lite.git"
    },
    "engines": {
        "node": ">=0.10.0"
    },
    "scripts": {
        "coverage": "c8 _mocha --grep .",
        "test": "mocha --reporter spec --grep ."
    },
    "browser": {
        "stream": false
    },
    "devDependencies": {
        "async": "^3.2.0",
        "c8": "^7.2.0",
        "errto": "^0.2.1",
        "iconv": "^2.3.5",
        "mocha": "^3.5.3",
        "request": "^2.88.2",
        "semver": "^6.3.0",
        "unorm": "^1.6.0"
    },
    "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3.0.0"
    }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\identity-obj-proxy\package.json
============================================================
{
  "name": "identity-obj-proxy",
  "version": "3.0.0",
  "description": "an identity object using ES6 proxies",
  "main": "src/index.js",
  "scripts": {
    "lint": "eslint src",
    "test": "node --harmony_proxies node_modules/.bin/jest",
    "coverage": "node --harmony_proxies node_modules/.bin/jest --coverage",
    "coveralls": "npm run coverage && cat ./coverage/lcov.info | coveralls",
    "prepublish": "npm run lint && npm run test"
  },
  "engines": {
    "node": ">=4"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/keyanzhang/identity-obj-proxy.git"
  },
  "keywords": [
    "proxy",
    "proxies",
    "identity",
    "jest",
    "mock"
  ],
  "author": "Keyan Zhang <root@keyanzhang.com> (http://keya.nz)",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/keyanzhang/identity-obj-proxy/issues"
  },
  "homepage": "https://github.com/keyanzhang/identity-obj-proxy#readme",
  "dependencies": {
    "harmony-reflect": "^1.4.6"
  },
  "devDependencies": {
    "babel-core": "^6.11.4",
    "babel-jest": "^14.1.0",
    "babel-preset-es2015": "^6.9.0",
    "babel-preset-stage-0": "^6.5.0",
    "coveralls": "^2.11.12",
    "eslint": "^3.2.2",
    "eslint-config-airbnb-base": "^5.0.1",
    "eslint-plugin-import": "^1.12.0",
    "jest-cli": "^14.1.0"
  },
  "jest": {
    "automock": false,
    "testPathDirs": [
      "<rootDir>/src"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\import-local\package.json
============================================================
{
	"name": "import-local",
	"version": "3.2.0",
	"description": "Let a globally installed package use a locally installed version of itself if available",
	"license": "MIT",
	"repository": "sindresorhus/import-local",
	"funding": "https://github.com/sponsors/sindresorhus",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"bin": {
		"import-local-fixture": "fixtures/cli.js"
	},
	"sideEffects": false,
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava"
	},
	"files": [
		"index.js",
		"index.d.ts",
		"fixtures/cli.js"
	],
	"keywords": [
		"import",
		"local",
		"require",
		"resolve",
		"global",
		"version",
		"prefer",
		"cli"
	],
	"dependencies": {
		"pkg-dir": "^4.2.0",
		"resolve-cwd": "^3.0.0"
	},
	"devDependencies": {
		"ava": "2.1.0",
		"cpy": "^7.0.1",
		"del": "^4.1.1",
		"execa": "^2.0.1",
		"xo": "^0.24.0"
	},
	"xo": {
		"ignores": [
			"fixtures"
		]
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\imurmurhash\package.json
============================================================
{
  "name": "imurmurhash",
  "version": "0.1.4",
  "description": "An incremental implementation of MurmurHash3",
  "homepage": "https://github.com/jensyt/imurmurhash-js",
  "main": "imurmurhash.js",
  "files": [
    "imurmurhash.js",
    "imurmurhash.min.js",
    "package.json",
    "README.md"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/jensyt/imurmurhash-js"
  },
  "bugs": {
    "url": "https://github.com/jensyt/imurmurhash-js/issues"
  },
  "keywords": [
    "murmur",
    "murmurhash",
    "murmurhash3",
    "hash",
    "incremental"
  ],
  "author": {
    "name": "Jens Taylor",
    "email": "jensyt@gmail.com",
    "url": "https://github.com/homebrewing"
  },
  "license": "MIT",
  "dependencies": {
  },
  "devDependencies": {
  },
  "engines": {
    "node": ">=0.8.19"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\indent-string\package.json
============================================================
{
	"name": "indent-string",
	"version": "4.0.0",
	"description": "Indent each line in a string",
	"license": "MIT",
	"repository": "sindresorhus/indent-string",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"indent",
		"string",
		"pad",
		"align",
		"line",
		"text",
		"each",
		"every"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\inflight\package.json
============================================================
{
  "name": "inflight",
  "version": "1.0.6",
  "description": "Add callbacks to requests in flight to avoid async duplication",
  "main": "inflight.js",
  "files": [
    "inflight.js"
  ],
  "dependencies": {
    "once": "^1.3.0",
    "wrappy": "1"
  },
  "devDependencies": {
    "tap": "^7.1.2"
  },
  "scripts": {
    "test": "tap test.js --100"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/npm/inflight.git"
  },
  "author": "Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)",
  "bugs": {
    "url": "https://github.com/isaacs/inflight/issues"
  },
  "homepage": "https://github.com/isaacs/inflight",
  "license": "ISC"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\inherits\package.json
============================================================
{
  "name": "inherits",
  "description": "Browser-friendly inheritance fully compatible with standard node.js inherits()",
  "version": "2.0.4",
  "keywords": [
    "inheritance",
    "class",
    "klass",
    "oop",
    "object-oriented",
    "inherits",
    "browser",
    "browserify"
  ],
  "main": "./inherits.js",
  "browser": "./inherits_browser.js",
  "repository": "git://github.com/isaacs/inherits",
  "license": "ISC",
  "scripts": {
    "test": "tap"
  },
  "devDependencies": {
    "tap": "^14.2.4"
  },
  "files": [
    "inherits.js",
    "inherits_browser.js"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\is-arrayish\package.json
============================================================
{
  "name": "is-arrayish",
  "description": "Determines if an object can be used as an array",
  "version": "0.2.1",
  "author": "Qix (http://github.com/qix-)",
  "keywords": [
    "is",
    "array",
    "duck",
    "type",
    "arrayish",
    "similar",
    "proto",
    "prototype",
    "type"
  ],
  "license": "MIT",
  "scripts": {
    "pretest": "xo",
    "test": "mocha --compilers coffee:coffee-script/register"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/qix-/node-is-arrayish.git"
  },
  "devDependencies": {
    "coffee-script": "^1.9.3",
    "coveralls": "^2.11.2",
    "istanbul": "^0.3.17",
    "mocha": "^2.2.5",
    "should": "^7.0.1",
    "xo": "^0.6.1"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\is-core-module\package.json
============================================================
{
	"name": "is-core-module",
	"version": "2.16.1",
	"description": "Is this specifier a node.js core module?",
	"main": "index.js",
	"sideEffects": false,
	"exports": {
		".": "./index.js",
		"./package.json": "./package.json"
	},
	"scripts": {
		"prepack": "npmignore --auto --commentLines=autogenerated",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"prepublishOnly": "safe-publish-latest",
		"lint": "eslint .",
		"pretest": "npm run lint",
		"tests-only": "nyc tape 'test/**/*.js'",
		"test": "npm run tests-only",
		"posttest": "npx npm@'>=10.2' audit --production",
		"version": "auto-changelog && git add CHANGELOG.md",
		"postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
	},
	"repository": {
		"type": "git",
		"url": "git+https://github.com/inspect-js/is-core-module.git"
	},
	"keywords": [
		"core",
		"modules",
		"module",
		"npm",
		"node",
		"dependencies"
	],
	"author": "Jordan Harband <ljharb@gmail.com>",
	"funding": {
		"url": "https://github.com/sponsors/ljharb"
	},
	"license": "MIT",
	"bugs": {
		"url": "https://github.com/inspect-js/is-core-module/issues"
	},
	"homepage": "https://github.com/inspect-js/is-core-module",
	"dependencies": {
		"hasown": "^2.0.2"
	},
	"devDependencies": {
		"@ljharb/eslint-config": "^21.1.1",
		"auto-changelog": "^2.5.0",
		"encoding": "^0.1.13",
		"eslint": "=8.8.0",
		"in-publish": "^2.0.1",
		"mock-property": "^1.1.0",
		"npmignore": "^0.3.1",
		"nyc": "^10.3.2",
		"safe-publish-latest": "^2.0.0",
		"semver": "^6.3.1",
		"tape": "^5.9.0"
	},
	"auto-changelog": {
		"output": "CHANGELOG.md",
		"template": "keepachangelog",
		"unreleased": false,
		"commitLimit": false,
		"backfillLimit": false,
		"hideCredit": true
	},
	"publishConfig": {
		"ignore": [
			".github"
		]
	},
	"engines": {
		"node": ">= 0.4"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\is-fullwidth-code-point\package.json
============================================================
{
	"name": "is-fullwidth-code-point",
	"version": "3.0.0",
	"description": "Check if the character represented by a given Unicode code point is fullwidth",
	"license": "MIT",
	"repository": "sindresorhus/is-fullwidth-code-point",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd-check"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"fullwidth",
		"full-width",
		"full",
		"width",
		"unicode",
		"character",
		"string",
		"codepoint",
		"code",
		"point",
		"is",
		"detect",
		"check"
	],
	"devDependencies": {
		"ava": "^1.3.1",
		"tsd-check": "^0.5.0",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\is-generator-fn\package.json
============================================================
{
	"name": "is-generator-fn",
	"version": "2.1.0",
	"description": "Check if something is a generator function",
	"license": "MIT",
	"repository": "sindresorhus/is-generator-fn",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=6"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"generator",
		"function",
		"func",
		"fn",
		"is",
		"check",
		"detect",
		"yield",
		"type"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\is-number\package.json
============================================================
{
  "name": "is-number",
  "description": "Returns true if a number or string value is a finite number. Useful for regex matches, parsing, user input, etc.",
  "version": "7.0.0",
  "homepage": "https://github.com/jonschlinkert/is-number",
  "author": "Jon Schlinkert (https://github.com/jonschlinkert)",
  "contributors": [
    "Jon Schlinkert (http://twitter.com/jonschlinkert)",
    "Olsten Larck (https://i.am.charlike.online)",
    "Rouven Weßling (www.rouvenwessling.de)"
  ],
  "repository": "jonschlinkert/is-number",
  "bugs": {
    "url": "https://github.com/jonschlinkert/is-number/issues"
  },
  "license": "MIT",
  "files": [
    "index.js"
  ],
  "main": "index.js",
  "engines": {
    "node": ">=0.12.0"
  },
  "scripts": {
    "test": "mocha"
  },
  "devDependencies": {
    "ansi": "^0.3.1",
    "benchmark": "^2.1.4",
    "gulp-format-md": "^1.0.0",
    "mocha": "^3.5.3"
  },
  "keywords": [
    "cast",
    "check",
    "coerce",
    "coercion",
    "finite",
    "integer",
    "is",
    "isnan",
    "is-nan",
    "is-num",
    "is-number",
    "isnumber",
    "isfinite",
    "istype",
    "kind",
    "math",
    "nan",
    "num",
    "number",
    "numeric",
    "parseFloat",
    "parseInt",
    "test",
    "type",
    "typeof",
    "value"
  ],
  "verb": {
    "toc": false,
    "layout": "default",
    "tasks": [
      "readme"
    ],
    "related": {
      "list": [
        "is-plain-object",
        "is-primitive",
        "isobject",
        "kind-of"
      ]
    },
    "plugins": [
      "gulp-format-md"
    ],
    "lint": {
      "reflinks": true
    }
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\is-potential-custom-element-name\package.json
============================================================
{
  "name": "is-potential-custom-element-name",
  "version": "1.0.1",
  "description": "Check whether a given string matches the `PotentialCustomElementName` production as defined in the HTML Standard.",
  "homepage": "https://github.com/mathiasbynens/is-potential-custom-element-name",
  "main": "index.js",
  "files": [
    "LICENSE-MIT.txt",
    "index.js"
  ],
  "keywords": [
    "html",
    "custom element",
    "custom element name",
    "web components"
  ],
  "license": "MIT",
  "author": {
    "name": "Mathias Bynens",
    "url": "https://mathiasbynens.be/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mathiasbynens/is-potential-custom-element-name.git"
  },
  "bugs": "https://github.com/mathiasbynens/is-potential-custom-element-name/issues",
  "devDependencies": {
    "mocha": "^2.2.1",
    "regenerate": "^1.4.2"
  },
  "scripts": {
    "build": "node build.js",
    "test": "mocha"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\is-stream\package.json
============================================================
{
	"name": "is-stream",
	"version": "2.0.1",
	"description": "Check if something is a Node.js stream",
	"license": "MIT",
	"repository": "sindresorhus/is-stream",
	"funding": "https://github.com/sponsors/sindresorhus",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"stream",
		"type",
		"streams",
		"writable",
		"readable",
		"duplex",
		"transform",
		"check",
		"detect",
		"is"
	],
	"devDependencies": {
		"@types/node": "^11.13.6",
		"ava": "^1.4.1",
		"tempy": "^0.3.0",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\isexe\package.json
============================================================
{
  "name": "isexe",
  "version": "2.0.0",
  "description": "Minimal module to check if a file is executable.",
  "main": "index.js",
  "directories": {
    "test": "test"
  },
  "devDependencies": {
    "mkdirp": "^0.5.1",
    "rimraf": "^2.5.0",
    "tap": "^10.3.0"
  },
  "scripts": {
    "test": "tap test/*.js --100",
    "preversion": "npm test",
    "postversion": "npm publish",
    "postpublish": "git push origin --all; git push origin --tags"
  },
  "author": "Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)",
  "license": "ISC",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/isaacs/isexe.git"
  },
  "keywords": [],
  "bugs": {
    "url": "https://github.com/isaacs/isexe/issues"
  },
  "homepage": "https://github.com/isaacs/isexe#readme"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\istanbul-lib-coverage\package.json
============================================================
{
  "name": "istanbul-lib-coverage",
  "version": "3.2.2",
  "description": "Data library for istanbul coverage objects",
  "author": "Krishnan Anantheswaran <kananthmail-github@yahoo.com>",
  "main": "index.js",
  "files": [
    "lib",
    "index.js"
  ],
  "scripts": {
    "test": "nyc mocha"
  },
  "devDependencies": {
    "chai": "^4.2.0",
    "mocha": "^6.2.2",
    "nyc": "^15.0.0-beta.2"
  },
  "karmaDeps": {
    "browserify-istanbul": "^0.2.1",
    "karma": "^0.13.10",
    "karma-browserify": "^4.2.1",
    "karma-chrome-launcher": "^0.2.0",
    "karma-coverage": "^0.4.2",
    "karma-mocha": "^0.2.0",
    "karma-phantomjs-launcher": "^0.2.0",
    "phantomjs": "^1.9.17"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/istanbuljs/istanbuljs.git",
    "directory": "packages/istanbul-lib-coverage"
  },
  "keywords": [
    "istanbul",
    "coverage",
    "data"
  ],
  "license": "BSD-3-Clause",
  "bugs": {
    "url": "https://github.com/istanbuljs/istanbuljs/issues"
  },
  "homepage": "https://istanbul.js.org/",
  "engines": {
    "node": ">=8"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\istanbul-lib-instrument\node_modules\semver\package.json
============================================================
{
  "name": "semver",
  "version": "7.7.3",
  "description": "The semantic version parser used by npm.",
  "main": "index.js",
  "scripts": {
    "test": "tap",
    "snap": "tap",
    "lint": "npm run eslint",
    "postlint": "template-oss-check",
    "lintfix": "npm run eslint -- --fix",
    "posttest": "npm run lint",
    "template-oss-apply": "template-oss-apply --force",
    "eslint": "eslint \"**/*.{js,cjs,ts,mjs,jsx,tsx}\""
  },
  "devDependencies": {
    "@npmcli/eslint-config": "^5.0.0",
    "@npmcli/template-oss": "4.25.1",
    "benchmark": "^2.1.4",
    "tap": "^16.0.0"
  },
  "license": "ISC",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/npm/node-semver.git"
  },
  "bin": {
    "semver": "bin/semver.js"
  },
  "files": [
    "bin/",
    "lib/",
    "classes/",
    "functions/",
    "internal/",
    "ranges/",
    "index.js",
    "preload.js",
    "range.bnf"
  ],
  "tap": {
    "timeout": 30,
    "coverage-map": "map.js",
    "nyc-arg": [
      "--exclude",
      "tap-snapshots/**"
    ]
  },
  "engines": {
    "node": ">=10"
  },
  "author": "GitHub Inc.",
  "templateOSS": {
    "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
    "version": "4.25.1",
    "engines": ">=10",
    "distPaths": [
      "classes/",
      "functions/",
      "internal/",
      "ranges/",
      "index.js",
      "preload.js",
      "range.bnf"
    ],
    "allowPaths": [
      "/classes/",
      "/functions/",
      "/internal/",
      "/ranges/",
      "/index.js",
      "/preload.js",
      "/range.bnf",
      "/benchmarks"
    ],
    "publish": "true"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\istanbul-lib-instrument\package.json
============================================================
{
  "name": "istanbul-lib-instrument",
  "version": "6.0.3",
  "description": "Core istanbul API for JS code coverage",
  "author": "Krishnan Anantheswaran <kananthmail-github@yahoo.com>",
  "main": "src/index.js",
  "files": [
    "src"
  ],
  "scripts": {
    "test": "nyc mocha"
  },
  "dependencies": {
    "@babel/core": "^7.23.9",
    "@babel/parser": "^7.23.9",
    "@istanbuljs/schema": "^0.1.3",
    "istanbul-lib-coverage": "^3.2.0",
    "semver": "^7.5.4"
  },
  "devDependencies": {
    "@babel/cli": "^7.23.9",
    "chai": "^4.2.0",
    "clone": "^2.1.2",
    "debug": "^4.1.1",
    "documentation": "^12.1.4",
    "js-yaml": "^3.13.1",
    "mocha": "^6.2.3",
    "nopt": "^4.0.1",
    "nyc": "^15.1.0"
  },
  "license": "BSD-3-Clause",
  "bugs": {
    "url": "https://github.com/istanbuljs/istanbuljs/issues"
  },
  "homepage": "https://istanbul.js.org/",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/istanbuljs/istanbuljs.git",
    "directory": "packages/istanbul-lib-instrument"
  },
  "keywords": [
    "coverage",
    "istanbul",
    "js",
    "instrumentation"
  ],
  "engines": {
    "node": ">=10"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\istanbul-lib-report\package.json
============================================================
{
  "name": "istanbul-lib-report",
  "version": "3.0.1",
  "description": "Base reporting library for istanbul",
  "author": "Krishnan Anantheswaran <kananthmail-github@yahoo.com>",
  "main": "index.js",
  "files": [
    "lib",
    "index.js"
  ],
  "scripts": {
    "test": "nyc mocha"
  },
  "dependencies": {
    "istanbul-lib-coverage": "^3.0.0",
    "make-dir": "^4.0.0",
    "supports-color": "^7.1.0"
  },
  "devDependencies": {
    "chai": "^4.2.0",
    "mocha": "^6.2.2",
    "nyc": "^15.0.0-beta.2",
    "rimraf": "^3.0.0"
  },
  "license": "BSD-3-Clause",
  "bugs": {
    "url": "https://github.com/istanbuljs/istanbuljs/issues"
  },
  "homepage": "https://istanbul.js.org/",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/istanbuljs/istanbuljs.git",
    "directory": "packages/istanbul-lib-report"
  },
  "keywords": [
    "istanbul",
    "report",
    "api",
    "lib"
  ],
  "engines": {
    "node": ">=10"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\istanbul-lib-source-maps\package.json
============================================================
{
  "name": "istanbul-lib-source-maps",
  "version": "5.0.6",
  "description": "Source maps support for istanbul",
  "author": "Krishnan Anantheswaran <kananthmail-github@yahoo.com>",
  "main": "index.js",
  "files": [
    "lib",
    "index.js"
  ],
  "scripts": {
    "test": "nyc mocha"
  },
  "dependencies": {
    "@jridgewell/trace-mapping": "^0.3.23",
    "debug": "^4.1.1",
    "istanbul-lib-coverage": "^3.0.0"
  },
  "devDependencies": {
    "chai": "^4.2.0",
    "mocha": "^6.2.2",
    "nyc": "^15.0.0-beta.2",
    "ts-node": "^8.5.4"
  },
  "license": "BSD-3-Clause",
  "bugs": {
    "url": "https://github.com/istanbuljs/istanbuljs/issues"
  },
  "homepage": "https://istanbul.js.org/",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/istanbuljs/istanbuljs.git",
    "directory": "packages/istanbul-lib-source-maps"
  },
  "keywords": [
    "istanbul",
    "sourcemaps",
    "sourcemap",
    "source",
    "maps"
  ],
  "engines": {
    "node": ">=10"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\istanbul-reports\package.json
============================================================
{
  "name": "istanbul-reports",
  "version": "3.2.0",
  "description": "istanbul reports",
  "author": "Krishnan Anantheswaran <kananthmail-github@yahoo.com>",
  "main": "index.js",
  "files": [
    "index.js",
    "lib"
  ],
  "scripts": {
    "test": "nyc mocha --recursive",
    "prepare": "webpack --config lib/html-spa/webpack.config.js --mode production",
    "prepare:watch": "webpack --config lib/html-spa/webpack.config.js --watch --mode development"
  },
  "dependencies": {
    "html-escaper": "^2.0.0",
    "istanbul-lib-report": "^3.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.7.5",
    "@babel/preset-env": "^7.7.5",
    "@babel/preset-react": "^7.7.4",
    "babel-loader": "^8.0.6",
    "chai": "^4.2.0",
    "is-windows": "^1.0.2",
    "istanbul-lib-coverage": "^3.0.0",
    "mocha": "^6.2.2",
    "nyc": "^15.0.0-beta.2",
    "react": "^16.12.0",
    "react-dom": "^16.12.0",
    "webpack": "^4.41.2",
    "webpack-cli": "^3.3.10"
  },
  "license": "BSD-3-Clause",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/istanbuljs/istanbuljs.git",
    "directory": "packages/istanbul-reports"
  },
  "keywords": [
    "istanbul",
    "reports"
  ],
  "bugs": {
    "url": "https://github.com/istanbuljs/istanbuljs/issues"
  },
  "homepage": "https://istanbul.js.org/",
  "nyc": {
    "exclude": [
      "lib/html/assets/**",
      "lib/html-spa/assets/**",
      "lib/html-spa/rollup.config.js",
      "test/**"
    ]
  },
  "engines": {
    "node": ">=8"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jackspeak\dist\commonjs\package.json
============================================================
{
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jackspeak\dist\esm\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jackspeak\package.json
============================================================
{
  "name": "jackspeak",
  "publishConfig": {
    "tag": "v3-legacy"
  },
  "version": "3.4.3",
  "description": "A very strict and proper argument parser.",
  "tshy": {
    "main": true,
    "exports": {
      "./package.json": "./package.json",
      ".": "./src/index.js"
    }
  },
  "main": "./dist/commonjs/index.js",
  "types": "./dist/commonjs/index.d.ts",
  "type": "module",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.js"
      }
    }
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "build-examples": "for i in examples/*.js ; do node $i -h > ${i/.js/.txt}; done",
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags",
    "prepare": "tshy",
    "pretest": "npm run prepare",
    "presnap": "npm run prepare",
    "test": "tap",
    "snap": "tap",
    "format": "prettier --write . --log-level warn",
    "typedoc": "typedoc --tsconfig .tshy/esm.json ./src/*.ts"
  },
  "license": "BlueOak-1.0.0",
  "prettier": {
    "experimentalTernaries": true,
    "semi": false,
    "printWidth": 75,
    "tabWidth": 2,
    "useTabs": false,
    "singleQuote": true,
    "jsxSingleQuote": false,
    "bracketSameLine": true,
    "arrowParens": "avoid",
    "endOfLine": "lf"
  },
  "devDependencies": {
    "@types/node": "^20.7.0",
    "@types/pkgjs__parseargs": "^0.10.1",
    "prettier": "^3.2.5",
    "tap": "^18.8.0",
    "tshy": "^1.14.0",
    "typedoc": "^0.25.1",
    "typescript": "^5.2.2"
  },
  "dependencies": {
    "@isaacs/cliui": "^8.0.2"
  },
  "funding": {
    "url": "https://github.com/sponsors/isaacs"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/isaacs/jackspeak.git"
  },
  "keywords": [
    "argument",
    "parser",
    "args",
    "option",
    "flag",
    "cli",
    "command",
    "line",
    "parse",
    "parsing"
  ],
  "author": "Isaac Z. Schlueter <i@izs.me>",
  "optionalDependencies": {
    "@pkgjs/parseargs": "^0.11.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest\package.json
============================================================
{
  "name": "jest",
  "description": "Delightful JavaScript Testing.",
  "version": "30.2.0",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json",
    "./bin/jest": "./bin/jest.js"
  },
  "dependencies": {
    "@jest/core": "30.2.0",
    "@jest/types": "30.2.0",
    "import-local": "^3.2.0",
    "jest-cli": "30.2.0"
  },
  "peerDependencies": {
    "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
  },
  "peerDependenciesMeta": {
    "node-notifier": {
      "optional": true
    }
  },
  "bin": "./bin/jest.js",
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest"
  },
  "homepage": "https://jestjs.io/",
  "license": "MIT",
  "keywords": [
    "ava",
    "babel",
    "coverage",
    "easy",
    "expect",
    "facebook",
    "immersive",
    "instant",
    "jasmine",
    "jest",
    "jsdom",
    "mocha",
    "mocking",
    "painless",
    "qunit",
    "runner",
    "sandboxed",
    "snapshot",
    "tap",
    "tape",
    "test",
    "testing",
    "typescript",
    "watch"
  ],
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-changed-files\package.json
============================================================
{
  "name": "jest-changed-files",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-changed-files"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "execa": "^5.1.1",
    "jest-util": "30.2.0",
    "p-limit": "^3.1.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-circus\node_modules\ansi-styles\package.json
============================================================
{
	"name": "ansi-styles",
	"version": "5.2.0",
	"description": "ANSI escape codes for styling strings in the terminal",
	"license": "MIT",
	"repository": "chalk/ansi-styles",
	"funding": "https://github.com/chalk/ansi-styles?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"screenshot": "svg-term --command='node screenshot' --out=screenshot.svg --padding=3 --width=55 --height=3 --at=1000 --no-cursor"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"devDependencies": {
		"ava": "^2.4.0",
		"svg-term-cli": "^2.1.1",
		"tsd": "^0.14.0",
		"xo": "^0.37.1"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-circus\node_modules\pretty-format\package.json
============================================================
{
  "name": "pretty-format",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/pretty-format"
  },
  "license": "MIT",
  "description": "Stringify any JavaScript value.",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "author": "James Kyle <me@thejameskyle.com>",
  "dependencies": {
    "@jest/schemas": "30.0.5",
    "ansi-styles": "^5.2.0",
    "react-is": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.23",
    "@types/react-is": "^18.3.1",
    "@types/react-test-renderer": "^18.3.1",
    "immutable": "^5.1.2",
    "jest-util": "30.2.0",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-test-renderer": "18.3.1"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-circus\node_modules\react-is\package.json
============================================================
{
  "name": "react-is",
  "version": "18.3.1",
  "description": "Brand checking of React Elements.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react-is"
  },
  "keywords": [
    "react"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/facebook/react/issues"
  },
  "homepage": "https://reactjs.org/",
  "files": [
    "LICENSE",
    "README.md",
    "index.js",
    "cjs/",
    "umd/"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-circus\package.json
============================================================
{
  "name": "jest-circus",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-circus"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json",
    "./runner": "./build/runner.js"
  },
  "dependencies": {
    "@jest/environment": "30.2.0",
    "@jest/expect": "30.2.0",
    "@jest/test-result": "30.2.0",
    "@jest/types": "30.2.0",
    "@types/node": "*",
    "chalk": "^4.1.2",
    "co": "^4.6.0",
    "dedent": "^1.6.0",
    "is-generator-fn": "^2.1.0",
    "jest-each": "30.2.0",
    "jest-matcher-utils": "30.2.0",
    "jest-message-util": "30.2.0",
    "jest-runtime": "30.2.0",
    "jest-snapshot": "30.2.0",
    "jest-util": "30.2.0",
    "p-limit": "^3.1.0",
    "pretty-format": "30.2.0",
    "pure-rand": "^7.0.0",
    "slash": "^3.0.0",
    "stack-utils": "^2.0.6"
  },
  "devDependencies": {
    "@babel/core": "^7.27.4",
    "@babel/register": "^7.27.1",
    "@types/co": "^4.6.6",
    "@types/graceful-fs": "^4.1.9",
    "@types/stack-utils": "^2.0.3",
    "execa": "^5.1.1",
    "graceful-fs": "^4.2.11",
    "tempy": "^1.0.1"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-cli\package.json
============================================================
{
  "name": "jest-cli",
  "description": "Delightful JavaScript Testing.",
  "version": "30.2.0",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json",
    "./bin/jest": "./bin/jest.js"
  },
  "dependencies": {
    "@jest/core": "30.2.0",
    "@jest/test-result": "30.2.0",
    "@jest/types": "30.2.0",
    "chalk": "^4.1.2",
    "exit-x": "^0.2.2",
    "import-local": "^3.2.0",
    "jest-config": "30.2.0",
    "jest-util": "30.2.0",
    "jest-validate": "30.2.0",
    "yargs": "^17.7.2"
  },
  "devDependencies": {
    "@types/yargs": "^17.0.33"
  },
  "peerDependencies": {
    "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
  },
  "peerDependenciesMeta": {
    "node-notifier": {
      "optional": true
    }
  },
  "bin": {
    "jest": "./bin/jest.js"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-cli"
  },
  "bugs": {
    "url": "https://github.com/jestjs/jest/issues"
  },
  "homepage": "https://jestjs.io/",
  "license": "MIT",
  "keywords": [
    "ava",
    "babel",
    "coverage",
    "easy",
    "expect",
    "facebook",
    "immersive",
    "instant",
    "jasmine",
    "jest",
    "jsdom",
    "mocha",
    "mocking",
    "painless",
    "qunit",
    "runner",
    "sandboxed",
    "snapshot",
    "tap",
    "tape",
    "test",
    "testing",
    "typescript",
    "watch"
  ],
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-config\node_modules\ansi-styles\package.json
============================================================
{
	"name": "ansi-styles",
	"version": "5.2.0",
	"description": "ANSI escape codes for styling strings in the terminal",
	"license": "MIT",
	"repository": "chalk/ansi-styles",
	"funding": "https://github.com/chalk/ansi-styles?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"screenshot": "svg-term --command='node screenshot' --out=screenshot.svg --padding=3 --width=55 --height=3 --at=1000 --no-cursor"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"devDependencies": {
		"ava": "^2.4.0",
		"svg-term-cli": "^2.1.1",
		"tsd": "^0.14.0",
		"xo": "^0.37.1"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-config\node_modules\pretty-format\package.json
============================================================
{
  "name": "pretty-format",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/pretty-format"
  },
  "license": "MIT",
  "description": "Stringify any JavaScript value.",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "author": "James Kyle <me@thejameskyle.com>",
  "dependencies": {
    "@jest/schemas": "30.0.5",
    "ansi-styles": "^5.2.0",
    "react-is": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.23",
    "@types/react-is": "^18.3.1",
    "@types/react-test-renderer": "^18.3.1",
    "immutable": "^5.1.2",
    "jest-util": "30.2.0",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-test-renderer": "18.3.1"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-config\node_modules\react-is\package.json
============================================================
{
  "name": "react-is",
  "version": "18.3.1",
  "description": "Brand checking of React Elements.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react-is"
  },
  "keywords": [
    "react"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/facebook/react/issues"
  },
  "homepage": "https://reactjs.org/",
  "files": [
    "LICENSE",
    "README.md",
    "index.js",
    "cjs/",
    "umd/"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-config\package.json
============================================================
{
  "name": "jest-config",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-config"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "peerDependencies": {
    "@types/node": "*",
    "esbuild-register": ">=3.4.0",
    "ts-node": ">=9.0.0"
  },
  "peerDependenciesMeta": {
    "@types/node": {
      "optional": true
    },
    "esbuild-register": {
      "optional": true
    },
    "ts-node": {
      "optional": true
    }
  },
  "dependencies": {
    "@babel/core": "^7.27.4",
    "@jest/get-type": "30.1.0",
    "@jest/pattern": "30.0.1",
    "@jest/test-sequencer": "30.2.0",
    "@jest/types": "30.2.0",
    "babel-jest": "30.2.0",
    "chalk": "^4.1.2",
    "ci-info": "^4.2.0",
    "deepmerge": "^4.3.1",
    "glob": "^10.3.10",
    "graceful-fs": "^4.2.11",
    "jest-circus": "30.2.0",
    "jest-docblock": "30.2.0",
    "jest-environment-node": "30.2.0",
    "jest-regex-util": "30.0.1",
    "jest-resolve": "30.2.0",
    "jest-runner": "30.2.0",
    "jest-util": "30.2.0",
    "jest-validate": "30.2.0",
    "micromatch": "^4.0.8",
    "parse-json": "^5.2.0",
    "pretty-format": "30.2.0",
    "slash": "^3.0.0",
    "strip-json-comments": "^3.1.1"
  },
  "devDependencies": {
    "@jest/test-utils": "30.2.0",
    "@types/graceful-fs": "^4.1.9",
    "@types/micromatch": "^4.0.9",
    "@types/parse-json": "^4.0.2",
    "esbuild": "^0.25.5",
    "esbuild-register": "^3.6.0",
    "semver": "^7.7.2",
    "ts-node": "^10.5.0",
    "typescript": "^5.8.3"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-diff\node_modules\ansi-styles\package.json
============================================================
{
	"name": "ansi-styles",
	"version": "5.2.0",
	"description": "ANSI escape codes for styling strings in the terminal",
	"license": "MIT",
	"repository": "chalk/ansi-styles",
	"funding": "https://github.com/chalk/ansi-styles?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"screenshot": "svg-term --command='node screenshot' --out=screenshot.svg --padding=3 --width=55 --height=3 --at=1000 --no-cursor"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"devDependencies": {
		"ava": "^2.4.0",
		"svg-term-cli": "^2.1.1",
		"tsd": "^0.14.0",
		"xo": "^0.37.1"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-diff\node_modules\pretty-format\package.json
============================================================
{
  "name": "pretty-format",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/pretty-format"
  },
  "license": "MIT",
  "description": "Stringify any JavaScript value.",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "author": "James Kyle <me@thejameskyle.com>",
  "dependencies": {
    "@jest/schemas": "30.0.5",
    "ansi-styles": "^5.2.0",
    "react-is": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.23",
    "@types/react-is": "^18.3.1",
    "@types/react-test-renderer": "^18.3.1",
    "immutable": "^5.1.2",
    "jest-util": "30.2.0",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-test-renderer": "18.3.1"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-diff\node_modules\react-is\package.json
============================================================
{
  "name": "react-is",
  "version": "18.3.1",
  "description": "Brand checking of React Elements.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react-is"
  },
  "keywords": [
    "react"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/facebook/react/issues"
  },
  "homepage": "https://reactjs.org/",
  "files": [
    "LICENSE",
    "README.md",
    "index.js",
    "cjs/",
    "umd/"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-diff\package.json
============================================================
{
  "name": "jest-diff",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-diff"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/diff-sequences": "30.0.1",
    "@jest/get-type": "30.1.0",
    "chalk": "^4.1.2",
    "pretty-format": "30.2.0"
  },
  "devDependencies": {
    "@jest/test-utils": "30.2.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-docblock\package.json
============================================================
{
  "name": "jest-docblock",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-docblock"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "detect-newline": "^3.1.0"
  },
  "devDependencies": {
    "@types/node": "*"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-each\node_modules\ansi-styles\package.json
============================================================
{
	"name": "ansi-styles",
	"version": "5.2.0",
	"description": "ANSI escape codes for styling strings in the terminal",
	"license": "MIT",
	"repository": "chalk/ansi-styles",
	"funding": "https://github.com/chalk/ansi-styles?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"screenshot": "svg-term --command='node screenshot' --out=screenshot.svg --padding=3 --width=55 --height=3 --at=1000 --no-cursor"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"devDependencies": {
		"ava": "^2.4.0",
		"svg-term-cli": "^2.1.1",
		"tsd": "^0.14.0",
		"xo": "^0.37.1"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-each\node_modules\pretty-format\package.json
============================================================
{
  "name": "pretty-format",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/pretty-format"
  },
  "license": "MIT",
  "description": "Stringify any JavaScript value.",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "author": "James Kyle <me@thejameskyle.com>",
  "dependencies": {
    "@jest/schemas": "30.0.5",
    "ansi-styles": "^5.2.0",
    "react-is": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.23",
    "@types/react-is": "^18.3.1",
    "@types/react-test-renderer": "^18.3.1",
    "immutable": "^5.1.2",
    "jest-util": "30.2.0",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-test-renderer": "18.3.1"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-each\node_modules\react-is\package.json
============================================================
{
  "name": "react-is",
  "version": "18.3.1",
  "description": "Brand checking of React Elements.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react-is"
  },
  "keywords": [
    "react"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/facebook/react/issues"
  },
  "homepage": "https://reactjs.org/",
  "files": [
    "LICENSE",
    "README.md",
    "index.js",
    "cjs/",
    "umd/"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-each\package.json
============================================================
{
  "name": "jest-each",
  "version": "30.2.0",
  "description": "Parameterised tests for Jest",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-each"
  },
  "keywords": [
    "jest",
    "parameterised",
    "test",
    "each"
  ],
  "author": "Matt Phillips (mattphillips)",
  "license": "MIT",
  "dependencies": {
    "@jest/get-type": "30.1.0",
    "@jest/types": "30.2.0",
    "chalk": "^4.1.2",
    "jest-util": "30.2.0",
    "pretty-format": "30.2.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-environment-jsdom\node_modules\@asamuzakjp\css-color\package.json
============================================================
{
  "name": "@asamuzakjp/css-color",
  "description": "CSS color - Resolve and convert CSS colors.",
  "author": "asamuzaK",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/asamuzaK/cssColor.git"
  },
  "homepage": "https://github.com/asamuzaK/cssColor#readme",
  "bugs": {
    "url": "https://github.com/asamuzaK/cssColor/issues"
  },
  "files": [
    "dist",
    "src"
  ],
  "type": "module",
  "types": "dist/esm/index.d.ts",
  "module": "dist/esm/index.js",
  "main": "dist/cjs/index.cjs",
  "exports": {
    ".": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.js"
      },
      "require": {
        "types": "./dist/cjs/index.d.cts",
        "default": "./dist/cjs/index.cjs"
      }
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@csstools/css-calc": "^2.1.3",
    "@csstools/css-color-parser": "^3.0.9",
    "@csstools/css-parser-algorithms": "^3.0.4",
    "@csstools/css-tokenizer": "^3.0.3",
    "lru-cache": "^10.4.3"
  },
  "devDependencies": {
    "@tanstack/vite-config": "^0.2.0",
    "@vitest/coverage-istanbul": "^3.1.4",
    "esbuild": "^0.25.4",
    "eslint": "^9.27.0",
    "eslint-plugin-regexp": "^2.7.0",
    "globals": "^16.1.0",
    "knip": "^5.56.0",
    "neostandard": "^0.12.1",
    "prettier": "^3.5.3",
    "publint": "^0.3.12",
    "rimraf": "^6.0.1",
    "tsup": "^8.5.0",
    "typescript": "^5.8.3",
    "vite": "^6.3.5",
    "vitest": "^3.1.4"
  },
  "packageManager": "pnpm@10.11.0",
  "pnpm": {
    "onlyBuiltDependencies": [
      "esbuild",
      "unrs-resolver"
    ]
  },
  "scripts": {
    "build": "pnpm run clean && pnpm run test && pnpm run knip && pnpm run build:prod && pnpm run build:cjs && pnpm run build:browser && pnpm run publint",
    "build:browser": "vite build -c ./vite.browser.config.ts",
    "build:prod": "vite build",
    "build:cjs": "tsup ./src/index.ts --format=cjs --platform=node --outDir=./dist/cjs/ --sourcemap --dts",
    "clean": "rimraf ./coverage ./dist",
    "knip": "knip",
    "prettier": "prettier . --ignore-unknown --write",
    "publint": "publint --strict",
    "test": "pnpm run prettier && pnpm run --stream \"/^test:.*/\"",
    "test:eslint": "eslint ./src ./test --fix",
    "test:types": "tsc",
    "test:unit": "vitest"
  },
  "version": "3.2.0"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-environment-jsdom\node_modules\cssstyle\package.json
============================================================
{
  "name": "cssstyle",
  "description": "CSSStyleDeclaration Object Model implementation",
  "keywords": [
    "CSS",
    "CSSStyleDeclaration",
    "StyleSheet"
  ],
  "version": "4.6.0",
  "homepage": "https://github.com/jsdom/cssstyle",
  "maintainers": [
    {
      "name": "Jon Sakas",
      "email": "jon.sakas@gmail.com",
      "url": "https://jon.sakas.co/"
    },
    {
      "name": "Rafał Ruciński",
      "email": "fatfisz@gmail.com",
      "url": "https://fatfisz.com"
    }
  ],
  "contributors": [
    {
      "name": "Chad Walker",
      "email": "chad@chad-cat-lore-eddie.com",
      "url": "https://github.com/chad3814"
    }
  ],
  "repository": "jsdom/cssstyle",
  "bugs": "https://github.com/jsdom/cssstyle/issues",
  "directories": {
    "lib": "./lib"
  },
  "files": [
    "lib/"
  ],
  "main": "./lib/CSSStyleDeclaration.js",
  "dependencies": {
    "@asamuzakjp/css-color": "^3.2.0",
    "rrweb-cssom": "^0.8.0"
  },
  "devDependencies": {
    "@babel/generator": "^7.26.9",
    "@babel/parser": "^7.26.9",
    "@babel/traverse": "^7.26.9",
    "@babel/types": "^7.26.9",
    "@domenic/eslint-config": "^4.0.1",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "globals": "^16.0.0",
    "npm-run-all": "^4.1.5",
    "prettier": "^3.5.3",
    "resolve": "^1.22.10"
  },
  "scripts": {
    "download": "node ./scripts/downloadLatestProperties.mjs",
    "generate": "run-p generate:*",
    "generate:implemented_properties": "node ./scripts/generateImplementedProperties.mjs",
    "generate:properties": "node ./scripts/generateProperties.js",
    "lint": "npm run generate && eslint --max-warnings 0",
    "lint:fix": "eslint --fix --max-warnings 0",
    "prepublishOnly": "npm run lint && npm run test",
    "test": "npm run generate && node --test",
    "test-ci": "npm run lint && npm run test"
  },
  "license": "MIT",
  "engines": {
    "node": ">=18"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-environment-jsdom\node_modules\data-urls\package.json
============================================================
{
  "name": "data-urls",
  "description": "Parses data: URLs",
  "keywords": [
    "data url",
    "data uri",
    "data:",
    "http",
    "fetch",
    "whatwg"
  ],
  "version": "5.0.0",
  "author": "Domenic Denicola <d@domenic.me> (https://domenic.me/)",
  "license": "MIT",
  "repository": "jsdom/data-urls",
  "main": "lib/parser.js",
  "files": [
    "lib/"
  ],
  "scripts": {
    "test": "node --test",
    "coverage": "c8 node --test --experimental-test-coverage",
    "lint": "eslint .",
    "pretest": "node scripts/get-latest-platform-tests.js"
  },
  "dependencies": {
    "whatwg-mimetype": "^4.0.0",
    "whatwg-url": "^14.0.0"
  },
  "devDependencies": {
    "@domenic/eslint-config": "^3.0.0",
    "c8": "^8.0.1",
    "eslint": "^8.53.0"
  },
  "engines": {
    "node": ">=18"
  },
  "c8": {
    "reporter": [
      "text",
      "html"
    ],
    "exclude": [
      "scripts/",
      "test/"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-environment-jsdom\node_modules\jsdom\lib\api.js
============================================================
"use strict";
const path = require("path");
const fs = require("fs").promises;
const vm = require("vm");
const toughCookie = require("tough-cookie");
const sniffHTMLEncoding = require("html-encoding-sniffer");
const whatwgURL = require("whatwg-url");
const whatwgEncoding = require("whatwg-encoding");
const { URL } = require("whatwg-url");
const MIMEType = require("whatwg-mimetype");
const idlUtils = require("./jsdom/living/generated/utils.js");
const VirtualConsole = require("./jsdom/virtual-console.js");
const { createWindow } = require("./jsdom/browser/Window.js");
const { parseIntoDocument } = require("./jsdom/browser/parser");
const { fragmentSerialization } = require("./jsdom/living/domparsing/serialization.js");
const ResourceLoader = require("./jsdom/browser/resources/resource-loader.js");
const NoOpResourceLoader = require("./jsdom/browser/resources/no-op-resource-loader.js");

class CookieJar extends toughCookie.CookieJar {
  constructor(store, options) {
    // jsdom cookie jars must be loose by default
    super(store, { looseMode: true, ...options });
  }
}

const window = Symbol("window");
let sharedFragmentDocument = null;

class JSDOM {
  constructor(input = "", options = {}) {
    const mimeType = new MIMEType(options.contentType === undefined ? "text/html" : options.contentType);
    const { html, encoding } = normalizeHTML(input, mimeType);

    options = transformOptions(options, encoding, mimeType);

    this[window] = createWindow(options.windowOptions);

    const documentImpl = idlUtils.implForWrapper(this[window]._document);

    options.beforeParse(this[window]._globalProxy);

    parseIntoDocument(html, documentImpl);

    documentImpl.close();
  }

  get window() {
    // It's important to grab the global proxy, instead of just the result of `createWindow(...)`, since otherwise
    // things like `window.eval` don't exist.
    return this[window]._globalProxy;
  }

  get virtualConsole() {
    return this[window]._virtualConsole;
  }

  get cookieJar() {
    // TODO NEWAPI move _cookieJar to window probably
    return idlUtils.implForWrapper(this[window]._document)._cookieJar;
  }

  serialize() {
    return fragmentSerialization(idlUtils.implForWrapper(this[window]._document), { requireWellFormed: false });
  }

  nodeLocation(node) {
    if (!idlUtils.implForWrapper(this[window]._document)._parseOptions.sourceCodeLocationInfo) {
      throw new Error("Location information was not saved for this jsdom. Use includeNodeLocations during creation.");
    }

    return idlUtils.implForWrapper(node).sourceCodeLocation;
  }

  getInternalVMContext() {
    if (!vm.isContext(this[window])) {
      throw new TypeError("This jsdom was not configured to allow script running. " +
        "Use the runScripts option during creation.");
    }

    return this[window];
  }

  reconfigure(settings) {
    if ("windowTop" in settings) {
      this[window]._top = settings.windowTop;
    }

    if ("url" in settings) {
      const document = idlUtils.implForWrapper(this[window]._document);

      const url = whatwgURL.parseURL(settings.url);
      if (url === null) {
        throw new TypeError(`Could not parse "${settings.url}" as a URL`);
      }

      document._URL = url;
      document._origin = whatwgURL.serializeURLOrigin(document._URL);
      this[window]._sessionHistory.currentEntry.url = url;
    }
  }

  static fragment(string = "") {
    if (!sharedFragmentDocument) {
      sharedFragmentDocument = (new JSDOM()).window.document;
    }

    const template = sharedFragmentDocument.createElement("template");
    template.innerHTML = string;
    return template.content;
  }

  static fromURL(url, options = {}) {
    return Promise.resolve().then(() => {
      // Remove the hash while sending this through the research loader fetch().
      // It gets added back a few lines down when constructing the JSDOM object.
      const parsedURL = new URL(url);
      const originalHash = parsedURL.hash;
      parsedURL.hash = "";
      url = parsedURL.href;

      options = normalizeFromURLOptions(options);

      const resourceLoader = resourcesToResourceLoader(options.resources);
      const resourceLoaderForInitialRequest = resourceLoader.constructor === NoOpResourceLoader ?
        new ResourceLoader() :
        resourceLoader;

      const req = resourceLoaderForInitialRequest.fetch(url, {
        accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        cookieJar: options.cookieJar,
        referrer: options.referrer
      });

      return req.then(body => {
        const res = req.response;

        options = Object.assign(options, {
          url: req.href + originalHash,
          contentType: res.headers["content-type"],
          referrer: req.getHeader("referer") ?? undefined
        });

        return new JSDOM(body, options);
      });
    });
  }

  static async fromFile(filename, options = {}) {
    options = normalizeFromFileOptions(filename, options);
    const buffer = await fs.readFile(filename);

    return new JSDOM(buffer, options);
  }
}

function normalizeFromURLOptions(options) {
  // Checks on options that are invalid for `fromURL`
  if (options.url !== undefined) {
    throw new TypeError("Cannot supply a url option when using fromURL");
  }
  if (options.contentType !== undefined) {
    throw new TypeError("Cannot supply a contentType option when using fromURL");
  }

  // Normalization of options which must be done before the rest of the fromURL code can use them, because they are
  // given to request()
  const normalized = { ...options };

  if (options.referrer !== undefined) {
    normalized.referrer = (new URL(options.referrer)).href;
  }

  if (options.cookieJar === undefined) {
    normalized.cookieJar = new CookieJar();
  }

  return normalized;

  // All other options don't need to be processed yet, and can be taken care of in the normal course of things when
  // `fromURL` calls `new JSDOM(html, options)`.
}

function normalizeFromFileOptions(filename, options) {
  const normalized = { ...options };

  if (normalized.contentType === undefined) {
    const extname = path.extname(filename);
    if (extname === ".xhtml" || extname === ".xht" || extname === ".xml") {
      normalized.contentType = "application/xhtml+xml";
    }
  }

  if (normalized.url === undefined) {
    normalized.url = new URL("file:" + path.resolve(filename));
  }

  return normalized;
}

function transformOptions(options, encoding, mimeType) {
  const transformed = {
    windowOptions: {
      // Defaults
      url: "about:blank",
      referrer: "",
      contentType: "text/html",
      parsingMode: "html",
      parseOptions: {
        sourceCodeLocationInfo: false,
        scriptingEnabled: false
      },
      runScripts: undefined,
      encoding,
      pretendToBeVisual: false,
      storageQuota: 5000000,

      // Defaults filled in later
      resourceLoader: undefined,
      virtualConsole: undefined,
      cookieJar: undefined
    },

    // Defaults
    beforeParse() { }
  };

  // options.contentType was parsed into mimeType by the caller.
  if (!mimeType.isHTML() && !mimeType.isXML()) {
    throw new RangeError(`The given content type of "${options.contentType}" was not a HTML or XML content type`);
  }

  transformed.windowOptions.contentType = mimeType.essence;
  transformed.windowOptions.parsingMode = mimeType.isHTML() ? "html" : "xml";

  if (options.url !== undefined) {
    transformed.windowOptions.url = (new URL(options.url)).href;
  }

  if (options.referrer !== undefined) {
    transformed.windowOptions.referrer = (new URL(options.referrer)).href;
  }

  if (options.includeNodeLocations) {
    if (transformed.windowOptions.parsingMode === "xml") {
      throw new TypeError("Cannot set includeNodeLocations to true with an XML content type");
    }

    transformed.windowOptions.parseOptions = { sourceCodeLocationInfo: true };
  }

  transformed.windowOptions.cookieJar = options.cookieJar === undefined ?
                                       new CookieJar() :
                                       options.cookieJar;

  transformed.windowOptions.virtualConsole = options.virtualConsole === undefined ?
                                            (new VirtualConsole()).sendTo(console) :
                                            options.virtualConsole;

  if (!(transformed.windowOptions.virtualConsole instanceof VirtualConsole)) {
    throw new TypeError("virtualConsole must be an instance of VirtualConsole");
  }

  transformed.windowOptions.resourceLoader = resourcesToResourceLoader(options.resources);

  if (options.runScripts !== undefined) {
    transformed.windowOptions.runScripts = String(options.runScripts);
    if (transformed.windowOptions.runScripts === "dangerously") {
      transformed.windowOptions.parseOptions.scriptingEnabled = true;
    } else if (transformed.windowOptions.runScripts !== "outside-only") {
      throw new RangeError(`runScripts must be undefined, "dangerously", or "outside-only"`);
    }
  }

  if (options.beforeParse !== undefined) {
    transformed.beforeParse = options.beforeParse;
  }

  if (options.pretendToBeVisual !== undefined) {
    transformed.windowOptions.pretendToBeVisual = Boolean(options.pretendToBeVisual);
  }

  if (options.storageQuota !== undefined) {
    transformed.windowOptions.storageQuota = Number(options.storageQuota);
  }

  return transformed;
}

function normalizeHTML(html, mimeType) {
  let encoding = "UTF-8";

  if (ArrayBuffer.isView(html)) {
    html = Buffer.from(html.buffer, html.byteOffset, html.byteLength);
  } else if (html instanceof ArrayBuffer) {
    html = Buffer.from(html);
  }

  if (Buffer.isBuffer(html)) {
    encoding = sniffHTMLEncoding(html, {
      defaultEncoding: mimeType.isXML() ? "UTF-8" : "windows-1252",
      transportLayerEncodingLabel: mimeType.parameters.get("charset")
    });
    html = whatwgEncoding.decode(html, encoding);
  } else {
    html = String(html);
  }

  return { html, encoding };
}

function resourcesToResourceLoader(resources) {
  switch (resources) {
    case undefined: {
      return new NoOpResourceLoader();
    }
    case "usable": {
      return new ResourceLoader();
    }
    default: {
      if (!(resources instanceof ResourceLoader)) {
        throw new TypeError("resources must be an instance of ResourceLoader");
      }
      return resources;
    }
  }
}

exports.JSDOM = JSDOM;

exports.VirtualConsole = VirtualConsole;
exports.CookieJar = CookieJar;
exports.ResourceLoader = ResourceLoader;

exports.toughCookie = toughCookie;

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-environment-jsdom\node_modules\jsdom\package.json
============================================================
{
  "name": "jsdom",
  "version": "26.1.0",
  "description": "A JavaScript implementation of many web standards",
  "keywords": [
    "dom",
    "html",
    "whatwg",
    "w3c"
  ],
  "maintainers": [
    "Elijah Insua <tmpvar@gmail.com> (http://tmpvar.com)",
    "Domenic Denicola <d@domenic.me> (https://domenic.me/)",
    "Sebastian Mayr <sebmaster16@gmail.com> (https://blog.smayr.name/)",
    "Joris van der Wel <joris@jorisvanderwel.com>",
    "Timothy Gu <timothygu99@gmail.com> (https://timothygu.me/)",
    "Magne Andersson <code@zirro.se> (https://zirro.se/)",
    "Pierre-Marie Dartus <dartus.pierremarie@gmail.com>"
  ],
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jsdom/jsdom.git"
  },
  "dependencies": {
    "cssstyle": "^4.2.1",
    "data-urls": "^5.0.0",
    "decimal.js": "^10.5.0",
    "html-encoding-sniffer": "^4.0.0",
    "http-proxy-agent": "^7.0.2",
    "https-proxy-agent": "^7.0.6",
    "is-potential-custom-element-name": "^1.0.1",
    "nwsapi": "^2.2.16",
    "parse5": "^7.2.1",
    "rrweb-cssom": "^0.8.0",
    "saxes": "^6.0.0",
    "symbol-tree": "^3.2.4",
    "tough-cookie": "^5.1.1",
    "w3c-xmlserializer": "^5.0.0",
    "webidl-conversions": "^7.0.0",
    "whatwg-encoding": "^3.1.1",
    "whatwg-mimetype": "^4.0.0",
    "whatwg-url": "^14.1.1",
    "ws": "^8.18.0",
    "xml-name-validator": "^5.0.0"
  },
  "peerDependencies": {
    "canvas": "^3.0.0"
  },
  "peerDependenciesMeta": {
    "canvas": {
      "optional": true
    }
  },
  "devDependencies": {
    "@domenic/eslint-config": "^4.0.1",
    "benchmark": "^2.1.4",
    "eslint": "^9.20.0",
    "eslint-plugin-html": "^8.1.2",
    "globals": "^15.14.0",
    "js-yaml": "^4.1.0",
    "minimatch": "^9.0.5",
    "mocha": "^11.1.0",
    "mocha-sugar-free": "^1.4.0",
    "pngjs": "^7.0.0",
    "server-destroy": "^1.0.1",
    "webidl2js": "^18.0.0",
    "yargs": "^17.7.2"
  },
  "scripts": {
    "prepare": "npm run convert-idl && npm run generate-js-globals",
    "pretest": "npm run prepare && npm run init-wpt",
    "test-wpt": "mocha test/web-platform-tests/run-wpts.js",
    "test-tuwpt": "mocha test/web-platform-tests/run-tuwpts.js",
    "test-mocha": "mocha",
    "test-api": "mocha test/api",
    "test": "mocha test/index.js",
    "lint": "eslint --cache",
    "init-wpt": "git submodule update --init --recursive",
    "reset-wpt": "rm -rf ./test/web-platform-tests/tests && npm run init-wpt",
    "update-wpt": "git submodule update --init --recursive --remote && cd test/web-platform-tests/tests && python wpt.py manifest --path ../wpt-manifest.json",
    "update-authors": "git log --format=\"%aN <%aE>\" | sort -f | uniq > AUTHORS.txt",
    "benchmark": "node ./benchmark/runner",
    "convert-idl": "node ./scripts/webidl/convert.js",
    "generate-js-globals": "node ./scripts/generate-js-globals.js"
  },
  "main": "./lib/api.js",
  "type": "commonjs",
  "engines": {
    "node": ">=18"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-environment-jsdom\node_modules\lru-cache\dist\commonjs\package.json
============================================================
{
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-environment-jsdom\node_modules\lru-cache\dist\esm\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-environment-jsdom\node_modules\lru-cache\package.json
============================================================
{
  "name": "lru-cache",
  "publishConfig": {
    "tag": "legacy-v10"
  },
  "description": "A cache object that deletes the least-recently-used items.",
  "version": "10.4.3",
  "author": "Isaac Z. Schlueter <i@izs.me>",
  "keywords": [
    "mru",
    "lru",
    "cache"
  ],
  "sideEffects": false,
  "scripts": {
    "build": "npm run prepare",
    "prepare": "tshy && bash fixup.sh",
    "pretest": "npm run prepare",
    "presnap": "npm run prepare",
    "test": "tap",
    "snap": "tap",
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags",
    "format": "prettier --write .",
    "typedoc": "typedoc --tsconfig ./.tshy/esm.json ./src/*.ts",
    "benchmark-results-typedoc": "bash scripts/benchmark-results-typedoc.sh",
    "prebenchmark": "npm run prepare",
    "benchmark": "make -C benchmark",
    "preprofile": "npm run prepare",
    "profile": "make -C benchmark profile"
  },
  "main": "./dist/commonjs/index.js",
  "types": "./dist/commonjs/index.d.ts",
  "tshy": {
    "exports": {
      ".": "./src/index.ts",
      "./min": {
        "import": {
          "types": "./dist/esm/index.d.ts",
          "default": "./dist/esm/index.min.js"
        },
        "require": {
          "types": "./dist/commonjs/index.d.ts",
          "default": "./dist/commonjs/index.min.js"
        }
      }
    }
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/node-lru-cache.git"
  },
  "devDependencies": {
    "@types/node": "^20.2.5",
    "@types/tap": "^15.0.6",
    "benchmark": "^2.1.4",
    "esbuild": "^0.17.11",
    "eslint-config-prettier": "^8.5.0",
    "marked": "^4.2.12",
    "mkdirp": "^2.1.5",
    "prettier": "^2.6.2",
    "tap": "^20.0.3",
    "tshy": "^2.0.0",
    "tslib": "^2.4.0",
    "typedoc": "^0.25.3",
    "typescript": "^5.2.2"
  },
  "license": "ISC",
  "files": [
    "dist"
  ],
  "prettier": {
    "semi": false,
    "printWidth": 70,
    "tabWidth": 2,
    "useTabs": false,
    "singleQuote": true,
    "jsxSingleQuote": false,
    "bracketSameLine": true,
    "arrowParens": "avoid",
    "endOfLine": "lf"
  },
  "tap": {
    "node-arg": [
      "--expose-gc"
    ],
    "plugin": [
      "@tapjs/clock"
    ]
  },
  "exports": {
    ".": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.js"
      }
    },
    "./min": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.min.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.min.js"
      }
    }
  },
  "type": "module",
  "module": "./dist/esm/index.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-environment-jsdom\node_modules\tldts\package.json
============================================================
{
  "name": "tldts",
  "version": "6.1.86",
  "description": "Library to work against complex domain names, subdomains and URIs.",
  "author": {
    "name": "Rémi Berson"
  },
  "contributors": [
    "Alexei <alexeiatyahoodotcom@gmail.com>",
    "Alexey <kureev-mail@ya.ru>",
    "Andrew <chefandrew@seomoz.org>",
    "Johannes Ewald <johannes.ewald@peerigon.com>",
    "Jérôme Desboeufs <jerome.desboeufs@gmail.com>",
    "Kelly Campbell <kelly.a.campbell@gmail.com>",
    "Kiko Beats <josefrancisco.verdu@gmail.com>",
    "Kris Reeves <krisreeves@searchfanatics.com>",
    "Krzysztof Jan Modras <chrmod@chrmod.net>",
    "Olivier Melcher <olivier.melcher@gmail.com>",
    "Rémi Berson <remi.berson@pm.me>",
    "Saad Rashid <srashid@lendinghome.com>",
    "Thomas Parisot <hi@oncletom.io>",
    "Timo Tijhof <krinklemail@gmail.com>",
    "Xavier Damman <xdamman@gmail.com>",
    "Yehezkiel Syamsuhadi <yehezkielbs@gmail.com>"
  ],
  "publishConfig": {
    "access": "public"
  },
  "license": "MIT",
  "homepage": "https://github.com/remusao/tldts#readme",
  "bugs": {
    "url": "https://github.com/remusao/tldts/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/remusao/tldts.git"
  },
  "main": "dist/cjs/index.js",
  "module": "dist/es6/index.js",
  "types": "dist/types/index.d.ts",
  "files": [
    "dist",
    "src",
    "index.ts"
  ],
  "bin": {
    "tldts": "bin/cli.js"
  },
  "scripts": {
    "clean": "rimraf dist coverage",
    "build": "tsc --build ./tsconfig.json",
    "bundle": "tsc --build ./tsconfig.bundle.json && rollup --config ./rollup.config.mjs",
    "prepack": "yarn run bundle",
    "test": "nyc mocha --config ../../.mocharc.cjs"
  },
  "devDependencies": {
    "@rollup/plugin-node-resolve": "^16.0.0",
    "@rollup/plugin-terser": "^0.4.0",
    "@rollup/plugin-typescript": "^12.1.0",
    "@types/chai": "^4.2.18",
    "@types/mocha": "^10.0.0",
    "@types/node": "^22.0.0",
    "chai": "^4.4.1",
    "mocha": "^11.0.1",
    "nyc": "^17.0.0",
    "rimraf": "^5.0.1",
    "rollup": "^4.1.0",
    "rollup-plugin-sourcemaps": "^0.6.1",
    "tldts-tests": "^6.1.86",
    "typescript": "^5.0.4"
  },
  "dependencies": {
    "tldts-core": "^6.1.86"
  },
  "keywords": [
    "tld",
    "sld",
    "domain",
    "subdomain",
    "subdomain",
    "hostname",
    "browser",
    "uri",
    "url",
    "domain name",
    "public suffix",
    "url parsing",
    "typescript"
  ],
  "gitHead": "94251baa0e4ee46df6fd06fcd3749fcdf9b14ebc"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-environment-jsdom\node_modules\tldts-core\package.json
============================================================
{
  "name": "tldts-core",
  "version": "6.1.86",
  "description": "tldts core primitives (internal module)",
  "author": {
    "name": "Rémi Berson"
  },
  "contributors": [
    "Alexei <alexeiatyahoodotcom@gmail.com>",
    "Alexey <kureev-mail@ya.ru>",
    "Andrew <chefandrew@seomoz.org>",
    "Johannes Ewald <johannes.ewald@peerigon.com>",
    "Jérôme Desboeufs <jerome.desboeufs@gmail.com>",
    "Kelly Campbell <kelly.a.campbell@gmail.com>",
    "Kiko Beats <josefrancisco.verdu@gmail.com>",
    "Kris Reeves <krisreeves@searchfanatics.com>",
    "Krzysztof Jan Modras <chrmod@chrmod.net>",
    "Olivier Melcher <olivier.melcher@gmail.com>",
    "Rémi Berson <remi.berson@pm.me>",
    "Saad Rashid <srashid@lendinghome.com>",
    "Thomas Parisot <hi@oncletom.io>",
    "Timo Tijhof <krinklemail@gmail.com>",
    "Xavier Damman <xdamman@gmail.com>",
    "Yehezkiel Syamsuhadi <yehezkielbs@gmail.com>"
  ],
  "publishConfig": {
    "access": "public"
  },
  "license": "MIT",
  "homepage": "https://github.com/remusao/tldts#readme",
  "bugs": {
    "url": "https://github.com/remusao/tldts/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/remusao/tldts.git"
  },
  "main": "dist/cjs/index.js",
  "module": "dist/es6/index.js",
  "types": "dist/types/index.d.ts",
  "files": [
    "dist",
    "src",
    "index.ts"
  ],
  "scripts": {
    "clean": "rimraf dist",
    "build": "tsc --build ./tsconfig.json",
    "bundle": "tsc --build ./tsconfig.bundle.json && rollup --config ./rollup.config.ts --configPlugin typescript",
    "prepack": "yarn run bundle",
    "test": "nyc mocha --config ../../.mocharc.cjs"
  },
  "devDependencies": {
    "@rollup/plugin-node-resolve": "^16.0.0",
    "@rollup/plugin-typescript": "^12.1.0",
    "@types/chai": "^4.2.18",
    "@types/mocha": "^10.0.0",
    "@types/node": "^22.0.0",
    "chai": "^4.4.1",
    "mocha": "^11.0.1",
    "nyc": "^17.0.0",
    "rimraf": "^5.0.1",
    "rollup": "^4.1.0",
    "rollup-plugin-sourcemaps": "^0.6.1",
    "typescript": "^5.0.4"
  },
  "gitHead": "94251baa0e4ee46df6fd06fcd3749fcdf9b14ebc"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-environment-jsdom\node_modules\tough-cookie\package.json
============================================================
{
  "author": {
    "name": "Jeremy Stashewsky",
    "email": "jstash@gmail.com",
    "website": "https://github.com/stash"
  },
  "contributors": [
    {
      "name": "Ivan Nikulin",
      "website": "https://github.com/inikulin"
    },
    {
      "name": "Shivan Kaul Sahib",
      "website": "https://github.com/ShivanKaul"
    },
    {
      "name": "Clint Ruoho",
      "website": "https://github.com/ruoho"
    },
    {
      "name": "Ian Livingstone",
      "website": "https://github.com/ianlivingstone"
    },
    {
      "name": "Andrew Waterman",
      "website": "https://github.com/awaterma"
    },
    {
      "name": "Michael de Libero ",
      "website": "https://github.com/medelibero-sfdc"
    },
    {
      "name": "Jonathan Stewmon",
      "website": "https://github.com/jstewmon"
    },
    {
      "name": "Miguel Roncancio",
      "website": "https://github.com/miggs125"
    },
    {
      "name": "Sebastian Mayr",
      "website": "https://github.com/Sebmaster"
    },
    {
      "name": "Alexander Savin",
      "website": "https://github.com/apsavin"
    },
    {
      "name": "Lalit Kapoor",
      "website": "https://github.com/lalitkapoor"
    },
    {
      "name": "Sam Thompson",
      "website": "https://github.com/sambthompson"
    },
    {
      "name": "Colin Casey",
      "website": "https://github.com/colincasey"
    },
    {
      "name": "Will Harney",
      "website": "https://github.com/wjhsf"
    }
  ],
  "license": "BSD-3-Clause",
  "name": "tough-cookie",
  "description": "RFC6265 Cookies and Cookie Jar for node.js",
  "keywords": [
    "HTTP",
    "cookie",
    "cookies",
    "set-cookie",
    "cookiejar",
    "jar",
    "RFC6265",
    "RFC2965"
  ],
  "version": "5.1.2",
  "homepage": "https://github.com/salesforce/tough-cookie",
  "repository": {
    "type": "git",
    "url": "git://github.com/salesforce/tough-cookie.git"
  },
  "bugs": {
    "url": "https://github.com/salesforce/tough-cookie/issues"
  },
  "main": "./dist/cookie/index.js",
  "types": "./dist/cookie/index.d.ts",
  "files": [
    "dist/**/*.js",
    "dist/**/*.d.ts",
    "!__tests__"
  ],
  "scripts": {
    "build": "npm run _build:clean && npm run _build:compile",
    "lint": "npm run _lint:check",
    "prepack": "npm run build",
    "prepare-pr": "npm test && npm run _api:update && npm run _docs:generate && npm run _format:fix && npm run _lint:fix",
    "test": "npm run build && npm run _test:ts && npm run _test:legacy",
    "version": "npm run _version:generate && npm run prepare-pr && git add --renormalize .",
    "_api:check": "api-extractor run --verbose",
    "_api:update": "api-extractor run --verbose --local",
    "_build:clean": "rm -rf dist",
    "_build:compile": "tsc",
    "_docs:generate": "api-documenter markdown --input-folder ./tmp --output-folder ./api/docs",
    "_docs:fix": "prettier ./api/docs --write",
    "_format:check": "prettier . --check",
    "_format:fix": "prettier . --write",
    "_lint:check": "eslint .",
    "_lint:fix": "eslint . --fix",
    "_test:legacy": "./test/scripts/vows.js test/*_test.js",
    "_test:ts": "jest",
    "_version:generate": "genversion --template version-template.ejs --force lib/version.ts"
  },
  "//": "We only support node 18+, but v16 still works. We won't block v16 until it becomes a burden.",
  "engines": {
    "node": ">=16"
  },
  "devDependencies": {
    "@eslint/js": "^9.7.0",
    "@microsoft/api-documenter": "^7.25.7",
    "@microsoft/api-extractor": "^7.47.2",
    "@types/jest": "^29.5.12",
    "@types/node": "^16.18.101",
    "async": "3.2.6",
    "eslint": "^9.9.1",
    "eslint-config-prettier": "^10.0.1",
    "eslint-import-resolver-typescript": "^3.7.0",
    "eslint-plugin-import": "^2.31.0",
    "eslint-plugin-prettier": "^5.2.1",
    "genversion": "^3.2.0",
    "globals": "^15.8.0",
    "jest": "^29.7.0",
    "prettier": "^3.3.3",
    "ts-jest": "^29.2.2",
    "ts-node": "^10.9.2",
    "typescript": "5.5.3",
    "typescript-eslint": "^8.0.1",
    "vows": "^0.8.3"
  },
  "dependencies": {
    "tldts": "^6.1.32"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-environment-jsdom\node_modules\tr46\package.json
============================================================
{
  "name": "tr46",
  "version": "5.1.1",
  "engines": {
    "node": ">=18"
  },
  "description": "An implementation of the Unicode UTS #46: Unicode IDNA Compatibility Processing",
  "main": "index.js",
  "files": [
    "index.js",
    "lib/"
  ],
  "scripts": {
    "test": "node --test",
    "lint": "eslint",
    "pretest": "node scripts/getLatestTests.js",
    "prepublish": "node scripts/generateMappingTable.js && node scripts/generateRegexes.js"
  },
  "repository": "https://github.com/jsdom/tr46",
  "keywords": [
    "unicode",
    "tr46",
    "uts46",
    "punycode",
    "url",
    "whatwg"
  ],
  "author": "Sebastian Mayr <npm@smayr.name>",
  "contributors": [
    "Timothy Gu <timothygu99@gmail.com>"
  ],
  "license": "MIT",
  "dependencies": {
    "punycode": "^2.3.1"
  },
  "devDependencies": {
    "@domenic/eslint-config": "^4.0.1",
    "@unicode/unicode-16.0.0": "^1.6.5",
    "eslint": "^9.22.0",
    "globals": "^16.0.0",
    "regenerate": "^1.4.2"
  },
  "unicodeVersion": "16.0.0"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-environment-jsdom\node_modules\webidl-conversions\package.json
============================================================
{
  "name": "webidl-conversions",
  "version": "7.0.0",
  "description": "Implements the WebIDL algorithms for converting to and from JavaScript values",
  "main": "lib/index.js",
  "scripts": {
    "lint": "eslint .",
    "test": "mocha test/*.js",
    "test-no-sab": "mocha --parallel --jobs 2 --require test/helpers/delete-sab.js test/*.js",
    "coverage": "nyc mocha test/*.js"
  },
  "_scripts_comments": {
    "test-no-sab": "Node.js internals are broken by deleting SharedArrayBuffer if you run tests on the main thread. Using Mocha's parallel mode avoids this."
  },
  "repository": "jsdom/webidl-conversions",
  "keywords": [
    "webidl",
    "web",
    "types"
  ],
  "files": [
    "lib/"
  ],
  "author": "Domenic Denicola <d@domenic.me> (https://domenic.me/)",
  "license": "BSD-2-Clause",
  "devDependencies": {
    "@domenic/eslint-config": "^1.3.0",
    "eslint": "^7.32.0",
    "mocha": "^9.1.1",
    "nyc": "^15.1.0"
  },
  "engines": {
    "node": ">=12"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-environment-jsdom\node_modules\whatwg-url\package.json
============================================================
{
  "name": "whatwg-url",
  "version": "14.2.0",
  "description": "An implementation of the WHATWG URL Standard's URL API and parsing machinery",
  "main": "index.js",
  "files": [
    "index.js",
    "webidl2js-wrapper.js",
    "lib/*.js"
  ],
  "author": "Sebastian Mayr <github@smayr.name>",
  "license": "MIT",
  "repository": "jsdom/whatwg-url",
  "dependencies": {
    "tr46": "^5.1.0",
    "webidl-conversions": "^7.0.0"
  },
  "devDependencies": {
    "@domenic/eslint-config": "^4.0.1",
    "benchmark": "^2.1.4",
    "c8": "^10.1.3",
    "esbuild": "^0.25.1",
    "eslint": "^9.22.0",
    "globals": "^16.0.0",
    "webidl2js": "^18.0.0"
  },
  "engines": {
    "node": ">=18"
  },
  "scripts": {
    "coverage": "c8 node --test --experimental-test-coverage test/*.js",
    "lint": "eslint",
    "prepare": "node scripts/transform.js",
    "pretest": "node scripts/get-latest-platform-tests.js && node scripts/transform.js",
    "build-live-viewer": "esbuild --bundle --format=esm --sourcemap --outfile=live-viewer/whatwg-url.mjs index.js",
    "test": "node --test test/*.js",
    "bench": "node scripts/benchmark.js"
  },
  "c8": {
    "reporter": [
      "text",
      "html"
    ],
    "exclude": [
      "lib/Function.js",
      "lib/URL.js",
      "lib/URLSearchParams.js",
      "lib/utils.js",
      "scripts/",
      "test/"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-environment-jsdom\package.json
============================================================
{
  "name": "jest-environment-jsdom",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-environment-jsdom"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/environment": "30.2.0",
    "@jest/environment-jsdom-abstract": "30.2.0",
    "@types/jsdom": "^21.1.7",
    "@types/node": "*",
    "jsdom": "^26.1.0"
  },
  "devDependencies": {
    "@jest/test-utils": "30.2.0"
  },
  "peerDependencies": {
    "canvas": "^3.0.0"
  },
  "peerDependenciesMeta": {
    "canvas": {
      "optional": true
    }
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-environment-node\package.json
============================================================
{
  "name": "jest-environment-node",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-environment-node"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/environment": "30.2.0",
    "@jest/fake-timers": "30.2.0",
    "@jest/types": "30.2.0",
    "@types/node": "*",
    "jest-mock": "30.2.0",
    "jest-util": "30.2.0",
    "jest-validate": "30.2.0"
  },
  "devDependencies": {
    "@jest/test-utils": "30.2.0",
    "clsx": "^2.1.1"
  },
  "scripts": {
    "test:base": "echo GLOBALS_CLEANUP=$GLOBALS_CLEANUP && yarn --cwd='../.' jest --runInBand packages/jest-environment-node/src/__tests__",
    "test:globals-cleanup-off": "GLOBALS_CLEANUP=off yarn test:base",
    "test:globals-cleanup-soft": "GLOBALS_CLEANUP=soft yarn test:base",
    "test:globals-cleanup-on": "GLOBALS_CLEANUP=on yarn test:base",
    "test": "yarn test:globals-cleanup-off && yarn test:globals-cleanup-soft && yarn test:globals-cleanup-on"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-haste-map\package.json
============================================================
{
  "name": "jest-haste-map",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-haste-map"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/types": "30.2.0",
    "@types/node": "*",
    "anymatch": "^3.1.3",
    "fb-watchman": "^2.0.2",
    "graceful-fs": "^4.2.11",
    "jest-regex-util": "30.0.1",
    "jest-util": "30.2.0",
    "jest-worker": "30.2.0",
    "micromatch": "^4.0.8",
    "walker": "^1.0.8"
  },
  "devDependencies": {
    "@types/fb-watchman": "^2.0.5",
    "@types/graceful-fs": "^4.1.9",
    "@types/micromatch": "^4.0.9",
    "slash": "^3.0.0"
  },
  "optionalDependencies": {
    "fsevents": "^2.3.3"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-leak-detector\node_modules\ansi-styles\package.json
============================================================
{
	"name": "ansi-styles",
	"version": "5.2.0",
	"description": "ANSI escape codes for styling strings in the terminal",
	"license": "MIT",
	"repository": "chalk/ansi-styles",
	"funding": "https://github.com/chalk/ansi-styles?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"screenshot": "svg-term --command='node screenshot' --out=screenshot.svg --padding=3 --width=55 --height=3 --at=1000 --no-cursor"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"devDependencies": {
		"ava": "^2.4.0",
		"svg-term-cli": "^2.1.1",
		"tsd": "^0.14.0",
		"xo": "^0.37.1"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-leak-detector\node_modules\pretty-format\package.json
============================================================
{
  "name": "pretty-format",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/pretty-format"
  },
  "license": "MIT",
  "description": "Stringify any JavaScript value.",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "author": "James Kyle <me@thejameskyle.com>",
  "dependencies": {
    "@jest/schemas": "30.0.5",
    "ansi-styles": "^5.2.0",
    "react-is": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.23",
    "@types/react-is": "^18.3.1",
    "@types/react-test-renderer": "^18.3.1",
    "immutable": "^5.1.2",
    "jest-util": "30.2.0",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-test-renderer": "18.3.1"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-leak-detector\node_modules\react-is\package.json
============================================================
{
  "name": "react-is",
  "version": "18.3.1",
  "description": "Brand checking of React Elements.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react-is"
  },
  "keywords": [
    "react"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/facebook/react/issues"
  },
  "homepage": "https://reactjs.org/",
  "files": [
    "LICENSE",
    "README.md",
    "index.js",
    "cjs/",
    "umd/"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-leak-detector\package.json
============================================================
{
  "name": "jest-leak-detector",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-leak-detector"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/get-type": "30.1.0",
    "pretty-format": "30.2.0"
  },
  "devDependencies": {
    "@types/node": "*"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-matcher-utils\node_modules\ansi-styles\package.json
============================================================
{
	"name": "ansi-styles",
	"version": "5.2.0",
	"description": "ANSI escape codes for styling strings in the terminal",
	"license": "MIT",
	"repository": "chalk/ansi-styles",
	"funding": "https://github.com/chalk/ansi-styles?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"screenshot": "svg-term --command='node screenshot' --out=screenshot.svg --padding=3 --width=55 --height=3 --at=1000 --no-cursor"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"devDependencies": {
		"ava": "^2.4.0",
		"svg-term-cli": "^2.1.1",
		"tsd": "^0.14.0",
		"xo": "^0.37.1"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-matcher-utils\node_modules\pretty-format\package.json
============================================================
{
  "name": "pretty-format",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/pretty-format"
  },
  "license": "MIT",
  "description": "Stringify any JavaScript value.",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "author": "James Kyle <me@thejameskyle.com>",
  "dependencies": {
    "@jest/schemas": "30.0.5",
    "ansi-styles": "^5.2.0",
    "react-is": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.23",
    "@types/react-is": "^18.3.1",
    "@types/react-test-renderer": "^18.3.1",
    "immutable": "^5.1.2",
    "jest-util": "30.2.0",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-test-renderer": "18.3.1"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-matcher-utils\node_modules\react-is\package.json
============================================================
{
  "name": "react-is",
  "version": "18.3.1",
  "description": "Brand checking of React Elements.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react-is"
  },
  "keywords": [
    "react"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/facebook/react/issues"
  },
  "homepage": "https://reactjs.org/",
  "files": [
    "LICENSE",
    "README.md",
    "index.js",
    "cjs/",
    "umd/"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-matcher-utils\package.json
============================================================
{
  "name": "jest-matcher-utils",
  "description": "A set of utility functions for expect and related packages",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-matcher-utils"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/get-type": "30.1.0",
    "chalk": "^4.1.2",
    "jest-diff": "30.2.0",
    "pretty-format": "30.2.0"
  },
  "devDependencies": {
    "@jest/test-utils": "30.2.0",
    "@types/node": "*"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-message-util\node_modules\ansi-styles\package.json
============================================================
{
	"name": "ansi-styles",
	"version": "5.2.0",
	"description": "ANSI escape codes for styling strings in the terminal",
	"license": "MIT",
	"repository": "chalk/ansi-styles",
	"funding": "https://github.com/chalk/ansi-styles?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"screenshot": "svg-term --command='node screenshot' --out=screenshot.svg --padding=3 --width=55 --height=3 --at=1000 --no-cursor"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"devDependencies": {
		"ava": "^2.4.0",
		"svg-term-cli": "^2.1.1",
		"tsd": "^0.14.0",
		"xo": "^0.37.1"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-message-util\node_modules\pretty-format\package.json
============================================================
{
  "name": "pretty-format",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/pretty-format"
  },
  "license": "MIT",
  "description": "Stringify any JavaScript value.",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "author": "James Kyle <me@thejameskyle.com>",
  "dependencies": {
    "@jest/schemas": "30.0.5",
    "ansi-styles": "^5.2.0",
    "react-is": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.23",
    "@types/react-is": "^18.3.1",
    "@types/react-test-renderer": "^18.3.1",
    "immutable": "^5.1.2",
    "jest-util": "30.2.0",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-test-renderer": "18.3.1"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-message-util\node_modules\react-is\package.json
============================================================
{
  "name": "react-is",
  "version": "18.3.1",
  "description": "Brand checking of React Elements.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react-is"
  },
  "keywords": [
    "react"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/facebook/react/issues"
  },
  "homepage": "https://reactjs.org/",
  "files": [
    "LICENSE",
    "README.md",
    "index.js",
    "cjs/",
    "umd/"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-message-util\package.json
============================================================
{
  "name": "jest-message-util",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-message-util"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@babel/code-frame": "^7.27.1",
    "@jest/types": "30.2.0",
    "@types/stack-utils": "^2.0.3",
    "chalk": "^4.1.2",
    "graceful-fs": "^4.2.11",
    "micromatch": "^4.0.8",
    "pretty-format": "30.2.0",
    "slash": "^3.0.0",
    "stack-utils": "^2.0.6"
  },
  "devDependencies": {
    "@types/babel__code-frame": "^7.0.6",
    "@types/graceful-fs": "^4.1.9",
    "@types/micromatch": "^4.0.9",
    "tempy": "^1.0.1"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-mock\package.json
============================================================
{
  "name": "jest-mock",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-mock"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/types": "30.2.0",
    "@types/node": "*",
    "jest-util": "30.2.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-pnp-resolver\package.json
============================================================
{
    "name": "jest-pnp-resolver",
    "version": "1.2.3",
    "description": "plug'n'play resolver for Webpack",
    "license": "MIT",
    "engines": {
        "node": ">=6"
    },
    "homepage": "https://github.com/arcanis/jest-pnp-resolver",
    "bugs": {
        "url": "https://github.com/arcanis/jest-pnp-resolver/issues"
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/arcanis/jest-pnp-resolver.git"
    },
    "keywords": [
        "jest",
        "yarn",
        "plugnplay",
        "pnp"
    ],
    "peerDependencies": {
        "jest-resolve": "*"
    },
    "peerDependenciesMeta": {
        "jest-resolve": {
            "optional": true
        }
    }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-regex-util\package.json
============================================================
{
  "name": "jest-regex-util",
  "version": "30.0.1",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-regex-util"
  },
  "devDependencies": {
    "@types/node": "*"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "5ce865b4060189fe74cd486544816c079194a0f7"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-resolve\package.json
============================================================
{
  "name": "jest-resolve",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-resolve"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "chalk": "^4.1.2",
    "graceful-fs": "^4.2.11",
    "jest-haste-map": "30.2.0",
    "jest-pnp-resolver": "^1.2.3",
    "jest-util": "30.2.0",
    "jest-validate": "30.2.0",
    "slash": "^3.0.0",
    "unrs-resolver": "^1.7.11"
  },
  "devDependencies": {
    "@types/graceful-fs": "^4.1.9",
    "url": "^0.11.4"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-resolve-dependencies\package.json
============================================================
{
  "name": "jest-resolve-dependencies",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-resolve-dependencies"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "jest-regex-util": "30.0.1",
    "jest-snapshot": "30.2.0"
  },
  "devDependencies": {
    "@jest/test-utils": "30.2.0",
    "@jest/types": "30.2.0",
    "jest-haste-map": "30.2.0",
    "jest-resolve": "30.2.0",
    "jest-runtime": "30.2.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-runner\package.json
============================================================
{
  "name": "jest-runner",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-runner"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/console": "30.2.0",
    "@jest/environment": "30.2.0",
    "@jest/test-result": "30.2.0",
    "@jest/transform": "30.2.0",
    "@jest/types": "30.2.0",
    "@types/node": "*",
    "chalk": "^4.1.2",
    "emittery": "^0.13.1",
    "exit-x": "^0.2.2",
    "graceful-fs": "^4.2.11",
    "jest-docblock": "30.2.0",
    "jest-environment-node": "30.2.0",
    "jest-haste-map": "30.2.0",
    "jest-leak-detector": "30.2.0",
    "jest-message-util": "30.2.0",
    "jest-resolve": "30.2.0",
    "jest-runtime": "30.2.0",
    "jest-util": "30.2.0",
    "jest-watcher": "30.2.0",
    "jest-worker": "30.2.0",
    "p-limit": "^3.1.0",
    "source-map-support": "0.5.13"
  },
  "devDependencies": {
    "@jest/test-utils": "30.2.0",
    "@types/graceful-fs": "^4.1.9",
    "@types/source-map-support": "^0.5.10",
    "jest-jasmine2": "30.2.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-runtime\package.json
============================================================
{
  "name": "jest-runtime",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-runtime"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/environment": "30.2.0",
    "@jest/fake-timers": "30.2.0",
    "@jest/globals": "30.2.0",
    "@jest/source-map": "30.0.1",
    "@jest/test-result": "30.2.0",
    "@jest/transform": "30.2.0",
    "@jest/types": "30.2.0",
    "@types/node": "*",
    "chalk": "^4.1.2",
    "cjs-module-lexer": "^2.1.0",
    "collect-v8-coverage": "^1.0.2",
    "glob": "^10.3.10",
    "graceful-fs": "^4.2.11",
    "jest-haste-map": "30.2.0",
    "jest-message-util": "30.2.0",
    "jest-mock": "30.2.0",
    "jest-regex-util": "30.0.1",
    "jest-resolve": "30.2.0",
    "jest-snapshot": "30.2.0",
    "jest-util": "30.2.0",
    "slash": "^3.0.0",
    "strip-bom": "^4.0.0"
  },
  "devDependencies": {
    "@jest/test-utils": "30.2.0",
    "@types/graceful-fs": "^4.1.9",
    "jest-environment-node": "30.2.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-snapshot\node_modules\ansi-styles\package.json
============================================================
{
	"name": "ansi-styles",
	"version": "5.2.0",
	"description": "ANSI escape codes for styling strings in the terminal",
	"license": "MIT",
	"repository": "chalk/ansi-styles",
	"funding": "https://github.com/chalk/ansi-styles?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"screenshot": "svg-term --command='node screenshot' --out=screenshot.svg --padding=3 --width=55 --height=3 --at=1000 --no-cursor"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"devDependencies": {
		"ava": "^2.4.0",
		"svg-term-cli": "^2.1.1",
		"tsd": "^0.14.0",
		"xo": "^0.37.1"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-snapshot\node_modules\pretty-format\package.json
============================================================
{
  "name": "pretty-format",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/pretty-format"
  },
  "license": "MIT",
  "description": "Stringify any JavaScript value.",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "author": "James Kyle <me@thejameskyle.com>",
  "dependencies": {
    "@jest/schemas": "30.0.5",
    "ansi-styles": "^5.2.0",
    "react-is": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.23",
    "@types/react-is": "^18.3.1",
    "@types/react-test-renderer": "^18.3.1",
    "immutable": "^5.1.2",
    "jest-util": "30.2.0",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-test-renderer": "18.3.1"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-snapshot\node_modules\react-is\package.json
============================================================
{
  "name": "react-is",
  "version": "18.3.1",
  "description": "Brand checking of React Elements.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react-is"
  },
  "keywords": [
    "react"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/facebook/react/issues"
  },
  "homepage": "https://reactjs.org/",
  "files": [
    "LICENSE",
    "README.md",
    "index.js",
    "cjs/",
    "umd/"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-snapshot\node_modules\semver\package.json
============================================================
{
  "name": "semver",
  "version": "7.7.3",
  "description": "The semantic version parser used by npm.",
  "main": "index.js",
  "scripts": {
    "test": "tap",
    "snap": "tap",
    "lint": "npm run eslint",
    "postlint": "template-oss-check",
    "lintfix": "npm run eslint -- --fix",
    "posttest": "npm run lint",
    "template-oss-apply": "template-oss-apply --force",
    "eslint": "eslint \"**/*.{js,cjs,ts,mjs,jsx,tsx}\""
  },
  "devDependencies": {
    "@npmcli/eslint-config": "^5.0.0",
    "@npmcli/template-oss": "4.25.1",
    "benchmark": "^2.1.4",
    "tap": "^16.0.0"
  },
  "license": "ISC",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/npm/node-semver.git"
  },
  "bin": {
    "semver": "bin/semver.js"
  },
  "files": [
    "bin/",
    "lib/",
    "classes/",
    "functions/",
    "internal/",
    "ranges/",
    "index.js",
    "preload.js",
    "range.bnf"
  ],
  "tap": {
    "timeout": 30,
    "coverage-map": "map.js",
    "nyc-arg": [
      "--exclude",
      "tap-snapshots/**"
    ]
  },
  "engines": {
    "node": ">=10"
  },
  "author": "GitHub Inc.",
  "templateOSS": {
    "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
    "version": "4.25.1",
    "engines": ">=10",
    "distPaths": [
      "classes/",
      "functions/",
      "internal/",
      "ranges/",
      "index.js",
      "preload.js",
      "range.bnf"
    ],
    "allowPaths": [
      "/classes/",
      "/functions/",
      "/internal/",
      "/ranges/",
      "/index.js",
      "/preload.js",
      "/range.bnf",
      "/benchmarks"
    ],
    "publish": "true"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-snapshot\package.json
============================================================
{
  "name": "jest-snapshot",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-snapshot"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@babel/core": "^7.27.4",
    "@babel/generator": "^7.27.5",
    "@babel/plugin-syntax-jsx": "^7.27.1",
    "@babel/plugin-syntax-typescript": "^7.27.1",
    "@babel/types": "^7.27.3",
    "@jest/expect-utils": "30.2.0",
    "@jest/get-type": "30.1.0",
    "@jest/snapshot-utils": "30.2.0",
    "@jest/transform": "30.2.0",
    "@jest/types": "30.2.0",
    "babel-preset-current-node-syntax": "^1.2.0",
    "chalk": "^4.1.2",
    "expect": "30.2.0",
    "graceful-fs": "^4.2.11",
    "jest-diff": "30.2.0",
    "jest-matcher-utils": "30.2.0",
    "jest-message-util": "30.2.0",
    "jest-util": "30.2.0",
    "pretty-format": "30.2.0",
    "semver": "^7.7.2",
    "synckit": "^0.11.8"
  },
  "devDependencies": {
    "@babel/preset-flow": "^7.27.1",
    "@babel/preset-react": "^7.27.1",
    "@jest/test-utils": "30.2.0",
    "@types/babel__core": "^7.20.5",
    "@types/graceful-fs": "^4.1.9",
    "@types/prettier-v2": "npm:@types/prettier@^2.1.5",
    "@types/semver": "^7.7.0",
    "ansi-regex": "^5.0.1",
    "ansi-styles": "^5.2.0",
    "prettier": "^3.0.3",
    "prettier-v2": "npm:prettier@^2.1.5"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-transform-stub\package.json
============================================================
{
  "name": "jest-transform-stub",
  "version": "2.0.0",
  "description": "Jest transform stub",
  "main": "index.js",
  "files": [
    "index.js"
  ],
  "scripts": {
    "test": "jest"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/eddyerburgh/jest-transform-stub.git"
  },
  "keywords": [
    "jest"
  ],
  "author": "Edd Yerburgh",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/eddyerburgh/jest-transform-stub/issues"
  },
  "homepage": "https://github.com/eddyerburgh/jest-transform-stub#readme",
  "devDependencies": {
    "jest": "^22.4.2"
  },
  "jest": {
    "transform": {
      ".+\\.png$": "<rootDir>/index.js"
    }
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-util\node_modules\picomatch\package.json
============================================================
{
  "name": "picomatch",
  "description": "Blazing fast and accurate glob matcher written in JavaScript, with no dependencies and full support for standard and extended Bash glob features, including braces, extglobs, POSIX brackets, and regular expressions.",
  "version": "4.0.3",
  "homepage": "https://github.com/micromatch/picomatch",
  "author": "Jon Schlinkert (https://github.com/jonschlinkert)",
  "funding": "https://github.com/sponsors/jonschlinkert",
  "repository": "micromatch/picomatch",
  "bugs": {
    "url": "https://github.com/micromatch/picomatch/issues"
  },
  "license": "MIT",
  "files": [
    "index.js",
    "posix.js",
    "lib"
  ],
  "sideEffects": false,
  "main": "index.js",
  "engines": {
    "node": ">=12"
  },
  "scripts": {
    "lint": "eslint --cache --cache-location node_modules/.cache/.eslintcache --report-unused-disable-directives --ignore-path .gitignore .",
    "mocha": "mocha --reporter dot",
    "test": "npm run lint && npm run mocha",
    "test:ci": "npm run test:cover",
    "test:cover": "nyc npm run mocha"
  },
  "devDependencies": {
    "eslint": "^8.57.0",
    "fill-range": "^7.0.1",
    "gulp-format-md": "^2.0.0",
    "mocha": "^10.4.0",
    "nyc": "^15.1.0",
    "time-require": "github:jonschlinkert/time-require"
  },
  "keywords": [
    "glob",
    "match",
    "picomatch"
  ],
  "nyc": {
    "reporter": [
      "html",
      "lcov",
      "text-summary"
    ]
  },
  "verb": {
    "toc": {
      "render": true,
      "method": "preWrite",
      "maxdepth": 3
    },
    "layout": "empty",
    "tasks": [
      "readme"
    ],
    "plugins": [
      "gulp-format-md"
    ],
    "lint": {
      "reflinks": true
    },
    "related": {
      "list": [
        "braces",
        "micromatch"
      ]
    },
    "reflinks": [
      "braces",
      "expand-brackets",
      "extglob",
      "fill-range",
      "micromatch",
      "minimatch",
      "nanomatch",
      "picomatch"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-util\package.json
============================================================
{
  "name": "jest-util",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-util"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/types": "30.2.0",
    "@types/node": "*",
    "chalk": "^4.1.2",
    "ci-info": "^4.2.0",
    "graceful-fs": "^4.2.11",
    "picomatch": "^4.0.2"
  },
  "devDependencies": {
    "@types/graceful-fs": "^4.1.9",
    "@types/picomatch": "^4.0.0",
    "lodash": "^4.17.19"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-validate\node_modules\ansi-styles\package.json
============================================================
{
	"name": "ansi-styles",
	"version": "5.2.0",
	"description": "ANSI escape codes for styling strings in the terminal",
	"license": "MIT",
	"repository": "chalk/ansi-styles",
	"funding": "https://github.com/chalk/ansi-styles?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"screenshot": "svg-term --command='node screenshot' --out=screenshot.svg --padding=3 --width=55 --height=3 --at=1000 --no-cursor"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"devDependencies": {
		"ava": "^2.4.0",
		"svg-term-cli": "^2.1.1",
		"tsd": "^0.14.0",
		"xo": "^0.37.1"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-validate\node_modules\camelcase\package.json
============================================================
{
	"name": "camelcase",
	"version": "6.3.0",
	"description": "Convert a dash/dot/underscore/space separated string to camelCase or PascalCase: `foo-bar` → `fooBar`",
	"license": "MIT",
	"repository": "sindresorhus/camelcase",
	"funding": "https://github.com/sponsors/sindresorhus",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"camelcase",
		"camel-case",
		"camel",
		"case",
		"dash",
		"hyphen",
		"dot",
		"underscore",
		"separator",
		"string",
		"text",
		"convert",
		"pascalcase",
		"pascal-case"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.11.0",
		"xo": "^0.28.3"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-validate\node_modules\pretty-format\package.json
============================================================
{
  "name": "pretty-format",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/pretty-format"
  },
  "license": "MIT",
  "description": "Stringify any JavaScript value.",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "author": "James Kyle <me@thejameskyle.com>",
  "dependencies": {
    "@jest/schemas": "30.0.5",
    "ansi-styles": "^5.2.0",
    "react-is": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.23",
    "@types/react-is": "^18.3.1",
    "@types/react-test-renderer": "^18.3.1",
    "immutable": "^5.1.2",
    "jest-util": "30.2.0",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-test-renderer": "18.3.1"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-validate\node_modules\react-is\package.json
============================================================
{
  "name": "react-is",
  "version": "18.3.1",
  "description": "Brand checking of React Elements.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react-is"
  },
  "keywords": [
    "react"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/facebook/react/issues"
  },
  "homepage": "https://reactjs.org/",
  "files": [
    "LICENSE",
    "README.md",
    "index.js",
    "cjs/",
    "umd/"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-validate\package.json
============================================================
{
  "name": "jest-validate",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-validate"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/get-type": "30.1.0",
    "@jest/types": "30.2.0",
    "camelcase": "^6.3.0",
    "chalk": "^4.1.2",
    "leven": "^3.1.0",
    "pretty-format": "30.2.0"
  },
  "devDependencies": {
    "@types/yargs": "^17.0.33"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-watcher\package.json
============================================================
{
  "name": "jest-watcher",
  "description": "Delightful JavaScript Testing.",
  "version": "30.2.0",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/test-result": "30.2.0",
    "@jest/types": "30.2.0",
    "@types/node": "*",
    "ansi-escapes": "^4.3.2",
    "chalk": "^4.1.2",
    "emittery": "^0.13.1",
    "jest-util": "30.2.0",
    "string-length": "^4.0.2"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-watcher"
  },
  "bugs": {
    "url": "https://github.com/jestjs/jest/issues"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "homepage": "https://jestjs.io/",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-worker\node_modules\supports-color\package.json
============================================================
{
	"name": "supports-color",
	"version": "8.1.1",
	"description": "Detect whether a terminal supports color",
	"license": "MIT",
	"repository": "chalk/supports-color",
	"funding": "https://github.com/chalk/supports-color?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava"
	},
	"files": [
		"index.js",
		"browser.js"
	],
	"exports": {
		"node": "./index.js",
		"default": "./browser.js"
	},
	"keywords": [
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"ansi",
		"styles",
		"tty",
		"rgb",
		"256",
		"shell",
		"xterm",
		"command-line",
		"support",
		"supports",
		"capability",
		"detect",
		"truecolor",
		"16m"
	],
	"dependencies": {
		"has-flag": "^4.0.0"
	},
	"devDependencies": {
		"ava": "^2.4.0",
		"import-fresh": "^3.2.2",
		"xo": "^0.35.0"
	},
	"browser": "browser.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jest-worker\package.json
============================================================
{
  "name": "jest-worker",
  "version": "30.2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-worker"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@types/node": "*",
    "@ungap/structured-clone": "^1.3.0",
    "jest-util": "30.2.0",
    "merge-stream": "^2.0.0",
    "supports-color": "^8.1.1"
  },
  "devDependencies": {
    "@babel/core": "^7.27.4",
    "@types/merge-stream": "^2.0.0",
    "@types/supports-color": "^8.1.3",
    "@types/ungap__structured-clone": "^1.2.0",
    "get-stream": "^6.0.0",
    "jest-leak-detector": "30.2.0",
    "worker-farm": "^1.7.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "855864e3f9751366455246790be2bf912d4d0dac"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\js-tokens\package.json
============================================================
{
  "name": "js-tokens",
  "version": "4.0.0",
  "author": "Simon Lydell",
  "license": "MIT",
  "description": "A regex that tokenizes JavaScript.",
  "keywords": [
    "JavaScript",
    "js",
    "token",
    "tokenize",
    "regex"
  ],
  "files": [
    "index.js"
  ],
  "repository": "lydell/js-tokens",
  "scripts": {
    "test": "mocha --ui tdd",
    "esprima-compare": "node esprima-compare ./index.js everything.js/es5.js",
    "build": "node generate-index.js",
    "dev": "npm run build && npm test"
  },
  "devDependencies": {
    "coffeescript": "2.1.1",
    "esprima": "4.0.0",
    "everything.js": "1.0.3",
    "mocha": "5.0.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jsdom\lib\api.js
============================================================
"use strict";
const path = require("path");
const fs = require("fs").promises;
const vm = require("vm");
const toughCookie = require("tough-cookie");
const sniffHTMLEncoding = require("html-encoding-sniffer");
const whatwgURL = require("whatwg-url");
const whatwgEncoding = require("whatwg-encoding");
const { URL } = require("whatwg-url");
const MIMEType = require("whatwg-mimetype");
const idlUtils = require("./jsdom/living/generated/utils.js");
const VirtualConsole = require("./jsdom/virtual-console.js");
const { createWindow } = require("./jsdom/browser/Window.js");
const { parseIntoDocument } = require("./jsdom/browser/parser");
const { fragmentSerialization } = require("./jsdom/living/domparsing/serialization.js");
const ResourceLoader = require("./jsdom/browser/resources/resource-loader.js");
const NoOpResourceLoader = require("./jsdom/browser/resources/no-op-resource-loader.js");

class CookieJar extends toughCookie.CookieJar {
  constructor(store, options) {
    // jsdom cookie jars must be loose by default
    super(store, { looseMode: true, ...options });
  }
}

const window = Symbol("window");
let sharedFragmentDocument = null;

class JSDOM {
  constructor(input = "", options = {}) {
    const mimeType = new MIMEType(options.contentType === undefined ? "text/html" : options.contentType);
    const { html, encoding } = normalizeHTML(input, mimeType);

    options = transformOptions(options, encoding, mimeType);

    this[window] = createWindow(options.windowOptions);

    const documentImpl = idlUtils.implForWrapper(this[window]._document);

    options.beforeParse(this[window]._globalProxy);

    parseIntoDocument(html, documentImpl);

    documentImpl.close();
  }

  get window() {
    // It's important to grab the global proxy, instead of just the result of `createWindow(...)`, since otherwise
    // things like `window.eval` don't exist.
    return this[window]._globalProxy;
  }

  get virtualConsole() {
    return this[window]._virtualConsole;
  }

  get cookieJar() {
    // TODO NEWAPI move _cookieJar to window probably
    return idlUtils.implForWrapper(this[window]._document)._cookieJar;
  }

  serialize() {
    return fragmentSerialization(idlUtils.implForWrapper(this[window]._document), { requireWellFormed: false });
  }

  nodeLocation(node) {
    if (!idlUtils.implForWrapper(this[window]._document)._parseOptions.sourceCodeLocationInfo) {
      throw new Error("Location information was not saved for this jsdom. Use includeNodeLocations during creation.");
    }

    return idlUtils.implForWrapper(node).sourceCodeLocation;
  }

  getInternalVMContext() {
    if (!vm.isContext(this[window])) {
      throw new TypeError("This jsdom was not configured to allow script running. " +
        "Use the runScripts option during creation.");
    }

    return this[window];
  }

  reconfigure(settings) {
    if ("windowTop" in settings) {
      this[window]._top = settings.windowTop;
    }

    if ("url" in settings) {
      const document = idlUtils.implForWrapper(this[window]._document);

      const url = whatwgURL.parseURL(settings.url);
      if (url === null) {
        throw new TypeError(`Could not parse "${settings.url}" as a URL`);
      }

      document._URL = url;
      document._origin = whatwgURL.serializeURLOrigin(document._URL);
      this[window]._sessionHistory.currentEntry.url = url;
      document._clearBaseURLCache();
    }
  }

  static fragment(string = "") {
    if (!sharedFragmentDocument) {
      sharedFragmentDocument = (new JSDOM()).window.document;
    }

    const template = sharedFragmentDocument.createElement("template");
    template.innerHTML = string;
    return template.content;
  }

  static fromURL(url, options = {}) {
    return Promise.resolve().then(() => {
      // Remove the hash while sending this through the research loader fetch().
      // It gets added back a few lines down when constructing the JSDOM object.
      const parsedURL = new URL(url);
      const originalHash = parsedURL.hash;
      parsedURL.hash = "";
      url = parsedURL.href;

      options = normalizeFromURLOptions(options);

      const resourceLoader = resourcesToResourceLoader(options.resources);
      const resourceLoaderForInitialRequest = resourceLoader.constructor === NoOpResourceLoader ?
        new ResourceLoader() :
        resourceLoader;

      const req = resourceLoaderForInitialRequest.fetch(url, {
        accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        cookieJar: options.cookieJar,
        referrer: options.referrer
      });

      return req.then(body => {
        const res = req.response;

        options = Object.assign(options, {
          url: req.href + originalHash,
          contentType: res.headers["content-type"],
          referrer: req.getHeader("referer") ?? undefined
        });

        return new JSDOM(body, options);
      });
    });
  }

  static async fromFile(filename, options = {}) {
    options = normalizeFromFileOptions(filename, options);
    const buffer = await fs.readFile(filename);

    return new JSDOM(buffer, options);
  }
}

function normalizeFromURLOptions(options) {
  // Checks on options that are invalid for `fromURL`
  if (options.url !== undefined) {
    throw new TypeError("Cannot supply a url option when using fromURL");
  }
  if (options.contentType !== undefined) {
    throw new TypeError("Cannot supply a contentType option when using fromURL");
  }

  // Normalization of options which must be done before the rest of the fromURL code can use them, because they are
  // given to request()
  const normalized = { ...options };

  if (options.referrer !== undefined) {
    normalized.referrer = (new URL(options.referrer)).href;
  }

  if (options.cookieJar === undefined) {
    normalized.cookieJar = new CookieJar();
  }

  return normalized;

  // All other options don't need to be processed yet, and can be taken care of in the normal course of things when
  // `fromURL` calls `new JSDOM(html, options)`.
}

function normalizeFromFileOptions(filename, options) {
  const normalized = { ...options };

  if (normalized.contentType === undefined) {
    const extname = path.extname(filename);
    if (extname === ".xhtml" || extname === ".xht" || extname === ".xml") {
      normalized.contentType = "application/xhtml+xml";
    }
  }

  if (normalized.url === undefined) {
    normalized.url = new URL("file:" + path.resolve(filename));
  }

  return normalized;
}

function transformOptions(options, encoding, mimeType) {
  const transformed = {
    windowOptions: {
      // Defaults
      url: "about:blank",
      referrer: "",
      contentType: "text/html",
      parsingMode: "html",
      parseOptions: {
        sourceCodeLocationInfo: false,
        scriptingEnabled: false
      },
      runScripts: undefined,
      encoding,
      pretendToBeVisual: false,
      storageQuota: 5000000,

      // Defaults filled in later
      resourceLoader: undefined,
      virtualConsole: undefined,
      cookieJar: undefined
    },

    // Defaults
    beforeParse() { }
  };

  // options.contentType was parsed into mimeType by the caller.
  if (!mimeType.isHTML() && !mimeType.isXML()) {
    throw new RangeError(`The given content type of "${options.contentType}" was not a HTML or XML content type`);
  }

  transformed.windowOptions.contentType = mimeType.essence;
  transformed.windowOptions.parsingMode = mimeType.isHTML() ? "html" : "xml";

  if (options.url !== undefined) {
    transformed.windowOptions.url = (new URL(options.url)).href;
  }

  if (options.referrer !== undefined) {
    transformed.windowOptions.referrer = (new URL(options.referrer)).href;
  }

  if (options.includeNodeLocations) {
    if (transformed.windowOptions.parsingMode === "xml") {
      throw new TypeError("Cannot set includeNodeLocations to true with an XML content type");
    }

    transformed.windowOptions.parseOptions = { sourceCodeLocationInfo: true };
  }

  transformed.windowOptions.cookieJar = options.cookieJar === undefined ?
                                       new CookieJar() :
                                       options.cookieJar;

  transformed.windowOptions.virtualConsole = options.virtualConsole === undefined ?
                                            (new VirtualConsole()).forwardTo(console) :
                                            options.virtualConsole;

  if (!(transformed.windowOptions.virtualConsole instanceof VirtualConsole)) {
    throw new TypeError("virtualConsole must be an instance of VirtualConsole");
  }

  transformed.windowOptions.resourceLoader = resourcesToResourceLoader(options.resources);

  if (options.runScripts !== undefined) {
    transformed.windowOptions.runScripts = String(options.runScripts);
    if (transformed.windowOptions.runScripts === "dangerously") {
      transformed.windowOptions.parseOptions.scriptingEnabled = true;
    } else if (transformed.windowOptions.runScripts !== "outside-only") {
      throw new RangeError(`runScripts must be undefined, "dangerously", or "outside-only"`);
    }
  }

  if (options.beforeParse !== undefined) {
    transformed.beforeParse = options.beforeParse;
  }

  if (options.pretendToBeVisual !== undefined) {
    transformed.windowOptions.pretendToBeVisual = Boolean(options.pretendToBeVisual);
  }

  if (options.storageQuota !== undefined) {
    transformed.windowOptions.storageQuota = Number(options.storageQuota);
  }

  return transformed;
}

function normalizeHTML(html, mimeType) {
  let encoding = "UTF-8";

  if (ArrayBuffer.isView(html)) {
    html = Buffer.from(html.buffer, html.byteOffset, html.byteLength);
  } else if (html instanceof ArrayBuffer) {
    html = Buffer.from(html);
  }

  if (Buffer.isBuffer(html)) {
    encoding = sniffHTMLEncoding(html, {
      defaultEncoding: mimeType.isXML() ? "UTF-8" : "windows-1252",
      transportLayerEncodingLabel: mimeType.parameters.get("charset")
    });
    html = whatwgEncoding.decode(html, encoding);
  } else {
    html = String(html);
  }

  return { html, encoding };
}

function resourcesToResourceLoader(resources) {
  switch (resources) {
    case undefined: {
      return new NoOpResourceLoader();
    }
    case "usable": {
      return new ResourceLoader();
    }
    default: {
      if (!(resources instanceof ResourceLoader)) {
        throw new TypeError("resources must be an instance of ResourceLoader");
      }
      return resources;
    }
  }
}

exports.JSDOM = JSDOM;

exports.VirtualConsole = VirtualConsole;
exports.CookieJar = CookieJar;
exports.ResourceLoader = ResourceLoader;

exports.toughCookie = toughCookie;

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jsdom\node_modules\parse5\package.json
============================================================
{
    "name": "parse5",
    "type": "module",
    "description": "HTML parser and serializer.",
    "version": "8.0.0",
    "author": "Ivan Nikulin <ifaaan@gmail.com> (https://github.com/inikulin)",
    "contributors": "https://github.com/inikulin/parse5/graphs/contributors",
    "homepage": "https://parse5.js.org",
    "funding": "https://github.com/inikulin/parse5?sponsor=1",
    "dependencies": {
        "entities": "^6.0.0"
    },
    "keywords": [
        "html",
        "parser",
        "html5",
        "WHATWG",
        "specification",
        "fast",
        "html parser",
        "html5 parser",
        "htmlparser",
        "parse5",
        "serializer",
        "html serializer",
        "htmlserializer",
        "parse",
        "serialize"
    ],
    "license": "MIT",
    "main": "dist/index.js",
    "module": "dist/index.js",
    "types": "dist/index.d.ts",
    "exports": {
        ".": {
            "default": "./dist/index.js"
        }
    },
    "scripts": {},
    "repository": {
        "type": "git",
        "url": "git://github.com/inikulin/parse5.git"
    },
    "files": [
        "dist/**/*.js",
        "dist/**/*.d.ts"
    ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jsdom\package.json
============================================================
{
  "name": "jsdom",
  "version": "27.0.1",
  "description": "A JavaScript implementation of many web standards",
  "keywords": [
    "dom",
    "html",
    "whatwg",
    "w3c"
  ],
  "maintainers": [
    "Elijah Insua <tmpvar@gmail.com> (http://tmpvar.com)",
    "Domenic Denicola <d@domenic.me> (https://domenic.me/)",
    "Sebastian Mayr <sebmaster16@gmail.com> (https://blog.smayr.name/)",
    "Joris van der Wel <joris@jorisvanderwel.com>",
    "Timothy Gu <timothygu99@gmail.com> (https://timothygu.me/)",
    "Magne Andersson <code@zirro.se> (https://zirro.se/)",
    "Pierre-Marie Dartus <dartus.pierremarie@gmail.com>"
  ],
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jsdom/jsdom.git"
  },
  "dependencies": {
    "@asamuzakjp/dom-selector": "^6.7.2",
    "cssstyle": "^5.3.1",
    "data-urls": "^6.0.0",
    "decimal.js": "^10.6.0",
    "html-encoding-sniffer": "^4.0.0",
    "http-proxy-agent": "^7.0.2",
    "https-proxy-agent": "^7.0.6",
    "is-potential-custom-element-name": "^1.0.1",
    "parse5": "^8.0.0",
    "rrweb-cssom": "^0.8.0",
    "saxes": "^6.0.0",
    "symbol-tree": "^3.2.4",
    "tough-cookie": "^6.0.0",
    "w3c-xmlserializer": "^5.0.0",
    "webidl-conversions": "^8.0.0",
    "whatwg-encoding": "^3.1.1",
    "whatwg-mimetype": "^4.0.0",
    "whatwg-url": "^15.1.0",
    "ws": "^8.18.3",
    "xml-name-validator": "^5.0.0"
  },
  "peerDependencies": {
    "canvas": "^3.0.0"
  },
  "peerDependenciesMeta": {
    "canvas": {
      "optional": true
    }
  },
  "devDependencies": {
    "@domenic/eslint-config": "^4.0.1",
    "benchmark": "^2.1.4",
    "eslint": "^9.37.0",
    "eslint-plugin-html": "^8.1.3",
    "globals": "^16.4.0",
    "js-yaml": "^4.1.0",
    "minimatch": "^10.0.3",
    "mocha": "^11.7.4",
    "mocha-sugar-free": "^1.4.0",
    "npm-run-all2": "^8.0.4",
    "pngjs": "^7.0.0",
    "server-destroy": "^1.0.1",
    "webidl2js": "^19.1.0",
    "yargs": "^18.0.0"
  },
  "scripts": {
    "prepare": "npm-run-all prepare:*",
    "prepare:convert-idl": "node ./scripts/webidl/convert.js",
    "prepare:generate-js-globals": "node ./scripts/generate-js-globals.js",
    "pretest": "npm run prepare && npm run wpt:init",
    "test": "npm-run-all --continue-on-error test:*",
    "test:api": "mocha test/api/",
    "test:to-port-to-wpts": "mocha test/to-port-to-wpts/ && mocha test/to-port-to-wpts/level1/ && mocha test/to-port-to-wpts/level2/ && mocha test/to-port-to-wpts/level3/",
    "test:tuwpt": "mocha test/web-platform-tests/run-tuwpts.js",
    "test:wpt": "mocha test/web-platform-tests/run-wpts.js",
    "lint": "eslint --cache",
    "wpt:init": "git submodule update --init --recursive",
    "wpt:reset": "rm -rf ./test/web-platform-tests/tests && npm run wpt:init",
    "wpt:update": "git submodule update --init --recursive --remote && cd test/web-platform-tests/tests && python wpt.py manifest --path ../wpt-manifest.json",
    "update-authors": "git log --format=\"%aN <%aE>\" | sort -f | uniq > AUTHORS.txt",
    "benchmark": "node ./benchmark/runner"
  },
  "main": "./lib/api.js",
  "type": "commonjs",
  "engines": {
    "node": ">=20"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\jsesc\package.json
============================================================
{
  "name": "jsesc",
  "version": "3.1.0",
  "description": "Given some data, jsesc returns the shortest possible stringified & ASCII-safe representation of that data.",
  "homepage": "https://mths.be/jsesc",
  "engines": {
    "node": ">=6"
  },
  "main": "jsesc.js",
  "bin": "bin/jsesc",
  "man": "man/jsesc.1",
  "keywords": [
    "buffer",
    "escape",
    "javascript",
    "json",
    "map",
    "set",
    "string",
    "stringify",
    "tool"
  ],
  "license": "MIT",
  "author": {
    "name": "Mathias Bynens",
    "url": "https://mathiasbynens.be/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mathiasbynens/jsesc.git"
  },
  "bugs": "https://github.com/mathiasbynens/jsesc/issues",
  "files": [
    "LICENSE-MIT.txt",
    "jsesc.js",
    "bin/",
    "man/"
  ],
  "scripts": {
    "build": "grunt template",
    "coveralls": "istanbul cover --verbose --dir 'coverage' 'tests/tests.js' && coveralls < coverage/lcov.info'",
    "cover": "istanbul cover --report 'html' --verbose --dir 'coverage' 'tests/tests.js'",
    "test": "mocha tests"
  },
  "devDependencies": {
    "coveralls": "^2.11.6",
    "grunt": "^0.4.5",
    "grunt-cli": "^1.3.2",
    "grunt-template": "^0.2.3",
    "istanbul": "^0.4.2",
    "mocha": "^5.2.0",
    "regenerate": "^1.3.0",
    "requirejs": "^2.1.22",
    "unicode-13.0.0": "0.8.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\json-parse-even-better-errors\package.json
============================================================
{
  "name": "json-parse-even-better-errors",
  "version": "2.3.1",
  "description": "JSON.parse with context information on error",
  "main": "index.js",
  "files": [
    "*.js"
  ],
  "scripts": {
    "preversion": "npm t",
    "postversion": "npm publish",
    "prepublishOnly": "git push --follow-tags",
    "test": "tap",
    "snap": "tap"
  },
  "repository": "https://github.com/npm/json-parse-even-better-errors",
  "keywords": [
    "JSON",
    "parser"
  ],
  "author": {
    "name": "Kat Marchán",
    "email": "kzm@zkat.tech",
    "twitter": "maybekatz"
  },
  "license": "MIT",
  "devDependencies": {
    "tap": "^14.6.5"
  },
  "tap": {
    "check-coverage": true
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\json5\package.json
============================================================
{
  "name": "json5",
  "version": "2.2.3",
  "description": "JSON for Humans",
  "main": "lib/index.js",
  "module": "dist/index.mjs",
  "bin": "lib/cli.js",
  "browser": "dist/index.js",
  "types": "lib/index.d.ts",
  "files": [
    "lib/",
    "dist/"
  ],
  "engines": {
    "node": ">=6"
  },
  "scripts": {
    "build": "rollup -c",
    "build-package": "node build/package.js",
    "build-unicode": "node build/unicode.js",
    "coverage": "tap --coverage-report html test",
    "lint": "eslint --fix .",
    "lint-report": "eslint .",
    "prepublishOnly": "npm run production",
    "preversion": "npm run production",
    "production": "run-s test build",
    "tap": "tap -Rspec --100 test",
    "test": "run-s lint-report tap",
    "version": "npm run build-package && git add package.json5"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/json5/json5.git"
  },
  "keywords": [
    "json",
    "json5",
    "es5",
    "es2015",
    "ecmascript"
  ],
  "author": "Aseem Kishore <aseem.kishore@gmail.com>",
  "contributors": [
    "Max Nanasy <max.nanasy@gmail.com>",
    "Andrew Eisenberg <andrew@eisenberg.as>",
    "Jordan Tucker <jordanbtucker@gmail.com>"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/json5/json5/issues"
  },
  "homepage": "http://json5.org/",
  "devDependencies": {
    "core-js": "^2.6.5",
    "eslint": "^5.15.3",
    "eslint-config-standard": "^12.0.0",
    "eslint-plugin-import": "^2.16.0",
    "eslint-plugin-node": "^8.0.1",
    "eslint-plugin-promise": "^4.0.1",
    "eslint-plugin-standard": "^4.0.0",
    "npm-run-all": "^4.1.5",
    "regenerate": "^1.4.0",
    "rollup": "^0.64.1",
    "rollup-plugin-buble": "^0.19.6",
    "rollup-plugin-commonjs": "^9.2.1",
    "rollup-plugin-node-resolve": "^3.4.0",
    "rollup-plugin-terser": "^1.0.1",
    "sinon": "^6.3.5",
    "tap": "^12.6.0",
    "unicode-10.0.0": "^0.7.5"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\leven\package.json
============================================================
{
	"name": "leven",
	"version": "3.1.0",
	"description": "Measure the difference between two strings using the fastest JS implementation of the Levenshtein distance algorithm",
	"license": "MIT",
	"repository": "sindresorhus/leven",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=6"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"bench": "matcha bench.js"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"leven",
		"levenshtein",
		"distance",
		"algorithm",
		"algo",
		"string",
		"difference",
		"diff",
		"fast",
		"fuzzy",
		"similar",
		"similarity",
		"compare",
		"comparison",
		"edit",
		"text",
		"match",
		"matching"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"fast-levenshtein": "^2.0.6",
		"ld": "^0.1.0",
		"levdist": "^2.2.9",
		"levenshtein": "^1.0.5",
		"levenshtein-component": "^0.0.1",
		"levenshtein-edit-distance": "^2.0.3",
		"matcha": "^0.7.0",
		"natural": "^0.6.3",
		"talisman": "^0.21.0",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\lines-and-columns\package.json
============================================================
{
  "name": "lines-and-columns",
  "version": "1.2.4",
  "description": "Maps lines and columns to character offsets and back.",
  "keywords": [
    "lines",
    "columns",
    "parser"
  ],
  "homepage": "https://github.com/eventualbuddha/lines-and-columns#readme",
  "bugs": {
    "url": "https://github.com/eventualbuddha/lines-and-columns/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/eventualbuddha/lines-and-columns.git"
  },
  "license": "MIT",
  "author": "Brian Donovan <brian@donovans.cc>",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "files": [
    "build"
  ],
  "scripts": {
    "build:watch": "tsc --build tsconfig.build.json --watch",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "test": "is-ci test:coverage test:watch",
    "test:coverage": "jest --coverage",
    "test:watch": "jest --watch"
  },
  "devDependencies": {
    "@types/jest": "^27.0.3",
    "@types/node": "^16.11.9",
    "@typescript-eslint/eslint-plugin": "^5.4.0",
    "@typescript-eslint/parser": "^5.4.0",
    "esbuild": "^0.13.15",
    "esbuild-runner": "^2.2.1",
    "eslint": "^8.2.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "is-ci-cli": "^2.2.0",
    "jest": "^27.3.1",
    "prettier": "^2.4.1",
    "semantic-release": "^18.0.0",
    "typescript": "^4.5.2"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\lodash\package.json
============================================================
{
  "name": "lodash",
  "version": "4.17.21",
  "description": "Lodash modular utilities.",
  "keywords": "modules, stdlib, util",
  "homepage": "https://lodash.com/",
  "repository": "lodash/lodash",
  "icon": "https://lodash.com/icon.svg",
  "license": "MIT",
  "main": "lodash.js",
  "author": "John-David Dalton <john.david.dalton@gmail.com>",
  "contributors": [
    "John-David Dalton <john.david.dalton@gmail.com>",
    "Mathias Bynens <mathias@qiwi.be>"
  ],
  "scripts": { "test": "echo \"See https://travis-ci.org/lodash-archive/lodash-cli for testing details.\"" }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\lodash.debounce\package.json
============================================================
{
  "name": "lodash.debounce",
  "version": "4.0.8",
  "description": "The lodash method `_.debounce` exported as a module.",
  "homepage": "https://lodash.com/",
  "icon": "https://lodash.com/icon.svg",
  "license": "MIT",
  "keywords": "lodash-modularized, debounce",
  "author": "John-David Dalton <john.david.dalton@gmail.com> (http://allyoucanleet.com/)",
  "contributors": [
    "John-David Dalton <john.david.dalton@gmail.com> (http://allyoucanleet.com/)",
    "Blaine Bublitz <blaine.bublitz@gmail.com> (https://github.com/phated)",
    "Mathias Bynens <mathias@qiwi.be> (https://mathiasbynens.be/)"
  ],
  "repository": "lodash/lodash",
  "scripts": { "test": "echo \"See https://travis-ci.org/lodash/lodash-cli for testing details.\"" }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\loose-envify\package.json
============================================================
{
  "name": "loose-envify",
  "version": "1.4.0",
  "description": "Fast (and loose) selective `process.env` replacer using js-tokens instead of an AST",
  "keywords": [
    "environment",
    "variables",
    "browserify",
    "browserify-transform",
    "transform",
    "source",
    "configuration"
  ],
  "homepage": "https://github.com/zertosh/loose-envify",
  "license": "MIT",
  "author": "Andres Suarez <zertosh@gmail.com>",
  "main": "index.js",
  "bin": {
    "loose-envify": "cli.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/zertosh/loose-envify.git"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "dependencies": {
    "js-tokens": "^3.0.0 || ^4.0.0"
  },
  "devDependencies": {
    "browserify": "^13.1.1",
    "envify": "^3.4.0",
    "tap": "^8.0.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\lru-cache\package.json
============================================================
{
  "name": "lru-cache",
  "description": "A cache object that deletes the least-recently-used items.",
  "version": "5.1.1",
  "author": "Isaac Z. Schlueter <i@izs.me>",
  "keywords": [
    "mru",
    "lru",
    "cache"
  ],
  "scripts": {
    "test": "tap test/*.js --100 -J",
    "snap": "TAP_SNAPSHOT=1 tap test/*.js -J",
    "coveragerport": "tap --coverage-report=html",
    "preversion": "npm test",
    "postversion": "npm publish",
    "postpublish": "git push origin --all; git push origin --tags"
  },
  "main": "index.js",
  "repository": "git://github.com/isaacs/node-lru-cache.git",
  "devDependencies": {
    "benchmark": "^2.1.4",
    "tap": "^12.1.0"
  },
  "license": "ISC",
  "dependencies": {
    "yallist": "^3.0.2"
  },
  "files": [
    "index.js"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\lz-string\package.json
============================================================
{
  "name": "lz-string",
  "version": "1.5.0",
  "license": "MIT",
  "filename": "lz-string.js",
  "description": "LZ-based compression algorithm",
  "homepage": "http://pieroxy.net/blog/pages/lz-string/index.html",
  "keywords": [
    "lz",
    "compression",
    "string"
  ],
  "main": "libs/lz-string.js",
  "typings": "typings/lz-string.d.ts",
  "bin": {
    "lz-string": "bin/bin.js"
  },
  "scripts": {},
  "dependencies": {},
  "devDependencies": {},
  "repository": {
    "type": "git",
    "url": "https://github.com/pieroxy/lz-string.git"
  },
  "bugs": {
    "url": "https://github.com/pieroxy/lz-string/issues"
  },
  "directories": {
    "test": "tests"
  },
  "author": "pieroxy <pieroxy@pieroxy.net>",
  "autoupdate": {
    "source": "git",
    "target": "git://github.com/pieroxy/lz-string.git",
    "basePath": "libs/",
    "files": [
      "lz-string.js",
      "lz-string.min.js",
      "base64-string.js"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\magic-string\package.json
============================================================
{
  "name": "magic-string",
  "version": "0.27.0",
  "description": "Modify strings, generate sourcemaps",
  "keywords": [
    "string",
    "string manipulation",
    "sourcemap",
    "templating",
    "transpilation"
  ],
  "repository": "https://github.com/rich-harris/magic-string",
  "license": "MIT",
  "author": "Rich Harris",
  "main": "./dist/magic-string.cjs.js",
  "module": "./dist/magic-string.es.mjs",
  "jsnext:main": "./dist/magic-string.es.mjs",
  "types": "./index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "import": "./dist/magic-string.es.mjs",
      "require": "./dist/magic-string.cjs.js",
      "types": "./index.d.ts"
    }
  },
  "files": [
    "dist/*",
    "index.d.ts",
    "README.md"
  ],
  "scripts": {
    "build": "rollup -c",
    "changelog": "conventional-changelog -p angular -i CHANGELOG.md -s",
    "format": "prettier --single-quote --print-width 100 --use-tabs --write src/*.js src/**/*.js",
    "lint": "eslint src test",
    "prepare": "npm run build",
    "prepublishOnly": "rm -rf dist && npm test",
    "release": "bumpp -x \"npm run changelog\" --all --commit --tag --push && npm publish",
    "pretest": "npm run lint && npm run build",
    "test": "mocha",
    "bench": "npm run build && node benchmark/index.mjs",
    "watch": "rollup -cw"
  },
  "devDependencies": {
    "@rollup/plugin-node-resolve": "^14.1.0",
    "@rollup/plugin-replace": "^4.0.0",
    "benchmark": "^2.1.4",
    "bumpp": "^8.2.1",
    "conventional-changelog-cli": "^2.2.2",
    "eslint": "^8.23.1",
    "mocha": "^10.0.0",
    "prettier": "^2.7.1",
    "rollup": "^2.79.1",
    "source-map-js": "^1.0.2",
    "source-map-support": "^0.5.21"
  },
  "engines": {
    "node": ">=12"
  },
  "dependencies": {
    "@jridgewell/sourcemap-codec": "^1.4.13"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\make-dir\node_modules\semver\package.json
============================================================
{
  "name": "semver",
  "version": "7.7.3",
  "description": "The semantic version parser used by npm.",
  "main": "index.js",
  "scripts": {
    "test": "tap",
    "snap": "tap",
    "lint": "npm run eslint",
    "postlint": "template-oss-check",
    "lintfix": "npm run eslint -- --fix",
    "posttest": "npm run lint",
    "template-oss-apply": "template-oss-apply --force",
    "eslint": "eslint \"**/*.{js,cjs,ts,mjs,jsx,tsx}\""
  },
  "devDependencies": {
    "@npmcli/eslint-config": "^5.0.0",
    "@npmcli/template-oss": "4.25.1",
    "benchmark": "^2.1.4",
    "tap": "^16.0.0"
  },
  "license": "ISC",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/npm/node-semver.git"
  },
  "bin": {
    "semver": "bin/semver.js"
  },
  "files": [
    "bin/",
    "lib/",
    "classes/",
    "functions/",
    "internal/",
    "ranges/",
    "index.js",
    "preload.js",
    "range.bnf"
  ],
  "tap": {
    "timeout": 30,
    "coverage-map": "map.js",
    "nyc-arg": [
      "--exclude",
      "tap-snapshots/**"
    ]
  },
  "engines": {
    "node": ">=10"
  },
  "author": "GitHub Inc.",
  "templateOSS": {
    "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
    "version": "4.25.1",
    "engines": ">=10",
    "distPaths": [
      "classes/",
      "functions/",
      "internal/",
      "ranges/",
      "index.js",
      "preload.js",
      "range.bnf"
    ],
    "allowPaths": [
      "/classes/",
      "/functions/",
      "/internal/",
      "/ranges/",
      "/index.js",
      "/preload.js",
      "/range.bnf",
      "/benchmarks"
    ],
    "publish": "true"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\make-dir\package.json
============================================================
{
	"name": "make-dir",
	"version": "4.0.0",
	"description": "Make a directory and its parents if needed - Think `mkdir -p`",
	"license": "MIT",
	"repository": "sindresorhus/make-dir",
	"funding": "https://github.com/sponsors/sindresorhus",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && nyc ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"mkdir",
		"mkdirp",
		"make",
		"directories",
		"folders",
		"directory",
		"folder",
		"path",
		"parent",
		"parents",
		"intermediate",
		"recursively",
		"recursive",
		"create",
		"fs",
		"filesystem",
		"file-system"
	],
	"dependencies": {
		"semver": "^7.5.3"
	},
	"devDependencies": {
		"@types/graceful-fs": "^4.1.3",
		"@types/node": "^14.14.6",
		"ava": "^2.4.0",
		"codecov": "^3.2.0",
		"graceful-fs": "^4.1.15",
		"nyc": "^15.0.0",
		"path-type": "^4.0.0",
		"tempy": "^1.0.0",
		"tsd": "^0.13.1",
		"xo": "^0.34.2"
	},
	"nyc": {
		"reporter": [
			"text",
			"lcov"
		]
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\makeerror\package.json
============================================================
{
  "name": "makeerror",
  "description": "A library to make errors.",
  "version": "1.0.12",
  "license": "BSD-3-Clause",
  "author": "Naitik Shah <n@daaku.org>",
  "main": "lib/makeerror",
  "repository": {
    "type": "git",
    "url": "https://github.com/daaku/nodejs-makeerror"
  },
  "scripts": {
    "test": "NODE_PATH=./lib mocha --ui exports"
  },
  "dependencies": {
    "tmpl": "1.0.5"
  },
  "devDependencies": {
    "mocha": "9.1.3"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\math-intrinsics\package.json
============================================================
{
	"name": "math-intrinsics",
	"version": "1.1.0",
	"description": "ES Math-related intrinsics and helpers, robustly cached.",
	"main": false,
	"exports": {
		"./abs": "./abs.js",
		"./floor": "./floor.js",
		"./isFinite": "./isFinite.js",
		"./isInteger": "./isInteger.js",
		"./isNaN": "./isNaN.js",
		"./isNegativeZero": "./isNegativeZero.js",
		"./max": "./max.js",
		"./min": "./min.js",
		"./mod": "./mod.js",
		"./pow": "./pow.js",
		"./sign": "./sign.js",
		"./round": "./round.js",
		"./constants/maxArrayLength": "./constants/maxArrayLength.js",
		"./constants/maxSafeInteger": "./constants/maxSafeInteger.js",
		"./constants/maxValue": "./constants/maxValue.js",
		"./package.json": "./package.json"
	},
	"sideEffects": false,
	"scripts": {
		"prepack": "npmignore --auto --commentLines=autogenerated",
		"prepublishOnly": "safe-publish-latest",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"pretest": "npm run lint",
		"test": "npm run tests-only",
		"tests-only": "nyc tape 'test/**/*.js'",
		"posttest": "npx npm@'>= 10.2' audit --production",
		"prelint": "evalmd README.md && eclint check $(git ls-files | xargs find 2> /dev/null | grep -vE 'node_modules|\\.git' | grep -v dist/)",
		"lint": "eslint --ext=js,mjs .",
		"postlint": "tsc && attw -P",
		"version": "auto-changelog && git add CHANGELOG.md",
		"postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
	},
	"repository": {
		"type": "git",
		"url": "git+https://github.com/es-shims/math-intrinsics.git"
	},
	"author": "Jordan Harband <ljharb@gmail.com>",
	"license": "MIT",
	"bugs": {
		"url": "https://github.com/es-shims/math-intrinsics/issues"
	},
	"homepage": "https://github.com/es-shims/math-intrinsics#readme",
	"devDependencies": {
		"@arethetypeswrong/cli": "^0.17.1",
		"@ljharb/eslint-config": "^21.1.1",
		"@ljharb/tsconfig": "^0.2.2",
		"@types/for-each": "^0.3.3",
		"@types/object-inspect": "^1.13.0",
		"@types/tape": "^5.8.0",
		"auto-changelog": "^2.5.0",
		"eclint": "^2.8.1",
		"es-value-fixtures": "^1.5.0",
		"eslint": "^8.8.0",
		"evalmd": "^0.0.19",
		"for-each": "^0.3.3",
		"in-publish": "^2.0.1",
		"npmignore": "^0.3.1",
		"nyc": "^10.3.2",
		"object-inspect": "^1.13.3",
		"safe-publish-latest": "^2.0.0",
		"tape": "^5.9.0",
		"typescript": "next"
	},
	"auto-changelog": {
		"output": "CHANGELOG.md",
		"template": "keepachangelog",
		"unreleased": false,
		"commitLimit": false,
		"backfillLimit": false,
		"hideCredit": true
	},
	"publishConfig": {
		"ignore": [
			".github/workflows"
		]
	},
	"engines": {
		"node": ">= 0.4"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\mdn-data\package.json
============================================================
{
  "name": "mdn-data",
  "version": "2.12.2",
  "description": "Open Web data by the Mozilla Developer Network",
  "main": "index.js",
  "files": [
    "api/index.js",
    "api/*.json",
    "css/index.js",
    "css/*.json",
    "l10n/index.js",
    "l10n/*.json"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/mdn/data.git"
  },
  "keywords": [
    "data",
    "mdn",
    "mozilla",
    "css"
  ],
  "author": "Mozilla Developer Network",
  "license": "CC0-1.0",
  "bugs": {
    "url": "https://github.com/mdn/data/issues"
  },
  "homepage": "https://developer.mozilla.org",
  "devDependencies": {
    "ajv": "^6.12.6",
    "better-ajv-errors": "^1.1.2"
  },
  "scripts": {
    "lint": "node test/lint",
    "test": "npm run lint"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\merge-stream\package.json
============================================================
{
  "name": "merge-stream",
  "version": "2.0.0",
  "description": "Create a stream that emits events from multiple other streams",
  "files": [
    "index.js"
  ],
  "scripts": {
    "test": "istanbul cover test.js && istanbul check-cover --statements 100 --branches 100"
  },
  "repository": "grncdr/merge-stream",
  "author": "Stephen Sugden <me@stephensugden.com>",
  "license": "MIT",
  "dependencies": {},
  "devDependencies": {
    "from2": "^2.0.3",
    "istanbul": "^0.4.5"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\micromatch\package.json
============================================================
{
  "name": "micromatch",
  "description": "Glob matching for javascript/node.js. A replacement and faster alternative to minimatch and multimatch.",
  "version": "4.0.8",
  "homepage": "https://github.com/micromatch/micromatch",
  "author": "Jon Schlinkert (https://github.com/jonschlinkert)",
  "contributors": [
    "(https://github.com/DianeLooney)",
    "Amila Welihinda (amilajack.com)",
    "Bogdan Chadkin (https://github.com/TrySound)",
    "Brian Woodward (https://twitter.com/doowb)",
    "Devon Govett (http://badassjs.com)",
    "Elan Shanker (https://github.com/es128)",
    "Fabrício Matté (https://ultcombo.js.org)",
    "Jon Schlinkert (http://twitter.com/jonschlinkert)",
    "Martin Kolárik (https://kolarik.sk)",
    "Olsten Larck (https://i.am.charlike.online)",
    "Paul Miller (paulmillr.com)",
    "Tom Byrer (https://github.com/tomByrer)",
    "Tyler Akins (http://rumkin.com)",
    "Peter Bright <drpizza@quiscalusmexicanus.org> (https://github.com/drpizza)",
    "Kuba Juszczyk (https://github.com/ku8ar)"
  ],
  "repository": "micromatch/micromatch",
  "bugs": {
    "url": "https://github.com/micromatch/micromatch/issues"
  },
  "license": "MIT",
  "files": [
    "index.js"
  ],
  "main": "index.js",
  "engines": {
    "node": ">=8.6"
  },
  "scripts": {
    "test": "mocha"
  },
  "dependencies": {
    "braces": "^3.0.3",
    "picomatch": "^2.3.1"
  },
  "devDependencies": {
    "fill-range": "^7.0.1",
    "gulp-format-md": "^2.0.0",
    "minimatch": "^5.0.1",
    "mocha": "^9.2.2",
    "time-require": "github:jonschlinkert/time-require"
  },
  "keywords": [
    "bash",
    "bracket",
    "character-class",
    "expand",
    "expansion",
    "expression",
    "extglob",
    "extglobs",
    "file",
    "files",
    "filter",
    "find",
    "glob",
    "globbing",
    "globs",
    "globstar",
    "lookahead",
    "lookaround",
    "lookbehind",
    "match",
    "matcher",
    "matches",
    "matching",
    "micromatch",
    "minimatch",
    "multimatch",
    "negate",
    "negation",
    "path",
    "pattern",
    "patterns",
    "posix",
    "regex",
    "regexp",
    "regular",
    "shell",
    "star",
    "wildcard"
  ],
  "verb": {
    "toc": "collapsible",
    "layout": "default",
    "tasks": [
      "readme"
    ],
    "plugins": [
      "gulp-format-md"
    ],
    "lint": {
      "reflinks": true
    },
    "related": {
      "list": [
        "braces",
        "expand-brackets",
        "extglob",
        "fill-range",
        "nanomatch"
      ]
    },
    "reflinks": [
      "extglob",
      "fill-range",
      "glob-object",
      "minimatch",
      "multimatch"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\mime-db\package.json
============================================================
{
  "name": "mime-db",
  "description": "Media Type Database",
  "version": "1.52.0",
  "contributors": [
    "Douglas Christopher Wilson <doug@somethingdoug.com>",
    "Jonathan Ong <me@jongleberry.com> (http://jongleberry.com)",
    "Robert Kieffer <robert@broofa.com> (http://github.com/broofa)"
  ],
  "license": "MIT",
  "keywords": [
    "mime",
    "db",
    "type",
    "types",
    "database",
    "charset",
    "charsets"
  ],
  "repository": "jshttp/mime-db",
  "devDependencies": {
    "bluebird": "3.7.2",
    "co": "4.6.0",
    "cogent": "1.0.1",
    "csv-parse": "4.16.3",
    "eslint": "7.32.0",
    "eslint-config-standard": "15.0.1",
    "eslint-plugin-import": "2.25.4",
    "eslint-plugin-markdown": "2.2.1",
    "eslint-plugin-node": "11.1.0",
    "eslint-plugin-promise": "5.1.1",
    "eslint-plugin-standard": "4.1.0",
    "gnode": "0.1.2",
    "media-typer": "1.1.0",
    "mocha": "9.2.1",
    "nyc": "15.1.0",
    "raw-body": "2.5.0",
    "stream-to-array": "2.3.0"
  },
  "files": [
    "HISTORY.md",
    "LICENSE",
    "README.md",
    "db.json",
    "index.js"
  ],
  "engines": {
    "node": ">= 0.6"
  },
  "scripts": {
    "build": "node scripts/build",
    "fetch": "node scripts/fetch-apache && gnode scripts/fetch-iana && node scripts/fetch-nginx",
    "lint": "eslint .",
    "test": "mocha --reporter spec --bail --check-leaks test/",
    "test-ci": "nyc --reporter=lcov --reporter=text npm test",
    "test-cov": "nyc --reporter=html --reporter=text npm test",
    "update": "npm run fetch && npm run build",
    "version": "node scripts/version-history.js && git add HISTORY.md"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\mime-types\package.json
============================================================
{
  "name": "mime-types",
  "description": "The ultimate javascript content-type utility.",
  "version": "2.1.35",
  "contributors": [
    "Douglas Christopher Wilson <doug@somethingdoug.com>",
    "Jeremiah Senkpiel <fishrock123@rocketmail.com> (https://searchbeam.jit.su)",
    "Jonathan Ong <me@jongleberry.com> (http://jongleberry.com)"
  ],
  "license": "MIT",
  "keywords": [
    "mime",
    "types"
  ],
  "repository": "jshttp/mime-types",
  "dependencies": {
    "mime-db": "1.52.0"
  },
  "devDependencies": {
    "eslint": "7.32.0",
    "eslint-config-standard": "14.1.1",
    "eslint-plugin-import": "2.25.4",
    "eslint-plugin-markdown": "2.2.1",
    "eslint-plugin-node": "11.1.0",
    "eslint-plugin-promise": "5.2.0",
    "eslint-plugin-standard": "4.1.0",
    "mocha": "9.2.2",
    "nyc": "15.1.0"
  },
  "files": [
    "HISTORY.md",
    "LICENSE",
    "index.js"
  ],
  "engines": {
    "node": ">= 0.6"
  },
  "scripts": {
    "lint": "eslint .",
    "test": "mocha --reporter spec test/test.js",
    "test-ci": "nyc --reporter=lcov --reporter=text npm test",
    "test-cov": "nyc --reporter=html --reporter=text npm test"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\mimic-fn\package.json
============================================================
{
	"name": "mimic-fn",
	"version": "2.1.0",
	"description": "Make a function mimic another one",
	"license": "MIT",
	"repository": "sindresorhus/mimic-fn",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=6"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"function",
		"mimic",
		"imitate",
		"rename",
		"copy",
		"inherit",
		"properties",
		"name",
		"func",
		"fn",
		"set",
		"infer",
		"change"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.1",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\min-indent\package.json
============================================================
{
  "name": "min-indent",
  "version": "1.0.1",
  "description": "Get the shortest leading whitespace from lines in a string",
  "main": "index.js",
  "license": "MIT",
  "repository": "https://github.com/thejameskyle/min-indent",
  "author": {
    "name": "James Kyle",
    "email": "me@thejameskyle.com",
    "url": "thejameskyle.com"
  },
  "engines": {
    "node": ">=4"
  },
  "scripts": {
    "test": "xo && ava"
  },
  "files": [
    "index.js"
  ],
  "keywords": [
    "indent",
    "indentation",
    "normalize",
    "whitespace",
    "space",
    "tab",
    "string",
    "str",
    "min",
    "minimum"
  ],
  "devDependencies": {
    "ava": "*",
    "xo": "*"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\minimatch\package.json
============================================================
{
  "author": "Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me)",
  "name": "minimatch",
  "description": "a glob matcher in javascript",
  "version": "3.1.2",
  "publishConfig": {
    "tag": "v3-legacy"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/minimatch.git"
  },
  "main": "minimatch.js",
  "scripts": {
    "test": "tap",
    "preversion": "npm test",
    "postversion": "npm publish",
    "postpublish": "git push origin --all; git push origin --tags"
  },
  "engines": {
    "node": "*"
  },
  "dependencies": {
    "brace-expansion": "^1.1.7"
  },
  "devDependencies": {
    "tap": "^15.1.6"
  },
  "license": "ISC",
  "files": [
    "minimatch.js"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\minipass\dist\commonjs\package.json
============================================================
{
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\minipass\dist\esm\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\minipass\package.json
============================================================
{
  "name": "minipass",
  "version": "7.1.2",
  "description": "minimal implementation of a PassThrough stream",
  "main": "./dist/commonjs/index.js",
  "types": "./dist/commonjs/index.d.ts",
  "type": "module",
  "tshy": {
    "selfLink": false,
    "main": true,
    "exports": {
      "./package.json": "./package.json",
      ".": "./src/index.ts"
    }
  },
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.js"
      }
    }
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags",
    "prepare": "tshy",
    "pretest": "npm run prepare",
    "presnap": "npm run prepare",
    "test": "tap",
    "snap": "tap",
    "format": "prettier --write . --loglevel warn",
    "typedoc": "typedoc --tsconfig .tshy/esm.json ./src/*.ts"
  },
  "prettier": {
    "semi": false,
    "printWidth": 75,
    "tabWidth": 2,
    "useTabs": false,
    "singleQuote": true,
    "jsxSingleQuote": false,
    "bracketSameLine": true,
    "arrowParens": "avoid",
    "endOfLine": "lf"
  },
  "devDependencies": {
    "@types/end-of-stream": "^1.4.2",
    "@types/node": "^20.1.2",
    "end-of-stream": "^1.4.0",
    "node-abort-controller": "^3.1.1",
    "prettier": "^2.6.2",
    "tap": "^19.0.0",
    "through2": "^2.0.3",
    "tshy": "^1.14.0",
    "typedoc": "^0.25.1"
  },
  "repository": "https://github.com/isaacs/minipass",
  "keywords": [
    "passthrough",
    "stream"
  ],
  "author": "Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)",
  "license": "ISC",
  "engines": {
    "node": ">=16 || 14 >=14.17"
  },
  "tap": {
    "typecheck": true,
    "include": [
      "test/*.ts"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\mrmime\package.json
============================================================
{
  "name": "mrmime",
  "version": "2.0.1",
  "repository": "lukeed/mrmime",
  "description": "A tiny (2.8kB) and fast utility for getting a MIME type from an extension or filename",
  "module": "index.mjs",
  "types": "index.d.ts",
  "main": "index.js",
  "license": "MIT",
  "author": {
    "name": "Luke Edwards",
    "email": "luke.edwards05@gmail.com",
    "url": "https://lukeed.com"
  },
  "exports": {
    ".": {
      "types": "./index.d.ts",
      "import": "./index.mjs",
      "require": "./index.js"
    },
    "./package.json": "./package.json"
  },
  "files": [
    "index.d.ts",
    "index.mjs",
    "index.js"
  ],
  "engines": {
    "node": ">=10"
  },
  "scripts": {
    "build": "tsm bin/index.ts",
    "test": "uvu -r tsm test"
  },
  "keywords": [
    "mime",
    "extension",
    "mimetype"
  ],
  "devDependencies": {
    "tsm": "2.3.0",
    "uvu": "0.5.2"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\ms\package.json
============================================================
{
  "name": "ms",
  "version": "2.1.3",
  "description": "Tiny millisecond conversion utility",
  "repository": "vercel/ms",
  "main": "./index",
  "files": [
    "index.js"
  ],
  "scripts": {
    "precommit": "lint-staged",
    "lint": "eslint lib/* bin/*",
    "test": "mocha tests.js"
  },
  "eslintConfig": {
    "extends": "eslint:recommended",
    "env": {
      "node": true,
      "es6": true
    }
  },
  "lint-staged": {
    "*.js": [
      "npm run lint",
      "prettier --single-quote --write",
      "git add"
    ]
  },
  "license": "MIT",
  "devDependencies": {
    "eslint": "4.18.2",
    "expect.js": "0.3.1",
    "husky": "0.14.3",
    "lint-staged": "5.0.0",
    "mocha": "4.0.1",
    "prettier": "2.0.5"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\nanoid\async\package.json
============================================================
{
  "type": "module",
  "main": "index.cjs",
  "module": "index.js",
  "react-native": {
    "./index.js": "./index.native.js"
  },
  "browser": {
    "./index.js": "./index.browser.js",
    "./index.cjs": "./index.browser.cjs"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\nanoid\non-secure\package.json
============================================================
{
  "type": "module",
  "main": "index.cjs",
  "module": "index.js",
  "react-native": "index.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\nanoid\url-alphabet\package.json
============================================================
{
  "type": "module",
  "main": "index.cjs",
  "module": "index.js",
  "react-native": "index.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\nanoid\package.json
============================================================
{
  "name": "nanoid",
  "version": "3.3.11",
  "description": "A tiny (116 bytes), secure URL-friendly unique string ID generator",
  "keywords": [
    "uuid",
    "random",
    "id",
    "url"
  ],
  "engines": {
    "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
  },
  "funding": [
    {
      "type": "github",
      "url": "https://github.com/sponsors/ai"
    }
  ],
  "author": "Andrey Sitnik <andrey@sitnik.ru>",
  "license": "MIT",
  "repository": "ai/nanoid",
  "browser": {
    "./index.js": "./index.browser.js",
    "./async/index.js": "./async/index.browser.js",
    "./async/index.cjs": "./async/index.browser.cjs",
    "./index.cjs": "./index.browser.cjs"
  },
  "react-native": "index.js",
  "bin": "./bin/nanoid.cjs",
  "sideEffects": false,
  "types": "./index.d.ts",
  "type": "module",
  "main": "index.cjs",
  "module": "index.js",
  "exports": {
    ".": {
      "react-native": "./index.browser.js",
      "browser": "./index.browser.js",
      "require": {
        "types": "./index.d.cts",
        "default": "./index.cjs"
      },
      "import": {
        "types": "./index.d.ts",
        "default": "./index.js"
      },
      "default": "./index.js"
    },
    "./package.json": "./package.json",
    "./async/package.json": "./async/package.json",
    "./async": {
      "browser": "./async/index.browser.js",
      "require": {
        "types": "./index.d.cts",
        "default": "./async/index.cjs"
      },
      "import": {
        "types": "./index.d.ts",
        "default": "./async/index.js"
      },
      "default": "./async/index.js"
    },
    "./non-secure/package.json": "./non-secure/package.json",
    "./non-secure": {
      "require": {
        "types": "./index.d.cts",
        "default": "./non-secure/index.cjs"
      },
      "import": {
        "types": "./index.d.ts",
        "default": "./non-secure/index.js"
      },
      "default": "./non-secure/index.js"
    },
    "./url-alphabet/package.json": "./url-alphabet/package.json",
    "./url-alphabet": {
      "require": {
        "types": "./index.d.cts",
        "default": "./url-alphabet/index.cjs"
      },
      "import": {
        "types": "./index.d.ts",
        "default": "./url-alphabet/index.js"
      },
      "default": "./url-alphabet/index.js"
    }
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\napi-postinstall\package.json
============================================================
{
  "name": "napi-postinstall",
  "version": "0.3.4",
  "type": "commonjs",
  "description": "The `postinstall` script helper for handling native bindings in legacy `npm` versions",
  "repository": "git+https://github.com/un-ts/napi-postinstall.git",
  "author": "JounQin <admin@1stg.me> (https://www.1stG.me)",
  "funding": "https://opencollective.com/napi-postinstall",
  "license": "MIT",
  "engines": {
    "node": "^12.20.0 || ^14.18.0 || >=16.0.0"
  },
  "bin": "./lib/cli.js",
  "main": "./lib/index.js",
  "types": "./lib/index.d.ts",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./fallback": {
      "types": "./lib/fallback.d.ts",
      "default": "./lib/fallback.js"
    },
    "./package.json": "./package.json"
  },
  "files": [
    "lib",
    "!**/*.tsbuildinfo"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\natural-compare\package.json
============================================================
{
  "name": "natural-compare",
  "version": "1.4.0",
  "stability": 3,
  "author": "Lauri Rooden (https://github.com/litejs/natural-compare-lite)",
  "license": "MIT",
  "description": "Compare strings containing a mix of letters and numbers in the way a human being would in sort order.",
  "keywords": [
    "string",
    "natural",
    "order",
    "sort",
    "natsort",
    "natcmp",
    "compare",
    "alphanum",
    "litejs"
  ],
  "main": "index.js",
  "readmeFilename": "README.md",
  "files": [
    "index.js"
  ],
  "scripts": {
    "build": "node node_modules/buildman/index.js --all",
    "test": "node tests/index.js"
  },
  "repository": "git://github.com/litejs/natural-compare-lite.git",
  "bugs": {
    "url": "https://github.com/litejs/natural-compare-lite/issues"
  },
  "devDependencies": {
    "buildman": "*",
    "testman": "*"
  },
  "buildman": {
    "dist/index-min.js": {
      "banner": "/*! litejs.com/MIT-LICENSE.txt */",
      "input": "index.js"
    }
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\node-int64\package.json
============================================================
{
  "name": "node-int64",
  "description": "Support for representing 64-bit integers in JavaScript",
  "url": "http://github.com/broofa/node-int64",
  "keywords": [
    "math",
    "integer",
    "int64"
  ],
  "author": "Robert Kieffer <robert@broofa.com>",
  "contributors": [],
  "dependencies": {},
  "license": "MIT",
  "lib": ".",
  "main": "./Int64.js",
  "version": "0.4.0",
  "scripts": {
    "test": "nodeunit test.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/broofa/node-int64"
  },
  "devDependencies": {
    "nodeunit": "^0.9.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\node-releases\package.json
============================================================
{
  "name": "node-releases",
  "version": "2.0.26",
  "description": "Node.js releases data",
  "type": "module",
  "scripts": {
    "build": "node scripts/build.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/chicoxyzzy/node-releases.git"
  },
  "keywords": [
    "nodejs",
    "releases"
  ],
  "author": "Sergey Rubanov <chi187@gmail.com>",
  "license": "MIT",
  "devDependencies": {
    "semver": "^7.3.5"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\normalize-path\package.json
============================================================
{
  "name": "normalize-path",
  "description": "Normalize slashes in a file path to be posix/unix-like forward slashes. Also condenses repeat slashes to a single slash and removes and trailing slashes, unless disabled.",
  "version": "3.0.0",
  "homepage": "https://github.com/jonschlinkert/normalize-path",
  "author": "Jon Schlinkert (https://github.com/jonschlinkert)",
  "contributors": [
    "Blaine Bublitz (https://twitter.com/BlaineBublitz)",
    "Jon Schlinkert (http://twitter.com/jonschlinkert)"
  ],
  "repository": "jonschlinkert/normalize-path",
  "bugs": {
    "url": "https://github.com/jonschlinkert/normalize-path/issues"
  },
  "license": "MIT",
  "files": [
    "index.js"
  ],
  "main": "index.js",
  "engines": {
    "node": ">=0.10.0"
  },
  "scripts": {
    "test": "mocha"
  },
  "devDependencies": {
    "gulp-format-md": "^1.0.0",
    "minimist": "^1.2.0",
    "mocha": "^3.5.3"
  },
  "keywords": [
    "absolute",
    "backslash",
    "delimiter",
    "file",
    "file-path",
    "filepath",
    "fix",
    "forward",
    "fp",
    "fs",
    "normalize",
    "path",
    "relative",
    "separator",
    "slash",
    "slashes",
    "trailing",
    "unix",
    "urix"
  ],
  "verb": {
    "toc": false,
    "layout": "default",
    "tasks": [
      "readme"
    ],
    "plugins": [
      "gulp-format-md"
    ],
    "related": {
      "description": "Other useful path-related libraries:",
      "list": [
        "contains-path",
        "is-absolute",
        "is-relative",
        "parse-filepath",
        "path-ends-with",
        "path-ends-with",
        "unixify"
      ]
    },
    "lint": {
      "reflinks": true
    }
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\npm-run-path\package.json
============================================================
{
	"name": "npm-run-path",
	"version": "4.0.1",
	"description": "Get your PATH prepended with locally installed binaries",
	"license": "MIT",
	"repository": "sindresorhus/npm-run-path",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"npm",
		"run",
		"path",
		"package",
		"bin",
		"binary",
		"binaries",
		"script",
		"cli",
		"command-line",
		"execute",
		"executable"
	],
	"dependencies": {
		"path-key": "^3.0.0"
	},
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\nwsapi\package.json
============================================================
{
  "name": "nwsapi",
  "version": "2.2.22",
  "description": "Fast CSS Selectors API Engine",
  "homepage": "https://javascript.nwbox.com/nwsapi/",
  "main": "./src/nwsapi",
  "keywords": [
    "css",
    "css3",
    "css4",
    "matcher",
    "selector"
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "https://javascript.nwbox.com/nwsapi/MIT-LICENSE"
    }
  ],
  "license": "MIT",
  "author": {
    "name": "Diego Perini",
    "email": "diego.perini@gmail.com",
    "web": "https://www.iport.it/"
  },
  "maintainers": [
    {
      "name": "Diego Perini",
      "email": "diego.perini@gmail.com",
      "web": "https://www.iport.it/"
    }
  ],
  "bugs": {
    "url": "https://github.com/dperini/nwsapi/issues"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/dperini/nwsapi.git"
  },
  "scripts": {
    "lint": "eslint ./src/nwsapi.js"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\once\package.json
============================================================
{
  "name": "once",
  "version": "1.4.0",
  "description": "Run a function exactly one time",
  "main": "once.js",
  "directories": {
    "test": "test"
  },
  "dependencies": {
    "wrappy": "1"
  },
  "devDependencies": {
    "tap": "^7.0.1"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "files": [
    "once.js"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/once"
  },
  "keywords": [
    "once",
    "function",
    "one",
    "single"
  ],
  "author": "Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)",
  "license": "ISC"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\onetime\package.json
============================================================
{
	"name": "onetime",
	"version": "5.1.2",
	"description": "Ensure a function is only called once",
	"license": "MIT",
	"repository": "sindresorhus/onetime",
	"funding": "https://github.com/sponsors/sindresorhus",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=6"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"once",
		"function",
		"one",
		"onetime",
		"func",
		"fn",
		"single",
		"call",
		"called",
		"prevent"
	],
	"dependencies": {
		"mimic-fn": "^2.1.0"
	},
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.1",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\p-limit\package.json
============================================================
{
	"name": "p-limit",
	"version": "3.1.0",
	"description": "Run multiple promise-returning & async functions with limited concurrency",
	"license": "MIT",
	"repository": "sindresorhus/p-limit",
	"funding": "https://github.com/sponsors/sindresorhus",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"promise",
		"limit",
		"limited",
		"concurrency",
		"throttle",
		"throat",
		"rate",
		"batch",
		"ratelimit",
		"task",
		"queue",
		"async",
		"await",
		"promises",
		"bluebird"
	],
	"dependencies": {
		"yocto-queue": "^0.1.0"
	},
	"devDependencies": {
		"ava": "^2.4.0",
		"delay": "^4.4.0",
		"in-range": "^2.0.0",
		"random-int": "^2.0.1",
		"time-span": "^4.0.0",
		"tsd": "^0.13.1",
		"xo": "^0.35.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\p-try\package.json
============================================================
{
	"name": "p-try",
	"version": "2.2.0",
	"description": "`Start a promise chain",
	"license": "MIT",
	"repository": "sindresorhus/p-try",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=6"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"promise",
		"try",
		"resolve",
		"function",
		"catch",
		"async",
		"await",
		"promises",
		"settled",
		"ponyfill",
		"polyfill",
		"shim",
		"bluebird"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.1",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\package-json-from-dist\dist\commonjs\package.json
============================================================
{
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\package-json-from-dist\dist\esm\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\package-json-from-dist\package.json
============================================================
{
  "name": "package-json-from-dist",
  "version": "1.0.1",
  "description": "Load the local package.json from either src or dist folder",
  "main": "./dist/commonjs/index.js",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.js"
      }
    }
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags",
    "prepare": "tshy",
    "pretest": "npm run prepare",
    "presnap": "npm run prepare",
    "test": "tap",
    "snap": "tap",
    "format": "prettier --write . --log-level warn",
    "typedoc": "typedoc"
  },
  "author": "Isaac Z. Schlueter <i@izs.me> (https://izs.me)",
  "license": "BlueOak-1.0.0",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/isaacs/package-json-from-dist.git"
  },
  "devDependencies": {
    "@types/node": "^20.12.12",
    "prettier": "^3.2.5",
    "tap": "^18.5.3",
    "typedoc": "^0.24.8",
    "typescript": "^5.1.6",
    "tshy": "^1.14.0"
  },
  "prettier": {
    "semi": false,
    "printWidth": 70,
    "tabWidth": 2,
    "useTabs": false,
    "singleQuote": true,
    "jsxSingleQuote": false,
    "bracketSameLine": true,
    "arrowParens": "avoid",
    "endOfLine": "lf",
    "experimentalTernaries": true
  },
  "tshy": {
    "exports": {
      "./package.json": "./package.json",
      ".": "./src/index.ts"
    }
  },
  "types": "./dist/commonjs/index.d.ts",
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\parse-json\package.json
============================================================
{
	"name": "parse-json",
	"version": "5.2.0",
	"description": "Parse JSON with more helpful errors",
	"license": "MIT",
	"repository": "sindresorhus/parse-json",
	"funding": "https://github.com/sponsors/sindresorhus",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && nyc ava"
	},
	"files": [
		"index.js",
		"vendor"
	],
	"keywords": [
		"parse",
		"json",
		"graceful",
		"error",
		"message",
		"humanize",
		"friendly",
		"helpful",
		"string"
	],
	"dependencies": {
		"@babel/code-frame": "^7.0.0",
		"error-ex": "^1.3.1",
		"json-parse-even-better-errors": "^2.3.0",
		"lines-and-columns": "^1.1.6"
	},
	"devDependencies": {
		"ava": "^1.4.1",
		"nyc": "^14.1.1",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\parse5\dist\cjs\package.json
============================================================
{"type":"commonjs"}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\parse5\package.json
============================================================
{
    "name": "parse5",
    "type": "module",
    "description": "HTML parser and serializer.",
    "version": "7.3.0",
    "author": "Ivan Nikulin <ifaaan@gmail.com> (https://github.com/inikulin)",
    "contributors": "https://github.com/inikulin/parse5/graphs/contributors",
    "homepage": "https://parse5.js.org",
    "funding": "https://github.com/inikulin/parse5?sponsor=1",
    "dependencies": {
        "entities": "^6.0.0"
    },
    "keywords": [
        "html",
        "parser",
        "html5",
        "WHATWG",
        "specification",
        "fast",
        "html parser",
        "html5 parser",
        "htmlparser",
        "parse5",
        "serializer",
        "html serializer",
        "htmlserializer",
        "parse",
        "serialize"
    ],
    "license": "MIT",
    "main": "dist/cjs/index.js",
    "module": "dist/index.js",
    "types": "dist/index.d.ts",
    "exports": {
        "import": "./dist/index.js",
        "require": "./dist/cjs/index.js"
    },
    "scripts": {
        "build:cjs": "tsc --noCheck --moduleResolution node10 --module CommonJS --target ES6 --outDir dist/cjs && echo '{\"type\":\"commonjs\"}' > dist/cjs/package.json"
    },
    "repository": {
        "type": "git",
        "url": "git://github.com/inikulin/parse5.git"
    },
    "files": [
        "dist/cjs/package.json",
        "dist/**/*.js",
        "dist/**/*.d.ts"
    ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\path-exists\package.json
============================================================
{
	"name": "path-exists",
	"version": "4.0.0",
	"description": "Check if a path exists",
	"license": "MIT",
	"repository": "sindresorhus/path-exists",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"path",
		"exists",
		"exist",
		"file",
		"filepath",
		"fs",
		"filesystem",
		"file-system",
		"access",
		"stat"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\path-is-absolute\package.json
============================================================
{
  "name": "path-is-absolute",
  "version": "1.0.1",
  "description": "Node.js 0.12 path.isAbsolute() ponyfill",
  "license": "MIT",
  "repository": "sindresorhus/path-is-absolute",
  "author": {
    "name": "Sindre Sorhus",
    "email": "sindresorhus@gmail.com",
    "url": "sindresorhus.com"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "scripts": {
    "test": "xo && node test.js"
  },
  "files": [
    "index.js"
  ],
  "keywords": [
    "path",
    "paths",
    "file",
    "dir",
    "absolute",
    "isabsolute",
    "is-absolute",
    "built-in",
    "util",
    "utils",
    "core",
    "ponyfill",
    "polyfill",
    "shim",
    "is",
    "detect",
    "check"
  ],
  "devDependencies": {
    "xo": "^0.16.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\path-key\package.json
============================================================
{
	"name": "path-key",
	"version": "3.1.1",
	"description": "Get the PATH environment variable key cross-platform",
	"license": "MIT",
	"repository": "sindresorhus/path-key",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"path",
		"key",
		"environment",
		"env",
		"variable",
		"var",
		"get",
		"cross-platform",
		"windows"
	],
	"devDependencies": {
		"@types/node": "^11.13.0",
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\path-parse\package.json
============================================================
{
  "name": "path-parse",
  "version": "1.0.7",
  "description": "Node.js path.parse() ponyfill",
  "main": "index.js",
  "scripts": {
    "test": "node test.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jbgutierrez/path-parse.git"
  },
  "keywords": [
    "path",
    "paths",
    "file",
    "dir",
    "parse",
    "built-in",
    "util",
    "utils",
    "core",
    "ponyfill",
    "polyfill",
    "shim"
  ],
  "author": "Javier Blanco <http://jbgutierrez.info>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/jbgutierrez/path-parse/issues"
  },
  "homepage": "https://github.com/jbgutierrez/path-parse#readme"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\path-scurry\dist\commonjs\package.json
============================================================
{
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\path-scurry\dist\esm\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\path-scurry\node_modules\lru-cache\dist\commonjs\package.json
============================================================
{
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\path-scurry\node_modules\lru-cache\dist\esm\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\path-scurry\node_modules\lru-cache\package.json
============================================================
{
  "name": "lru-cache",
  "publishConfig": {
    "tag": "legacy-v10"
  },
  "description": "A cache object that deletes the least-recently-used items.",
  "version": "10.4.3",
  "author": "Isaac Z. Schlueter <i@izs.me>",
  "keywords": [
    "mru",
    "lru",
    "cache"
  ],
  "sideEffects": false,
  "scripts": {
    "build": "npm run prepare",
    "prepare": "tshy && bash fixup.sh",
    "pretest": "npm run prepare",
    "presnap": "npm run prepare",
    "test": "tap",
    "snap": "tap",
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags",
    "format": "prettier --write .",
    "typedoc": "typedoc --tsconfig ./.tshy/esm.json ./src/*.ts",
    "benchmark-results-typedoc": "bash scripts/benchmark-results-typedoc.sh",
    "prebenchmark": "npm run prepare",
    "benchmark": "make -C benchmark",
    "preprofile": "npm run prepare",
    "profile": "make -C benchmark profile"
  },
  "main": "./dist/commonjs/index.js",
  "types": "./dist/commonjs/index.d.ts",
  "tshy": {
    "exports": {
      ".": "./src/index.ts",
      "./min": {
        "import": {
          "types": "./dist/esm/index.d.ts",
          "default": "./dist/esm/index.min.js"
        },
        "require": {
          "types": "./dist/commonjs/index.d.ts",
          "default": "./dist/commonjs/index.min.js"
        }
      }
    }
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/node-lru-cache.git"
  },
  "devDependencies": {
    "@types/node": "^20.2.5",
    "@types/tap": "^15.0.6",
    "benchmark": "^2.1.4",
    "esbuild": "^0.17.11",
    "eslint-config-prettier": "^8.5.0",
    "marked": "^4.2.12",
    "mkdirp": "^2.1.5",
    "prettier": "^2.6.2",
    "tap": "^20.0.3",
    "tshy": "^2.0.0",
    "tslib": "^2.4.0",
    "typedoc": "^0.25.3",
    "typescript": "^5.2.2"
  },
  "license": "ISC",
  "files": [
    "dist"
  ],
  "prettier": {
    "semi": false,
    "printWidth": 70,
    "tabWidth": 2,
    "useTabs": false,
    "singleQuote": true,
    "jsxSingleQuote": false,
    "bracketSameLine": true,
    "arrowParens": "avoid",
    "endOfLine": "lf"
  },
  "tap": {
    "node-arg": [
      "--expose-gc"
    ],
    "plugin": [
      "@tapjs/clock"
    ]
  },
  "exports": {
    ".": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.js"
      }
    },
    "./min": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.min.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.min.js"
      }
    }
  },
  "type": "module",
  "module": "./dist/esm/index.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\path-scurry\package.json
============================================================
{
  "name": "path-scurry",
  "version": "1.11.1",
  "description": "walk paths fast and efficiently",
  "author": "Isaac Z. Schlueter <i@izs.me> (https://blog.izs.me)",
  "main": "./dist/commonjs/index.js",
  "type": "module",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.js"
      }
    }
  },
  "files": [
    "dist"
  ],
  "license": "BlueOak-1.0.0",
  "scripts": {
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags",
    "prepare": "tshy",
    "pretest": "npm run prepare",
    "presnap": "npm run prepare",
    "test": "tap",
    "snap": "tap",
    "format": "prettier --write . --loglevel warn",
    "typedoc": "typedoc --tsconfig tsconfig-esm.json ./src/*.ts",
    "bench": "bash ./scripts/bench.sh"
  },
  "prettier": {
    "experimentalTernaries": true,
    "semi": false,
    "printWidth": 75,
    "tabWidth": 2,
    "useTabs": false,
    "singleQuote": true,
    "jsxSingleQuote": false,
    "bracketSameLine": true,
    "arrowParens": "avoid",
    "endOfLine": "lf"
  },
  "devDependencies": {
    "@nodelib/fs.walk": "^1.2.8",
    "@types/node": "^20.12.11",
    "c8": "^7.12.0",
    "eslint-config-prettier": "^8.6.0",
    "mkdirp": "^3.0.0",
    "prettier": "^3.2.5",
    "rimraf": "^5.0.1",
    "tap": "^18.7.2",
    "ts-node": "^10.9.2",
    "tshy": "^1.14.0",
    "typedoc": "^0.25.12",
    "typescript": "^5.4.3"
  },
  "tap": {
    "typecheck": true
  },
  "engines": {
    "node": ">=16 || 14 >=14.18"
  },
  "funding": {
    "url": "https://github.com/sponsors/isaacs"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/isaacs/path-scurry"
  },
  "dependencies": {
    "lru-cache": "^10.2.0",
    "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
  },
  "tshy": {
    "selfLink": false,
    "exports": {
      "./package.json": "./package.json",
      ".": "./src/index.ts"
    }
  },
  "types": "./dist/commonjs/index.d.ts"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\pathe\package.json
============================================================
{
  "name": "pathe",
  "version": "2.0.3",
  "description": "Universal filesystem path utils",
  "repository": "unjs/pathe",
  "license": "MIT",
  "sideEffects": false,
  "type": "module",
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.mts",
        "default": "./dist/index.mjs"
      },
      "require": {
        "types": "./dist/index.d.cts",
        "default": "./dist/index.cjs"
      }
    },
    "./utils": {
      "import": {
        "types": "./dist/utils.d.mts",
        "default": "./dist/utils.mjs"
      },
      "require": {
        "types": "./dist/utils.d.cts",
        "default": "./dist/utils.cjs"
      }
    }
  },
  "main": "./dist/index.cjs",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "files": [
    "dist",
    "utils.d.ts"
  ],
  "devDependencies": {
    "@types/node": "^22.13.1",
    "@vitest/coverage-v8": "^3.0.5",
    "changelogen": "^0.5.7",
    "esbuild": "^0.25.0",
    "eslint": "^9.20.1",
    "eslint-config-unjs": "^0.4.2",
    "jiti": "^2.4.2",
    "prettier": "^3.5.0",
    "typescript": "^5.7.3",
    "unbuild": "^3.3.1",
    "vitest": "^3.0.5",
    "zeptomatch": "^2.0.0"
  },
  "scripts": {
    "build": "unbuild",
    "dev": "vitest",
    "lint": "eslint . && prettier -c src test",
    "lint:fix": "eslint . --fix && prettier -w src test",
    "release": "pnpm test && pnpm build && changelogen --release && pnpm publish && git push --follow-tags",
    "test": "pnpm lint && vitest run --coverage",
    "test:types": "tsc --noEmit"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\picocolors\package.json
============================================================
{
  "name": "picocolors",
  "version": "1.1.1",
  "main": "./picocolors.js",
  "types": "./picocolors.d.ts",
  "browser": {
    "./picocolors.js": "./picocolors.browser.js"
  },
  "sideEffects": false,
  "description": "The tiniest and the fastest library for terminal output formatting with ANSI colors",
  "files": [
    "picocolors.*",
    "types.d.ts"
  ],
  "keywords": [
    "terminal",
    "colors",
    "formatting",
    "cli",
    "console"
  ],
  "author": "Alexey Raspopov",
  "repository": "alexeyraspopov/picocolors",
  "license": "ISC"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\picomatch\package.json
============================================================
{
  "name": "picomatch",
  "description": "Blazing fast and accurate glob matcher written in JavaScript, with no dependencies and full support for standard and extended Bash glob features, including braces, extglobs, POSIX brackets, and regular expressions.",
  "version": "2.3.1",
  "homepage": "https://github.com/micromatch/picomatch",
  "author": "Jon Schlinkert (https://github.com/jonschlinkert)",
  "funding": "https://github.com/sponsors/jonschlinkert",
  "repository": "micromatch/picomatch",
  "bugs": {
    "url": "https://github.com/micromatch/picomatch/issues"
  },
  "license": "MIT",
  "files": [
    "index.js",
    "lib"
  ],
  "main": "index.js",
  "engines": {
    "node": ">=8.6"
  },
  "scripts": {
    "lint": "eslint --cache --cache-location node_modules/.cache/.eslintcache --report-unused-disable-directives --ignore-path .gitignore .",
    "mocha": "mocha --reporter dot",
    "test": "npm run lint && npm run mocha",
    "test:ci": "npm run test:cover",
    "test:cover": "nyc npm run mocha"
  },
  "devDependencies": {
    "eslint": "^6.8.0",
    "fill-range": "^7.0.1",
    "gulp-format-md": "^2.0.0",
    "mocha": "^6.2.2",
    "nyc": "^15.0.0",
    "time-require": "github:jonschlinkert/time-require"
  },
  "keywords": [
    "glob",
    "match",
    "picomatch"
  ],
  "nyc": {
    "reporter": [
      "html",
      "lcov",
      "text-summary"
    ]
  },
  "verb": {
    "toc": {
      "render": true,
      "method": "preWrite",
      "maxdepth": 3
    },
    "layout": "empty",
    "tasks": [
      "readme"
    ],
    "plugins": [
      "gulp-format-md"
    ],
    "lint": {
      "reflinks": true
    },
    "related": {
      "list": [
        "braces",
        "micromatch"
      ]
    },
    "reflinks": [
      "braces",
      "expand-brackets",
      "extglob",
      "fill-range",
      "micromatch",
      "minimatch",
      "nanomatch",
      "picomatch"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\pirates\package.json
============================================================
{
  "name": "pirates",
  "description": "Properly hijack require, i.e., properly define require hooks and customizations",
  "main": "lib/index.js",
  "types": "index.d.ts",
  "scripts": {
    "test": "ava"
  },
  "files": [
    "lib",
    "index.d.ts"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/danez/pirates.git"
  },
  "engines": {
    "node": ">= 6"
  },
  "author": {
    "name": "Ari Porad",
    "email": "ari@ariporad.com",
    "url": "http://ariporad.com"
  },
  "devDependencies": {
    "ava": "1.4.1",
    "decache": "4.6.2"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/danez/pirates/issues"
  },
  "homepage": "https://github.com/danez/pirates#readme",
  "ava": {
    "files": [
      "test/*.js"
    ],
    "sources": [
      "lib/**/*.js"
    ]
  },
  "version": "4.0.7"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\pkg-dir\node_modules\find-up\package.json
============================================================
{
	"name": "find-up",
	"version": "4.1.0",
	"description": "Find a file or directory by walking up parent directories",
	"license": "MIT",
	"repository": "sindresorhus/find-up",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"find",
		"up",
		"find-up",
		"findup",
		"look-up",
		"look",
		"file",
		"search",
		"match",
		"package",
		"resolve",
		"parent",
		"parents",
		"folder",
		"directory",
		"walk",
		"walking",
		"path"
	],
	"dependencies": {
		"locate-path": "^5.0.0",
		"path-exists": "^4.0.0"
	},
	"devDependencies": {
		"ava": "^2.1.0",
		"is-path-inside": "^2.1.0",
		"tempy": "^0.3.0",
		"tsd": "^0.7.3",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\pkg-dir\node_modules\locate-path\package.json
============================================================
{
	"name": "locate-path",
	"version": "5.0.0",
	"description": "Get the first path that exists on disk of multiple paths",
	"license": "MIT",
	"repository": "sindresorhus/locate-path",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"locate",
		"path",
		"paths",
		"file",
		"files",
		"exists",
		"find",
		"finder",
		"search",
		"searcher",
		"array",
		"iterable",
		"iterator"
	],
	"dependencies": {
		"p-locate": "^4.1.0"
	},
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\pkg-dir\node_modules\p-limit\package.json
============================================================
{
	"name": "p-limit",
	"version": "2.3.0",
	"description": "Run multiple promise-returning & async functions with limited concurrency",
	"license": "MIT",
	"repository": "sindresorhus/p-limit",
	"funding": "https://github.com/sponsors/sindresorhus",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=6"
	},
	"scripts": {
		"test": "xo && ava && tsd-check"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"promise",
		"limit",
		"limited",
		"concurrency",
		"throttle",
		"throat",
		"rate",
		"batch",
		"ratelimit",
		"task",
		"queue",
		"async",
		"await",
		"promises",
		"bluebird"
	],
	"dependencies": {
		"p-try": "^2.0.0"
	},
	"devDependencies": {
		"ava": "^1.2.1",
		"delay": "^4.1.0",
		"in-range": "^1.0.0",
		"random-int": "^1.0.0",
		"time-span": "^2.0.0",
		"tsd-check": "^0.3.0",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\pkg-dir\node_modules\p-locate\package.json
============================================================
{
	"name": "p-locate",
	"version": "4.1.0",
	"description": "Get the first fulfilled promise that satisfies the provided testing function",
	"license": "MIT",
	"repository": "sindresorhus/p-locate",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"promise",
		"locate",
		"find",
		"finder",
		"search",
		"searcher",
		"test",
		"array",
		"collection",
		"iterable",
		"iterator",
		"race",
		"fulfilled",
		"fastest",
		"async",
		"await",
		"promises",
		"bluebird"
	],
	"dependencies": {
		"p-limit": "^2.2.0"
	},
	"devDependencies": {
		"ava": "^1.4.1",
		"delay": "^4.1.0",
		"in-range": "^1.0.0",
		"time-span": "^3.0.0",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\pkg-dir\package.json
============================================================
{
	"name": "pkg-dir",
	"version": "4.2.0",
	"description": "Find the root directory of a Node.js project or npm package",
	"license": "MIT",
	"repository": "sindresorhus/pkg-dir",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"package",
		"json",
		"root",
		"npm",
		"entry",
		"find",
		"up",
		"find-up",
		"findup",
		"look-up",
		"look",
		"file",
		"search",
		"match",
		"resolve",
		"parent",
		"parents",
		"folder",
		"directory",
		"dir",
		"walk",
		"walking",
		"path"
	],
	"dependencies": {
		"find-up": "^4.0.0"
	},
	"devDependencies": {
		"ava": "^1.4.1",
		"tempy": "^0.3.0",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\postcss\package.json
============================================================
{
  "name": "postcss",
  "version": "8.5.6",
  "description": "Tool for transforming styles with JS plugins",
  "engines": {
    "node": "^10 || ^12 || >=14"
  },
  "exports": {
    ".": {
      "import": "./lib/postcss.mjs",
      "require": "./lib/postcss.js"
    },
    "./lib/at-rule": "./lib/at-rule.js",
    "./lib/comment": "./lib/comment.js",
    "./lib/container": "./lib/container.js",
    "./lib/css-syntax-error": "./lib/css-syntax-error.js",
    "./lib/declaration": "./lib/declaration.js",
    "./lib/fromJSON": "./lib/fromJSON.js",
    "./lib/input": "./lib/input.js",
    "./lib/lazy-result": "./lib/lazy-result.js",
    "./lib/no-work-result": "./lib/no-work-result.js",
    "./lib/list": "./lib/list.js",
    "./lib/map-generator": "./lib/map-generator.js",
    "./lib/node": "./lib/node.js",
    "./lib/parse": "./lib/parse.js",
    "./lib/parser": "./lib/parser.js",
    "./lib/postcss": "./lib/postcss.js",
    "./lib/previous-map": "./lib/previous-map.js",
    "./lib/processor": "./lib/processor.js",
    "./lib/result": "./lib/result.js",
    "./lib/root": "./lib/root.js",
    "./lib/rule": "./lib/rule.js",
    "./lib/stringifier": "./lib/stringifier.js",
    "./lib/stringify": "./lib/stringify.js",
    "./lib/symbols": "./lib/symbols.js",
    "./lib/terminal-highlight": "./lib/terminal-highlight.js",
    "./lib/tokenize": "./lib/tokenize.js",
    "./lib/warn-once": "./lib/warn-once.js",
    "./lib/warning": "./lib/warning.js",
    "./package.json": "./package.json"
  },
  "main": "./lib/postcss.js",
  "types": "./lib/postcss.d.ts",
  "keywords": [
    "css",
    "postcss",
    "rework",
    "preprocessor",
    "parser",
    "source map",
    "transform",
    "manipulation",
    "transpiler"
  ],
  "funding": [
    {
      "type": "opencollective",
      "url": "https://opencollective.com/postcss/"
    },
    {
      "type": "tidelift",
      "url": "https://tidelift.com/funding/github/npm/postcss"
    },
    {
      "type": "github",
      "url": "https://github.com/sponsors/ai"
    }
  ],
  "author": "Andrey Sitnik <andrey@sitnik.ru>",
  "license": "MIT",
  "homepage": "https://postcss.org/",
  "repository": "postcss/postcss",
  "bugs": {
    "url": "https://github.com/postcss/postcss/issues"
  },
  "dependencies": {
    "nanoid": "^3.3.11",
    "picocolors": "^1.1.1",
    "source-map-js": "^1.2.1"
  },
  "browser": {
    "./lib/terminal-highlight": false,
    "source-map-js": false,
    "path": false,
    "url": false,
    "fs": false
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\postcss-value-parser\package.json
============================================================
{
  "name": "postcss-value-parser",
  "version": "4.2.0",
  "description": "Transforms css values and at-rule params into the tree",
  "main": "lib/index.js",
  "files": [
    "lib"
  ],
  "devDependencies": {
    "eslint": "^5.16.0",
    "husky": "^2.3.0",
    "lint-staged": "^8.1.7",
    "prettier": "^1.17.1",
    "tap-spec": "^5.0.0",
    "tape": "^4.10.2"
  },
  "scripts": {
    "lint:prettier": "prettier \"**/*.js\" \"**/*.ts\" --list-different",
    "lint:js": "eslint . --cache",
    "lint": "yarn lint:js && yarn lint:prettier",
    "pretest": "yarn lint",
    "test": "tape test/*.js | tap-spec"
  },
  "eslintConfig": {
    "env": {
      "es6": true,
      "node": true
    },
    "extends": "eslint:recommended"
  },
  "lint-staged": {
    "*.js": [
      "eslint",
      "prettier --write",
      "git add"
    ]
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "author": "Bogdan Chadkin <trysound@yandex.ru>",
  "license": "MIT",
  "homepage": "https://github.com/TrySound/postcss-value-parser",
  "repository": {
    "type": "git",
    "url": "https://github.com/TrySound/postcss-value-parser.git"
  },
  "keywords": [
    "postcss",
    "value",
    "parser"
  ],
  "bugs": {
    "url": "https://github.com/TrySound/postcss-value-parser/issues"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\pretty-format\node_modules\ansi-styles\package.json
============================================================
{
	"name": "ansi-styles",
	"version": "5.2.0",
	"description": "ANSI escape codes for styling strings in the terminal",
	"license": "MIT",
	"repository": "chalk/ansi-styles",
	"funding": "https://github.com/chalk/ansi-styles?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"screenshot": "svg-term --command='node screenshot' --out=screenshot.svg --padding=3 --width=55 --height=3 --at=1000 --no-cursor"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"devDependencies": {
		"ava": "^2.4.0",
		"svg-term-cli": "^2.1.1",
		"tsd": "^0.14.0",
		"xo": "^0.37.1"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\pretty-format\node_modules\react-is\package.json
============================================================
{
  "name": "react-is",
  "version": "17.0.2",
  "description": "Brand checking of React Elements.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react-is"
  },
  "keywords": [
    "react"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/facebook/react/issues"
  },
  "homepage": "https://reactjs.org/",
  "files": [
    "LICENSE",
    "README.md",
    "build-info.json",
    "index.js",
    "cjs/",
    "umd/"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\pretty-format\package.json
============================================================
{
  "name": "pretty-format",
  "version": "27.5.1",
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/jest.git",
    "directory": "packages/pretty-format"
  },
  "license": "MIT",
  "description": "Stringify any JavaScript value.",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json",
    "./ConvertAnsi": "./build/plugins/ConvertAnsi.js"
  },
  "author": "James Kyle <me@thejameskyle.com>",
  "dependencies": {
    "ansi-regex": "^5.0.1",
    "ansi-styles": "^5.0.0",
    "react-is": "^17.0.1"
  },
  "devDependencies": {
    "@types/react": "*",
    "@types/react-is": "^17.0.0",
    "@types/react-test-renderer": "*",
    "immutable": "^4.0.0",
    "jest-util": "^27.5.1",
    "react": "*",
    "react-dom": "*",
    "react-test-renderer": "*"
  },
  "engines": {
    "node": "^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "67c1aa20c5fec31366d733e901fee2b981cb1850"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\proxy-from-env\package.json
============================================================
{
  "name": "proxy-from-env",
  "version": "1.1.0",
  "description": "Offers getProxyForUrl to get the proxy URL for a URL, respecting the *_PROXY (e.g. HTTP_PROXY) and NO_PROXY environment variables.",
  "main": "index.js",
  "scripts": {
    "lint": "eslint *.js",
    "test": "mocha ./test.js --reporter spec",
    "test-coverage": "istanbul cover ./node_modules/.bin/_mocha -- --reporter spec"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Rob--W/proxy-from-env.git"
  },
  "keywords": [
    "proxy",
    "http_proxy",
    "https_proxy",
    "no_proxy",
    "environment"
  ],
  "author": "Rob Wu <rob@robwu.nl> (https://robwu.nl/)",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/Rob--W/proxy-from-env/issues"
  },
  "homepage": "https://github.com/Rob--W/proxy-from-env#readme",
  "devDependencies": {
    "coveralls": "^3.0.9",
    "eslint": "^6.8.0",
    "istanbul": "^0.4.5",
    "mocha": "^7.1.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\punycode\package.json
============================================================
{
  "name": "punycode",
  "version": "2.3.1",
  "description": "A robust Punycode converter that fully complies to RFC 3492 and RFC 5891, and works on nearly all JavaScript platforms.",
  "homepage": "https://mths.be/punycode",
  "main": "punycode.js",
  "jsnext:main": "punycode.es6.js",
  "module": "punycode.es6.js",
  "engines": {
    "node": ">=6"
  },
  "keywords": [
    "punycode",
    "unicode",
    "idn",
    "idna",
    "dns",
    "url",
    "domain"
  ],
  "license": "MIT",
  "author": {
    "name": "Mathias Bynens",
    "url": "https://mathiasbynens.be/"
  },
  "contributors": [
    {
      "name": "Mathias Bynens",
      "url": "https://mathiasbynens.be/"
    }
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/mathiasbynens/punycode.js.git"
  },
  "bugs": "https://github.com/mathiasbynens/punycode.js/issues",
  "files": [
    "LICENSE-MIT.txt",
    "punycode.js",
    "punycode.es6.js"
  ],
  "scripts": {
    "test": "mocha tests",
    "build": "node scripts/prepublish.js"
  },
  "devDependencies": {
    "codecov": "^3.8.3",
    "nyc": "^15.1.0",
    "mocha": "^10.2.0"
  },
  "jspm": {
    "map": {
      "./punycode.js": {
        "node": "@node/punycode"
      }
    }
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\pure-rand\lib\esm\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\pure-rand\package.json
============================================================
{
  "name": "pure-rand",
  "version": "7.0.1",
  "description": " Pure random number generator written in TypeScript",
  "type": "commonjs",
  "main": "lib/pure-rand.js",
  "exports": {
    "./package.json": "./package.json",
    "./distribution/*": {
      "require": {
        "types": "./lib/types/distribution/*.d.ts",
        "default": "./lib/distribution/*.js"
      },
      "import": {
        "types": "./lib/esm/types/distribution/*.d.ts",
        "default": "./lib/esm/distribution/*.js"
      }
    },
    "./generator/*": {
      "require": {
        "types": "./lib/types/generator/*.d.ts",
        "default": "./lib/generator/*.js"
      },
      "import": {
        "types": "./lib/esm/types/generator/*.d.ts",
        "default": "./lib/esm/generator/*.js"
      }
    },
    "./types/*": {
      "require": {
        "types": "./lib/types/types/*.d.ts",
        "default": "./lib/types/*.js"
      },
      "import": {
        "types": "./lib/esm/types/types/*.d.ts",
        "default": "./lib/esm/types/*.js"
      }
    },
    ".": {
      "require": {
        "types": "./lib/types/pure-rand.d.ts",
        "default": "./lib/pure-rand.js"
      },
      "import": {
        "types": "./lib/esm/types/pure-rand.d.ts",
        "default": "./lib/esm/pure-rand.js"
      }
    }
  },
  "module": "lib/esm/pure-rand.js",
  "types": "lib/types/pure-rand.d.ts",
  "files": [
    "lib"
  ],
  "sideEffects": false,
  "packageManager": "yarn@4.6.0",
  "scripts": {
    "format:check": "prettier --list-different .",
    "format": "prettier --write .",
    "build": "tsc && tsc -p ./tsconfig.declaration.json",
    "build:esm": "tsc --module es2015 --outDir lib/esm --moduleResolution node && tsc -p ./tsconfig.declaration.json --outDir lib/esm/types && cp package.esm-template.json lib/esm/package.json",
    "build:prod": "yarn build && yarn build:esm && node postbuild/main.mjs",
    "build:prod-ci": "cross-env EXPECT_GITHUB_SHA=true yarn build:prod",
    "test": "jest --config jest.config.js --coverage",
    "build:bench:old": "tsc --outDir lib-reference/",
    "build:bench:new": "tsc --outDir lib-test/",
    "bench": "node perf/benchmark.cjs"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dubzzz/pure-rand.git"
  },
  "author": "Nicolas DUBIEN <github@dubien.org>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/dubzzz/pure-rand/issues"
  },
  "homepage": "https://github.com/dubzzz/pure-rand#readme",
  "devDependencies": {
    "@types/jest": "^29.5.14",
    "@types/node": "^22.13.1",
    "cross-env": "^7.0.3",
    "fast-check": "^3.23.2",
    "jest": "^29.7.0",
    "prettier": "3.4.2",
    "replace-in-file": "^8.3.0",
    "source-map-support": "^0.5.21",
    "tinybench": "^3.1.1",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.5.3"
  },
  "keywords": [
    "seed",
    "random",
    "prng",
    "generator",
    "pure",
    "rand",
    "mersenne",
    "random number generator",
    "fastest",
    "fast"
  ],
  "funding": [
    {
      "type": "individual",
      "url": "https://github.com/sponsors/dubzzz"
    },
    {
      "type": "opencollective",
      "url": "https://opencollective.com/fast-check"
    }
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\react\package.json
============================================================
{
  "name": "react",
  "description": "React is a JavaScript library for building user interfaces.",
  "keywords": [
    "react"
  ],
  "version": "18.3.1",
  "homepage": "https://reactjs.org/",
  "bugs": "https://github.com/facebook/react/issues",
  "license": "MIT",
  "files": [
    "LICENSE",
    "README.md",
    "index.js",
    "cjs/",
    "umd/",
    "jsx-runtime.js",
    "jsx-dev-runtime.js",
    "react.shared-subset.js"
  ],
  "main": "index.js",
  "exports": {
    ".": {
      "react-server": "./react.shared-subset.js",
      "default": "./index.js"
    },
    "./package.json": "./package.json",
    "./jsx-runtime": "./jsx-runtime.js",
    "./jsx-dev-runtime": "./jsx-dev-runtime.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "dependencies": {
    "loose-envify": "^1.1.0"
  },
  "browserify": {
    "transform": [
      "loose-envify"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\react-dom\package.json
============================================================
{
  "name": "react-dom",
  "version": "18.3.1",
  "description": "React package for working with the DOM.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react-dom"
  },
  "keywords": [
    "react"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/facebook/react/issues"
  },
  "homepage": "https://reactjs.org/",
  "dependencies": {
    "loose-envify": "^1.1.0",
    "scheduler": "^0.23.2"
  },
  "peerDependencies": {
    "react": "^18.3.1"
  },
  "files": [
    "LICENSE",
    "README.md",
    "index.js",
    "client.js",
    "profiling.js",
    "server.js",
    "server.browser.js",
    "server.node.js",
    "test-utils.js",
    "cjs/",
    "umd/"
  ],
  "exports": {
    ".": "./index.js",
    "./client": "./client.js",
    "./server": {
      "deno": "./server.browser.js",
      "worker": "./server.browser.js",
      "browser": "./server.browser.js",
      "default": "./server.node.js"
    },
    "./server.browser": "./server.browser.js",
    "./server.node": "./server.node.js",
    "./profiling": "./profiling.js",
    "./test-utils": "./test-utils.js",
    "./package.json": "./package.json"
  },
  "browser": {
    "./server.js": "./server.browser.js"
  },
  "browserify": {
    "transform": [
      "loose-envify"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\react-i18next\dist\es\package.json
============================================================
{"type":"module","version":"12.3.1"}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\react-i18next\package.json
============================================================
{
  "name": "react-i18next",
  "version": "12.3.1",
  "description": "Internationalization for react done right. Using the i18next i18n ecosystem.",
  "main": "dist/commonjs/index.js",
  "types": "./index.d.ts",
  "jsnext:main": "dist/es/index.js",
  "module": "dist/es/index.js",
  "keywords": [
    "i18next",
    "internationalization",
    "i18n",
    "translation",
    "localization",
    "l10n",
    "globalization",
    "react",
    "reactjs"
  ],
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./index.d.ts",
      "module": "./dist/es/index.js",
      "import": "./dist/es/index.js",
      "require": "./dist/commonjs/index.js",
      "default": "./dist/es/index.js"
    },
    "./TransWithoutContext": {
      "types": "./TransWithoutContext.d.ts",
      "module": "./dist/es/TransWithoutContext.js",
      "import": "./dist/es/TransWithoutContext.js",
      "require": "./dist/commonjs/TransWithoutContext.js",
      "default": "./dist/es/TransWithoutContext.js"
    },
    "./initReactI18next": {
      "types": "./initReactI18next.d.ts",
      "module": "./dist/es/initReactI18next.js",
      "import": "./dist/es/initReactI18next.js",
      "require": "./dist/commonjs/initReactI18next.js",
      "default": "./dist/es/initReactI18next.js"
    }
  },
  "homepage": "https://github.com/i18next/react-i18next",
  "bugs": "https://github.com/i18next/react-i18next/issues",
  "repository": {
    "type": "git",
    "url": "https://github.com/i18next/react-i18next.git"
  },
  "dependencies": {
    "@babel/runtime": "^7.20.6",
    "html-parse-stringify": "^3.0.1"
  },
  "devDependencies": {
    "@babel/cli": "^7.14.5",
    "@babel/core": "^7.14.5",
    "@babel/plugin-proposal-async-generator-functions": "^7.14.5",
    "@babel/plugin-proposal-object-rest-spread": "^7.14.5",
    "@babel/plugin-transform-modules-commonjs": "^7.14.5",
    "@babel/plugin-transform-runtime": "^7.14.5",
    "@babel/polyfill": "^7.2.5",
    "@babel/preset-env": "^7.14.5",
    "@babel/preset-react": "^7.14.5",
    "@babel/register": "^7.14.5",
    "@testing-library/jest-dom": "^5.11.6",
    "@testing-library/react": "^11.2.7",
    "@testing-library/react-hooks": "^3.4.2",
    "all-contributors-cli": "^6.20.0",
    "babel-core": "^7.0.0-bridge.0",
    "babel-eslint": "^10.0.3",
    "babel-jest": "^24.8.0",
    "babel-plugin-macros": "^2.5.0",
    "babel-plugin-tester": "^6.0.0",
    "coveralls": "^3.1.0",
    "cp-cli": "^2.0.0",
    "cross-env": "^7.0.3",
    "dtslint": "^4.1.0",
    "eslint": "^7.28.0",
    "eslint-config-airbnb": "^18.2.1",
    "eslint-config-prettier": "6.4.0",
    "eslint-plugin-import": "^2.23.4",
    "eslint-plugin-jest-dom": "^3.6.3",
    "eslint-plugin-jsx-a11y": "^6.4.1",
    "eslint-plugin-react": "^7.16.0",
    "eslint-plugin-testing-library": "^3.10.1",
    "husky": "^3.0.3",
    "i18next": "^22.5.0",
    "jest": "^24.8.0",
    "jest-cli": "^24.8.4",
    "lint-staged": "^8.1.3",
    "mkdirp": "^1.0.4",
    "prettier": "2.2.1",
    "react": "^16.14.0",
    "react-dom": "^16.14.0",
    "react-test-renderer": "^16.14.0",
    "rimraf": "2.6.3",
    "rollup": "1.19.4",
    "rollup-plugin-babel": "^4.3.2",
    "rollup-plugin-commonjs": "^10.0.2",
    "rollup-plugin-node-resolve": "^5.2.0",
    "rollup-plugin-replace": "^2.1.0",
    "rollup-plugin-terser": "^5.1.1",
    "sinon": "^7.2.3",
    "tslint": "^6.1.3",
    "typescript": "4.6.2",
    "yargs": "^13.3.0"
  },
  "peerDependencies": {
    "i18next": ">= 19.0.0",
    "react": ">= 16.8.0"
  },
  "peerDependenciesMeta": {
    "react-dom": {
      "optional": true
    },
    "react-native": {
      "optional": true
    }
  },
  "scripts": {
    "clean": "rimraf dist && mkdirp dist",
    "copy": "cp-cli ./dist/umd/react-i18next.min.js ./react-i18next.min.js && cp-cli ./dist/umd/react-i18next.js ./react-i18next.js && echo '{\"type\":\"module\"}' > dist/es/package.json",
    "build:es": "cross-env BABEL_ENV=jsnext babel src --out-dir dist/es",
    "build:cjs": "babel src --out-dir dist/commonjs",
    "build:umd": "rollup -c rollup.config.js --format umd && rollup -c rollup.config.js --format umd --uglify",
    "build:amd": "rollup -c rollup.config.js --format amd && rollup -c rollup.config.js --format amd --uglify",
    "build:iife": "rollup -c rollup.config.js --format iife && rollup -c rollup.config.js --format iife --uglify",
    "build": "npm run clean && npm run build:cjs && npm run build:es && npm run build:umd && npm run build:amd && npm run copy",
    "fix_dist_package": "node -e 'console.log(`{\"type\":\"module\",\"version\":\"${process.env.npm_package_version}\"}`)' > dist/es/package.json",
    "preversion": "npm run build && git push",
    "postversion": "npm run fix_dist_package && git push && git push --tags",
    "pretest": "npm run test:typescript && npm run test:typescript:noninterop && npm run test:typescript:customtypes",
    "test": "cross-env BABEL_ENV=development jest --no-cache",
    "test:watch": "cross-env BABEL_ENV=development jest --no-cache --watch",
    "test:coverage": "cross-env BABEL_ENV=development jest --no-cache --coverage",
    "test:lint": "eslint ./src ./test",
    "test:typescript": "tslint --project tsconfig.json '**/*.{ts,tsx}'",
    "test:typescript:noninterop": "tslint --project tsconfig.nonEsModuleInterop.json '**/*.{ts,tsx}'",
    "test:typescript:customtypes": "tslint --project ./test/typescript/custom-types/tsconfig.json '**/*.{ts,tsx}'",
    "contributors:add": "all-contributors add",
    "contributors:generate": "all-contributors generate",
    "prettier": "prettier --write \"{,**/}*.{ts,tsx,js,json,md}\""
  },
  "author": "Jan Mühlemann <jan.muehlemann@gmail.com> (https://github.com/jamuhl)",
  "license": "MIT",
  "jest": {
    "setupFilesAfterEnv": [
      "./test/setup.js"
    ],
    "unmockedModulePathPatterns": [
      "react"
    ],
    "testMatch": [
      "**/test/?(*.)(spec|test).js?(x)"
    ],
    "modulePathIgnorePatterns": [
      "<rootDir>/example/"
    ],
    "collectCoverageFrom": [
      "**/src/*.{js,jsx}",
      "*.macro.js",
      "!**/src/index.js",
      "!**/src/shallowEqual.js",
      "!**/node_modules/**",
      "!**/test/**",
      "!**/example/**"
    ]
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "linters": {
      "*.{ts,tsx,js,json,md}": [
        "prettier --write",
        "git add"
      ]
    },
    "ignore": [
      "**/dist/**/*.js",
      "**/react-i18next.js",
      "**/react-i18next.min.js"
    ]
  },
  "lock": false,
  "sideEffects": false
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\react-is\package.json
============================================================
{
  "name": "react-is",
  "version": "19.2.0",
  "description": "Brand checking of React Elements.",
  "main": "index.js",
  "sideEffects": false,
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react-is"
  },
  "keywords": [
    "react"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/facebook/react/issues"
  },
  "homepage": "https://react.dev/",
  "files": [
    "LICENSE",
    "README.md",
    "index.js",
    "cjs/"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\react-refresh\package.json
============================================================
{
  "name": "react-refresh",
  "description": "React is a JavaScript library for building user interfaces.",
  "keywords": [
    "react"
  ],
  "version": "0.14.2",
  "homepage": "https://reactjs.org/",
  "bugs": "https://github.com/facebook/react/issues",
  "license": "MIT",
  "files": [
    "LICENSE",
    "README.md",
    "babel.js",
    "runtime.js",
    "cjs/",
    "umd/"
  ],
  "main": "runtime.js",
  "exports": {
    ".": "./runtime.js",
    "./runtime": "./runtime.js",
    "./babel": "./babel.js",
    "./package.json": "./package.json"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "devDependencies": {
    "react-16-8": "npm:react@16.8.0",
    "react-dom-16-8": "npm:react-dom@16.8.0",
    "scheduler-0-13": "npm:scheduler@0.13.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\react-router\package.json
============================================================
{
  "name": "react-router",
  "version": "6.30.1",
  "description": "Declarative routing for React",
  "keywords": [
    "react",
    "router",
    "route",
    "routing",
    "history",
    "link"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/remix-run/react-router",
    "directory": "packages/react-router"
  },
  "license": "MIT",
  "author": "Remix Software <hello@remix.run>",
  "sideEffects": false,
  "main": "./dist/main.js",
  "unpkg": "./dist/umd/react-router.production.min.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "@remix-run/router": "1.23.0"
  },
  "devDependencies": {
    "react": "^18.2.0",
    "react-router-dom": "6.30.1"
  },
  "peerDependencies": {
    "react": ">=16.8"
  },
  "files": [
    "dist/",
    "CHANGELOG.md",
    "LICENSE.md",
    "README.md"
  ],
  "engines": {
    "node": ">=14.0.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\react-router-dom\package.json
============================================================
{
  "name": "react-router-dom",
  "version": "6.30.1",
  "description": "Declarative routing for React web applications",
  "keywords": [
    "react",
    "router",
    "route",
    "routing",
    "history",
    "link"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/remix-run/react-router",
    "directory": "packages/react-router-dom"
  },
  "license": "MIT",
  "author": "Remix Software <hello@remix.run>",
  "sideEffects": false,
  "main": "./dist/main.js",
  "unpkg": "./dist/umd/react-router-dom.production.min.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "@remix-run/router": "1.23.0",
    "react-router": "6.30.1"
  },
  "devDependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "peerDependencies": {
    "react": ">=16.8",
    "react-dom": ">=16.8"
  },
  "files": [
    "dist/",
    "CHANGELOG.md",
    "LICENSE.md",
    "README.md",
    "server.d.ts",
    "server.js",
    "server.mjs"
  ],
  "engines": {
    "node": ">=14.0.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\redent\package.json
============================================================
{
	"name": "redent",
	"version": "3.0.0",
	"description": "Strip redundant indentation and indent the string",
	"license": "MIT",
	"repository": "sindresorhus/redent",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"string",
		"strip",
		"trim",
		"indent",
		"indentation",
		"add",
		"reindent",
		"normalize",
		"remove",
		"whitespace",
		"space"
	],
	"dependencies": {
		"indent-string": "^4.0.0",
		"strip-indent": "^3.0.0"
	},
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\regenerate\package.json
============================================================
{
  "name": "regenerate",
  "version": "1.4.2",
  "description": "Generate JavaScript-compatible regular expressions based on a given set of Unicode symbols or code points.",
  "homepage": "https://mths.be/regenerate",
  "main": "regenerate.js",
  "keywords": [
    "regex",
    "regexp",
    "javascript",
    "unicode",
    "generator",
    "tool"
  ],
  "license": "MIT",
  "author": {
    "name": "Mathias Bynens",
    "url": "https://mathiasbynens.be/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mathiasbynens/regenerate.git"
  },
  "bugs": "https://github.com/mathiasbynens/regenerate/issues",
  "scripts": {
    "cover": "istanbul cover --report html --verbose --dir coverage tests/tests.js",
    "test": "node tests/tests.js"
  },
  "devDependencies": {
    "codecov": "^1.0.1",
    "grunt": "^0.4.5",
    "grunt-shell": "^1.1.1",
    "istanbul": "^0.4.3",
    "qunit-extras": "^1.1.0",
    "qunitjs": "~1.11.0",
    "requirejs": "^2.1.15"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\regenerate-unicode-properties\package.json
============================================================
{
  "name": "regenerate-unicode-properties",
  "version": "10.2.2",
  "description": "Regenerate sets for Unicode properties and values.",
  "homepage": "https://github.com/mathiasbynens/regenerate-unicode-properties",
  "main": "index.js",
  "engines": {
    "node": ">=4"
  },
  "files": [
    "LICENSE-MIT.txt",
    "index.js",
    "unicode-version.js",
    "Binary_Property",
    "General_Category",
    "Property_of_Strings",
    "Script",
    "Script_Extensions"
  ],
  "keywords": [
    "unicode",
    "unicode-data",
    "regenerate"
  ],
  "license": "MIT",
  "author": {
    "name": "Mathias Bynens",
    "url": "https://mathiasbynens.be/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mathiasbynens/regenerate-unicode-properties.git"
  },
  "bugs": "https://github.com/mathiasbynens/regenerate-unicode-properties/issues",
  "dependencies": {
    "regenerate": "^1.4.2"
  },
  "devDependencies": {
    "@unicode/unicode-17.0.0": "^1.6.12",
    "jsesc": "^3.1.0",
    "unicode-canonical-property-names-ecmascript": "^2.0.1"
  },
  "scripts": {
    "build": "node build.js",
    "test": "node --test tests/tests.js"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\regexpu-core\package.json
============================================================
{
	"name": "regexpu-core",
	"version": "6.4.0",
	"description": "regexpu’s core functionality (i.e. `rewritePattern(pattern, flag)`), capable of translating ES6 Unicode regular expressions to ES5.",
	"homepage": "https://mths.be/regexpu",
	"main": "rewrite-pattern.js",
	"engines": {
		"node": ">=4"
	},
	"keywords": [
		"codegen",
		"desugaring",
		"ecmascript",
		"es5",
		"es6",
		"harmony",
		"javascript",
		"refactoring",
		"regex",
		"regexp",
		"regular expressions",
		"rewriting",
		"syntax",
		"transformation",
		"transpile",
		"transpiler",
		"unicode"
	],
	"license": "MIT",
	"author": {
		"name": "Mathias Bynens",
		"url": "https://mathiasbynens.be/"
	},
	"repository": {
		"type": "git",
		"url": "https://github.com/mathiasbynens/regexpu-core.git"
	},
	"bugs": "https://github.com/mathiasbynens/regexpu-core/issues",
	"files": [
		"LICENSE-MIT.txt",
		"rewrite-pattern.js",
		"rewrite-pattern.d.ts",
		"data/all-characters.js",
		"data/character-class-escape-sets.js",
		"data/i-bmp-mappings.js",
		"data/iu-foldings.js",
		"data/iu-mappings.js"
	],
	"scripts": {
		"build": "node scripts/index.js",
		"test": "node --test tests/tests.js",
		"test-node6": "mocha tests",
		"cover": "NODE_V8_COVERAGE=coverage node --test  --experimental-test-coverage tests/tests.js"
	},
	"dependencies": {
		"regenerate": "^1.4.2",
		"regenerate-unicode-properties": "^10.2.2",
		"regjsgen": "^0.8.0",
		"regjsparser": "^0.13.0",
		"unicode-match-property-ecmascript": "^2.0.0",
		"unicode-match-property-value-ecmascript": "^2.2.1"
	},
	"devDependencies": {
		"jsesc": "^3.0.2",
		"@unicode/unicode-17.0.0": "^1.6.12"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\regjsgen\package.json
============================================================
{
  "name": "regjsgen",
  "version": "0.8.0",
  "description": "Generate regular expressions from regjsparser’s AST.",
  "homepage": "https://github.com/bnjmnt4n/regjsgen",
  "main": "regjsgen.js",
  "keywords": [
    "ast",
    "generate",
    "regex",
    "regexp",
    "regular expressions"
  ],
  "license": "MIT",
  "author": {
    "name": "Benjamin Tan",
    "url": "https://ofcr.se/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/bnjmnt4n/regjsgen.git"
  },
  "bugs": "https://github.com/bnjmnt4n/regjsgen/issues",
  "files": [
    "LICENSE-MIT.txt",
    "regjsgen.js"
  ],
  "scripts": {
    "test": "node tests/tests.js",
    "coverage": "nyc --reporter=html npm test",
    "report-coverage": "nyc --reporter=lcov npm test && codecov",
    "update-fixtures": "node tests/update-fixtures.js"
  },
  "devDependencies": {
    "codecov": "^3.8.3",
    "nyc": "^15.1.0",
    "regjsparser": "^0.10.0",
    "request": "^2.88.2"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\regjsparser\package.json
============================================================
{
  "name": "regjsparser",
  "version": "0.13.0",
  "author": "'Julian Viereck' <julian.viereck@gmail.com>",
  "license": "BSD-2-Clause",
  "main": "./parser",
  "types": "./parser.d.ts",
  "bin": {
    "regjsparser": "bin/parser"
  },
  "homepage": "https://github.com/jviereck/regjsparser",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/jviereck/regjsparser.git"
  },
  "scripts": {
    "lint": "eslint --max-warnings 0 .",
    "test": "run-p test:* lint",
    "test:src": "node test/index.js",
    "test:types": "tsc test/types.ts --noEmit",
    "bench:baseline": "node ./tools/bench/index.mjs baseline",
    "bench:current": "node ./tools/bench/index.mjs current",
    "bench": "run-s bench:*"
  },
  "files": [
    "bin/",
    "LICENSE.BSD",
    "parser.js",
    "parser.d.ts",
    "README.md"
  ],
  "dependencies": {
    "jsesc": "~3.1.0"
  },
  "devDependencies": {
    "@unicode/unicode-17.0.0": "^1.6.12",
    "eslint": "^9.35.0",
    "eslint-plugin-regexp": "^2.10.0",
    "globals": "^16.4.0",
    "npm-run-all": "^4.1.5",
    "regenerate": "^1.4.2",
    "regjsparser": "^0.11.2",
    "tinybench": "^5.0.1",
    "typescript": "~5.9.2"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\require-directory\package.json
============================================================
{
  "author": "Troy Goode <troygoode@gmail.com> (http://github.com/troygoode/)",
  "name": "require-directory",
  "version": "2.1.1",
  "description": "Recursively iterates over specified directory, require()'ing each file, and returning a nested hash structure containing those modules.",
  "keywords": [
    "require",
    "directory",
    "library",
    "recursive"
  ],
  "homepage": "https://github.com/troygoode/node-require-directory/",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/troygoode/node-require-directory.git"
  },
  "contributors": [
    {
      "name": "Troy Goode",
      "email": "troygoode@gmail.com",
      "web": "http://github.com/troygoode/"
    }
  ],
  "license": "MIT",
  "bugs": {
    "url": "http://github.com/troygoode/node-require-directory/issues/"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "devDependencies": {
    "jshint": "^2.6.0",
    "mocha": "^2.1.0"
  },
  "scripts": {
    "test": "mocha",
    "lint": "jshint index.js test/test.js"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\require-from-string\package.json
============================================================
{
  "name": "require-from-string",
  "version": "2.0.2",
  "description": "Require module from string",
  "license": "MIT",
  "repository": "floatdrop/require-from-string",
  "author": {
    "name": "Vsevolod Strukchinsky",
    "email": "floatdrop@gmail.com",
    "url": "github.com/floatdrop"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "scripts": {
    "test": "mocha"
  },
  "files": [
    "index.js"
  ],
  "keywords": [
    ""
  ],
  "dependencies": {},
  "devDependencies": {
    "mocha": "*"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\resolve\test\module_dir\zmodules\bbb\package.json
============================================================
{
  "main": "main.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\resolve\test\resolver\baz\package.json
============================================================
{
    "name": "baz",
    "main": "quux.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\resolve\test\resolver\browser_field\package.json
============================================================
{
  "name": "browser_field",
  "main": "a",
  "browser": "b"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\resolve\test\resolver\dot_main\package.json
============================================================
{
    "main": "."
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\resolve\test\resolver\dot_slash_main\package.json
============================================================
{
    "main": "./"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\resolve\test\resolver\false_main\package.json
============================================================
{
	"name": "false_main",
	"main": false
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\resolve\test\resolver\incorrect_main\package.json
============================================================
{
    "main": "wrong.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\resolve\test\resolver\invalid_main\package.json
============================================================
{
  "name": "invalid_main",
  "main": [
    "why is this a thing",
    "srsly omg wtf"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\resolve\test\resolver\multirepo\packages\package-a\package.json
============================================================
{
  "name": "@my-scope/package-a",
  "version": "0.0.0",
  "private": true,
  "description": "",
  "license": "MIT",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: run tests from root\" && exit 1"
  },
  "dependencies": {
    "@my-scope/package-b": "^0.0.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\resolve\test\resolver\multirepo\packages\package-b\package.json
============================================================
{
  "name": "@my-scope/package-b",
  "private": true,
  "version": "0.0.0",
  "description": "",
  "license": "MIT",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: run tests from root\" && exit 1"
  },
  "dependencies": {
    "@my-scope/package-a": "^0.0.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\resolve\test\resolver\multirepo\package.json
============================================================
{
  "name": "ljharb-monorepo-symlink-test",
  "private": true,
  "version": "0.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "postinstall": "lerna bootstrap",
    "test": "node packages/package-a"
  },
  "author": "",
  "license": "MIT",
  "dependencies": {
    "jquery": "^3.3.1",
    "resolve": "../../../"
  },
  "devDependencies": {
    "lerna": "^3.4.3"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\resolve\test\resolver\nested_symlinks\mylib\package.json
============================================================
{
  "name": "mylib",
  "version": "0.0.0",
  "description": "",
  "private": true,
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "buffer": "*"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\resolve\test\resolver\symlinked\package\package.json
============================================================
{
    "main": "bar.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\resolve\package.json
============================================================
{
	"name": "resolve",
	"description": "resolve like require.resolve() on behalf of files asynchronously and synchronously",
	"version": "1.22.11",
	"repository": {
		"type": "git",
		"url": "ssh://github.com/browserify/resolve.git"
	},
	"bin": {
		"resolve": "./bin/resolve"
	},
	"main": "index.js",
	"keywords": [
		"resolve",
		"require",
		"node",
		"module"
	],
	"scripts": {
		"prepack": "npmignore --auto --commentLines=autogenerated && cp node_modules/is-core-module/core.json ./lib/ ||:",
		"prepublishOnly": "safe-publish-latest",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"prelint": "eclint check $(git ls-files | xargs find 2> /dev/null | grep -vE 'node_modules|\\.git')",
		"lint": "eslint --ext=js,mjs --no-eslintrc -c .eslintrc . 'bin/**'",
		"pretests-only": "cd ./test/resolver/nested_symlinks && node mylib/sync && node mylib/async",
		"tests-only": "tape test/*.js",
		"pretest": "npm run lint",
		"test": "npm run --silent tests-only",
		"posttest": "npm run test:multirepo && npx npm@'>= 10.2' audit --production",
		"test:multirepo": "cd ./test/resolver/multirepo && npm install && npm test"
	},
	"devDependencies": {
		"@ljharb/eslint-config": "^21.2.0",
		"array.prototype.map": "^1.0.8",
		"copy-dir": "^1.3.0",
		"eclint": "^2.8.1",
		"eslint": "=8.8.0",
		"in-publish": "^2.0.1",
		"mkdirp": "^0.5.5",
		"mv": "^2.1.1",
		"npmignore": "^0.3.1",
		"object-keys": "^1.1.1",
		"rimraf": "^2.7.1",
		"safe-publish-latest": "^2.0.0",
		"semver": "^6.3.1",
		"tap": "0.4.13",
		"tape": "^5.9.0",
		"tmp": "^0.0.31"
	},
	"license": "MIT",
	"author": {
		"name": "James Halliday",
		"email": "mail@substack.net",
		"url": "http://substack.net"
	},
	"funding": {
		"url": "https://github.com/sponsors/ljharb"
	},
	"dependencies": {
		"is-core-module": "^2.16.1",
		"path-parse": "^1.0.7",
		"supports-preserve-symlinks-flag": "^1.0.0"
	},
	"publishConfig": {
		"ignore": [
			".github/workflows",
			"appveyor.yml",
			"test/resolver/malformed_package_json",
			"test/list-exports"
		]
	},
	"engines": {
		"node": ">= 0.4"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\resolve-cwd\node_modules\resolve-from\package.json
============================================================
{
	"name": "resolve-from",
	"version": "5.0.0",
	"description": "Resolve the path of a module like `require.resolve()` but from a given path",
	"license": "MIT",
	"repository": "sindresorhus/resolve-from",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"require",
		"resolve",
		"path",
		"module",
		"from",
		"like",
		"import"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\resolve-cwd\package.json
============================================================
{
	"name": "resolve-cwd",
	"version": "3.0.0",
	"description": "Resolve the path of a module like `require.resolve()` but from the current working directory",
	"license": "MIT",
	"repository": "sindresorhus/resolve-cwd",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"require",
		"resolve",
		"path",
		"module",
		"from",
		"like",
		"cwd",
		"current",
		"working",
		"directory",
		"import"
	],
	"dependencies": {
		"resolve-from": "^5.0.0"
	},
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\rollup\dist\es\package.json
============================================================
{"type":"module"}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\rollup\package.json
============================================================
{
  "name": "rollup",
  "version": "3.29.5",
  "description": "Next-generation ES module bundler",
  "main": "dist/rollup.js",
  "module": "dist/es/rollup.js",
  "types": "dist/rollup.d.ts",
  "bin": {
    "rollup": "dist/bin/rollup"
  },
  "scripts": {
    "build": "rollup --config rollup.config.ts --configPlugin typescript",
    "dev": "vitepress dev docs",
    "build:cjs": "rollup --config rollup.config.ts --configPlugin typescript --configTest",
    "build:bootstrap": "node dist/bin/rollup --config rollup.config.ts --configPlugin typescript",
    "build:docs": "vitepress build docs",
    "preview:docs": "vitepress preview docs",
    "ci:lint": "concurrently 'npm:lint:js:nofix' 'npm:lint:markdown:nofix'",
    "ci:test": "npm run build:cjs && npm run build:bootstrap && npm run test:all",
    "ci:test:only": "npm run build:cjs && npm run build:bootstrap && npm run test:only",
    "ci:coverage": "npm run build:cjs && npm run build:bootstrap && nyc --reporter lcovonly mocha",
    "lint": "concurrently -c red,green 'npm:lint:js' 'npm:lint:markdown'",
    "lint:js": "eslint . --fix --cache",
    "lint:js:nofix": "eslint . --cache",
    "lint:markdown": "prettier --write \"**/*.md\"",
    "lint:markdown:nofix": "prettier --check \"**/*.md\"",
    "perf": "npm run build:cjs && node --expose-gc scripts/perf.js",
    "perf:init": "node scripts/perf-init.js",
    "prepare": "husky install && node scripts/check-release.js || npm run build",
    "prepublishOnly": "node scripts/check-release.js",
    "release": "node scripts/release.js",
    "release:docs": "git fetch --update-head-ok origin master:master && git branch --force documentation-published master && git push origin documentation-published",
    "test": "npm run build && npm run test:all",
    "test:update-snapshots": "node scripts/update-snapshots.js",
    "test:cjs": "npm run build:cjs && npm run test:only",
    "test:quick": "mocha -b test/test.js",
    "test:all": "concurrently --kill-others-on-fail -c green,blue,magenta,cyan,red 'npm:test:only' 'npm:test:browser' 'npm:test:typescript' 'npm:test:leak' 'npm:test:package' 'npm:test:options'",
    "test:coverage": "npm run build:cjs && shx rm -rf coverage/* && nyc --reporter html mocha test/test.js",
    "test:coverage:browser": "npm run build && shx rm -rf coverage/* && nyc mocha test/browser/index.js",
    "test:leak": "node --expose-gc test/leak/index.js",
    "test:package": "node scripts/test-package.js",
    "test:options": "node scripts/test-options.js",
    "test:only": "mocha test/test.js",
    "test:typescript": "shx rm -rf test/typescript/dist && shx cp -r dist test/typescript/ && tsc --noEmit -p test/typescript && tsc --noEmit",
    "test:browser": "mocha test/browser/index.js",
    "watch": "rollup --config rollup.config.ts --configPlugin typescript --watch"
  },
  "repository": "rollup/rollup",
  "keywords": [
    "modules",
    "bundler",
    "bundling",
    "es6",
    "optimizer"
  ],
  "author": "Rich Harris",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/rollup/rollup/issues"
  },
  "homepage": "https://rollupjs.org/",
  "optionalDependencies": {
    "fsevents": "~2.3.2"
  },
  "devDependenciesComments": {
    "@rollup/plugin-typescript": "It appears that 11.1.3 breaks sourcemaps"
  },
  "devDependencies": {
    "@codemirror/commands": "^6.2.5",
    "@codemirror/lang-javascript": "^6.2.1",
    "@codemirror/language": "^6.9.0",
    "@codemirror/search": "^6.5.3",
    "@codemirror/state": "^6.2.1",
    "@codemirror/view": "^6.19.0",
    "@jridgewell/sourcemap-codec": "^1.4.15",
    "@mermaid-js/mermaid-cli": "^10.4.0",
    "@rollup/plugin-alias": "^5.0.0",
    "@rollup/plugin-buble": "^1.0.2",
    "@rollup/plugin-commonjs": "^25.0.4",
    "@rollup/plugin-json": "^6.0.0",
    "@rollup/plugin-node-resolve": "^15.2.1",
    "@rollup/plugin-replace": "^5.0.2",
    "@rollup/plugin-terser": "^0.4.3",
    "@rollup/plugin-typescript": "11.1.2",
    "@rollup/pluginutils": "^5.0.4",
    "@types/estree": "1.0.1",
    "@types/mocha": "^10.0.1",
    "@types/node": "~14.18.61",
    "@types/yargs-parser": "^21.0.0",
    "@typescript-eslint/eslint-plugin": "^6.7.2",
    "@typescript-eslint/parser": "^6.7.2",
    "@vue/eslint-config-prettier": "^8.0.0",
    "@vue/eslint-config-typescript": "^12.0.0",
    "acorn": "^8.10.0",
    "acorn-import-assertions": "^1.9.0",
    "acorn-jsx": "^5.3.2",
    "acorn-walk": "^8.2.0",
    "buble": "^0.20.0",
    "builtin-modules": "^3.3.0",
    "chokidar": "^3.5.3",
    "colorette": "^2.0.20",
    "concurrently": "^8.2.1",
    "core-js": "^3.32.2",
    "date-time": "^4.0.0",
    "es5-shim": "^4.6.7",
    "es6-shim": "^0.35.8",
    "eslint": "^8.49.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-import": "^2.28.1",
    "eslint-plugin-prettier": "^5.0.0",
    "eslint-plugin-unicorn": "^48.0.1",
    "eslint-plugin-vue": "^9.17.0",
    "fixturify": "^3.0.0",
    "flru": "^1.0.2",
    "fs-extra": "^11.1.1",
    "github-api": "^3.4.0",
    "hash.js": "^1.1.7",
    "husky": "^8.0.3",
    "inquirer": "^9.2.11",
    "is-reference": "^3.0.2",
    "lint-staged": "^14.0.1",
    "locate-character": "^3.0.0",
    "magic-string": "^0.30.3",
    "mocha": "^10.2.0",
    "nyc": "^15.1.0",
    "pinia": "^2.1.6",
    "prettier": "^3.0.3",
    "pretty-bytes": "^6.1.1",
    "pretty-ms": "^8.0.0",
    "requirejs": "^2.3.6",
    "rollup": "^3.29.2",
    "rollup-plugin-license": "^3.1.0",
    "rollup-plugin-string": "^3.0.0",
    "rollup-plugin-thatworks": "^1.0.4",
    "semver": "^7.5.4",
    "shx": "^0.3.4",
    "signal-exit": "^4.1.0",
    "source-map": "^0.7.4",
    "source-map-support": "^0.5.21",
    "systemjs": "^6.14.2",
    "terser": "^5.19.4",
    "tslib": "^2.6.2",
    "typescript": "^5.2.2",
    "vite": "^4.4.9",
    "vitepress": "^1.0.0-rc.14",
    "vue": "^3.3.4",
    "weak-napi": "^2.0.2",
    "yargs-parser": "^21.1.1"
  },
  "overrides": {
    "semver": "^7.5.4"
  },
  "files": [
    "dist/**/*.js",
    "dist/*.d.ts",
    "dist/bin/rollup",
    "dist/es/package.json"
  ],
  "engines": {
    "node": ">=14.18.0",
    "npm": ">=8.0.0"
  },
  "exports": {
    ".": {
      "types": "./dist/rollup.d.ts",
      "require": "./dist/rollup.js",
      "import": "./dist/es/rollup.js"
    },
    "./loadConfigFile": {
      "types": "./dist/loadConfigFile.d.ts",
      "require": "./dist/loadConfigFile.js",
      "default": "./dist/loadConfigFile.js"
    },
    "./getLogFilter": {
      "types": "./dist/getLogFilter.d.ts",
      "require": "./dist/getLogFilter.js",
      "import": "./dist/es/getLogFilter.js"
    },
    "./dist/*": "./dist/*"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\rrweb-cssom\package.json
============================================================
{
  "name": "rrweb-cssom",
  "description": "CSS Object Model implementation and CSS parser",
  "keywords": [
    "CSS",
    "CSSOM",
    "parser",
    "styleSheet"
  ],
  "version": "0.8.0",
  "author": "Nikita Vasilyev <me@elv1s.ru>",
  "repository": "rrweb-io/CSSOM",
  "files": [
    "lib/",
    "build/"
  ],
  "main": "./lib/index.js",
  "license": "MIT",
  "scripts": {
    "build": "node build.js",
    "release": "npm run build && changeset publish"
  },
  "devDependencies": {
    "@changesets/changelog-github": "^0.5.0",
    "@changesets/cli": "^2.27.1"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\safer-buffer\package.json
============================================================
{
  "name": "safer-buffer",
  "version": "2.1.2",
  "description": "Modern Buffer API polyfill without footguns",
  "main": "safer.js",
  "scripts": {
    "browserify-test": "browserify --external tape tests.js > browserify-tests.js && tape browserify-tests.js",
    "test": "standard && tape tests.js"
  },
  "author": {
    "name": "Nikita Skovoroda",
    "email": "chalkerx@gmail.com",
    "url": "https://github.com/ChALkeR"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ChALkeR/safer-buffer.git"
  },
  "bugs": {
    "url": "https://github.com/ChALkeR/safer-buffer/issues"
  },
  "devDependencies": {
    "standard": "^11.0.1",
    "tape": "^4.9.0"
  },
  "files": [
    "Porting-Buffer.md",
    "Readme.md",
    "tests.js",
    "dangerous.js",
    "safer.js"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\saxes\package.json
============================================================
{
  "name": "saxes",
  "description": "An evented streaming XML parser in JavaScript",
  "author": "Louis-Dominique Dubeau <ldd@lddubeau.com>",
  "version": "6.0.0",
  "main": "saxes.js",
  "types": "saxes.d.ts",
  "license": "ISC",
  "engines": {
    "node": ">=v12.22.7"
  },
  "scripts": {
    "tsc": "tsc",
    "copy": "cp -p README.md build/dist && sed -e'/\"private\": true/d' package.json > build/dist/package.json",
    "build": "npm run tsc && npm run copy",
    "test": "npm run build && mocha --delay",
    "lint": "eslint --ignore-path .gitignore '**/*.ts' '**/*.js'",
    "lint-fix": "npm run lint -- --fix",
    "posttest": "npm run lint",
    "typedoc": "typedoc --tsconfig tsconfig.json --name saxes --out build/docs/ --listInvalidSymbolLinks --excludePrivate --excludeNotExported",
    "build-docs": "npm run typedoc",
    "gh-pages": "npm run build-docs && mkdir -p build && (cd build; rm -rf gh-pages; git clone .. --branch gh-pages gh-pages) && mkdir -p build/gh-pages/latest && find build/gh-pages/latest -type f -delete && cp -rp build/docs/* build/gh-pages/latest && find build/gh-pages -type d -empty -delete",
    "self:publish": "cd build/dist && npm_config_tag=`simple-dist-tag` npm publish",
    "version": "conventional-changelog -p angular -i CHANGELOG.md -s && git add CHANGELOG.md",
    "postversion": "npm run test && npm run self:publish",
    "postpublish": "git push origin --follow-tags"
  },
  "repository": "https://github.com/lddubeau/saxes.git",
  "devDependencies": {
    "@commitlint/cli": "^14.1.0",
    "@commitlint/config-angular": "^14.1.0",
    "@types/chai": "^4.2.22",
    "@types/mocha": "^9.0.0",
    "@types/node": "^16.11.6",
    "@typescript-eslint/eslint-plugin": "^5.3.0",
    "@typescript-eslint/eslint-plugin-tslint": "^5.3.0",
    "@typescript-eslint/parser": "^5.3.0",
    "@xml-conformance-suite/js": "^3.0.0",
    "@xml-conformance-suite/mocha": "^3.0.0",
    "@xml-conformance-suite/test-data": "^3.0.0",
    "chai": "^4.3.4",
    "conventional-changelog-cli": "^2.1.1",
    "eslint": "^8.2.0",
    "eslint-config-lddubeau-base": "^6.1.0",
    "eslint-config-lddubeau-ts": "^2.0.2",
    "eslint-import-resolver-typescript": "^2.5.0",
    "eslint-plugin-import": "^2.25.2",
    "eslint-plugin-jsx-a11y": "^6.4.1",
    "eslint-plugin-prefer-arrow": "^1.2.3",
    "eslint-plugin-react": "^7.26.1",
    "eslint-plugin-simple-import-sort": "^7.0.0",
    "husky": "^7.0.4",
    "mocha": "^9.1.3",
    "renovate-config-lddubeau": "^1.0.0",
    "simple-dist-tag": "^1.0.2",
    "ts-node": "^10.4.0",
    "tsd": "^0.18.0",
    "tslint": "^6.1.3",
    "tslint-microsoft-contrib": "^6.2.0",
    "typedoc": "^0.22.8",
    "typescript": "^4.4.4"
  },
  "dependencies": {
    "xmlchars": "^2.2.0"
  },
  "husky": {
    "hooks": {
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\scheduler\package.json
============================================================
{
  "name": "scheduler",
  "version": "0.23.2",
  "description": "Cooperative scheduler for the browser environment.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/scheduler"
  },
  "license": "MIT",
  "keywords": [
    "react"
  ],
  "bugs": {
    "url": "https://github.com/facebook/react/issues"
  },
  "homepage": "https://reactjs.org/",
  "dependencies": {
    "loose-envify": "^1.1.0"
  },
  "files": [
    "LICENSE",
    "README.md",
    "index.js",
    "unstable_mock.js",
    "unstable_post_task.js",
    "cjs/",
    "umd/"
  ],
  "browserify": {
    "transform": [
      "loose-envify"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\semver\package.json
============================================================
{
  "name": "semver",
  "version": "6.3.1",
  "description": "The semantic version parser used by npm.",
  "main": "semver.js",
  "scripts": {
    "test": "tap test/ --100 --timeout=30",
    "lint": "echo linting disabled",
    "postlint": "template-oss-check",
    "template-oss-apply": "template-oss-apply --force",
    "lintfix": "npm run lint -- --fix",
    "snap": "tap test/ --100 --timeout=30",
    "posttest": "npm run lint"
  },
  "devDependencies": {
    "@npmcli/template-oss": "4.17.0",
    "tap": "^12.7.0"
  },
  "license": "ISC",
  "repository": {
    "type": "git",
    "url": "https://github.com/npm/node-semver.git"
  },
  "bin": {
    "semver": "./bin/semver.js"
  },
  "files": [
    "bin",
    "range.bnf",
    "semver.js"
  ],
  "author": "GitHub Inc.",
  "templateOSS": {
    "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
    "content": "./scripts/template-oss",
    "version": "4.17.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\shallowequal\package.json
============================================================
{
  "name": "shallowequal",
  "version": "1.1.0",
  "description": "Like lodash isEqualWith but for shallow equal.",
  "main": "index.js",
  "scripts": {
    "lint": "eslint index.js test",
    "test": "mocha --require babel-register",
    "build:strip-flow":
      "flow-remove-types --pretty index.original.js > index.js",
    "build:gen-flow": "flow gen-flow-files index.original.js > index.js.flow",
    "build": "npm run build:strip-flow && npm run build:gen-flow",
    "prepublish":
      "npm run build && npm run pretty && npm run lint && npm run test",
    "travis": "npm run lint && npm run test",
    "pretty": "prettier --write --tab-width 2 'test/**/*.js' '*.{js,js.flow}'",
    "precommit": "lint-staged"
  },
  "lint-staged": {
    "*.{js,json,css,js.flow}": ["prettier --write", "git add"]
  },
  "author": {
    "name": "Alberto Leal",
    "email": "mailforalberto@gmail.com",
    "url": "github.com/dashed"
  },
  "repository": "dashed/shallowequal",
  "license": "MIT",
  "files": ["index.js", "index.js.flow", "index.original.js"],
  "keywords": [
    "shallowequal",
    "shallow",
    "equal",
    "isequal",
    "compare",
    "isequalwith"
  ],
  "eslintConfig": {
    "parser": "babel-eslint",
    "env": {
      "browser": true,
      "node": true,
      "mocha": true
    },
    "extends": ["eslint:recommended"]
  },
  "devDependencies": {
    "babel-eslint": "^8.0.0",
    "babel-preset-env": "^1.6.1",
    "babel-register": "^6.24.1",
    "chai": "^4.0.0",
    "eslint": "^4.7.1",
    "flow-bin": "^0.75.0",
    "flow-remove-types": "^1.2.3",
    "husky": "^0.14.3",
    "lint-staged": "^6.0.0",
    "mocha": "^5.0.0",
    "prettier": "^1.9.2"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\shebang-command\package.json
============================================================
{
	"name": "shebang-command",
	"version": "2.0.0",
	"description": "Get the command from a shebang",
	"license": "MIT",
	"repository": "kevva/shebang-command",
	"author": {
		"name": "Kevin Mårtensson",
		"email": "kevinmartensson@gmail.com",
		"url": "github.com/kevva"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava"
	},
	"files": [
		"index.js"
	],
	"keywords": [
		"cmd",
		"command",
		"parse",
		"shebang"
	],
	"dependencies": {
		"shebang-regex": "^3.0.0"
	},
	"devDependencies": {
		"ava": "^2.3.0",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\shebang-regex\package.json
============================================================
{
	"name": "shebang-regex",
	"version": "3.0.0",
	"description": "Regular expression for matching a shebang line",
	"license": "MIT",
	"repository": "sindresorhus/shebang-regex",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"regex",
		"regexp",
		"shebang",
		"match",
		"test",
		"line"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\siginfo\package.json
============================================================
{
  "name": "siginfo",
  "version": "2.0.0",
  "description": "Utility module to print pretty messages on SIGINFO/SIGUSR1",
  "main": "index.js",
  "dependencies": {},
  "devDependencies": {
    "standard": "^14.3.4"
  },
  "scripts": {
    "test": "standard"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/emilbayes/siginfo.git"
  },
  "keywords": [
    "siginfo",
    "sigusr1",
    "ctrl",
    "t",
    "info",
    "progress",
    "inspect"
  ],
  "author": "Emil Bay <github@tixz.dk>",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/emilbayes/siginfo/issues"
  },
  "homepage": "https://github.com/emilbayes/siginfo#readme"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\signal-exit\dist\cjs\package.json
============================================================
{
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\signal-exit\dist\mjs\package.json
============================================================
{
  "type": "module"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\signal-exit\package.json
============================================================
{
  "name": "signal-exit",
  "version": "4.1.0",
  "description": "when you want to fire an event no matter how a process exits.",
  "main": "./dist/cjs/index.js",
  "module": "./dist/mjs/index.js",
  "browser": "./dist/mjs/browser.js",
  "types": "./dist/mjs/index.d.ts",
  "exports": {
    ".": {
      "import": {
        "types": "./dist/mjs/index.d.ts",
        "default": "./dist/mjs/index.js"
      },
      "require": {
        "types": "./dist/cjs/index.d.ts",
        "default": "./dist/cjs/index.js"
      }
    },
    "./signals": {
      "import": {
        "types": "./dist/mjs/signals.d.ts",
        "default": "./dist/mjs/signals.js"
      },
      "require": {
        "types": "./dist/cjs/signals.d.ts",
        "default": "./dist/cjs/signals.js"
      }
    },
    "./browser": {
      "import": {
        "types": "./dist/mjs/browser.d.ts",
        "default": "./dist/mjs/browser.js"
      },
      "require": {
        "types": "./dist/cjs/browser.d.ts",
        "default": "./dist/cjs/browser.js"
      }
    }
  },
  "files": [
    "dist"
  ],
  "engines": {
    "node": ">=14"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/tapjs/signal-exit.git"
  },
  "keywords": [
    "signal",
    "exit"
  ],
  "author": "Ben Coe <ben@npmjs.com>",
  "license": "ISC",
  "devDependencies": {
    "@types/cross-spawn": "^6.0.2",
    "@types/node": "^18.15.11",
    "@types/signal-exit": "^3.0.1",
    "@types/tap": "^15.0.8",
    "c8": "^7.13.0",
    "prettier": "^2.8.6",
    "tap": "^16.3.4",
    "ts-node": "^10.9.1",
    "typedoc": "^0.23.28",
    "typescript": "^5.0.2"
  },
  "scripts": {
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags",
    "preprepare": "rm -rf dist",
    "prepare": "tsc -p tsconfig.json && tsc -p tsconfig-esm.json && bash ./scripts/fixup.sh",
    "pretest": "npm run prepare",
    "presnap": "npm run prepare",
    "test": "c8 tap",
    "snap": "c8 tap",
    "format": "prettier --write . --loglevel warn",
    "typedoc": "typedoc --tsconfig tsconfig-esm.json ./src/*.ts"
  },
  "prettier": {
    "semi": false,
    "printWidth": 75,
    "tabWidth": 2,
    "useTabs": false,
    "singleQuote": true,
    "jsxSingleQuote": false,
    "bracketSameLine": true,
    "arrowParens": "avoid",
    "endOfLine": "lf"
  },
  "tap": {
    "coverage": false,
    "jobs": 1,
    "node-arg": [
      "--no-warnings",
      "--loader",
      "ts-node/esm"
    ],
    "ts": false
  },
  "funding": {
    "url": "https://github.com/sponsors/isaacs"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\sirv\package.json
============================================================
{
  "name": "sirv",
  "version": "3.0.2",
  "description": "The optimized & lightweight middleware for serving requests to static assets",
  "repository": "lukeed/sirv",
  "module": "build.mjs",
  "types": "index.d.ts",
  "main": "build.js",
  "license": "MIT",
  "files": [
    "build.*",
    "index.d.*"
  ],
  "exports": {
    ".": {
      "import": {
        "types": "./index.d.mts",
        "default": "./build.mjs"
      },
      "require": {
        "types": "./index.d.ts",
        "default": "./build.js"
      }
    },
    "./package.json": "./package.json"
  },
  "author": {
    "name": "Luke Edwards",
    "email": "luke@lukeed.com",
    "url": "https://lukeed.com"
  },
  "engines": {
    "node": ">=18"
  },
  "dependencies": {
    "@polka/url": "^1.0.0-next.24",
    "mrmime": "^2.0.0",
    "totalist": "^3.0.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\slash\package.json
============================================================
{
	"name": "slash",
	"version": "3.0.0",
	"description": "Convert Windows backslash paths to slash paths",
	"license": "MIT",
	"repository": "sindresorhus/slash",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"path",
		"seperator",
		"slash",
		"backslash",
		"windows",
		"convert"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\source-map\package.json
============================================================
{
  "name": "source-map",
  "description": "Generates and consumes source maps",
  "version": "0.6.1",
  "homepage": "https://github.com/mozilla/source-map",
  "author": "Nick Fitzgerald <nfitzgerald@mozilla.com>",
  "contributors": [
    "Tobias Koppers <tobias.koppers@googlemail.com>",
    "Duncan Beevers <duncan@dweebd.com>",
    "Stephen Crane <scrane@mozilla.com>",
    "Ryan Seddon <seddon.ryan@gmail.com>",
    "Miles Elam <miles.elam@deem.com>",
    "Mihai Bazon <mihai.bazon@gmail.com>",
    "Michael Ficarra <github.public.email@michael.ficarra.me>",
    "Todd Wolfson <todd@twolfson.com>",
    "Alexander Solovyov <alexander@solovyov.net>",
    "Felix Gnass <fgnass@gmail.com>",
    "Conrad Irwin <conrad.irwin@gmail.com>",
    "usrbincc <usrbincc@yahoo.com>",
    "David Glasser <glasser@davidglasser.net>",
    "Chase Douglas <chase@newrelic.com>",
    "Evan Wallace <evan.exe@gmail.com>",
    "Heather Arthur <fayearthur@gmail.com>",
    "Hugh Kennedy <hughskennedy@gmail.com>",
    "David Glasser <glasser@davidglasser.net>",
    "Simon Lydell <simon.lydell@gmail.com>",
    "Jmeas Smith <jellyes2@gmail.com>",
    "Michael Z Goddard <mzgoddard@gmail.com>",
    "azu <azu@users.noreply.github.com>",
    "John Gozde <john@gozde.ca>",
    "Adam Kirkton <akirkton@truefitinnovation.com>",
    "Chris Montgomery <christopher.montgomery@dowjones.com>",
    "J. Ryan Stinnett <jryans@gmail.com>",
    "Jack Herrington <jherrington@walmartlabs.com>",
    "Chris Truter <jeffpalentine@gmail.com>",
    "Daniel Espeset <daniel@danielespeset.com>",
    "Jamie Wong <jamie.lf.wong@gmail.com>",
    "Eddy Bruël <ejpbruel@mozilla.com>",
    "Hawken Rives <hawkrives@gmail.com>",
    "Gilad Peleg <giladp007@gmail.com>",
    "djchie <djchie.dev@gmail.com>",
    "Gary Ye <garysye@gmail.com>",
    "Nicolas Lalevée <nicolas.lalevee@hibnet.org>"
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/mozilla/source-map.git"
  },
  "main": "./source-map.js",
  "files": [
    "source-map.js",
    "source-map.d.ts",
    "lib/",
    "dist/source-map.debug.js",
    "dist/source-map.js",
    "dist/source-map.min.js",
    "dist/source-map.min.js.map"
  ],
  "engines": {
    "node": ">=0.10.0"
  },
  "license": "BSD-3-Clause",
  "scripts": {
    "test": "npm run build && node test/run-tests.js",
    "build": "webpack --color",
    "toc": "doctoc --title '## Table of Contents' README.md && doctoc --title '## Table of Contents' CONTRIBUTING.md"
  },
  "devDependencies": {
    "doctoc": "^0.15.0",
    "webpack": "^1.12.0"
  },
  "typings": "source-map"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\source-map-js\package.json
============================================================
{
  "name": "source-map-js",
  "description": "Generates and consumes source maps",
  "version": "1.2.1",
  "homepage": "https://github.com/7rulnik/source-map-js",
  "author": "Valentin 7rulnik Semirulnik <v7rulnik@gmail.com>",
  "contributors": [
    "Nick Fitzgerald <nfitzgerald@mozilla.com>",
    "Tobias Koppers <tobias.koppers@googlemail.com>",
    "Duncan Beevers <duncan@dweebd.com>",
    "Stephen Crane <scrane@mozilla.com>",
    "Ryan Seddon <seddon.ryan@gmail.com>",
    "Miles Elam <miles.elam@deem.com>",
    "Mihai Bazon <mihai.bazon@gmail.com>",
    "Michael Ficarra <github.public.email@michael.ficarra.me>",
    "Todd Wolfson <todd@twolfson.com>",
    "Alexander Solovyov <alexander@solovyov.net>",
    "Felix Gnass <fgnass@gmail.com>",
    "Conrad Irwin <conrad.irwin@gmail.com>",
    "usrbincc <usrbincc@yahoo.com>",
    "David Glasser <glasser@davidglasser.net>",
    "Chase Douglas <chase@newrelic.com>",
    "Evan Wallace <evan.exe@gmail.com>",
    "Heather Arthur <fayearthur@gmail.com>",
    "Hugh Kennedy <hughskennedy@gmail.com>",
    "David Glasser <glasser@davidglasser.net>",
    "Simon Lydell <simon.lydell@gmail.com>",
    "Jmeas Smith <jellyes2@gmail.com>",
    "Michael Z Goddard <mzgoddard@gmail.com>",
    "azu <azu@users.noreply.github.com>",
    "John Gozde <john@gozde.ca>",
    "Adam Kirkton <akirkton@truefitinnovation.com>",
    "Chris Montgomery <christopher.montgomery@dowjones.com>",
    "J. Ryan Stinnett <jryans@gmail.com>",
    "Jack Herrington <jherrington@walmartlabs.com>",
    "Chris Truter <jeffpalentine@gmail.com>",
    "Daniel Espeset <daniel@danielespeset.com>",
    "Jamie Wong <jamie.lf.wong@gmail.com>",
    "Eddy Bruël <ejpbruel@mozilla.com>",
    "Hawken Rives <hawkrives@gmail.com>",
    "Gilad Peleg <giladp007@gmail.com>",
    "djchie <djchie.dev@gmail.com>",
    "Gary Ye <garysye@gmail.com>",
    "Nicolas Lalevée <nicolas.lalevee@hibnet.org>"
  ],
  "repository": "7rulnik/source-map-js",
  "main": "./source-map.js",
  "files": [
    "source-map.js",
    "source-map.d.ts",
    "lib/"
  ],
  "engines": {
    "node": ">=0.10.0"
  },
  "license": "BSD-3-Clause",
  "scripts": {
    "test": "npm run build && node test/run-tests.js",
    "build": "webpack --color",
    "toc": "doctoc --title '## Table of Contents' README.md && doctoc --title '## Table of Contents' CONTRIBUTING.md"
  },
  "devDependencies": {
    "clean-publish": "^3.1.0",
    "doctoc": "^0.15.0",
    "webpack": "^1.12.0"
  },
  "clean-publish": {
    "cleanDocs": true
  },
  "typings": "source-map.d.ts"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\source-map-support\package.json
============================================================
{
  "name": "source-map-support",
  "description": "Fixes stack traces for files with source maps",
  "version": "0.5.13",
  "main": "./source-map-support.js",
  "scripts": {
    "build": "node build.js",
    "serve-tests": "http-server -p 1336",
    "prepublish": "npm run build",
    "test": "mocha"
  },
  "dependencies": {
    "buffer-from": "^1.0.0",
    "source-map": "^0.6.0"
  },
  "devDependencies": {
    "browserify": "^4.2.3",
    "coffeescript": "^1.12.7",
    "http-server": "^0.11.1",
    "mocha": "^3.5.3",
    "webpack": "^1.15.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/evanw/node-source-map-support"
  },
  "bugs": {
    "url": "https://github.com/evanw/node-source-map-support/issues"
  },
  "license": "MIT"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\sprintf-js\package.json
============================================================
{
    "name": "sprintf-js",
    "version": "1.0.3",
    "description": "JavaScript sprintf implementation",
    "author": "Alexandru Marasteanu <hello@alexei.ro> (http://alexei.ro/)",
    "main": "src/sprintf.js",
    "scripts": {
        "test": "mocha test/test.js"
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/alexei/sprintf.js.git"
    },
    "license": "BSD-3-Clause",
    "readmeFilename": "README.md",
    "devDependencies": {
        "mocha": "*",
        "grunt": "*",
        "grunt-contrib-watch": "*",
        "grunt-contrib-uglify": "*"
    }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\stack-utils\node_modules\escape-string-regexp\package.json
============================================================
{
	"name": "escape-string-regexp",
	"version": "2.0.0",
	"description": "Escape RegExp special characters",
	"license": "MIT",
	"repository": "sindresorhus/escape-string-regexp",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"maintainers": [
		"Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)",
		"Joshua Boy Nicolai Appelman <joshua@jbna.nl> (jbna.nl)"
	],
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"escape",
		"regex",
		"regexp",
		"re",
		"regular",
		"expression",
		"string",
		"str",
		"special",
		"characters"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\stack-utils\package.json
============================================================
{
  "name": "stack-utils",
  "version": "2.0.6",
  "description": "Captures and cleans stack traces",
  "license": "MIT",
  "repository": "tapjs/stack-utils",
  "author": {
    "name": "James Talmage",
    "email": "james@talmage.io",
    "url": "github.com/jamestalmage"
  },
  "engines": {
    "node": ">=10"
  },
  "scripts": {
    "test": "tap",
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags"
  },
  "tap": {
    "check-coverage": true
  },
  "files": [
    "index.js"
  ],
  "dependencies": {
    "escape-string-regexp": "^2.0.0"
  },
  "devDependencies": {
    "bluebird": "^3.7.2",
    "coveralls": "^3.0.9",
    "nested-error-stacks": "^2.1.0",
    "pify": "^4.0.1",
    "q": "^1.5.1",
    "source-map-support": "^0.5.20",
    "tap": "^16.3.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\stackback\package.json
============================================================
{
  "name": "stackback",
  "version": "0.0.2",
  "description": "return list of CallSite objects from a captured stacktrace",
  "main": "index.js",
  "scripts": {
    "test": "mocha --ui qunit"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/shtylman/node-stackback.git"
  },
  "keywords": [
    "stacktrace",
    "trace",
    "stack"
  ],
  "devDependencies": {
    "mocha": "~1.6.0"
  },
  "author": "Roman Shtylman <shtylman@gmail.com>",
  "license": "MIT"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\std-env\package.json
============================================================
{
  "name": "std-env",
  "version": "3.10.0",
  "description": "Runtime agnostic JS utils",
  "repository": "unjs/std-env",
  "license": "MIT",
  "sideEffects": false,
  "type": "module",
  "exports": {
    "types": "./dist/index.d.ts",
    "import": "./dist/index.mjs",
    "require": "./dist/index.cjs"
  },
  "main": "./dist/index.cjs",
  "types": "./dist/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "unbuild",
    "dev": "vitest",
    "lint": "eslint . && prettier -c src test",
    "lint:fix": "eslint --fix . && prettier -w src test",
    "prepack": "unbuild",
    "play:bun": "bun playground/bun.ts",
    "play:deno": "pnpm build && deno run -A playground/deno.ts",
    "play:node": "pnpm build && node playground/node.mjs",
    "release": "pnpm test && changelogen --release && npm publish && git push --follow-tags",
    "test": "pnpm lint && pnpm typecheck && vitest run --coverage",
    "typecheck": "tsc --noEmit"
  },
  "devDependencies": {
    "@types/node": "^24.7.2",
    "@vitest/coverage-v8": "^3.2.4",
    "changelogen": "^0.6.2",
    "esbuild": "^0.25.10",
    "eslint": "^9.37.0",
    "eslint-config-unjs": "^0.5.0",
    "prettier": "^3.6.2",
    "rollup": "^4.52.4",
    "typescript": "^5.9.3",
    "unbuild": "^3.6.1",
    "vitest": "^3.2.4"
  },
  "packageManager": "pnpm@10.18.2"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\string-length\node_modules\strip-ansi\package.json
============================================================
{
	"name": "strip-ansi",
	"version": "6.0.1",
	"description": "Strip ANSI escape codes from a string",
	"license": "MIT",
	"repository": "chalk/strip-ansi",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"strip",
		"trim",
		"remove",
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"dependencies": {
		"ansi-regex": "^5.0.1"
	},
	"devDependencies": {
		"ava": "^2.4.0",
		"tsd": "^0.10.0",
		"xo": "^0.25.3"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\string-length\package.json
============================================================
{
	"name": "string-length",
	"version": "4.0.2",
	"description": "Get the real length of a string - by correctly counting astral symbols and ignoring ansi escape codes",
	"license": "MIT",
	"repository": "sindresorhus/string-length",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"unicode",
		"string",
		"length",
		"size",
		"count",
		"astral",
		"symbol",
		"surrogates",
		"codepoints",
		"ansi",
		"escape",
		"codes"
	],
	"dependencies": {
		"char-regex": "^1.0.2",
		"strip-ansi": "^6.0.0"
	},
	"devDependencies": {
		"ava": "^3.1.0",
		"tsd": "^0.11.0",
		"xo": "^0.25.3"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\string-width\package.json
============================================================
{
	"name": "string-width",
	"version": "5.1.2",
	"description": "Get the visual width of a string - the number of columns required to display it",
	"license": "MIT",
	"repository": "sindresorhus/string-width",
	"funding": "https://github.com/sponsors/sindresorhus",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"type": "module",
	"exports": "./index.js",
	"engines": {
		"node": ">=12"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"string",
		"character",
		"unicode",
		"width",
		"visual",
		"column",
		"columns",
		"fullwidth",
		"full-width",
		"full",
		"ansi",
		"escape",
		"codes",
		"cli",
		"command-line",
		"terminal",
		"console",
		"cjk",
		"chinese",
		"japanese",
		"korean",
		"fixed-width"
	],
	"dependencies": {
		"eastasianwidth": "^0.2.0",
		"emoji-regex": "^9.2.2",
		"strip-ansi": "^7.0.1"
	},
	"devDependencies": {
		"ava": "^3.15.0",
		"tsd": "^0.14.0",
		"xo": "^0.38.2"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\string-width-cjs\node_modules\emoji-regex\package.json
============================================================
{
  "name": "emoji-regex",
  "version": "8.0.0",
  "description": "A regular expression to match all Emoji-only symbols as per the Unicode Standard.",
  "homepage": "https://mths.be/emoji-regex",
  "main": "index.js",
  "types": "index.d.ts",
  "keywords": [
    "unicode",
    "regex",
    "regexp",
    "regular expressions",
    "code points",
    "symbols",
    "characters",
    "emoji"
  ],
  "license": "MIT",
  "author": {
    "name": "Mathias Bynens",
    "url": "https://mathiasbynens.be/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mathiasbynens/emoji-regex.git"
  },
  "bugs": "https://github.com/mathiasbynens/emoji-regex/issues",
  "files": [
    "LICENSE-MIT.txt",
    "index.js",
    "index.d.ts",
    "text.js",
    "es2015/index.js",
    "es2015/text.js"
  ],
  "scripts": {
    "build": "rm -rf -- es2015; babel src -d .; NODE_ENV=es2015 babel src -d ./es2015; node script/inject-sequences.js",
    "test": "mocha",
    "test:watch": "npm run test -- --watch"
  },
  "devDependencies": {
    "@babel/cli": "^7.2.3",
    "@babel/core": "^7.3.4",
    "@babel/plugin-proposal-unicode-property-regex": "^7.2.0",
    "@babel/preset-env": "^7.3.4",
    "mocha": "^6.0.2",
    "regexgen": "^1.3.0",
    "unicode-12.0.0": "^0.7.9"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\string-width-cjs\node_modules\strip-ansi\package.json
============================================================
{
	"name": "strip-ansi",
	"version": "6.0.1",
	"description": "Strip ANSI escape codes from a string",
	"license": "MIT",
	"repository": "chalk/strip-ansi",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"strip",
		"trim",
		"remove",
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"dependencies": {
		"ansi-regex": "^5.0.1"
	},
	"devDependencies": {
		"ava": "^2.4.0",
		"tsd": "^0.10.0",
		"xo": "^0.25.3"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\string-width-cjs\package.json
============================================================
{
	"name": "string-width",
	"version": "4.2.3",
	"description": "Get the visual width of a string - the number of columns required to display it",
	"license": "MIT",
	"repository": "sindresorhus/string-width",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"string",
		"character",
		"unicode",
		"width",
		"visual",
		"column",
		"columns",
		"fullwidth",
		"full-width",
		"full",
		"ansi",
		"escape",
		"codes",
		"cli",
		"command-line",
		"terminal",
		"console",
		"cjk",
		"chinese",
		"japanese",
		"korean",
		"fixed-width"
	],
	"dependencies": {
		"emoji-regex": "^8.0.0",
		"is-fullwidth-code-point": "^3.0.0",
		"strip-ansi": "^6.0.1"
	},
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.1",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\strip-ansi\node_modules\ansi-regex\package.json
============================================================
{
	"name": "ansi-regex",
	"version": "6.2.2",
	"description": "Regular expression for matching ANSI escape codes",
	"license": "MIT",
	"repository": "chalk/ansi-regex",
	"funding": "https://github.com/chalk/ansi-regex?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"type": "module",
	"exports": "./index.js",
	"types": "./index.d.ts",
	"sideEffects": false,
	"engines": {
		"node": ">=12"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"view-supported": "node fixtures/view-codes.js"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"command-line",
		"text",
		"regex",
		"regexp",
		"re",
		"match",
		"test",
		"find",
		"pattern"
	],
	"devDependencies": {
		"ansi-escapes": "^5.0.0",
		"ava": "^3.15.0",
		"tsd": "^0.21.0",
		"xo": "^0.54.2"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\strip-ansi\package.json
============================================================
{
	"name": "strip-ansi",
	"version": "7.1.2",
	"description": "Strip ANSI escape codes from a string",
	"license": "MIT",
	"repository": "chalk/strip-ansi",
	"funding": "https://github.com/chalk/strip-ansi?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"type": "module",
	"exports": "./index.js",
	"types": "./index.d.ts",
	"sideEffects": false,
	"engines": {
		"node": ">=12"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"strip",
		"trim",
		"remove",
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"dependencies": {
		"ansi-regex": "^6.0.1"
	},
	"devDependencies": {
		"ava": "^3.15.0",
		"tsd": "^0.17.0",
		"xo": "^0.44.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\strip-ansi-cjs\package.json
============================================================
{
	"name": "strip-ansi",
	"version": "6.0.1",
	"description": "Strip ANSI escape codes from a string",
	"license": "MIT",
	"repository": "chalk/strip-ansi",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"strip",
		"trim",
		"remove",
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"dependencies": {
		"ansi-regex": "^5.0.1"
	},
	"devDependencies": {
		"ava": "^2.4.0",
		"tsd": "^0.10.0",
		"xo": "^0.25.3"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\strip-bom\package.json
============================================================
{
	"name": "strip-bom",
	"version": "4.0.0",
	"description": "Strip UTF-8 byte order mark (BOM) from a string",
	"license": "MIT",
	"repository": "sindresorhus/strip-bom",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"strip",
		"bom",
		"byte",
		"order",
		"mark",
		"unicode",
		"utf8",
		"utf-8",
		"remove",
		"delete",
		"trim",
		"text",
		"string"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\strip-final-newline\package.json
============================================================
{
	"name": "strip-final-newline",
	"version": "2.0.0",
	"description": "Strip the final newline character from a string/buffer",
	"license": "MIT",
	"repository": "sindresorhus/strip-final-newline",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=6"
	},
	"scripts": {
		"test": "xo && ava"
	},
	"files": [
		"index.js"
	],
	"keywords": [
		"strip",
		"trim",
		"remove",
		"delete",
		"final",
		"last",
		"end",
		"file",
		"newline",
		"linebreak",
		"character",
		"string",
		"buffer"
	],
	"devDependencies": {
		"ava": "^0.25.0",
		"xo": "^0.23.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\strip-indent\package.json
============================================================
{
	"name": "strip-indent",
	"version": "3.0.0",
	"description": "Strip leading whitespace from each line in a string",
	"license": "MIT",
	"repository": "sindresorhus/strip-indent",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"strip",
		"indent",
		"indentation",
		"normalize",
		"remove",
		"delete",
		"whitespace",
		"space",
		"tab",
		"string"
	],
	"dependencies": {
		"min-indent": "^1.0.0"
	},
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\strip-json-comments\package.json
============================================================
{
	"name": "strip-json-comments",
	"version": "3.1.1",
	"description": "Strip comments from JSON. Lets you use comments in your JSON files!",
	"license": "MIT",
	"repository": "sindresorhus/strip-json-comments",
	"funding": "https://github.com/sponsors/sindresorhus",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"bench": "matcha benchmark.js"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"json",
		"strip",
		"comments",
		"remove",
		"delete",
		"trim",
		"multiline",
		"parse",
		"config",
		"configuration",
		"settings",
		"util",
		"env",
		"environment",
		"jsonc"
	],
	"devDependencies": {
		"ava": "^1.4.1",
		"matcha": "^0.7.0",
		"tsd": "^0.7.2",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\styled-components\macro\package.json
============================================================
{
  "name": "styled-components/macro",
  "private": true,
  "main": "../dist/styled-components-macro.cjs.js",
  "module": "../dist/styled-components-macro.esm.js",
  "jsnext:main": "../dist/styled-components-macro.esm.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\styled-components\native\package.json
============================================================
{
  "name": "styled-components/native",
  "private": true,
  "main": "./dist/styled-components.native.cjs.js",
  "jsnext:main": "./dist/styled-components.native.esm.js",
  "module": "./dist/styled-components.native.esm.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\styled-components\node_modules\has-flag\package.json
============================================================
{
  "name": "has-flag",
  "version": "3.0.0",
  "description": "Check if argv has a specific flag",
  "license": "MIT",
  "repository": "sindresorhus/has-flag",
  "author": {
    "name": "Sindre Sorhus",
    "email": "sindresorhus@gmail.com",
    "url": "sindresorhus.com"
  },
  "engines": {
    "node": ">=4"
  },
  "scripts": {
    "test": "xo && ava"
  },
  "files": [
    "index.js"
  ],
  "keywords": [
    "has",
    "check",
    "detect",
    "contains",
    "find",
    "flag",
    "cli",
    "command-line",
    "argv",
    "process",
    "arg",
    "args",
    "argument",
    "arguments",
    "getopt",
    "minimist",
    "optimist"
  ],
  "devDependencies": {
    "ava": "*",
    "xo": "*"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\styled-components\node_modules\supports-color\package.json
============================================================
{
	"name": "supports-color",
	"version": "5.5.0",
	"description": "Detect whether a terminal supports color",
	"license": "MIT",
	"repository": "chalk/supports-color",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=4"
	},
	"scripts": {
		"test": "xo && ava"
	},
	"files": [
		"index.js",
		"browser.js"
	],
	"keywords": [
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"ansi",
		"styles",
		"tty",
		"rgb",
		"256",
		"shell",
		"xterm",
		"command-line",
		"support",
		"supports",
		"capability",
		"detect",
		"truecolor",
		"16m"
	],
	"dependencies": {
		"has-flag": "^3.0.0"
	},
	"devDependencies": {
		"ava": "^0.25.0",
		"import-fresh": "^2.0.0",
		"xo": "^0.20.0"
	},
	"browser": "browser.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\styled-components\primitives\package.json
============================================================
{
  "name": "styled-components/primitives",
  "private": true,
  "main": "./dist/styled-components-primitives.cjs.js",
  "module": "./dist/styled-components-primitives.esm.js",
  "jsnext:main": "./dist/styled-components-primitives.esm.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\styled-components\package.json
============================================================
{
  "name": "styled-components",
  "version": "5.3.11",
  "description": "Visual primitives for the component age. Use the best bits of ES6 and CSS to style your apps without stress",
  "main": "dist/styled-components.cjs.js",
  "jsnext:main": "dist/styled-components.esm.js",
  "module": "dist/styled-components.esm.js",
  "react-native": "native/dist/styled-components.native.cjs.js",
  "browser": {
    "./dist/styled-components.esm.js": "./dist/styled-components.browser.esm.js",
    "./dist/styled-components.cjs.js": "./dist/styled-components.browser.cjs.js"
  },
  "sideEffects": [
    "./src/base.js"
  ],
  "scripts": {
    "generateErrors": "node scripts/generateErrorMap.js",
    "prebuild": "rimraf dist && npm run generateErrors",
    "build": "rollup -c",
    "postbuild": "npm run lint:size",
    "flow": "flow check",
    "flow:watch": "flow-watch",
    "pretest": "npm run generateErrors",
    "test": "npm run test:web && npm run test:native && npm run test:primitives",
    "test:web": "jest -c ../../scripts/jest/config.main.js",
    "test:native": "jest -c ../../scripts/jest/config.native.js",
    "test:primitives": "jest -c ../../scripts/jest/config.primitives.js",
    "test:integration": "jest -c ../../scripts/jest/config.integration.js --runInBand --forceExit",
    "format": "eslint ./**/*.js --fix",
    "lint": "eslint src",
    "lint:size": "bundlewatch",
    "prettier": "prettier */**/*.js --write",
    "prepublishOnly": "npm run build",
    "dev": "cross-env BABEL_ENV=cjs babel-node example/startServer.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/styled-components/styled-components.git"
  },
  "files": [
    "CODE_OF_CONDUCT.md",
    "CONTRIBUTING.md",
    "dist",
    "native",
    "primitives",
    "scripts",
    "test-utils",
    "macro"
  ],
  "keywords": [
    "react",
    "css",
    "css-in-js",
    "styled-components",
    "babel-macro",
    "babel-macros",
    "styling"
  ],
  "author": "Glen Maddern",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/styled-components/styled-components/issues"
  },
  "homepage": "https://styled-components.com",
  "dependencies": {
    "@babel/helper-module-imports": "^7.0.0",
    "@babel/traverse": "^7.4.5",
    "@emotion/is-prop-valid": "^1.1.0",
    "@emotion/stylis": "^0.8.4",
    "@emotion/unitless": "^0.7.4",
    "babel-plugin-styled-components": ">= 1.12.0",
    "css-to-react-native": "^3.0.0",
    "hoist-non-react-statics": "^3.0.0",
    "shallowequal": "^1.1.0",
    "supports-color": "^5.5.0"
  },
  "peerDependencies": {
    "react": ">= 16.8.0",
    "react-dom": ">= 16.8.0",
    "react-is": ">= 16.8.0"
  },
  "devDependencies": {
    "@babel/cli": "^7.0.0",
    "@babel/core": "^7.0.0",
    "@babel/plugin-proposal-object-rest-spread": "^7.0.0",
    "@babel/preset-env": "^7.0.0",
    "@babel/preset-flow": "^7.0.0",
    "@babel/preset-react": "^7.0.0",
    "babel-eslint": "^10.0.1",
    "eslint-plugin-flowtype": "^5.2.0",
    "eslint-plugin-import": "^2.22.0",
    "eslint-plugin-react": "^7.20.6",
    "flow-bin": "^0.132.0",
    "jest-serializer-html": "^7.0.0",
    "js-beautify": "^1.13.0",
    "prop-types": "^15.7.2",
    "react": "^16.8.6",
    "react-dom": "^16.8.6",
    "react-frame-component": "^4.0.2",
    "react-is": "^16.8.6",
    "react-native": "^0.63.4",
    "react-primitives": "^0.8.0",
    "react-test-renderer": "^16.8.6",
    "rollup": "^1.13.1",
    "rollup-plugin-babel": "^4.3.2",
    "rollup-plugin-terser": "^5.0.0",
    "stylis-plugin-rtl": "^1.0.0"
  },
  "bundlewatch": {
    "files": [
      {
        "path": "./dist/styled-components.min.js",
        "maxSize": "13kB"
      }
    ]
  },
  "collective": {
    "type": "opencollective",
    "url": "https://opencollective.com/styled-components"
  },
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/styled-components"
  },
  "engines": {
    "node": ">=10"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\supports-color\package.json
============================================================
{
	"name": "supports-color",
	"version": "7.2.0",
	"description": "Detect whether a terminal supports color",
	"license": "MIT",
	"repository": "chalk/supports-color",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava"
	},
	"files": [
		"index.js",
		"browser.js"
	],
	"keywords": [
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"ansi",
		"styles",
		"tty",
		"rgb",
		"256",
		"shell",
		"xterm",
		"command-line",
		"support",
		"supports",
		"capability",
		"detect",
		"truecolor",
		"16m"
	],
	"dependencies": {
		"has-flag": "^4.0.0"
	},
	"devDependencies": {
		"ava": "^1.4.1",
		"import-fresh": "^3.0.0",
		"xo": "^0.24.0"
	},
	"browser": "browser.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\supports-preserve-symlinks-flag\package.json
============================================================
{
	"name": "supports-preserve-symlinks-flag",
	"version": "1.0.0",
	"description": "Determine if the current node version supports the `--preserve-symlinks` flag.",
	"main": "./index.js",
	"browser": "./browser.js",
	"exports": {
		".": [
			{
				"browser": "./browser.js",
				"default": "./index.js"
			},
			"./index.js"
		],
		"./package.json": "./package.json"
	},
	"sideEffects": false,
	"scripts": {
		"prepublishOnly": "safe-publish-latest",
		"prepublish": "not-in-publish || npm run prepublishOnly",
		"lint": "eslint --ext=js,mjs .",
		"pretest": "npm run lint",
		"tests-only": "nyc tape 'test/**/*.js'",
		"test": "npm run tests-only",
		"posttest": "aud --production",
		"version": "auto-changelog && git add CHANGELOG.md",
		"postversion": "auto-changelog && git add CHANGELOG.md && git commit --no-edit --amend && git tag -f \"v$(node -e \"console.log(require('./package.json').version)\")\""
	},
	"repository": {
		"type": "git",
		"url": "git+https://github.com/inspect-js/node-supports-preserve-symlinks-flag.git"
	},
	"keywords": [
		"node",
		"flag",
		"symlink",
		"symlinks",
		"preserve-symlinks"
	],
	"author": "Jordan Harband <ljharb@gmail.com>",
	"funding": {
		"url": "https://github.com/sponsors/ljharb"
	},
	"license": "MIT",
	"bugs": {
		"url": "https://github.com/inspect-js/node-supports-preserve-symlinks-flag/issues"
	},
	"homepage": "https://github.com/inspect-js/node-supports-preserve-symlinks-flag#readme",
	"devDependencies": {
		"@ljharb/eslint-config": "^20.1.0",
		"aud": "^1.1.5",
		"auto-changelog": "^2.3.0",
		"eslint": "^8.6.0",
		"nyc": "^10.3.2",
		"safe-publish-latest": "^2.0.0",
		"semver": "^6.3.0",
		"tape": "^5.4.0"
	},
	"engines": {
		"node": ">= 0.4"
	},
	"auto-changelog": {
		"output": "CHANGELOG.md",
		"template": "keepachangelog",
		"unreleased": false,
		"commitLimit": false,
		"backfillLimit": false,
		"hideCredit": true
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\symbol-tree\package.json
============================================================
{
  "name": "symbol-tree",
  "version": "3.2.4",
  "description": "Turn any collection of objects into its own efficient tree or linked list using Symbol",
  "main": "lib/SymbolTree.js",
  "scripts": {
    "lint": "eslint lib test",
    "test": "istanbul cover test/SymbolTree.js",
    "posttest": "npm run lint",
    "ci": "istanbul cover test/SymbolTree.js --report lcovonly && cat ./coverage/lcov.info | coveralls",
    "postci": "npm run posttest",
    "predocumentation": "cp readme-header.md README.md",
    "documentation": "jsdoc2md --files lib/SymbolTree.js >> README.md"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jsdom/js-symbol-tree.git"
  },
  "keywords": [
    "list",
    "queue",
    "stack",
    "linked-list",
    "tree",
    "es6",
    "dom",
    "symbol"
  ],
  "files": [
    "lib"
  ],
  "author": "Joris van der Wel <joris@jorisvanderwel.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/jsdom/js-symbol-tree/issues"
  },
  "homepage": "https://github.com/jsdom/js-symbol-tree#symbol-tree",
  "devDependencies": {
    "babel-eslint": "^10.0.1",
    "coveralls": "^3.0.0",
    "eslint": "^5.16.0",
    "eslint-plugin-import": "^2.2.0",
    "istanbul": "^0.4.5",
    "jsdoc-to-markdown": "^5.0.0",
    "tape": "^4.0.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\synckit\package.json
============================================================
{
  "name": "synckit",
  "version": "0.11.11",
  "type": "module",
  "description": "Perform async work synchronously in Node.js using `worker_threads` with first-class TypeScript support.",
  "repository": "https://github.com/un-ts/synckit.git",
  "author": "JounQin <admin@1stg.me> (https://www.1stG.me)",
  "funding": "https://opencollective.com/synckit",
  "license": "MIT",
  "engines": {
    "node": "^14.18.0 || >=16.0.0"
  },
  "main": "./lib/index.cjs",
  "types": "./lib/index.d.cts",
  "module": "./lib/index.js",
  "exports": {
    "import": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "require": {
      "types": "./lib/index.d.cts",
      "default": "./lib/index.cjs"
    }
  },
  "files": [
    "index.d.cts",
    "lib",
    "!**/*.tsbuildinfo"
  ],
  "keywords": [
    "deasync",
    "make-synchronized",
    "make-synchronous",
    "sync",
    "sync-exec",
    "sync-rpc",
    "sync-threads",
    "synchronize",
    "synckit"
  ],
  "dependencies": {
    "@pkgr/core": "^0.2.9"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\test-exclude\node_modules\glob\package.json
============================================================
{
  "author": "Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)",
  "name": "glob",
  "description": "a little globber",
  "version": "7.2.3",
  "publishConfig": {
    "tag": "v7-legacy"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/node-glob.git"
  },
  "main": "glob.js",
  "files": [
    "glob.js",
    "sync.js",
    "common.js"
  ],
  "engines": {
    "node": "*"
  },
  "dependencies": {
    "fs.realpath": "^1.0.0",
    "inflight": "^1.0.4",
    "inherits": "2",
    "minimatch": "^3.1.1",
    "once": "^1.3.0",
    "path-is-absolute": "^1.0.0"
  },
  "devDependencies": {
    "memfs": "^3.2.0",
    "mkdirp": "0",
    "rimraf": "^2.2.8",
    "tap": "^15.0.6",
    "tick": "0.0.6"
  },
  "tap": {
    "before": "test/00-setup.js",
    "after": "test/zz-cleanup.js",
    "jobs": 1
  },
  "scripts": {
    "prepublish": "npm run benchclean",
    "profclean": "rm -f v8.log profile.txt",
    "test": "tap",
    "test-regen": "npm run profclean && TEST_REGEN=1 node test/00-setup.js",
    "bench": "bash benchmark.sh",
    "prof": "bash prof.sh && cat profile.txt",
    "benchclean": "node benchclean.js"
  },
  "license": "ISC",
  "funding": {
    "url": "https://github.com/sponsors/isaacs"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\test-exclude\package.json
============================================================
{
  "name": "test-exclude",
  "version": "6.0.0",
  "description": "test for inclusion or exclusion of paths using globs",
  "main": "index.js",
  "files": [
    "*.js",
    "!nyc.config.js"
  ],
  "scripts": {
    "release": "standard-version",
    "test": "nyc tap",
    "snap": "npm test -- --snapshot"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/istanbuljs/test-exclude.git"
  },
  "keywords": [
    "exclude",
    "include",
    "glob",
    "package",
    "config"
  ],
  "author": "Ben Coe <ben@npmjs.com>",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/istanbuljs/test-exclude/issues"
  },
  "homepage": "https://istanbul.js.org/",
  "dependencies": {
    "@istanbuljs/schema": "^0.1.2",
    "glob": "^7.1.4",
    "minimatch": "^3.0.4"
  },
  "devDependencies": {
    "nyc": "^15.0.0-beta.3",
    "standard-version": "^7.0.0",
    "tap": "^14.10.5"
  },
  "engines": {
    "node": ">=8"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\tinybench\package.json
============================================================
{
  "name": "tinybench",
  "version": "2.9.0",
  "type": "module",
  "packageManager": "pnpm@8.4.0",
  "main": "./dist/index.cjs",
  "module": "./dist/index.js",
  "types": "./dist/index.d.cts",
  "exports": {
    "require": "./dist/index.cjs",
    "import": "./dist/index.js",
    "default": "./dist/index.js"
  },
  "files": [
    "dist/**"
  ],
  "repository": "tinylibs/tinybench",
  "license": "MIT",
  "keywords": [
    "benchmark",
    "tinylibs",
    "tiny"
  ],
  "scripts": {
    "publish": "npm run build && clean-publish"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\tinyexec\package.json
============================================================
{
  "name": "tinyexec",
  "version": "0.3.2",
  "type": "module",
  "description": "A minimal library for executing processes in Node",
  "main": "./dist/main.js",
  "files": [
    "dist",
    "!dist/node_modules",
    "!dist/cjs/test",
    "!dist/esm/test"
  ],
  "scripts": {
    "build": "npm run build:types && tsup",
    "build:types": "tsc",
    "dev": "tsup --watch",
    "format": "prettier --write src",
    "format:check": "prettier --check src",
    "lint": "eslint src",
    "prepare": "npm run build",
    "test": "npm run build && c8 node --test"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/tinylibs/tinyexec.git"
  },
  "keywords": [
    "execa",
    "exec",
    "tiny",
    "child_process",
    "spawn"
  ],
  "author": "James Garbutt (https://github.com/43081j)",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/tinylibs/tinyexec/issues"
  },
  "homepage": "https://github.com/tinylibs/tinyexec#readme",
  "devDependencies": {
    "@eslint/js": "^9.0.0",
    "@types/cross-spawn": "^6.0.6",
    "@types/node": "^20.12.7",
    "c8": "^9.1.0",
    "cross-spawn": "^7.0.3",
    "eslint-config-google": "^0.14.0",
    "prettier": "^3.2.5",
    "tsup": "^8.1.0",
    "typescript": "^5.4.5",
    "typescript-eslint": "^7.7.0"
  },
  "exports": {
    ".": {
      "import": {
        "types": "./dist/main.d.ts",
        "default": "./dist/main.js"
      },
      "require": {
        "types": "./dist/main.d.cts",
        "default": "./dist/main.cjs"
      }
    },
    "./package.json": "./package.json"
  },
  "types": "./dist/main.d.ts"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\tinyglobby\node_modules\fdir\package.json
============================================================
{
  "name": "fdir",
  "version": "6.5.0",
  "description": "The fastest directory crawler & globbing alternative to glob, fast-glob, & tiny-glob. Crawls 1m files in < 1s",
  "main": "./dist/index.cjs",
  "types": "./dist/index.d.cts",
  "type": "module",
  "scripts": {
    "prepublishOnly": "npm run test && npm run build",
    "build": "tsdown",
    "format": "prettier --write src __tests__ benchmarks",
    "test": "vitest run __tests__/",
    "test:coverage": "vitest run --coverage __tests__/",
    "test:watch": "vitest __tests__/",
    "bench": "ts-node benchmarks/benchmark.js",
    "bench:glob": "ts-node benchmarks/glob-benchmark.ts",
    "bench:fdir": "ts-node benchmarks/fdir-benchmark.ts",
    "release": "./scripts/release.sh"
  },
  "engines": {
    "node": ">=12.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/thecodrr/fdir.git"
  },
  "keywords": [
    "util",
    "os",
    "sys",
    "fs",
    "walk",
    "crawler",
    "directory",
    "files",
    "io",
    "tiny-glob",
    "glob",
    "fast-glob",
    "speed",
    "javascript",
    "nodejs"
  ],
  "author": "thecodrr <thecodrr@protonmail.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/thecodrr/fdir/issues"
  },
  "homepage": "https://github.com/thecodrr/fdir#readme",
  "devDependencies": {
    "@types/glob": "^8.1.0",
    "@types/mock-fs": "^4.13.4",
    "@types/node": "^20.9.4",
    "@types/picomatch": "^4.0.0",
    "@types/tap": "^15.0.11",
    "@vitest/coverage-v8": "^0.34.6",
    "all-files-in-tree": "^1.1.2",
    "benny": "^3.7.1",
    "csv-to-markdown-table": "^1.3.1",
    "expect": "^29.7.0",
    "fast-glob": "^3.3.2",
    "fdir1": "npm:fdir@1.2.0",
    "fdir2": "npm:fdir@2.1.0",
    "fdir3": "npm:fdir@3.4.2",
    "fdir4": "npm:fdir@4.1.0",
    "fdir5": "npm:fdir@5.0.0",
    "fs-readdir-recursive": "^1.1.0",
    "get-all-files": "^4.1.0",
    "glob": "^10.3.10",
    "klaw-sync": "^6.0.0",
    "mock-fs": "^5.2.0",
    "picomatch": "^4.0.2",
    "prettier": "^3.5.3",
    "recur-readdir": "0.0.1",
    "recursive-files": "^1.0.2",
    "recursive-fs": "^2.1.0",
    "recursive-readdir": "^2.2.3",
    "rrdir": "^12.1.0",
    "systeminformation": "^5.21.17",
    "tiny-glob": "^0.2.9",
    "ts-node": "^10.9.1",
    "tsdown": "^0.12.5",
    "typescript": "^5.3.2",
    "vitest": "^0.34.6",
    "walk-sync": "^3.0.0"
  },
  "peerDependencies": {
    "picomatch": "^3 || ^4"
  },
  "peerDependenciesMeta": {
    "picomatch": {
      "optional": true
    }
  },
  "module": "./dist/index.mjs",
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    },
    "./package.json": "./package.json"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\tinyglobby\node_modules\picomatch\package.json
============================================================
{
  "name": "picomatch",
  "description": "Blazing fast and accurate glob matcher written in JavaScript, with no dependencies and full support for standard and extended Bash glob features, including braces, extglobs, POSIX brackets, and regular expressions.",
  "version": "4.0.3",
  "homepage": "https://github.com/micromatch/picomatch",
  "author": "Jon Schlinkert (https://github.com/jonschlinkert)",
  "funding": "https://github.com/sponsors/jonschlinkert",
  "repository": "micromatch/picomatch",
  "bugs": {
    "url": "https://github.com/micromatch/picomatch/issues"
  },
  "license": "MIT",
  "files": [
    "index.js",
    "posix.js",
    "lib"
  ],
  "sideEffects": false,
  "main": "index.js",
  "engines": {
    "node": ">=12"
  },
  "scripts": {
    "lint": "eslint --cache --cache-location node_modules/.cache/.eslintcache --report-unused-disable-directives --ignore-path .gitignore .",
    "mocha": "mocha --reporter dot",
    "test": "npm run lint && npm run mocha",
    "test:ci": "npm run test:cover",
    "test:cover": "nyc npm run mocha"
  },
  "devDependencies": {
    "eslint": "^8.57.0",
    "fill-range": "^7.0.1",
    "gulp-format-md": "^2.0.0",
    "mocha": "^10.4.0",
    "nyc": "^15.1.0",
    "time-require": "github:jonschlinkert/time-require"
  },
  "keywords": [
    "glob",
    "match",
    "picomatch"
  ],
  "nyc": {
    "reporter": [
      "html",
      "lcov",
      "text-summary"
    ]
  },
  "verb": {
    "toc": {
      "render": true,
      "method": "preWrite",
      "maxdepth": 3
    },
    "layout": "empty",
    "tasks": [
      "readme"
    ],
    "plugins": [
      "gulp-format-md"
    ],
    "lint": {
      "reflinks": true
    },
    "related": {
      "list": [
        "braces",
        "micromatch"
      ]
    },
    "reflinks": [
      "braces",
      "expand-brackets",
      "extglob",
      "fill-range",
      "micromatch",
      "minimatch",
      "nanomatch",
      "picomatch"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\tinyglobby\package.json
============================================================
{
  "name": "tinyglobby",
  "version": "0.2.15",
  "description": "A fast and minimal alternative to globby and fast-glob",
  "type": "module",
  "main": "./dist/index.cjs",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.cts",
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    },
    "./package.json": "./package.json"
  },
  "sideEffects": false,
  "files": [
    "dist"
  ],
  "author": "Superchupu",
  "license": "MIT",
  "keywords": [
    "glob",
    "patterns",
    "fast",
    "implementation"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/SuperchupuDev/tinyglobby.git"
  },
  "bugs": {
    "url": "https://github.com/SuperchupuDev/tinyglobby/issues"
  },
  "homepage": "https://superchupu.dev/tinyglobby",
  "funding": {
    "url": "https://github.com/sponsors/SuperchupuDev"
  },
  "dependencies": {
    "fdir": "^6.5.0",
    "picomatch": "^4.0.3"
  },
  "devDependencies": {
    "@biomejs/biome": "^2.2.3",
    "@types/node": "^24.3.1",
    "@types/picomatch": "^4.0.2",
    "fast-glob": "^3.3.3",
    "fs-fixture": "^2.8.1",
    "glob": "^11.0.3",
    "tinybench": "^5.0.1",
    "tsdown": "^0.14.2",
    "typescript": "^5.9.2"
  },
  "engines": {
    "node": ">=12.0.0"
  },
  "publishConfig": {
    "provenance": true
  },
  "scripts": {
    "bench": "node benchmark/bench.ts",
    "bench:setup": "node benchmark/setup.ts",
    "build": "tsdown",
    "check": "biome check",
    "check:fix": "biome check --write --unsafe",
    "format": "biome format --write",
    "lint": "biome lint",
    "test": "node --test \"test/**/*.ts\"",
    "test:coverage": "node --test --experimental-test-coverage \"test/**/*.ts\"",
    "test:only": "node --test --test-only \"test/**/*.ts\"",
    "typecheck": "tsc --noEmit"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\tinyrainbow\package.json
============================================================
{
  "name": "tinyrainbow",
  "version": "3.0.3",
  "packageManager": "pnpm@9.15.1",
  "description": "A small library to print colourful messages.",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "browser": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "types": "./dist/index.d.ts",
    "default": "./dist/index.js"
  },
  "files": [
    "dist/**"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/tinylibs/tinyrainbow.git"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/tinylibs/tinyrainbow/issues"
  },
  "homepage": "https://github.com/tinylibs/tinyrainbow#readme",
  "keywords": [
    "colors",
    "tty"
  ],
  "engines": {
    "node": ">=14.0.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\tldts\package.json
============================================================
{
  "name": "tldts",
  "version": "7.0.17",
  "description": "Library to work against complex domain names, subdomains and URIs.",
  "author": {
    "name": "Rémi Berson"
  },
  "contributors": [
    "Alexei <alexeiatyahoodotcom@gmail.com>",
    "Alexey <kureev-mail@ya.ru>",
    "Andrew <chefandrew@seomoz.org>",
    "Johannes Ewald <johannes.ewald@peerigon.com>",
    "Jérôme Desboeufs <jerome.desboeufs@gmail.com>",
    "Kelly Campbell <kelly.a.campbell@gmail.com>",
    "Kiko Beats <josefrancisco.verdu@gmail.com>",
    "Kris Reeves <krisreeves@searchfanatics.com>",
    "Krzysztof Jan Modras <chrmod@chrmod.net>",
    "Olivier Melcher <olivier.melcher@gmail.com>",
    "Rémi Berson <remi.berson@pm.me>",
    "Saad Rashid <srashid@lendinghome.com>",
    "Thomas Parisot <hi@oncletom.io>",
    "Timo Tijhof <krinklemail@gmail.com>",
    "Xavier Damman <xdamman@gmail.com>",
    "Yehezkiel Syamsuhadi <yehezkielbs@gmail.com>"
  ],
  "publishConfig": {
    "access": "public"
  },
  "license": "MIT",
  "homepage": "https://github.com/remusao/tldts#readme",
  "bugs": {
    "url": "https://github.com/remusao/tldts/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/remusao/tldts.git"
  },
  "main": "dist/cjs/index.js",
  "module": "dist/es6/index.js",
  "types": "dist/types/index.d.ts",
  "files": [
    "dist",
    "src",
    "index.ts"
  ],
  "bin": {
    "tldts": "bin/cli.js"
  },
  "scripts": {
    "clean": "rimraf dist coverage",
    "build": "tsc --build ./tsconfig.json",
    "bundle": "tsc --build ./tsconfig.bundle.json && rollup --config ./rollup.config.mjs",
    "prepack": "yarn run bundle",
    "test": "nyc mocha --config ../../.mocharc.cjs"
  },
  "devDependencies": {
    "@rollup/plugin-node-resolve": "^16.0.0",
    "@rollup/plugin-terser": "^0.4.0",
    "@rollup/plugin-typescript": "^12.1.0",
    "@types/chai": "^4.2.18",
    "@types/mocha": "^10.0.0",
    "@types/node": "^24.3.1",
    "chai": "^4.4.1",
    "mocha": "^11.0.1",
    "nyc": "^17.0.0",
    "rimraf": "^5.0.1",
    "rollup": "^4.1.0",
    "rollup-plugin-sourcemaps": "^0.6.1",
    "tldts-tests": "^7.0.17",
    "typescript": "^5.0.4"
  },
  "dependencies": {
    "tldts-core": "^7.0.17"
  },
  "keywords": [
    "tld",
    "sld",
    "domain",
    "subdomain",
    "subdomain",
    "hostname",
    "browser",
    "uri",
    "url",
    "domain name",
    "public suffix",
    "url parsing",
    "typescript"
  ],
  "gitHead": "334a864f7f56410662347e3079d2d07536b9a374"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\tldts-core\package.json
============================================================
{
  "name": "tldts-core",
  "version": "7.0.17",
  "description": "tldts core primitives (internal module)",
  "author": {
    "name": "Rémi Berson"
  },
  "contributors": [
    "Alexei <alexeiatyahoodotcom@gmail.com>",
    "Alexey <kureev-mail@ya.ru>",
    "Andrew <chefandrew@seomoz.org>",
    "Johannes Ewald <johannes.ewald@peerigon.com>",
    "Jérôme Desboeufs <jerome.desboeufs@gmail.com>",
    "Kelly Campbell <kelly.a.campbell@gmail.com>",
    "Kiko Beats <josefrancisco.verdu@gmail.com>",
    "Kris Reeves <krisreeves@searchfanatics.com>",
    "Krzysztof Jan Modras <chrmod@chrmod.net>",
    "Olivier Melcher <olivier.melcher@gmail.com>",
    "Rémi Berson <remi.berson@pm.me>",
    "Saad Rashid <srashid@lendinghome.com>",
    "Thomas Parisot <hi@oncletom.io>",
    "Timo Tijhof <krinklemail@gmail.com>",
    "Xavier Damman <xdamman@gmail.com>",
    "Yehezkiel Syamsuhadi <yehezkielbs@gmail.com>"
  ],
  "publishConfig": {
    "access": "public"
  },
  "license": "MIT",
  "homepage": "https://github.com/remusao/tldts#readme",
  "bugs": {
    "url": "https://github.com/remusao/tldts/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/remusao/tldts.git"
  },
  "main": "dist/cjs/index.js",
  "module": "dist/es6/index.js",
  "types": "dist/types/index.d.ts",
  "files": [
    "dist",
    "src",
    "index.ts"
  ],
  "scripts": {
    "clean": "rimraf dist",
    "build": "tsc --build ./tsconfig.json",
    "bundle": "tsc --build ./tsconfig.bundle.json && rollup --config ./rollup.config.ts --configPlugin typescript",
    "prepack": "yarn run bundle",
    "test": "nyc mocha --config ../../.mocharc.cjs"
  },
  "devDependencies": {
    "@rollup/plugin-node-resolve": "^16.0.0",
    "@rollup/plugin-typescript": "^12.1.0",
    "@types/chai": "^4.2.18",
    "@types/mocha": "^10.0.0",
    "@types/node": "^24.3.1",
    "chai": "^4.4.1",
    "mocha": "^11.0.1",
    "nyc": "^17.0.0",
    "rimraf": "^5.0.1",
    "rollup": "^4.1.0",
    "rollup-plugin-sourcemaps": "^0.6.1",
    "typescript": "^5.0.4"
  },
  "gitHead": "334a864f7f56410662347e3079d2d07536b9a374"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\tmpl\package.json
============================================================
{
  "name": "tmpl",
  "description": "JavaScript micro templates.",
  "version": "1.0.5",
  "license": "BSD-3-Clause",
  "homepage": "https://github.com/daaku/nodejs-tmpl",
  "author": "Naitik Shah <n@daaku.org>",
  "main": "lib/tmpl",
  "repository": {
    "type": "git",
    "url": "https://github.com/daaku/nodejs-tmpl"
  },
  "scripts": {
    "test": "NODE_PATH=./lib mocha --ui exports"
  },
  "devDependencies": {
    "mocha": "^9.1.1"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\to-regex-range\package.json
============================================================
{
  "name": "to-regex-range",
  "description": "Pass two numbers, get a regex-compatible source string for matching ranges. Validated against more than 2.78 million test assertions.",
  "version": "5.0.1",
  "homepage": "https://github.com/micromatch/to-regex-range",
  "author": "Jon Schlinkert (https://github.com/jonschlinkert)",
  "contributors": [
    "Jon Schlinkert (http://twitter.com/jonschlinkert)",
    "Rouven Weßling (www.rouvenwessling.de)"
  ],
  "repository": "micromatch/to-regex-range",
  "bugs": {
    "url": "https://github.com/micromatch/to-regex-range/issues"
  },
  "license": "MIT",
  "files": [
    "index.js"
  ],
  "main": "index.js",
  "engines": {
    "node": ">=8.0"
  },
  "scripts": {
    "test": "mocha"
  },
  "dependencies": {
    "is-number": "^7.0.0"
  },
  "devDependencies": {
    "fill-range": "^6.0.0",
    "gulp-format-md": "^2.0.0",
    "mocha": "^6.0.2",
    "text-table": "^0.2.0",
    "time-diff": "^0.3.1"
  },
  "keywords": [
    "bash",
    "date",
    "expand",
    "expansion",
    "expression",
    "glob",
    "match",
    "match date",
    "match number",
    "match numbers",
    "match year",
    "matches",
    "matching",
    "number",
    "numbers",
    "numerical",
    "range",
    "ranges",
    "regex",
    "regexp",
    "regular",
    "regular expression",
    "sequence"
  ],
  "verb": {
    "layout": "default",
    "toc": false,
    "tasks": [
      "readme"
    ],
    "plugins": [
      "gulp-format-md"
    ],
    "lint": {
      "reflinks": true
    },
    "helpers": {
      "examples": {
        "displayName": "examples"
      }
    },
    "related": {
      "list": [
        "expand-range",
        "fill-range",
        "micromatch",
        "repeat-element",
        "repeat-string"
      ]
    }
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\totalist\package.json
============================================================
{
  "name": "totalist",
  "version": "3.0.1",
  "repository": "lukeed/totalist",
  "description": "A tiny (195B to 220B) utility to recursively list all (total) files in a directory",
  "module": "dist/index.mjs",
  "main": "dist/index.js",
  "types": "index.d.ts",
  "exports": {
    ".": {
      "types": "./index.d.ts",
      "import": "./dist/index.mjs",
      "require": "./dist/index.js"
    },
    "./sync": {
      "types": "./sync/index.d.ts",
      "import": "./sync/index.mjs",
      "require": "./sync/index.js"
    }
  },
  "license": "MIT",
  "files": [
    "index.d.ts",
    "dist",
    "sync"
  ],
  "author": {
    "name": "Luke Edwards",
    "email": "luke.edwards05@gmail.com",
    "url": "https://lukeed.com"
  },
  "engines": {
    "node": ">=6"
  },
  "keywords": [
    "list",
    "recursive",
    "files",
    "glob",
    "tree"
  ],
  "scripts": {
    "build": "bundt",
    "test": "uvu -r esm test -i fixtures"
  },
  "modes": {
    "sync": "src/sync.js",
    "default": "src/async.js"
  },
  "devDependencies": {
    "bundt": "1.1.1",
    "esm": "3.2.25",
    "uvu": "0.3.3"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\tough-cookie\package.json
============================================================
{
  "author": {
    "name": "Jeremy Stashewsky",
    "email": "jstash@gmail.com",
    "website": "https://github.com/stash"
  },
  "contributors": [
    {
      "name": "Ivan Nikulin",
      "website": "https://github.com/inikulin"
    },
    {
      "name": "Shivan Kaul Sahib",
      "website": "https://github.com/ShivanKaul"
    },
    {
      "name": "Clint Ruoho",
      "website": "https://github.com/ruoho"
    },
    {
      "name": "Ian Livingstone",
      "website": "https://github.com/ianlivingstone"
    },
    {
      "name": "Andrew Waterman",
      "website": "https://github.com/awaterma"
    },
    {
      "name": "Michael de Libero ",
      "website": "https://github.com/medelibero-sfdc"
    },
    {
      "name": "Jonathan Stewmon",
      "website": "https://github.com/jstewmon"
    },
    {
      "name": "Miguel Roncancio",
      "website": "https://github.com/miggs125"
    },
    {
      "name": "Sebastian Mayr",
      "website": "https://github.com/Sebmaster"
    },
    {
      "name": "Alexander Savin",
      "website": "https://github.com/apsavin"
    },
    {
      "name": "Lalit Kapoor",
      "website": "https://github.com/lalitkapoor"
    },
    {
      "name": "Sam Thompson",
      "website": "https://github.com/sambthompson"
    },
    {
      "name": "Colin Casey",
      "website": "https://github.com/colincasey"
    },
    {
      "name": "Will Harney",
      "website": "https://github.com/wjhsf"
    }
  ],
  "license": "BSD-3-Clause",
  "name": "tough-cookie",
  "description": "RFC6265 Cookies and Cookie Jar for node.js",
  "keywords": [
    "HTTP",
    "cookie",
    "cookies",
    "set-cookie",
    "cookiejar",
    "jar",
    "RFC6265",
    "RFC2965"
  ],
  "version": "6.0.0",
  "homepage": "https://github.com/salesforce/tough-cookie",
  "repository": {
    "type": "git",
    "url": "git://github.com/salesforce/tough-cookie.git"
  },
  "bugs": {
    "url": "https://github.com/salesforce/tough-cookie/issues"
  },
  "type": "module",
  "main": "./dist/index.cjs",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "import": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    },
    "require": {
      "types": "./dist/index.d.cts",
      "require": "./dist/index.cjs"
    }
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "tsup lib/cookie/index.ts --format cjs,esm --dts --clean --sourcemap",
    "lint": "npm run _lint:check",
    "prepack": "npm run build",
    "prepare-pr": "npm run build && npm test -- run && npm run _api:update && npm run _docs:generate && npm run _format:fix && npm run _lint:fix && npm run _lint:types",
    "test": "vitest",
    "version": "npm run _version:generate && npm run prepare-pr && git add --renormalize .",
    "_api:check": "api-extractor run --verbose",
    "_api:update": "api-extractor run --verbose --local",
    "_docs:generate": "api-documenter markdown --input-folder ./tmp --output-folder ./api/docs",
    "_docs:fix": "prettier ./api/docs --write",
    "_format:check": "prettier . --check",
    "_format:fix": "prettier . --write",
    "_lint:check": "eslint .",
    "_lint:fix": "eslint . --fix",
    "_lint:types": "attw --pack .",
    "_version:generate": "genversion --template version-template.ejs --force lib/version.ts"
  },
  "//": "We only support node LTS versions, but v16 still works. We won't block v16 until it becomes a burden.",
  "engines": {
    "node": ">=16"
  },
  "devDependencies": {
    "@arethetypeswrong/cli": "^0.18.2",
    "@eslint/js": "^9.24.0",
    "@microsoft/api-documenter": "^7.26.20",
    "@microsoft/api-extractor": "^7.52.3",
    "@types/node": "^20.19.6",
    "@vitest/eslint-plugin": "^1.1.40",
    "eslint": "^9.24.0",
    "eslint-config-prettier": "^10.1.2",
    "eslint-import-resolver-typescript": "^4.3.2",
    "eslint-plugin-import": "^2.31.0",
    "eslint-plugin-prettier": "^5.2.6",
    "genversion": "^3.2.0",
    "globals": "^16.0.0",
    "prettier": "^3.5.3",
    "tsup": "^8.5.0",
    "typescript": "5.5.3",
    "typescript-eslint": "^8.29.1",
    "vitest": "^3.1.1"
  },
  "dependencies": {
    "tldts": "^7.0.5"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\tr46\package.json
============================================================
{
  "name": "tr46",
  "version": "6.0.0",
  "engines": {
    "node": ">=20"
  },
  "description": "An implementation of the Unicode UTS #46: Unicode IDNA Compatibility Processing",
  "main": "index.js",
  "files": [
    "index.js",
    "lib/"
  ],
  "scripts": {
    "test": "node --test",
    "lint": "eslint",
    "pretest": "node scripts/getLatestTests.js",
    "prepublish": "node scripts/generateMappingTable.js && node scripts/generateRegexes.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jsdom/tr46.git"
  },
  "keywords": [
    "unicode",
    "tr46",
    "uts46",
    "punycode",
    "url",
    "whatwg"
  ],
  "author": "Sebastian Mayr <npm@smayr.name>",
  "contributors": [
    "Timothy Gu <timothygu99@gmail.com>"
  ],
  "license": "MIT",
  "dependencies": {
    "punycode": "^2.3.1"
  },
  "devDependencies": {
    "@domenic/eslint-config": "^4.0.1",
    "@unicode/unicode-17.0.0": "^1.6.12",
    "eslint": "^9.35.0",
    "globals": "^16.4.0",
    "regenerate": "^1.4.2"
  },
  "unicodeVersion": "17.0.0"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\type-detect\package.json
============================================================
{"name":"type-detect","description":"Improved typeof detection for node.js and the browser.","keywords":["type","typeof","types"],"license":"MIT","author":"Jake Luer <jake@alogicalparadox.com> (http://alogicalparadox.com)","contributors":["Keith Cirkel (https://github.com/keithamus)","David Losert (https://github.com/davelosert)","Aleksey Shvayka (https://github.com/shvaikalesh)","Lucas Fernandes da Costa (https://github.com/lucasfcosta)","Grant Snodgrass (https://github.com/meeber)","Jeremy Tice (https://github.com/jetpacmonkey)","Edward Betts (https://github.com/EdwardBetts)","dvlsg (https://github.com/dvlsg)","Amila Welihinda (https://github.com/amilajack)","Jake Champion (https://github.com/JakeChampion)","Miroslav Bajtoš (https://github.com/bajtos)"],"files":["index.js","type-detect.js"],"main":"./type-detect.js","repository":{"type":"git","url":"git+ssh://git@github.com/chaijs/type-detect.git"},"scripts":{"bench":"node bench","build":"rollup -c rollup.conf.js","commit-msg":"commitlint -x angular","lint":"eslint --ignore-path .gitignore .","prepare":"cross-env NODE_ENV=production npm run build","semantic-release":"semantic-release pre && npm publish && semantic-release post","pretest:node":"cross-env NODE_ENV=test npm run build","pretest:browser":"cross-env NODE_ENV=test npm run build","test":"npm run test:node && npm run test:browser","test:browser":"karma start --singleRun=true","test:node":"nyc mocha type-detect.test.js","posttest:node":"nyc report --report-dir \"coverage/node-$(node --version)\" --reporter=lcovonly && npm run upload-coverage","posttest:browser":"npm run upload-coverage","upload-coverage":"codecov"},"eslintConfig":{"env":{"es6":true},"extends":["strict/es6"],"globals":{"HTMLElement":false},"rules":{"complexity":0,"max-statements":0,"prefer-rest-params":0}},"devDependencies":{"@commitlint/cli":"^4.2.2","benchmark":"^2.1.0","buble":"^0.16.0","codecov":"^3.0.0","commitlint-config-angular":"^4.2.1","cross-env":"^5.1.1","eslint":"^4.10.0","eslint-config-strict":"^14.0.0","eslint-plugin-filenames":"^1.2.0","husky":"^0.14.3","karma":"^1.7.1","karma-chrome-launcher":"^2.2.0","karma-coverage":"^1.1.1","karma-detect-browsers":"^2.2.5","karma-edge-launcher":"^0.4.2","karma-firefox-launcher":"^1.0.1","karma-ie-launcher":"^1.0.0","karma-mocha":"^1.3.0","karma-opera-launcher":"^1.0.0","karma-safari-launcher":"^1.0.0","karma-safaritechpreview-launcher":"0.0.6","karma-sauce-launcher":"^1.2.0","mocha":"^4.0.1","nyc":"^11.3.0","rollup":"^0.50.0","rollup-plugin-buble":"^0.16.0","rollup-plugin-commonjs":"^8.2.6","rollup-plugin-istanbul":"^1.1.0","rollup-plugin-node-resolve":"^3.0.0","semantic-release":"^8.2.0","simple-assert":"^1.0.0"},"engines":{"node":">=4"},"version":"4.0.8"}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\type-fest\package.json
============================================================
{
	"name": "type-fest",
	"version": "0.21.3",
	"description": "A collection of essential TypeScript types",
	"license": "(MIT OR CC0-1.0)",
	"repository": "sindresorhus/type-fest",
	"funding": "https://github.com/sponsors/sindresorhus",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && tsd && tsc"
	},
	"files": [
		"index.d.ts",
		"base.d.ts",
		"source",
		"ts41"
	],
	"keywords": [
		"typescript",
		"ts",
		"types",
		"utility",
		"util",
		"utilities",
		"omit",
		"merge",
		"json"
	],
	"devDependencies": {
		"@sindresorhus/tsconfig": "~0.7.0",
		"expect-type": "^0.11.0",
		"tsd": "^0.14.0",
		"typescript": "^4.1.3",
		"xo": "^0.36.1"
	},
	"types": "./index.d.ts",
	"typesVersions": {
		">=4.1": {
			"*": [
				"ts41/*"
			]
		}
	},
	"xo": {
		"rules": {
			"@typescript-eslint/ban-types": "off",
			"@typescript-eslint/indent": "off",
			"node/no-unsupported-features/es-builtins": "off"
		}
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\undici-types\package.json
============================================================
{
  "name": "undici-types",
  "version": "7.16.0",
  "description": "A stand-alone types package for Undici",
  "homepage": "https://undici.nodejs.org",
  "bugs": {
    "url": "https://github.com/nodejs/undici/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nodejs/undici.git"
  },
  "license": "MIT",
  "types": "index.d.ts",
  "files": [
    "*.d.ts"
  ],
  "contributors": [
    {
      "name": "Daniele Belardi",
      "url": "https://github.com/dnlup",
      "author": true
    },
    {
      "name": "Ethan Arrowood",
      "url": "https://github.com/ethan-arrowood",
      "author": true
    },
    {
      "name": "Matteo Collina",
      "url": "https://github.com/mcollina",
      "author": true
    },
    {
      "name": "Matthew Aitken",
      "url": "https://github.com/KhafraDev",
      "author": true
    },
    {
      "name": "Robert Nagy",
      "url": "https://github.com/ronag",
      "author": true
    },
    {
      "name": "Szymon Marczak",
      "url": "https://github.com/szmarczak",
      "author": true
    },
    {
      "name": "Tomas Della Vedova",
      "url": "https://github.com/delvedor",
      "author": true
    }
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\unicode-canonical-property-names-ecmascript\package.json
============================================================
{
  "name": "unicode-canonical-property-names-ecmascript",
  "version": "2.0.1",
  "description": "The set of canonical Unicode property names supported in ECMAScript RegExp property escapes.",
  "homepage": "https://github.com/mathiasbynens/unicode-canonical-property-names-ecmascript",
  "main": "index.js",
  "engines": {
    "node": ">=4"
  },
  "files": [
    "LICENSE-MIT.txt",
    "index.js"
  ],
  "keywords": [
    "unicode",
    "unicode properties"
  ],
  "license": "MIT",
  "author": {
    "name": "Mathias Bynens",
    "url": "https://mathiasbynens.be/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mathiasbynens/unicode-canonical-property-names-ecmascript.git"
  },
  "bugs": "https://github.com/mathiasbynens/unicode-canonical-property-names-ecmascript/issues",
  "devDependencies": {
    "ava": "*"
  },
  "scripts": {
    "test": "ava tests/tests.js"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\unicode-match-property-ecmascript\package.json
============================================================
{
  "name": "unicode-match-property-ecmascript",
  "version": "2.0.0",
  "description": "Match a Unicode property or property alias to its canonical property name per the algorithm used for RegExp Unicode property escapes in ECMAScript.",
  "homepage": "https://github.com/mathiasbynens/unicode-match-property-ecmascript",
  "main": "index.js",
  "engines": {
    "node": ">=4"
  },
  "files": [
    "LICENSE-MIT.txt",
    "index.js"
  ],
  "keywords": [
    "unicode",
    "unicode properties",
    "unicode property aliases"
  ],
  "license": "MIT",
  "author": {
    "name": "Mathias Bynens",
    "url": "https://mathiasbynens.be/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mathiasbynens/unicode-match-property-ecmascript.git"
  },
  "bugs": "https://github.com/mathiasbynens/unicode-match-property-ecmascript/issues",
  "dependencies": {
    "unicode-canonical-property-names-ecmascript": "^2.0.0",
    "unicode-property-aliases-ecmascript": "^2.0.0"
  },
  "devDependencies": {
    "ava": "*"
  },
  "scripts": {
    "test": "ava ./tests/*"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\unicode-match-property-value-ecmascript\package.json
============================================================
{
  "name": "unicode-match-property-value-ecmascript",
  "version": "2.2.1",
  "description": "Match a Unicode property or property alias to its canonical property name per the algorithm used for RegExp Unicode property escapes in ECMAScript.",
  "homepage": "https://github.com/mathiasbynens/unicode-match-property-value-ecmascript",
  "main": "index.js",
  "engines": {
    "node": ">=4"
  },
  "files": [
    "LICENSE-MIT.txt",
    "data/mappings.js",
    "index.js"
  ],
  "keywords": [
    "unicode",
    "unicode property values",
    "unicode property value aliases"
  ],
  "license": "MIT",
  "author": {
    "name": "Mathias Bynens",
    "url": "https://mathiasbynens.be/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mathiasbynens/unicode-match-property-value-ecmascript.git"
  },
  "bugs": "https://github.com/mathiasbynens/unicode-match-property-value-ecmascript/issues",
  "devDependencies": {
    "ava": "*",
    "jsesc": "^3.1.0",
    "unicode-property-value-aliases-ecmascript": "^2.2.1"
  },
  "scripts": {
    "build": "node scripts/build.js",
    "test": "ava tests/tests.js"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\unicode-property-aliases-ecmascript\package.json
============================================================
{
  "name": "unicode-property-aliases-ecmascript",
  "version": "2.2.0",
  "description": "Unicode property alias mappings in JavaScript format for property names that are supported in ECMAScript RegExp property escapes.",
  "homepage": "https://github.com/mathiasbynens/unicode-property-aliases-ecmascript",
  "main": "index.js",
  "engines": {
    "node": ">=4"
  },
  "files": [
    "LICENSE-MIT.txt",
    "index.js"
  ],
  "keywords": [
    "unicode",
    "unicode-data",
    "alias",
    "aliases",
    "property alias"
  ],
  "license": "MIT",
  "author": {
    "name": "Mathias Bynens",
    "url": "https://mathiasbynens.be/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mathiasbynens/unicode-property-aliases-ecmascript.git"
  },
  "bugs": "https://github.com/mathiasbynens/unicode-property-aliases-ecmascript/issues",
  "devDependencies": {
    "jsesc": "^3.0.2",
    "unicode-canonical-property-names-ecmascript": "^2.0.0"
  },
  "scripts": {
    "download": "curl -L https://unicode.org/Public/17.0.0/ucd/PropertyAliases.txt > data/PropertyAliases.txt",
    "build": "node scripts/build.js",
    "test": "node --test tests/tests.js"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\unrs-resolver\package.json
============================================================
{
  "name": "unrs-resolver",
  "version": "1.11.1",
  "type": "commonjs",
  "description": "UnRS Resolver Node API with PNP support",
  "repository": "git+https://github.com/unrs/unrs-resolver.git",
  "homepage": "https://github.com/unrs/unrs-resolver#readme",
  "author": "JounQin <admin@1stg.me> (https://www.1stG.me)",
  "funding": "https://opencollective.com/unrs-resolver",
  "license": "MIT",
  "main": "index.js",
  "browser": "browser.js",
  "files": [
    "browser.js",
    "index.d.ts",
    "index.js"
  ],
  "scripts": {
    "postinstall": "napi-postinstall unrs-resolver 1.11.1 check"
  },
  "dependencies": {
    "napi-postinstall": "^0.3.0"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org",
    "access": "public"
  },
  "napi": {
    "binaryName": "resolver",
    "packageName": "@unrs/resolver-binding",
    "wasm": {
      "browser": {
        "fs": true
      }
    },
    "targets": [
      "x86_64-pc-windows-msvc",
      "aarch64-pc-windows-msvc",
      "i686-pc-windows-msvc",
      "x86_64-unknown-linux-gnu",
      "x86_64-unknown-linux-musl",
      "x86_64-unknown-freebsd",
      "aarch64-linux-android",
      "aarch64-unknown-linux-gnu",
      "aarch64-unknown-linux-musl",
      "armv7-linux-androideabi",
      "armv7-unknown-linux-gnueabihf",
      "armv7-unknown-linux-musleabihf",
      "powerpc64le-unknown-linux-gnu",
      "riscv64gc-unknown-linux-gnu",
      "riscv64gc-unknown-linux-musl",
      "s390x-unknown-linux-gnu",
      "x86_64-apple-darwin",
      "aarch64-apple-darwin",
      "wasm32-wasip1-threads"
    ]
  },
  "optionalDependencies": {
    "@unrs/resolver-binding-win32-x64-msvc": "1.11.1",
    "@unrs/resolver-binding-win32-arm64-msvc": "1.11.1",
    "@unrs/resolver-binding-win32-ia32-msvc": "1.11.1",
    "@unrs/resolver-binding-linux-x64-gnu": "1.11.1",
    "@unrs/resolver-binding-linux-x64-musl": "1.11.1",
    "@unrs/resolver-binding-freebsd-x64": "1.11.1",
    "@unrs/resolver-binding-android-arm64": "1.11.1",
    "@unrs/resolver-binding-linux-arm64-gnu": "1.11.1",
    "@unrs/resolver-binding-linux-arm64-musl": "1.11.1",
    "@unrs/resolver-binding-android-arm-eabi": "1.11.1",
    "@unrs/resolver-binding-linux-arm-gnueabihf": "1.11.1",
    "@unrs/resolver-binding-linux-arm-musleabihf": "1.11.1",
    "@unrs/resolver-binding-linux-ppc64-gnu": "1.11.1",
    "@unrs/resolver-binding-linux-riscv64-gnu": "1.11.1",
    "@unrs/resolver-binding-linux-riscv64-musl": "1.11.1",
    "@unrs/resolver-binding-linux-s390x-gnu": "1.11.1",
    "@unrs/resolver-binding-darwin-x64": "1.11.1",
    "@unrs/resolver-binding-darwin-arm64": "1.11.1",
    "@unrs/resolver-binding-wasm32-wasi": "1.11.1"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\update-browserslist-db\package.json
============================================================
{
  "name": "update-browserslist-db",
  "version": "1.1.3",
  "description": "CLI tool to update caniuse-lite to refresh target browsers from Browserslist config",
  "keywords": [
    "caniuse",
    "browsers",
    "target"
  ],
  "funding": [
    {
      "type": "opencollective",
      "url": "https://opencollective.com/browserslist"
    },
    {
      "type": "tidelift",
      "url": "https://tidelift.com/funding/github/npm/browserslist"
    },
    {
      "type": "github",
      "url": "https://github.com/sponsors/ai"
    }
  ],
  "author": "Andrey Sitnik <andrey@sitnik.ru>",
  "license": "MIT",
  "repository": "browserslist/update-db",
  "types": "./index.d.ts",
  "exports": {
    ".": "./index.js",
    "./package.json": "./package.json"
  },
  "dependencies": {
    "escalade": "^3.2.0",
    "picocolors": "^1.1.1"
  },
  "peerDependencies": {
    "browserslist": ">= 4.21.0"
  },
  "bin": "cli.js"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\v8-to-istanbul\package.json
============================================================
{
  "name": "v8-to-istanbul",
  "version": "9.3.0",
  "description": "convert from v8 coverage format to istanbul's format",
  "main": "index.js",
  "types": "index.d.ts",
  "scripts": {
    "fix": "standard --fix",
    "snapshot": "TAP_SNAPSHOT=1 tap test/*.js",
    "test": "c8 --reporter=html --reporter=text tap --no-coverage test/*.js",
    "posttest": "standard",
    "coverage": "c8 report --check-coverage"
  },
  "repository": "istanbuljs/v8-to-istanbul",
  "keywords": [
    "istanbul",
    "v8",
    "coverage"
  ],
  "standard": {
    "ignore": [
      "**/test/fixtures"
    ]
  },
  "author": "Ben Coe <ben@npmjs.com>",
  "license": "ISC",
  "dependencies": {
    "@jridgewell/trace-mapping": "^0.3.12",
    "@types/istanbul-lib-coverage": "^2.0.1",
    "convert-source-map": "^2.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "c8": "^7.2.1",
    "semver": "^7.3.2",
    "should": "13.2.3",
    "source-map": "^0.7.3",
    "standard": "^17.0.0",
    "tap": "^16.0.0"
  },
  "engines": {
    "node": ">=10.12.0"
  },
  "files": [
    "lib/*.js",
    "index.js",
    "index.d.ts"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\vite\types\package.json
============================================================
{
  "//": "this file is here to make typescript happy when moduleResolution=node16+",
  "version": "0.0.0"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\vite\package.json
============================================================
{
  "name": "vite",
  "version": "4.5.14",
  "type": "module",
  "license": "MIT",
  "author": "Evan You",
  "description": "Native-ESM powered web dev build tool",
  "bin": {
    "vite": "bin/vite.js"
  },
  "keywords": [
    "frontend",
    "framework",
    "hmr",
    "dev-server",
    "build-tool",
    "vite"
  ],
  "main": "./dist/node/index.js",
  "types": "./dist/node/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/node/index.d.ts",
      "import": "./dist/node/index.js",
      "require": "./index.cjs"
    },
    "./client": {
      "types": "./client.d.ts"
    },
    "./dist/client/*": "./dist/client/*",
    "./types/*": {
      "types": "./types/*"
    },
    "./package.json": "./package.json"
  },
  "files": [
    "bin",
    "dist",
    "client.d.ts",
    "index.cjs",
    "types"
  ],
  "engines": {
    "node": "^14.18.0 || >=16.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitejs/vite.git",
    "directory": "packages/vite"
  },
  "bugs": {
    "url": "https://github.com/vitejs/vite/issues"
  },
  "homepage": "https://github.com/vitejs/vite/tree/main/#readme",
  "funding": "https://github.com/vitejs/vite?sponsor=1",
  "scripts": {
    "dev": "rimraf dist && pnpm run build-bundle -w",
    "build": "rimraf dist && run-s build-bundle build-types",
    "build-bundle": "rollup --config rollup.config.ts --configPlugin typescript",
    "build-types": "run-s build-types-temp build-types-pre-patch build-types-roll build-types-post-patch build-types-check",
    "build-types-temp": "tsc --emitDeclarationOnly --outDir temp/node -p src/node",
    "build-types-pre-patch": "tsx scripts/prePatchTypes.ts",
    "build-types-roll": "tsx scripts/api-extractor.ts run && rimraf temp",
    "build-types-post-patch": "tsx scripts/postPatchTypes.ts",
    "build-types-check": "tsx scripts/checkBuiltTypes.ts && tsc --project tsconfig.check.json",
    "typecheck": "tsc --noEmit",
    "lint": "eslint --cache --ext .ts src/**",
    "format": "prettier --write --cache --parser typescript \"src/**/*.ts\"",
    "prepublishOnly": "npm run build"
  },
  "//": "READ CONTRIBUTING.md to understand what to put under deps vs. devDeps!",
  "dependencies": {
    "esbuild": "^0.18.10",
    "postcss": "^8.4.27",
    "rollup": "^3.27.1"
  },
  "optionalDependencies": {
    "fsevents": "~2.3.2"
  },
  "devDependencies": {
    "@ampproject/remapping": "^2.2.1",
    "@babel/parser": "^7.22.7",
    "@babel/types": "^7.22.5",
    "@jridgewell/trace-mapping": "^0.3.18",
    "@rollup/plugin-alias": "^4.0.4",
    "@rollup/plugin-commonjs": "^25.0.3",
    "@rollup/plugin-dynamic-import-vars": "^2.0.4",
    "@rollup/plugin-json": "^6.0.0",
    "@rollup/plugin-node-resolve": "15.1.0",
    "@rollup/plugin-typescript": "^11.1.2",
    "@rollup/pluginutils": "^5.0.2",
    "@types/escape-html": "^1.0.2",
    "@types/pnpapi": "^0.0.2",
    "acorn": "^8.10.0",
    "acorn-walk": "^8.2.0",
    "cac": "^6.7.14",
    "chokidar": "^3.5.3",
    "connect": "^3.7.0",
    "connect-history-api-fallback": "^2.0.0",
    "convert-source-map": "^2.0.0",
    "cors": "^2.8.5",
    "cross-spawn": "^7.0.3",
    "debug": "^4.3.4",
    "dep-types": "link:./src/types",
    "dotenv": "^16.3.1",
    "dotenv-expand": "^9.0.0",
    "es-module-lexer": "^1.3.0",
    "escape-html": "^1.0.3",
    "estree-walker": "^3.0.3",
    "etag": "^1.8.1",
    "fast-glob": "^3.3.1",
    "http-proxy": "^1.18.1",
    "json-stable-stringify": "^1.0.2",
    "launch-editor-middleware": "^2.6.0",
    "lightningcss": "^1.21.5",
    "magic-string": "^0.30.2",
    "micromatch": "^4.0.5",
    "mlly": "^1.4.0",
    "mrmime": "^1.0.1",
    "okie": "^1.0.1",
    "open": "^8.4.2",
    "parse5": "^7.1.2",
    "periscopic": "^3.1.0",
    "picocolors": "^1.0.0",
    "picomatch": "^2.3.1",
    "postcss-import": "^15.1.0",
    "postcss-load-config": "^4.0.1",
    "postcss-modules": "^6.0.0",
    "resolve.exports": "^2.0.2",
    "rollup-plugin-license": "^3.0.1",
    "sirv": "^2.0.3",
    "source-map-support": "^0.5.21",
    "strip-ansi": "^7.1.0",
    "strip-literal": "^1.3.0",
    "tsconfck": "^2.1.2",
    "tslib": "^2.6.1",
    "types": "link:./types",
    "ufo": "^1.2.0",
    "ws": "^8.13.0"
  },
  "peerDependencies": {
    "@types/node": ">= 14",
    "less": "*",
    "lightningcss": "^1.21.0",
    "sass": "*",
    "stylus": "*",
    "sugarss": "*",
    "terser": "^5.4.0"
  },
  "peerDependenciesMeta": {
    "@types/node": {
      "optional": true
    },
    "sass": {
      "optional": true
    },
    "stylus": {
      "optional": true
    },
    "less": {
      "optional": true
    },
    "sugarss": {
      "optional": true
    },
    "lightningcss": {
      "optional": true
    },
    "terser": {
      "optional": true
    }
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\vitest\dist\config.js
============================================================
export { c as configDefaults, a as coverageConfigDefaults, d as defaultExclude, b as defaultInclude } from './chunks/defaults.BOqNVLsY.js';
export { mergeConfig } from 'vite';
export { d as defaultBrowserPort } from './chunks/constants.D_Q9UYh-.js';
import 'node:os';
import './chunks/env.D4Lgay0q.js';
import 'std-env';

function defineConfig(config) {
	return config;
}
function defineProject(config) {
	return config;
}

export { defineConfig, defineProject };

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\vitest\node_modules\@esbuild\win32-x64\package.json
============================================================
{
  "name": "@esbuild/win32-x64",
  "version": "0.25.11",
  "description": "The Windows 64-bit binary for esbuild, a JavaScript bundler.",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/evanw/esbuild.git"
  },
  "license": "MIT",
  "preferUnplugged": true,
  "engines": {
    "node": ">=18"
  },
  "os": [
    "win32"
  ],
  "cpu": [
    "x64"
  ]
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\vitest\node_modules\@vitest\mocker\package.json
============================================================
{
  "name": "@vitest/mocker",
  "type": "module",
  "version": "4.0.1",
  "description": "Vitest module mocker implementation",
  "license": "MIT",
  "funding": "https://opencollective.com/vitest",
  "homepage": "https://github.com/vitest-dev/vitest/tree/main/packages/mocker#readme",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitest-dev/vitest.git",
    "directory": "packages/mocker"
  },
  "bugs": {
    "url": "https://github.com/vitest-dev/vitest/issues"
  },
  "sideEffects": false,
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    },
    "./node": {
      "types": "./dist/node.d.ts",
      "default": "./dist/node.js"
    },
    "./browser": {
      "types": "./dist/browser.d.ts",
      "default": "./dist/browser.js"
    },
    "./redirect": {
      "types": "./dist/redirect.d.ts",
      "default": "./dist/redirect.js"
    },
    "./automock": {
      "types": "./dist/automock.d.ts",
      "default": "./dist/automock.js"
    },
    "./register": {
      "types": "./dist/register.d.ts",
      "default": "./dist/register.js"
    },
    "./auto-register": {
      "types": "./dist/register.d.ts",
      "default": "./dist/register.js"
    },
    "./*": "./*"
  },
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": [
    "*.d.ts",
    "dist"
  ],
  "peerDependencies": {
    "msw": "^2.4.9",
    "vite": "^6.0.0 || ^7.0.0-0"
  },
  "peerDependenciesMeta": {
    "msw": {
      "optional": true
    },
    "vite": {
      "optional": true
    }
  },
  "dependencies": {
    "estree-walker": "^3.0.3",
    "magic-string": "^0.30.19",
    "@vitest/spy": "4.0.1"
  },
  "devDependencies": {
    "@types/estree": "^1.0.8",
    "acorn-walk": "^8.3.4",
    "msw": "^2.11.3",
    "pathe": "^2.0.3",
    "vite": "^6.3.5",
    "@vitest/utils": "4.0.1",
    "@vitest/spy": "4.0.1"
  },
  "scripts": {
    "build": "premove dist && rollup -c",
    "dev": "rollup -c --watch"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\vitest\node_modules\esbuild\package.json
============================================================
{
  "name": "esbuild",
  "version": "0.25.11",
  "description": "An extremely fast JavaScript and CSS bundler and minifier.",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/evanw/esbuild.git"
  },
  "scripts": {
    "postinstall": "node install.js"
  },
  "main": "lib/main.js",
  "types": "lib/main.d.ts",
  "engines": {
    "node": ">=18"
  },
  "bin": {
    "esbuild": "bin/esbuild"
  },
  "optionalDependencies": {
    "@esbuild/aix-ppc64": "0.25.11",
    "@esbuild/android-arm": "0.25.11",
    "@esbuild/android-arm64": "0.25.11",
    "@esbuild/android-x64": "0.25.11",
    "@esbuild/darwin-arm64": "0.25.11",
    "@esbuild/darwin-x64": "0.25.11",
    "@esbuild/freebsd-arm64": "0.25.11",
    "@esbuild/freebsd-x64": "0.25.11",
    "@esbuild/linux-arm": "0.25.11",
    "@esbuild/linux-arm64": "0.25.11",
    "@esbuild/linux-ia32": "0.25.11",
    "@esbuild/linux-loong64": "0.25.11",
    "@esbuild/linux-mips64el": "0.25.11",
    "@esbuild/linux-ppc64": "0.25.11",
    "@esbuild/linux-riscv64": "0.25.11",
    "@esbuild/linux-s390x": "0.25.11",
    "@esbuild/linux-x64": "0.25.11",
    "@esbuild/netbsd-arm64": "0.25.11",
    "@esbuild/netbsd-x64": "0.25.11",
    "@esbuild/openbsd-arm64": "0.25.11",
    "@esbuild/openbsd-x64": "0.25.11",
    "@esbuild/openharmony-arm64": "0.25.11",
    "@esbuild/sunos-x64": "0.25.11",
    "@esbuild/win32-arm64": "0.25.11",
    "@esbuild/win32-ia32": "0.25.11",
    "@esbuild/win32-x64": "0.25.11"
  },
  "license": "MIT"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\vitest\node_modules\fdir\package.json
============================================================
{
  "name": "fdir",
  "version": "6.5.0",
  "description": "The fastest directory crawler & globbing alternative to glob, fast-glob, & tiny-glob. Crawls 1m files in < 1s",
  "main": "./dist/index.cjs",
  "types": "./dist/index.d.cts",
  "type": "module",
  "scripts": {
    "prepublishOnly": "npm run test && npm run build",
    "build": "tsdown",
    "format": "prettier --write src __tests__ benchmarks",
    "test": "vitest run __tests__/",
    "test:coverage": "vitest run --coverage __tests__/",
    "test:watch": "vitest __tests__/",
    "bench": "ts-node benchmarks/benchmark.js",
    "bench:glob": "ts-node benchmarks/glob-benchmark.ts",
    "bench:fdir": "ts-node benchmarks/fdir-benchmark.ts",
    "release": "./scripts/release.sh"
  },
  "engines": {
    "node": ">=12.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/thecodrr/fdir.git"
  },
  "keywords": [
    "util",
    "os",
    "sys",
    "fs",
    "walk",
    "crawler",
    "directory",
    "files",
    "io",
    "tiny-glob",
    "glob",
    "fast-glob",
    "speed",
    "javascript",
    "nodejs"
  ],
  "author": "thecodrr <thecodrr@protonmail.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/thecodrr/fdir/issues"
  },
  "homepage": "https://github.com/thecodrr/fdir#readme",
  "devDependencies": {
    "@types/glob": "^8.1.0",
    "@types/mock-fs": "^4.13.4",
    "@types/node": "^20.9.4",
    "@types/picomatch": "^4.0.0",
    "@types/tap": "^15.0.11",
    "@vitest/coverage-v8": "^0.34.6",
    "all-files-in-tree": "^1.1.2",
    "benny": "^3.7.1",
    "csv-to-markdown-table": "^1.3.1",
    "expect": "^29.7.0",
    "fast-glob": "^3.3.2",
    "fdir1": "npm:fdir@1.2.0",
    "fdir2": "npm:fdir@2.1.0",
    "fdir3": "npm:fdir@3.4.2",
    "fdir4": "npm:fdir@4.1.0",
    "fdir5": "npm:fdir@5.0.0",
    "fs-readdir-recursive": "^1.1.0",
    "get-all-files": "^4.1.0",
    "glob": "^10.3.10",
    "klaw-sync": "^6.0.0",
    "mock-fs": "^5.2.0",
    "picomatch": "^4.0.2",
    "prettier": "^3.5.3",
    "recur-readdir": "0.0.1",
    "recursive-files": "^1.0.2",
    "recursive-fs": "^2.1.0",
    "recursive-readdir": "^2.2.3",
    "rrdir": "^12.1.0",
    "systeminformation": "^5.21.17",
    "tiny-glob": "^0.2.9",
    "ts-node": "^10.9.1",
    "tsdown": "^0.12.5",
    "typescript": "^5.3.2",
    "vitest": "^0.34.6",
    "walk-sync": "^3.0.0"
  },
  "peerDependencies": {
    "picomatch": "^3 || ^4"
  },
  "peerDependenciesMeta": {
    "picomatch": {
      "optional": true
    }
  },
  "module": "./dist/index.mjs",
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    },
    "./package.json": "./package.json"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\vitest\node_modules\magic-string\package.json
============================================================
{
	"name": "magic-string",
	"version": "0.30.19",
	"type": "commonjs",
	"packageManager": "pnpm@10.15.1",
	"description": "Modify strings, generate sourcemaps",
	"keywords": [
		"string",
		"string manipulation",
		"sourcemap",
		"templating",
		"transpilation"
	],
	"repository": {
		"type": "git",
		"url": "https://github.com/rich-harris/magic-string.git"
	},
	"license": "MIT",
	"author": "Rich Harris",
	"main": "./dist/magic-string.cjs.js",
	"module": "./dist/magic-string.es.mjs",
	"sideEffects": false,
	"jsnext:main": "./dist/magic-string.es.mjs",
	"types": "./dist/magic-string.cjs.d.ts",
	"exports": {
		"./package.json": "./package.json",
		".": {
			"import": "./dist/magic-string.es.mjs",
			"require": "./dist/magic-string.cjs.js"
		}
	},
	"files": [
		"dist/*",
		"index.d.ts",
		"README.md"
	],
	"scripts": {
		"build": "rollup -c",
		"changelog": "conventional-changelog -p angular -i CHANGELOG.md -s",
		"format": "prettier --single-quote --print-width 100 --use-tabs --write .",
		"lint": "eslint src test && publint",
		"lint:fix": "eslint src test --fix",
		"prepare": "npm run build",
		"prepublishOnly": "npm run lint && rm -rf dist && npm test",
		"release": "bumpp -x \"npm run changelog\" --all --commit --tag --push && npm publish",
		"pretest": "npm run build",
		"test": "vitest run",
		"test:dev": "vitest",
		"bench": "npm run build && node benchmark/index.mjs",
		"watch": "rollup -cw"
	},
	"devDependencies": {
		"@eslint/js": "^9.35.0",
		"@rollup/plugin-node-resolve": "^16.0.1",
		"@rollup/plugin-replace": "^6.0.2",
		"benchmark": "^2.1.4",
		"bumpp": "^10.2.3",
		"conventional-changelog-cli": "^5.0.0",
		"eslint": "^9.35.0",
		"prettier": "^3.6.2",
		"publint": "^0.3.12",
		"rollup": "^4.50.1",
		"source-map-js": "^1.2.1",
		"source-map-support": "^0.5.21",
		"vitest": "^3.2.4"
	},
	"dependencies": {
		"@jridgewell/sourcemap-codec": "^1.5.5"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\vitest\node_modules\picomatch\package.json
============================================================
{
  "name": "picomatch",
  "description": "Blazing fast and accurate glob matcher written in JavaScript, with no dependencies and full support for standard and extended Bash glob features, including braces, extglobs, POSIX brackets, and regular expressions.",
  "version": "4.0.3",
  "homepage": "https://github.com/micromatch/picomatch",
  "author": "Jon Schlinkert (https://github.com/jonschlinkert)",
  "funding": "https://github.com/sponsors/jonschlinkert",
  "repository": "micromatch/picomatch",
  "bugs": {
    "url": "https://github.com/micromatch/picomatch/issues"
  },
  "license": "MIT",
  "files": [
    "index.js",
    "posix.js",
    "lib"
  ],
  "sideEffects": false,
  "main": "index.js",
  "engines": {
    "node": ">=12"
  },
  "scripts": {
    "lint": "eslint --cache --cache-location node_modules/.cache/.eslintcache --report-unused-disable-directives --ignore-path .gitignore .",
    "mocha": "mocha --reporter dot",
    "test": "npm run lint && npm run mocha",
    "test:ci": "npm run test:cover",
    "test:cover": "nyc npm run mocha"
  },
  "devDependencies": {
    "eslint": "^8.57.0",
    "fill-range": "^7.0.1",
    "gulp-format-md": "^2.0.0",
    "mocha": "^10.4.0",
    "nyc": "^15.1.0",
    "time-require": "github:jonschlinkert/time-require"
  },
  "keywords": [
    "glob",
    "match",
    "picomatch"
  ],
  "nyc": {
    "reporter": [
      "html",
      "lcov",
      "text-summary"
    ]
  },
  "verb": {
    "toc": {
      "render": true,
      "method": "preWrite",
      "maxdepth": 3
    },
    "layout": "empty",
    "tasks": [
      "readme"
    ],
    "plugins": [
      "gulp-format-md"
    ],
    "lint": {
      "reflinks": true
    },
    "related": {
      "list": [
        "braces",
        "micromatch"
      ]
    },
    "reflinks": [
      "braces",
      "expand-brackets",
      "extglob",
      "fill-range",
      "micromatch",
      "minimatch",
      "nanomatch",
      "picomatch"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\vitest\node_modules\rollup\dist\es\package.json
============================================================
{"type":"module"}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\vitest\node_modules\rollup\package.json
============================================================
{
  "name": "rollup",
  "version": "4.52.5",
  "description": "Next-generation ES module bundler",
  "main": "dist/rollup.js",
  "module": "dist/es/rollup.js",
  "types": "dist/rollup.d.ts",
  "bin": {
    "rollup": "dist/bin/rollup"
  },
  "napi": {
    "binaryName": "rollup",
    "packageName": "@rollup/rollup",
    "targets": [
      "aarch64-apple-darwin",
      "aarch64-linux-android",
      "aarch64-pc-windows-msvc",
      "aarch64-unknown-freebsd",
      "aarch64-unknown-linux-gnu",
      "aarch64-unknown-linux-musl",
      "armv7-linux-androideabi",
      "armv7-unknown-linux-gnueabihf",
      "armv7-unknown-linux-musleabihf",
      "i686-pc-windows-msvc",
      "loongarch64-unknown-linux-gnu",
      "riscv64gc-unknown-linux-gnu",
      "riscv64gc-unknown-linux-musl",
      "powerpc64le-unknown-linux-gnu",
      "s390x-unknown-linux-gnu",
      "x86_64-apple-darwin",
      "x86_64-pc-windows-gnu",
      "x86_64-pc-windows-msvc",
      "x86_64-unknown-freebsd",
      "x86_64-unknown-linux-gnu",
      "x86_64-unknown-linux-musl",
      "aarch64-unknown-linux-ohos"
    ]
  },
  "scripts": {
    "build": "concurrently -c green,blue \"npm run build:wasm\" \"npm:build:ast-converters\" && concurrently -c green,blue \"npm run build:napi -- --release\" \"npm:build:js\" && npm run build:copy-native",
    "build:quick": "concurrently -c green,blue 'npm:build:napi' 'npm:build:cjs' && npm run build:copy-native",
    "build:napi": "napi build --cwd rust/bindings_napi --platform --dts ../../native.d.ts --no-js --output-dir ../.. --package-json-path ../../package.json",
    "build:wasm": "wasm-pack build rust/bindings_wasm --out-dir ../../wasm --target web --no-pack && shx rm wasm/.gitignore",
    "build:wasm:node": "wasm-pack build rust/bindings_wasm --out-dir ../../wasm-node --target nodejs --no-pack && shx rm wasm-node/.gitignore",
    "update:napi": "npm run build:napi && npm run build:copy-native",
    "build:js": "rollup --config rollup.config.ts --configPlugin typescript --forceExit",
    "build:js:node": "rollup --config rollup.config.ts --configPlugin typescript --configIsBuildNode --forceExit",
    "build:prepare": "concurrently -c green,blue \"npm run build:napi -- --release\" \"npm:build:js:node\" && npm run build:copy-native",
    "update:js": "npm run build:js && npm run build:copy-native",
    "build:copy-native": "shx mkdir -p dist && shx cp rollup.*.node dist/",
    "dev": "concurrently -kc green,blue 'nodemon --watch rust -e rs --exec \"npm run build:wasm\"' 'vitepress dev docs'",
    "build:cjs": "rollup --config rollup.config.ts --configPlugin typescript --configTest --forceExit",
    "build:bootstrap": "shx mv dist dist-build && node dist-build/bin/rollup --config rollup.config.ts --configPlugin typescript --forceExit && shx rm -rf dist-build",
    "build:bootstrap:cjs": "shx mv dist dist-build && node dist-build/bin/rollup --config rollup.config.ts --configPlugin typescript --configTest --forceExit && shx rm -rf dist-build",
    "build:docs": "vitepress build docs",
    "build:ast-converters": "node scripts/generate-ast-converters.js",
    "preview:docs": "vitepress preview docs",
    "ci:artifacts": "napi artifacts",
    "ci:lint": "concurrently -c red,yellow,green,blue 'npm:lint:js:nofix' 'npm:lint:native-js' 'npm:lint:markdown:nofix' 'npm:lint:rust:nofix'",
    "ci:test:only": "npm run build:cjs && npm run build:copy-native && npm run build:bootstrap && npm run build:copy-native && npm run test:only",
    "ci:test:all": "npm run build:cjs && npm run build:copy-native && npm run build:bootstrap && npm run build:copy-native && concurrently --kill-others-on-fail -c green,blue,magenta,cyan 'npm:test:only' 'npm:test:typescript' 'npm:test:leak' 'npm:test:browser'",
    "ci:coverage": "npm run build:cjs && npm run build:copy-native && npm run build:bootstrap && npm run build:copy-native && NODE_OPTIONS=--no-experimental-require-module nyc --reporter lcovonly mocha",
    "lint": "concurrently -c red,yellow,green,blue 'npm:lint:js' 'npm:lint:native-js' 'npm:lint:markdown' 'npm:lint:rust'",
    "lint:js": "eslint . --fix --cache --concurrency auto",
    "lint:js:nofix": "eslint . --cache --concurrency auto",
    "lint:native-js": "node scripts/lint-native-js.js",
    "lint:markdown": "prettier --write \"**/*.md\"",
    "lint:markdown:nofix": "prettier --check \"**/*.md\"",
    "lint:rust": "cd rust && cargo fmt && cargo clippy --fix --allow-dirty",
    "lint:rust:nofix": "cd rust && cargo fmt --check && cargo clippy",
    "perf": "npm run build:bootstrap:cjs && node --expose-gc scripts/perf-report/index.js",
    "prepare": "husky && node scripts/check-release.js || npm run build:prepare",
    "prepublishOnly": "node scripts/check-release.js && node scripts/prepublish.js",
    "postpublish": "node scripts/postpublish.js",
    "prepublish:napi": "napi prepublish --no-gh-release",
    "release": "node scripts/prepare-release.js",
    "release:docs": "git fetch --update-head-ok origin master:master && git branch --force documentation-published master && git push origin documentation-published",
    "test": "npm run build && npm run test:all",
    "test:update-snapshots": "node scripts/update-snapshots.js",
    "test:cjs": "npm run build:cjs && npm run test:only",
    "test:quick": "mocha -b test/test.js",
    "test:all": "concurrently --kill-others-on-fail -c green,blue,magenta,cyan,red 'npm:test:only' 'npm:test:browser' 'npm:test:typescript' 'npm:test:package' 'npm:test:options'",
    "test:coverage": "npm run build:cjs && shx rm -rf coverage/* && nyc --reporter html mocha test/test.js",
    "test:coverage:browser": "npm run build && shx rm -rf coverage/* && nyc mocha test/browser/index.js",
    "test:leak": "npm install --no-save weak-napi && node --expose-gc test/leak/index.js",
    "test:package": "node scripts/test-package.js",
    "test:options": "node scripts/test-options.js",
    "test:only": "mocha test/test.js",
    "test:typescript": "shx rm -rf test/typescript/dist && shx cp -r dist test/typescript/ && tsc --noEmit -p test/typescript && tsc --noEmit && tsc --noEmit -p scripts",
    "test:browser": "mocha test/browser/index.js",
    "watch": "rollup --config rollup.config.ts --configPlugin typescript --watch"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rollup/rollup.git"
  },
  "keywords": [
    "modules",
    "bundler",
    "bundling",
    "es6",
    "optimizer"
  ],
  "author": "Rich Harris",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/rollup/rollup/issues"
  },
  "homepage": "https://rollupjs.org/",
  "optionalDependencies": {
    "fsevents": "~2.3.2",
    "@rollup/rollup-darwin-arm64": "4.52.5",
    "@rollup/rollup-android-arm64": "4.52.5",
    "@rollup/rollup-win32-arm64-msvc": "4.52.5",
    "@rollup/rollup-freebsd-arm64": "4.52.5",
    "@rollup/rollup-linux-arm64-gnu": "4.52.5",
    "@rollup/rollup-linux-arm64-musl": "4.52.5",
    "@rollup/rollup-android-arm-eabi": "4.52.5",
    "@rollup/rollup-linux-arm-gnueabihf": "4.52.5",
    "@rollup/rollup-linux-arm-musleabihf": "4.52.5",
    "@rollup/rollup-win32-ia32-msvc": "4.52.5",
    "@rollup/rollup-linux-loong64-gnu": "4.52.5",
    "@rollup/rollup-linux-riscv64-gnu": "4.52.5",
    "@rollup/rollup-linux-riscv64-musl": "4.52.5",
    "@rollup/rollup-linux-ppc64-gnu": "4.52.5",
    "@rollup/rollup-linux-s390x-gnu": "4.52.5",
    "@rollup/rollup-darwin-x64": "4.52.5",
    "@rollup/rollup-win32-x64-gnu": "4.52.5",
    "@rollup/rollup-win32-x64-msvc": "4.52.5",
    "@rollup/rollup-freebsd-x64": "4.52.5",
    "@rollup/rollup-linux-x64-gnu": "4.52.5",
    "@rollup/rollup-linux-x64-musl": "4.52.5",
    "@rollup/rollup-openharmony-arm64": "4.52.5"
  },
  "dependencies": {
    "@types/estree": "1.0.8"
  },
  "devDependenciesComments": {
    "core-js": "We only update manually as every update requires a snapshot update"
  },
  "devDependencies": {
    "@codemirror/commands": "^6.9.0",
    "@codemirror/lang-javascript": "^6.2.4",
    "@codemirror/language": "^6.11.3",
    "@codemirror/search": "^6.5.11",
    "@codemirror/state": "^6.5.2",
    "@codemirror/view": "^6.38.6",
    "@eslint/js": "^9.37.0",
    "@inquirer/prompts": "^7.9.0",
    "@jridgewell/sourcemap-codec": "^1.5.5",
    "@mermaid-js/mermaid-cli": "^11.4.0",
    "@napi-rs/cli": "^3.3.1",
    "@rollup/plugin-alias": "^5.1.1",
    "@rollup/plugin-buble": "^1.0.3",
    "@rollup/plugin-commonjs": "^28.0.7",
    "@rollup/plugin-json": "^6.1.0",
    "@rollup/plugin-node-resolve": "^16.0.3",
    "@rollup/plugin-replace": "^6.0.2",
    "@rollup/plugin-terser": "^0.4.4",
    "@rollup/plugin-typescript": "^12.1.4",
    "@rollup/pluginutils": "^5.3.0",
    "@shikijs/vitepress-twoslash": "^3.13.0",
    "@types/mocha": "^10.0.10",
    "@types/node": "^20.19.21",
    "@types/picomatch": "^4.0.2",
    "@types/semver": "^7.7.1",
    "@types/yargs-parser": "^21.0.3",
    "@vue/language-server": "^3.1.1",
    "acorn": "^8.15.0",
    "acorn-import-assertions": "^1.9.0",
    "acorn-jsx": "^5.3.2",
    "buble": "^0.20.0",
    "builtin-modules": "^5.0.0",
    "chokidar": "^3.6.0",
    "concurrently": "^9.2.1",
    "core-js": "3.38.1",
    "cross-env": "^10.1.0",
    "date-time": "^4.0.0",
    "es5-shim": "^4.6.7",
    "es6-shim": "^0.35.8",
    "eslint": "^9.37.0",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-prettier": "^5.5.4",
    "eslint-plugin-unicorn": "^61.0.2",
    "eslint-plugin-vue": "^10.5.0",
    "fixturify": "^3.0.0",
    "flru": "^1.0.2",
    "fs-extra": "^11.3.2",
    "github-api": "^3.4.0",
    "globals": "^16.4.0",
    "husky": "^9.1.7",
    "is-reference": "^3.0.3",
    "lint-staged": "^16.2.4",
    "locate-character": "^3.0.0",
    "magic-string": "^0.30.19",
    "memfs": "^4.49.0",
    "mocha": "^11.7.4",
    "nodemon": "^3.1.10",
    "nyc": "^17.1.0",
    "picocolors": "^1.1.1",
    "picomatch": "^4.0.3",
    "pinia": "^3.0.3",
    "prettier": "^3.6.2",
    "prettier-plugin-organize-imports": "^4.3.0",
    "pretty-bytes": "^7.1.0",
    "pretty-ms": "^9.3.0",
    "requirejs": "^2.3.7",
    "rollup": "^4.52.4",
    "rollup-plugin-license": "^3.6.0",
    "rollup-plugin-string": "^3.0.0",
    "semver": "^7.7.3",
    "shx": "^0.4.0",
    "signal-exit": "^4.1.0",
    "source-map": "^0.7.6",
    "source-map-support": "^0.5.21",
    "systemjs": "^6.15.1",
    "terser": "^5.44.0",
    "tslib": "^2.8.1",
    "typescript": "^5.9.3",
    "typescript-eslint": "^8.46.1",
    "vite": "^7.1.10",
    "vitepress": "^1.6.4",
    "vue": "^3.5.22",
    "vue-eslint-parser": "^10.2.0",
    "vue-tsc": "^2.2.12",
    "wasm-pack": "^0.13.1",
    "yargs-parser": "^21.1.1"
  },
  "overrides": {
    "axios": "^1.12.2",
    "semver": "^7.7.3",
    "readable-stream": "npm:@built-in/readable-stream@1",
    "esbuild": ">0.24.2"
  },
  "comments": {
    "vue-tsc": "This is necessary so that prettier-plugin-organize-imports works correctly in Vue templatges"
  },
  "files": [
    "dist/*.node",
    "dist/**/*.js",
    "dist/*.d.ts",
    "dist/bin/rollup",
    "dist/es/package.json"
  ],
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=8.0.0"
  },
  "exports": {
    ".": {
      "types": "./dist/rollup.d.ts",
      "import": "./dist/es/rollup.js",
      "require": "./dist/rollup.js"
    },
    "./loadConfigFile": {
      "types": "./dist/loadConfigFile.d.ts",
      "require": "./dist/loadConfigFile.js",
      "default": "./dist/loadConfigFile.js"
    },
    "./getLogFilter": {
      "types": "./dist/getLogFilter.d.ts",
      "import": "./dist/es/getLogFilter.js",
      "require": "./dist/getLogFilter.js"
    },
    "./parseAst": {
      "types": "./dist/parseAst.d.ts",
      "import": "./dist/es/parseAst.js",
      "require": "./dist/parseAst.js"
    },
    "./dist/*": "./dist/*",
    "./package.json": "./package.json"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\vitest\node_modules\vite\dist\node\chunks\config.js
============================================================
import { __commonJS, __require, __toDynamicImportESM, __toESM } from "./chunk.js";
import { CLIENT_DIR, CLIENT_ENTRY, CLIENT_PUBLIC_PATH, CSS_LANGS_RE, DEFAULT_ASSETS_INLINE_LIMIT, DEFAULT_ASSETS_RE, DEFAULT_CLIENT_CONDITIONS, DEFAULT_CLIENT_MAIN_FIELDS, DEFAULT_CONFIG_FILES, DEFAULT_DEV_PORT, DEFAULT_EXTERNAL_CONDITIONS, DEFAULT_PREVIEW_PORT, DEFAULT_SERVER_CONDITIONS, DEFAULT_SERVER_MAIN_FIELDS, DEP_VERSION_RE, DEV_PROD_CONDITION, ENV_ENTRY, ENV_PUBLIC_PATH, ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR, ERR_OPTIMIZE_DEPS_PROCESSING_ERROR, ESBUILD_BASELINE_WIDELY_AVAILABLE_TARGET, FS_PREFIX, JS_TYPES_RE, KNOWN_ASSET_TYPES, LogLevels, METADATA_FILENAME, OPTIMIZABLE_ENTRY_RE, ROLLUP_HOOKS, SPECIAL_QUERY_RE, VERSION, VITE_PACKAGE_DIR, createLogger, defaultAllowedOrigins, loopbackHosts, printServerUrls, require_picocolors, wildcardHosts } from "./logger.js";
import { builtinModules, createRequire } from "node:module";
import { parseAst, parseAstAsync } from "rollup/parseAst";
import * as fs$1 from "node:fs";
import fs, { existsSync, promises, readFileSync } from "node:fs";
import path, { basename, dirname, extname, isAbsolute, join, normalize, posix, relative, resolve, sep } from "node:path";
import fsp, { constants } from "node:fs/promises";
import { URL as URL$1, fileURLToPath, pathToFileURL } from "node:url";
import { format, inspect, promisify, stripVTControlCharacters } from "node:util";
import { performance as performance$1 } from "node:perf_hooks";
import crypto from "node:crypto";
import picomatch from "picomatch";
import esbuild, { build, formatMessages, transform } from "esbuild";
import os from "node:os";
import net from "node:net";
import childProcess, { exec, execFile, execSync } from "node:child_process";
import { promises as promises$1 } from "node:dns";
import path$1, { basename as basename$1, dirname as dirname$1, extname as extname$1, isAbsolute as isAbsolute$1, join as join$1, posix as posix$1, relative as relative$1, resolve as resolve$1, sep as sep$1, win32 } from "path";
import { existsSync as existsSync$1, readFileSync as readFileSync$1, readdirSync, statSync } from "fs";
import { fdir } from "fdir";
import { gzip } from "node:zlib";
import readline from "node:readline";
import { createRequire as createRequire$1 } from "module";
import { MessageChannel, Worker } from "node:worker_threads";
import { Buffer as Buffer$1 } from "node:buffer";
import { escapePath, glob, globSync, isDynamicPattern } from "tinyglobby";
import assert from "node:assert";
import process$1 from "node:process";
import v8 from "node:v8";
import { EventEmitter } from "node:events";
import { STATUS_CODES, createServer, get } from "node:http";
import { createServer as createServer$1, get as get$1 } from "node:https";
import { ESModulesEvaluator, ModuleRunner, createNodeImportMeta } from "vite/module-runner";
import zlib from "zlib";
import * as qs from "node:querystring";

//#region src/shared/constants.ts
/**
* Prefix for resolved Ids that are not valid browser import specifiers
*/
const VALID_ID_PREFIX = `/@id/`;
/**
* Plugins that use 'virtual modules' (e.g. for helper functions), prefix the
* module ID with `\0`, a convention from the rollup ecosystem.
* This prevents other plugins from trying to process the id (like node resolution),
* and core features like sourcemaps can use this info to differentiate between
* virtual modules and regular files.
* `\0` is not a permitted char in import URLs so we have to replace them during
* import analysis. The id will be decoded back before entering the plugins pipeline.
* These encoded virtual ids are also prefixed by the VALID_ID_PREFIX, so virtual
* modules in the browser end up encoded as `/@id/__x00__{id}`
*/
const NULL_BYTE_PLACEHOLDER = `__x00__`;
let SOURCEMAPPING_URL = "sourceMa";
SOURCEMAPPING_URL += "ppingURL";
const MODULE_RUNNER_SOURCEMAPPING_SOURCE = "//# sourceMappingSource=vite-generated";
const ERR_OUTDATED_OPTIMIZED_DEP = "ERR_OUTDATED_OPTIMIZED_DEP";

//#endregion
//#region src/shared/utils.ts
const isWindows = typeof process !== "undefined" && process.platform === "win32";
/**
* Prepend `/@id/` and replace null byte so the id is URL-safe.
* This is prepended to resolved ids that are not valid browser
* import specifiers by the importAnalysis plugin.
*/
function wrapId(id) {
	return id.startsWith(VALID_ID_PREFIX) ? id : VALID_ID_PREFIX + id.replace("\0", NULL_BYTE_PLACEHOLDER);
}
/**
* Undo {@link wrapId}'s `/@id/` and null byte replacements.
*/
function unwrapId(id) {
	return id.startsWith(VALID_ID_PREFIX) ? id.slice(VALID_ID_PREFIX.length).replace(NULL_BYTE_PLACEHOLDER, "\0") : id;
}
const windowsSlashRE = /\\/g;
function slash(p) {
	return p.replace(windowsSlashRE, "/");
}
const postfixRE = /[?#].*$/;
function cleanUrl(url$3) {
	return url$3.replace(postfixRE, "");
}
function splitFileAndPostfix(path$13) {
	const file = cleanUrl(path$13);
	return {
		file,
		postfix: path$13.slice(file.length)
	};
}
function withTrailingSlash(path$13) {
	if (path$13[path$13.length - 1] !== "/") return `${path$13}/`;
	return path$13;
}
function promiseWithResolvers() {
	let resolve$4;
	let reject;
	return {
		promise: new Promise((_resolve, _reject) => {
			resolve$4 = _resolve;
			reject = _reject;
		}),
		resolve: resolve$4,
		reject
	};
}

//#endregion
//#region ../../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.5/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i$1 = 0; i$1 < chars$1.length; i$1++) {
	const c = chars$1.charCodeAt(i$1);
	intToChar[i$1] = c;
	charToInt[c] = i$1;
}
function decodeInteger(reader, relative$3) {
	let value$1 = 0;
	let shift = 0;
	let integer = 0;
	do {
		integer = charToInt[reader.next()];
		value$1 |= (integer & 31) << shift;
		shift += 5;
	} while (integer & 32);
	const shouldNegate = value$1 & 1;
	value$1 >>>= 1;
	if (shouldNegate) value$1 = -2147483648 | -value$1;
	return relative$3 + value$1;
}
function encodeInteger(builder, num, relative$3) {
	let delta = num - relative$3;
	delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
	do {
		let clamped = delta & 31;
		delta >>>= 5;
		if (delta > 0) clamped |= 32;
		builder.write(intToChar[clamped]);
	} while (delta > 0);
	return num;
}
function hasMoreVlq(reader, max) {
	if (reader.pos >= max) return false;
	return reader.peek() !== comma;
}
var bufLength = 1024 * 16;
var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? { decode(buf) {
	return Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength).toString();
} } : { decode(buf) {
	let out = "";
	for (let i$1 = 0; i$1 < buf.length; i$1++) out += String.fromCharCode(buf[i$1]);
	return out;
} };
var StringWriter = class {
	constructor() {
		this.pos = 0;
		this.out = "";
		this.buffer = new Uint8Array(bufLength);
	}
	write(v) {
		const { buffer } = this;
		buffer[this.pos++] = v;
		if (this.pos === bufLength) {
			this.out += td.decode(buffer);
			this.pos = 0;
		}
	}
	flush() {
		const { buffer, out, pos } = this;
		return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
	}
};
var StringReader = class {
	constructor(buffer) {
		this.pos = 0;
		this.buffer = buffer;
	}
	next() {
		return this.buffer.charCodeAt(this.pos++);
	}
	peek() {
		return this.buffer.charCodeAt(this.pos);
	}
	indexOf(char) {
		const { buffer, pos } = this;
		const idx = buffer.indexOf(char, pos);
		return idx === -1 ? buffer.length : idx;
	}
};
function decode(mappings) {
	const { length } = mappings;
	const reader = new StringReader(mappings);
	const decoded = [];
	let genColumn = 0;
	let sourcesIndex = 0;
	let sourceLine = 0;
	let sourceColumn = 0;
	let namesIndex = 0;
	do {
		const semi = reader.indexOf(";");
		const line = [];
		let sorted = true;
		let lastCol = 0;
		genColumn = 0;
		while (reader.pos < semi) {
			let seg;
			genColumn = decodeInteger(reader, genColumn);
			if (genColumn < lastCol) sorted = false;
			lastCol = genColumn;
			if (hasMoreVlq(reader, semi)) {
				sourcesIndex = decodeInteger(reader, sourcesIndex);
				sourceLine = decodeInteger(reader, sourceLine);
				sourceColumn = decodeInteger(reader, sourceColumn);
				if (hasMoreVlq(reader, semi)) {
					namesIndex = decodeInteger(reader, namesIndex);
					seg = [
						genColumn,
						sourcesIndex,
						sourceLine,
						sourceColumn,
						namesIndex
					];
				} else seg = [
					genColumn,
					sourcesIndex,
					sourceLine,
					sourceColumn
				];
			} else seg = [genColumn];
			line.push(seg);
			reader.pos++;
		}
		if (!sorted) sort(line);
		decoded.push(line);
		reader.pos = semi + 1;
	} while (reader.pos <= length);
	return decoded;
}
function sort(line) {
	line.sort(sortComparator$1);
}
function sortComparator$1(a, b) {
	return a[0] - b[0];
}
function encode$1(decoded) {
	const writer = new StringWriter();
	let sourcesIndex = 0;
	let sourceLine = 0;
	let sourceColumn = 0;
	let namesIndex = 0;
	for (let i$1 = 0; i$1 < decoded.length; i$1++) {
		const line = decoded[i$1];
		if (i$1 > 0) writer.write(semicolon);
		if (line.length === 0) continue;
		let genColumn = 0;
		for (let j = 0; j < line.length; j++) {
			const segment = line[j];
			if (j > 0) writer.write(comma);
			genColumn = encodeInteger(writer, segment[0], genColumn);
			if (segment.length === 1) continue;
			sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
			sourceLine = encodeInteger(writer, segment[2], sourceLine);
			sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
			if (segment.length === 4) continue;
			namesIndex = encodeInteger(writer, segment[4], namesIndex);
		}
	}
	return writer.flush();
}

//#endregion
//#region ../../node_modules/.pnpm/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs
const schemeRegex = /^[\w+.-]+:\/\//;
/**
* Matches the parts of a URL:
* 1. Scheme, including ":", guaranteed.
* 2. User/password, including "@", optional.
* 3. Host, guaranteed.
* 4. Port, including ":", optional.
* 5. Path, including "/", optional.
* 6. Query, including "?", optional.
* 7. Hash, including "#", optional.
*/
const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
/**
* File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
* with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
*
* 1. Host, optional.
* 2. Path, which may include "/", guaranteed.
* 3. Query, including "?", optional.
* 4. Hash, including "#", optional.
*/
const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
function isAbsoluteUrl(input) {
	return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
	return input.startsWith("//");
}
function isAbsolutePath(input) {
	return input.startsWith("/");
}
function isFileUrl(input) {
	return input.startsWith("file:");
}
function isRelative(input) {
	return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
	const match = urlRegex.exec(input);
	return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
}
function parseFileUrl(input) {
	const match = fileRegex.exec(input);
	const path$13 = match[2];
	return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path$13) ? path$13 : "/" + path$13, match[3] || "", match[4] || "");
}
function makeUrl(scheme, user, host, port, path$13, query, hash$1) {
	return {
		scheme,
		user,
		host,
		port,
		path: path$13,
		query,
		hash: hash$1,
		type: 7
	};
}
function parseUrl$3(input) {
	if (isSchemeRelativeUrl(input)) {
		const url$4 = parseAbsoluteUrl("http:" + input);
		url$4.scheme = "";
		url$4.type = 6;
		return url$4;
	}
	if (isAbsolutePath(input)) {
		const url$4 = parseAbsoluteUrl("http://foo.com" + input);
		url$4.scheme = "";
		url$4.host = "";
		url$4.type = 5;
		return url$4;
	}
	if (isFileUrl(input)) return parseFileUrl(input);
	if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);
	const url$3 = parseAbsoluteUrl("http://foo.com/" + input);
	url$3.scheme = "";
	url$3.host = "";
	url$3.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
	return url$3;
}
function stripPathFilename(path$13) {
	if (path$13.endsWith("/..")) return path$13;
	const index = path$13.lastIndexOf("/");
	return path$13.slice(0, index + 1);
}
function mergePaths(url$3, base) {
	normalizePath$4(base, base.type);
	if (url$3.path === "/") url$3.path = base.path;
	else url$3.path = stripPathFilename(base.path) + url$3.path;
}
/**
* The path can have empty directories "//", unneeded parents "foo/..", or current directory
* "foo/.". We need to normalize to a standard representation.
*/
function normalizePath$4(url$3, type) {
	const rel = type <= 4;
	const pieces = url$3.path.split("/");
	let pointer = 1;
	let positive = 0;
	let addTrailingSlash = false;
	for (let i$1 = 1; i$1 < pieces.length; i$1++) {
		const piece = pieces[i$1];
		if (!piece) {
			addTrailingSlash = true;
			continue;
		}
		addTrailingSlash = false;
		if (piece === ".") continue;
		if (piece === "..") {
			if (positive) {
				addTrailingSlash = true;
				positive--;
				pointer--;
			} else if (rel) pieces[pointer++] = piece;
			continue;
		}
		pieces[pointer++] = piece;
		positive++;
	}
	let path$13 = "";
	for (let i$1 = 1; i$1 < pointer; i$1++) path$13 += "/" + pieces[i$1];
	if (!path$13 || addTrailingSlash && !path$13.endsWith("/..")) path$13 += "/";
	url$3.path = path$13;
}
/**
* Attempts to resolve `input` URL/path relative to `base`.
*/
function resolve$3(input, base) {
	if (!input && !base) return "";
	const url$3 = parseUrl$3(input);
	let inputType = url$3.type;
	if (base && inputType !== 7) {
		const baseUrl = parseUrl$3(base);
		const baseType = baseUrl.type;
		switch (inputType) {
			case 1: url$3.hash = baseUrl.hash;
			case 2: url$3.query = baseUrl.query;
			case 3:
			case 4: mergePaths(url$3, baseUrl);
			case 5:
				url$3.user = baseUrl.user;
				url$3.host = baseUrl.host;
				url$3.port = baseUrl.port;
			case 6: url$3.scheme = baseUrl.scheme;
		}
		if (baseType > inputType) inputType = baseType;
	}
	normalizePath$4(url$3, inputType);
	const queryHash = url$3.query + url$3.hash;
	switch (inputType) {
		case 2:
		case 3: return queryHash;
		case 4: {
			const path$13 = url$3.path.slice(1);
			if (!path$13) return queryHash || ".";
			if (isRelative(base || input) && !isRelative(path$13)) return "./" + path$13 + queryHash;
			return path$13 + queryHash;
		}
		case 5: return url$3.path + queryHash;
		default: return url$3.scheme + "//" + url$3.user + url$3.host + url$3.port + url$3.path + queryHash;
	}
}

//#endregion
//#region ../../node_modules/.pnpm/@jridgewell+trace-mapping@0.3.31/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs
function stripFilename(path$13) {
	if (!path$13) return "";
	const index = path$13.lastIndexOf("/");
	return path$13.slice(0, index + 1);
}
function resolver(mapUrl, sourceRoot) {
	const from = stripFilename(mapUrl);
	const prefix = sourceRoot ? sourceRoot + "/" : "";
	return (source) => resolve$3(prefix + (source || ""), from);
}
var COLUMN$1 = 0;
var SOURCES_INDEX$1 = 1;
var SOURCE_LINE$1 = 2;
var SOURCE_COLUMN$1 = 3;
var NAMES_INDEX$1 = 4;
function maybeSort(mappings, owned) {
	const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
	if (unsortedIndex === mappings.length) return mappings;
	if (!owned) mappings = mappings.slice();
	for (let i$1 = unsortedIndex; i$1 < mappings.length; i$1 = nextUnsortedSegmentLine(mappings, i$1 + 1)) mappings[i$1] = sortSegments(mappings[i$1], owned);
	return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
	for (let i$1 = start; i$1 < mappings.length; i$1++) if (!isSorted(mappings[i$1])) return i$1;
	return mappings.length;
}
function isSorted(line) {
	for (let j = 1; j < line.length; j++) if (line[j][COLUMN$1] < line[j - 1][COLUMN$1]) return false;
	return true;
}
function sortSegments(line, owned) {
	if (!owned) line = line.slice();
	return line.sort(sortComparator);
}
function sortComparator(a, b) {
	return a[COLUMN$1] - b[COLUMN$1];
}
var found = false;
function binarySearch(haystack, needle, low, high) {
	while (low <= high) {
		const mid = low + (high - low >> 1);
		const cmp = haystack[mid][COLUMN$1] - needle;
		if (cmp === 0) {
			found = true;
			return mid;
		}
		if (cmp < 0) low = mid + 1;
		else high = mid - 1;
	}
	found = false;
	return low - 1;
}
function upperBound(haystack, needle, index) {
	for (let i$1 = index + 1; i$1 < haystack.length; index = i$1++) if (haystack[i$1][COLUMN$1] !== needle) break;
	return index;
}
function lowerBound(haystack, needle, index) {
	for (let i$1 = index - 1; i$1 >= 0; index = i$1--) if (haystack[i$1][COLUMN$1] !== needle) break;
	return index;
}
function memoizedState() {
	return {
		lastKey: -1,
		lastNeedle: -1,
		lastIndex: -1
	};
}
function memoizedBinarySearch(haystack, needle, state, key) {
	const { lastKey, lastNeedle, lastIndex } = state;
	let low = 0;
	let high = haystack.length - 1;
	if (key === lastKey) {
		if (needle === lastNeedle) {
			found = lastIndex !== -1 && haystack[lastIndex][COLUMN$1] === needle;
			return lastIndex;
		}
		if (needle >= lastNeedle) low = lastIndex === -1 ? 0 : lastIndex;
		else high = lastIndex;
	}
	state.lastKey = key;
	state.lastNeedle = needle;
	return state.lastIndex = binarySearch(haystack, needle, low, high);
}
function parse$16(map$1) {
	return typeof map$1 === "string" ? JSON.parse(map$1) : map$1;
}
var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;
var TraceMap = class {
	constructor(map$1, mapUrl) {
		const isString$1 = typeof map$1 === "string";
		if (!isString$1 && map$1._decodedMemo) return map$1;
		const parsed = parse$16(map$1);
		const { version: version$2, file, names, sourceRoot, sources, sourcesContent } = parsed;
		this.version = version$2;
		this.file = file;
		this.names = names || [];
		this.sourceRoot = sourceRoot;
		this.sources = sources;
		this.sourcesContent = sourcesContent;
		this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
		const resolve$4 = resolver(mapUrl, sourceRoot);
		this.resolvedSources = sources.map(resolve$4);
		const { mappings } = parsed;
		if (typeof mappings === "string") {
			this._encoded = mappings;
			this._decoded = void 0;
		} else if (Array.isArray(mappings)) {
			this._encoded = void 0;
			this._decoded = maybeSort(mappings, isString$1);
		} else if (parsed.sections) throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
		else throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
		this._decodedMemo = memoizedState();
		this._bySources = void 0;
		this._bySourceMemos = void 0;
	}
};
function cast$1(map$1) {
	return map$1;
}
function encodedMappings(map$1) {
	var _a, _b;
	return (_b = (_a = cast$1(map$1))._encoded) != null ? _b : _a._encoded = encode$1(cast$1(map$1)._decoded);
}
function decodedMappings(map$1) {
	var _a;
	return (_a = cast$1(map$1))._decoded || (_a._decoded = decode(cast$1(map$1)._encoded));
}
function traceSegment(map$1, line, column) {
	const decoded = decodedMappings(map$1);
	if (line >= decoded.length) return null;
	const segments = decoded[line];
	const index = traceSegmentInternal(segments, cast$1(map$1)._decodedMemo, line, column, GREATEST_LOWER_BOUND);
	return index === -1 ? null : segments[index];
}
function originalPositionFor(map$1, needle) {
	let { line, column, bias } = needle;
	line--;
	if (line < 0) throw new Error(LINE_GTR_ZERO);
	if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
	const decoded = decodedMappings(map$1);
	if (line >= decoded.length) return OMapping(null, null, null, null);
	const segments = decoded[line];
	const index = traceSegmentInternal(segments, cast$1(map$1)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
	if (index === -1) return OMapping(null, null, null, null);
	const segment = segments[index];
	if (segment.length === 1) return OMapping(null, null, null, null);
	const { names, resolvedSources } = map$1;
	return OMapping(resolvedSources[segment[SOURCES_INDEX$1]], segment[SOURCE_LINE$1] + 1, segment[SOURCE_COLUMN$1], segment.length === 5 ? names[segment[NAMES_INDEX$1]] : null);
}
function decodedMap(map$1) {
	return clone(map$1, decodedMappings(map$1));
}
function encodedMap(map$1) {
	return clone(map$1, encodedMappings(map$1));
}
function clone(map$1, mappings) {
	return {
		version: map$1.version,
		file: map$1.file,
		names: map$1.names,
		sourceRoot: map$1.sourceRoot,
		sources: map$1.sources,
		sourcesContent: map$1.sourcesContent,
		mappings,
		ignoreList: map$1.ignoreList || map$1.x_google_ignoreList
	};
}
function OMapping(source, line, column, name) {
	return {
		source,
		line,
		column,
		name
	};
}
function traceSegmentInternal(segments, memo, line, column, bias) {
	let index = memoizedBinarySearch(segments, column, memo, line);
	if (found) index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
	else if (bias === LEAST_UPPER_BOUND) index++;
	if (index === -1 || index === segments.length) return -1;
	return index;
}

//#endregion
//#region ../../node_modules/.pnpm/@jridgewell+gen-mapping@0.3.12/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs
var SetArray = class {
	constructor() {
		this._indexes = { __proto__: null };
		this.array = [];
	}
};
function cast(set) {
	return set;
}
function get$2(setarr, key) {
	return cast(setarr)._indexes[key];
}
function put(setarr, key) {
	const index = get$2(setarr, key);
	if (index !== void 0) return index;
	const { array, _indexes: indexes } = cast(setarr);
	return indexes[key] = array.push(key) - 1;
}
function remove(setarr, key) {
	const index = get$2(setarr, key);
	if (index === void 0) return;
	const { array, _indexes: indexes } = cast(setarr);
	for (let i$1 = index + 1; i$1 < array.length; i$1++) {
		const k = array[i$1];
		array[i$1 - 1] = k;
		indexes[k]--;
	}
	indexes[key] = void 0;
	array.pop();
}
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
var NO_NAME = -1;
var GenMapping = class {
	constructor({ file, sourceRoot } = {}) {
		this._names = new SetArray();
		this._sources = new SetArray();
		this._sourcesContent = [];
		this._mappings = [];
		this.file = file;
		this.sourceRoot = sourceRoot;
		this._ignoreList = new SetArray();
	}
};
function cast2(map$1) {
	return map$1;
}
var maybeAddSegment = (map$1, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
	return addSegmentInternal(true, map$1, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
};
function setSourceContent(map$1, source, content) {
	const { _sources: sources, _sourcesContent: sourcesContent } = cast2(map$1);
	const index = put(sources, source);
	sourcesContent[index] = content;
}
function setIgnore(map$1, source, ignore = true) {
	const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast2(map$1);
	const index = put(sources, source);
	if (index === sourcesContent.length) sourcesContent[index] = null;
	if (ignore) put(ignoreList, index);
	else remove(ignoreList, index);
}
function toDecodedMap(map$1) {
	const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList } = cast2(map$1);
	removeEmptyFinalLines(mappings);
	return {
		version: 3,
		file: map$1.file || void 0,
		names: names.array,
		sourceRoot: map$1.sourceRoot || void 0,
		sources: sources.array,
		sourcesContent,
		mappings,
		ignoreList: ignoreList.array
	};
}
function toEncodedMap(map$1) {
	const decoded = toDecodedMap(map$1);
	return Object.assign({}, decoded, { mappings: encode$1(decoded.mappings) });
}
function addSegmentInternal(skipable, map$1, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
	const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = cast2(map$1);
	const line = getIndex(mappings, genLine);
	const index = getColumnIndex(line, genColumn);
	if (!source) {
		if (skipable && skipSourceless(line, index)) return;
		return insert(line, index, [genColumn]);
	}
	assert$2(sourceLine);
	assert$2(sourceColumn);
	const sourcesIndex = put(sources, source);
	const namesIndex = name ? put(names, name) : NO_NAME;
	if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content != null ? content : null;
	if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) return;
	return insert(line, index, name ? [
		genColumn,
		sourcesIndex,
		sourceLine,
		sourceColumn,
		namesIndex
	] : [
		genColumn,
		sourcesIndex,
		sourceLine,
		sourceColumn
	]);
}
function assert$2(_val) {}
function getIndex(arr, index) {
	for (let i$1 = arr.length; i$1 <= index; i$1++) arr[i$1] = [];
	return arr[index];
}
function getColumnIndex(line, genColumn) {
	let index = line.length;
	for (let i$1 = index - 1; i$1 >= 0; index = i$1--) if (genColumn >= line[i$1][COLUMN]) break;
	return index;
}
function insert(array, index, value$1) {
	for (let i$1 = array.length; i$1 > index; i$1--) array[i$1] = array[i$1 - 1];
	array[index] = value$1;
}
function removeEmptyFinalLines(mappings) {
	const { length } = mappings;
	let len = length;
	for (let i$1 = len - 1; i$1 >= 0; len = i$1, i$1--) if (mappings[i$1].length > 0) break;
	if (len < length) mappings.length = len;
}
function skipSourceless(line, index) {
	if (index === 0) return true;
	return line[index - 1].length === 1;
}
function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
	if (index === 0) return false;
	const prev = line[index - 1];
	if (prev.length === 1) return false;
	return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
}

//#endregion
//#region ../../node_modules/.pnpm/@jridgewell+remapping@2.3.5/node_modules/@jridgewell/remapping/dist/remapping.mjs
var SOURCELESS_MAPPING = /* @__PURE__ */ SegmentObject("", -1, -1, "", null, false);
var EMPTY_SOURCES = [];
function SegmentObject(source, line, column, name, content, ignore) {
	return {
		source,
		line,
		column,
		name,
		content,
		ignore
	};
}
function Source(map$1, sources, source, content, ignore) {
	return {
		map: map$1,
		sources,
		source,
		content,
		ignore
	};
}
function MapSource(map$1, sources) {
	return Source(map$1, sources, "", null, false);
}
function OriginalSource(source, content, ignore) {
	return Source(null, EMPTY_SOURCES, source, content, ignore);
}
function traceMappings(tree) {
	const gen = new GenMapping({ file: tree.map.file });
	const { sources: rootSources, map: map$1 } = tree;
	const rootNames = map$1.names;
	const rootMappings = decodedMappings(map$1);
	for (let i$1 = 0; i$1 < rootMappings.length; i$1++) {
		const segments = rootMappings[i$1];
		for (let j = 0; j < segments.length; j++) {
			const segment = segments[j];
			const genCol = segment[0];
			let traced = SOURCELESS_MAPPING;
			if (segment.length !== 1) {
				const source2 = rootSources[segment[1]];
				traced = originalPositionFor$1(source2, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
				if (traced == null) continue;
			}
			const { column, line, name, content, source, ignore } = traced;
			maybeAddSegment(gen, i$1, genCol, source, line, column, name);
			if (source && content != null) setSourceContent(gen, source, content);
			if (ignore) setIgnore(gen, source, true);
		}
	}
	return gen;
}
function originalPositionFor$1(source, line, column, name) {
	if (!source.map) return SegmentObject(source.source, line, column, name, source.content, source.ignore);
	const segment = traceSegment(source.map, line, column);
	if (segment == null) return null;
	if (segment.length === 1) return SOURCELESS_MAPPING;
	return originalPositionFor$1(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);
}
function asArray(value$1) {
	if (Array.isArray(value$1)) return value$1;
	return [value$1];
}
function buildSourceMapTree(input, loader$1) {
	const maps = asArray(input).map((m$2) => new TraceMap(m$2, ""));
	const map$1 = maps.pop();
	for (let i$1 = 0; i$1 < maps.length; i$1++) if (maps[i$1].sources.length > 1) throw new Error(`Transformation map ${i$1} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
	let tree = build$2(map$1, loader$1, "", 0);
	for (let i$1 = maps.length - 1; i$1 >= 0; i$1--) tree = MapSource(maps[i$1], [tree]);
	return tree;
}
function build$2(map$1, loader$1, importer, importerDepth) {
	const { resolvedSources, sourcesContent, ignoreList } = map$1;
	const depth = importerDepth + 1;
	return MapSource(map$1, resolvedSources.map((sourceFile, i$1) => {
		const ctx = {
			importer,
			depth,
			source: sourceFile || "",
			content: void 0,
			ignore: void 0
		};
		const sourceMap = loader$1(ctx.source, ctx);
		const { source, content, ignore } = ctx;
		if (sourceMap) return build$2(new TraceMap(sourceMap, source), loader$1, source, depth);
		return OriginalSource(source, content !== void 0 ? content : sourcesContent ? sourcesContent[i$1] : null, ignore !== void 0 ? ignore : ignoreList ? ignoreList.includes(i$1) : false);
	}));
}
var SourceMap$1 = class {
	constructor(map$1, options$1) {
		const out = options$1.decodedMappings ? toDecodedMap(map$1) : toEncodedMap(map$1);
		this.version = out.version;
		this.file = out.file;
		this.mappings = out.mappings;
		this.names = out.names;
		this.ignoreList = out.ignoreList;
		this.sourceRoot = out.sourceRoot;
		this.sources = out.sources;
		if (!options$1.excludeContent) this.sourcesContent = out.sourcesContent;
	}
	toString() {
		return JSON.stringify(this);
	}
};
function remapping(input, loader$1, options$1) {
	const opts = typeof options$1 === "object" ? options$1 : {
		excludeContent: !!options$1,
		decodedMappings: false
	};
	return new SourceMap$1(traceMappings(buildSourceMapTree(input, loader$1)), opts);
}

//#endregion
//#region ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js": ((exports, module) => {
	/**
	* Helpers.
	*/
	var s$1 = 1e3;
	var m$1 = s$1 * 60;
	var h$1 = m$1 * 60;
	var d$1 = h$1 * 24;
	var w = d$1 * 7;
	var y$1 = d$1 * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options$1) {
		options$1 = options$1 || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse$15(val);
		else if (type === "number" && isFinite(val)) return options$1.long ? fmtLong$1(val) : fmtShort$1(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse$15(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n$2 = parseFloat(match[1]);
		switch ((match[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n$2 * y$1;
			case "weeks":
			case "week":
			case "w": return n$2 * w;
			case "days":
			case "day":
			case "d": return n$2 * d$1;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n$2 * h$1;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n$2 * m$1;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n$2 * s$1;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n$2;
			default: return;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort$1(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d$1) return Math.round(ms / d$1) + "d";
		if (msAbs >= h$1) return Math.round(ms / h$1) + "h";
		if (msAbs >= m$1) return Math.round(ms / m$1) + "m";
		if (msAbs >= s$1) return Math.round(ms / s$1) + "s";
		return ms + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong$1(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d$1) return plural$1(ms, msAbs, d$1, "day");
		if (msAbs >= h$1) return plural$1(ms, msAbs, h$1, "hour");
		if (msAbs >= m$1) return plural$1(ms, msAbs, m$1, "minute");
		if (msAbs >= s$1) return plural$1(ms, msAbs, s$1, "second");
		return ms + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural$1(ms, msAbs, n$2, name) {
		var isPlural = msAbs >= n$2 * 1.5;
		return Math.round(ms / n$2) + " " + name + (isPlural ? "s" : "");
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js
var require_common$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js": ((exports, module) => {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*/
	function setup(env$1) {
		createDebug$1.debug = createDebug$1;
		createDebug$1.default = createDebug$1;
		createDebug$1.coerce = coerce$1;
		createDebug$1.disable = disable$1;
		createDebug$1.enable = enable$1;
		createDebug$1.enabled = enabled$1;
		createDebug$1.humanize = require_ms$1();
		createDebug$1.destroy = destroy$1;
		Object.keys(env$1).forEach((key) => {
			createDebug$1[key] = env$1[key];
		});
		/**
		* The currently active debug mode names, and names to skip.
		*/
		createDebug$1.names = [];
		createDebug$1.skips = [];
		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug$1.formatters = {};
		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor$1(namespace) {
			let hash$1 = 0;
			for (let i$1 = 0; i$1 < namespace.length; i$1++) {
				hash$1 = (hash$1 << 5) - hash$1 + namespace.charCodeAt(i$1);
				hash$1 |= 0;
			}
			return createDebug$1.colors[Math.abs(hash$1) % createDebug$1.colors.length];
		}
		createDebug$1.selectColor = selectColor$1;
		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug$1(namespace) {
			let prevTime$1;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;
			function debug$19(...args) {
				if (!debug$19.enabled) return;
				const self$1 = debug$19;
				const curr = Number(/* @__PURE__ */ new Date());
				self$1.diff = curr - (prevTime$1 || curr);
				self$1.prev = prevTime$1;
				self$1.curr = curr;
				prevTime$1 = curr;
				args[0] = createDebug$1.coerce(args[0]);
				if (typeof args[0] !== "string") args.unshift("%O");
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format$3) => {
					if (match === "%%") return "%";
					index++;
					const formatter = createDebug$1.formatters[format$3];
					if (typeof formatter === "function") {
						const val = args[index];
						match = formatter.call(self$1, val);
						args.splice(index, 1);
						index--;
					}
					return match;
				});
				createDebug$1.formatArgs.call(self$1, args);
				(self$1.log || createDebug$1.log).apply(self$1, args);
			}
			debug$19.namespace = namespace;
			debug$19.useColors = createDebug$1.useColors();
			debug$19.color = createDebug$1.selectColor(namespace);
			debug$19.extend = extend;
			debug$19.destroy = createDebug$1.destroy;
			Object.defineProperty(debug$19, "enabled", {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) return enableOverride;
					if (namespacesCache !== createDebug$1.namespaces) {
						namespacesCache = createDebug$1.namespaces;
						enabledCache = createDebug$1.enabled(namespace);
					}
					return enabledCache;
				},
				set: (v) => {
					enableOverride = v;
				}
			});
			if (typeof createDebug$1.init === "function") createDebug$1.init(debug$19);
			return debug$19;
		}
		function extend(namespace, delimiter) {
			const newDebug = createDebug$1(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable$1(namespaces) {
			createDebug$1.save(namespaces);
			createDebug$1.namespaces = namespaces;
			createDebug$1.names = [];
			createDebug$1.skips = [];
			const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
			for (const ns of split) if (ns[0] === "-") createDebug$1.skips.push(ns.slice(1));
			else createDebug$1.names.push(ns);
		}
		/**
		* Checks if the given string matches a namespace template, honoring
		* asterisks as wildcards.
		*
		* @param {String} search
		* @param {String} template
		* @return {Boolean}
		*/
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;
			while (searchIndex < search.length) if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) if (template[templateIndex] === "*") {
				starIndex = templateIndex;
				matchIndex = searchIndex;
				templateIndex++;
			} else {
				searchIndex++;
				templateIndex++;
			}
			else if (starIndex !== -1) {
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else return false;
			while (templateIndex < template.length && template[templateIndex] === "*") templateIndex++;
			return templateIndex === template.length;
		}
		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable$1() {
			const namespaces = [...createDebug$1.names, ...createDebug$1.skips.map((namespace) => "-" + namespace)].join(",");
			createDebug$1.enable("");
			return namespaces;
		}
		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled$1(name) {
			for (const skip of createDebug$1.skips) if (matchesTemplate(name, skip)) return false;
			for (const ns of createDebug$1.names) if (matchesTemplate(name, ns)) return true;
			return false;
		}
		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce$1(val) {
			if (val instanceof Error) return val.stack || val.message;
			return val;
		}
		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy$1() {
			console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		}
		createDebug$1.enable(createDebug$1.load());
		return createDebug$1;
	}
	module.exports = setup;
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/node.js
var require_node$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/node.js": ((exports, module) => {
	/**
	* Module dependencies.
	*/
	const tty$1 = __require("tty");
	const util$2 = __require("util");
	/**
	* This is the Node.js implementation of `debug()`.
	*/
	exports.init = init$2;
	exports.log = log$3;
	exports.formatArgs = formatArgs$1;
	exports.save = save$1;
	exports.load = load$2;
	exports.useColors = useColors$1;
	exports.destroy = util$2.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
	/**
	* Colors.
	*/
	exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	try {
		const supportsColor = __require("supports-color");
		if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	} catch (error$1) {}
	/**
	* Build up the default `inspectOpts` object from the environment variables.
	*
	*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	*/
	exports.inspectOpts = Object.keys(process.env).filter((key) => {
		return /^debug_/i.test(key);
	}).reduce((obj, key) => {
		const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});
		let val = process.env[key];
		if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		else if (val === "null") val = null;
		else val = Number(val);
		obj[prop] = val;
		return obj;
	}, {});
	/**
	* Is stdout a TTY? Colored output is enabled when `true`.
	*/
	function useColors$1() {
		return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty$1.isatty(process.stderr.fd);
	}
	/**
	* Adds ANSI color escape codes if enabled.
	*
	* @api public
	*/
	function formatArgs$1(args) {
		const { namespace: name, useColors: useColors$2 } = this;
		if (useColors$2) {
			const c = this.color;
			const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
			const prefix = `  ${colorCode};1m${name} \u001B[0m`;
			args[0] = prefix + args[0].split("\n").join("\n" + prefix);
			args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = getDate() + name + " " + args[0];
	}
	function getDate() {
		if (exports.inspectOpts.hideDate) return "";
		return (/* @__PURE__ */ new Date()).toISOString() + " ";
	}
	/**
	* Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
	*/
	function log$3(...args) {
		return process.stderr.write(util$2.formatWithOptions(exports.inspectOpts, ...args) + "\n");
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save$1(namespaces) {
		if (namespaces) process.env.DEBUG = namespaces;
		else delete process.env.DEBUG;
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load$2() {
		return process.env.DEBUG;
	}
	/**
	* Init logic for `debug` instances.
	*
	* Create a new `inspectOpts` object in case `useColors` is set
	* differently for a particular `debug` instance.
	*/
	function init$2(debug$19) {
		debug$19.inspectOpts = {};
		const keys = Object.keys(exports.inspectOpts);
		for (let i$1 = 0; i$1 < keys.length; i$1++) debug$19.inspectOpts[keys[i$1]] = exports.inspectOpts[keys[i$1]];
	}
	module.exports = require_common$1()(exports);
	const { formatters } = module.exports;
	/**
	* Map %o to `util.inspect()`, all on a single line.
	*/
	formatters.o = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
	};
	/**
	* Map %O to `util.inspect()`, allowing multiple lines if needed.
	*/
	formatters.O = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$2.inspect(v, this.inspectOpts);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/estree-walker@2.0.2/node_modules/estree-walker/dist/esm/estree-walker.js
/** @typedef { import('estree').BaseNode} BaseNode */
/** @typedef {{
skip: () => void;
remove: () => void;
replace: (node: BaseNode) => void;
}} WalkerContext */
var WalkerBase$1 = class {
	constructor() {
		/** @type {boolean} */
		this.should_skip = false;
		/** @type {boolean} */
		this.should_remove = false;
		/** @type {BaseNode | null} */
		this.replacement = null;
		/** @type {WalkerContext} */
		this.context = {
			skip: () => this.should_skip = true,
			remove: () => this.should_remove = true,
			replace: (node) => this.replacement = node
		};
	}
	/**
	*
	* @param {any} parent
	* @param {string} prop
	* @param {number} index
	* @param {BaseNode} node
	*/
	replace(parent, prop, index, node) {
		if (parent) if (index !== null) parent[prop][index] = node;
		else parent[prop] = node;
	}
	/**
	*
	* @param {any} parent
	* @param {string} prop
	* @param {number} index
	*/
	remove(parent, prop, index) {
		if (parent) if (index !== null) parent[prop].splice(index, 1);
		else delete parent[prop];
	}
};
/** @typedef { import('estree').BaseNode} BaseNode */
/** @typedef { import('./walker.js').WalkerContext} WalkerContext */
/** @typedef {(
*    this: WalkerContext,
*    node: BaseNode,
*    parent: BaseNode,
*    key: string,
*    index: number
* ) => void} SyncHandler */
var SyncWalker$1 = class extends WalkerBase$1 {
	/**
	*
	* @param {SyncHandler} enter
	* @param {SyncHandler} leave
	*/
	constructor(enter, leave) {
		super();
		/** @type {SyncHandler} */
		this.enter = enter;
		/** @type {SyncHandler} */
		this.leave = leave;
	}
	/**
	*
	* @param {BaseNode} node
	* @param {BaseNode} parent
	* @param {string} [prop]
	* @param {number} [index]
	* @returns {BaseNode}
	*/
	visit(node, parent, prop, index) {
		if (node) {
			if (this.enter) {
				const _should_skip = this.should_skip;
				const _should_remove = this.should_remove;
				const _replacement = this.replacement;
				this.should_skip = false;
				this.should_remove = false;
				this.replacement = null;
				this.enter.call(this.context, node, parent, prop, index);
				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}
				if (this.should_remove) this.remove(parent, prop, index);
				const skipped = this.should_skip;
				const removed = this.should_remove;
				this.should_skip = _should_skip;
				this.should_remove = _should_remove;
				this.replacement = _replacement;
				if (skipped) return node;
				if (removed) return null;
			}
			for (const key in node) {
				const value$1 = node[key];
				if (typeof value$1 !== "object") continue;
				else if (Array.isArray(value$1)) {
					for (let i$1 = 0; i$1 < value$1.length; i$1 += 1) if (value$1[i$1] !== null && typeof value$1[i$1].type === "string") {
						if (!this.visit(value$1[i$1], node, key, i$1)) i$1--;
					}
				} else if (value$1 !== null && typeof value$1.type === "string") this.visit(value$1, node, key, null);
			}
			if (this.leave) {
				const _replacement = this.replacement;
				const _should_remove = this.should_remove;
				this.replacement = null;
				this.should_remove = false;
				this.leave.call(this.context, node, parent, prop, index);
				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}
				if (this.should_remove) this.remove(parent, prop, index);
				const removed = this.should_remove;
				this.replacement = _replacement;
				this.should_remove = _should_remove;
				if (removed) return null;
			}
		}
		return node;
	}
};
/** @typedef { import('estree').BaseNode} BaseNode */
/** @typedef { import('./sync.js').SyncHandler} SyncHandler */
/** @typedef { import('./async.js').AsyncHandler} AsyncHandler */
/**
*
* @param {BaseNode} ast
* @param {{
*   enter?: SyncHandler
*   leave?: SyncHandler
* }} walker
* @returns {BaseNode}
*/
function walk$2(ast, { enter, leave }) {
	return new SyncWalker$1(enter, leave).visit(ast, null);
}

//#endregion
//#region ../../node_modules/.pnpm/@rollup+pluginutils@5.3.0_rollup@4.43.0/node_modules/@rollup/pluginutils/dist/es/index.js
const extractors = {
	ArrayPattern(names, param) {
		for (const element of param.elements) if (element) extractors[element.type](names, element);
	},
	AssignmentPattern(names, param) {
		extractors[param.left.type](names, param.left);
	},
	Identifier(names, param) {
		names.push(param.name);
	},
	MemberExpression() {},
	ObjectPattern(names, param) {
		for (const prop of param.properties) if (prop.type === "RestElement") extractors.RestElement(names, prop);
		else extractors[prop.value.type](names, prop.value);
	},
	RestElement(names, param) {
		extractors[param.argument.type](names, param.argument);
	}
};
const extractAssignedNames = function extractAssignedNames$1(param) {
	const names = [];
	extractors[param.type](names, param);
	return names;
};
const blockDeclarations = {
	const: true,
	let: true
};
var Scope = class {
	constructor(options$1 = {}) {
		this.parent = options$1.parent;
		this.isBlockScope = !!options$1.block;
		this.declarations = Object.create(null);
		if (options$1.params) options$1.params.forEach((param) => {
			extractAssignedNames(param).forEach((name) => {
				this.declarations[name] = true;
			});
		});
	}
	addDeclaration(node, isBlockDeclaration, isVar) {
		if (!isBlockDeclaration && this.isBlockScope) this.parent.addDeclaration(node, isBlockDeclaration, isVar);
		else if (node.id) extractAssignedNames(node.id).forEach((name) => {
			this.declarations[name] = true;
		});
	}
	contains(name) {
		return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);
	}
};
const attachScopes = function attachScopes$1(ast, propertyName = "scope") {
	let scope = new Scope();
	walk$2(ast, {
		enter(n$2, parent) {
			const node = n$2;
			if (/(?:Function|Class)Declaration/.test(node.type)) scope.addDeclaration(node, false, false);
			if (node.type === "VariableDeclaration") {
				const { kind } = node;
				const isBlockDeclaration = blockDeclarations[kind];
				node.declarations.forEach((declaration) => {
					scope.addDeclaration(declaration, isBlockDeclaration, true);
				});
			}
			let newScope;
			if (node.type.includes("Function")) {
				const func = node;
				newScope = new Scope({
					parent: scope,
					block: false,
					params: func.params
				});
				if (func.type === "FunctionExpression" && func.id) newScope.addDeclaration(func, false, false);
			}
			if (/For(?:In|Of)?Statement/.test(node.type)) newScope = new Scope({
				parent: scope,
				block: true
			});
			if (node.type === "BlockStatement" && !parent.type.includes("Function")) newScope = new Scope({
				parent: scope,
				block: true
			});
			if (node.type === "CatchClause") newScope = new Scope({
				parent: scope,
				params: node.param ? [node.param] : [],
				block: true
			});
			if (newScope) {
				Object.defineProperty(node, propertyName, {
					value: newScope,
					configurable: true
				});
				scope = newScope;
			}
		},
		leave(n$2) {
			if (n$2[propertyName]) scope = scope.parent;
		}
	});
	return scope;
};
function isArray(arg) {
	return Array.isArray(arg);
}
function ensureArray(thing) {
	if (isArray(thing)) return thing;
	if (thing == null) return [];
	return [thing];
}
const normalizePathRegExp = new RegExp(`\\${win32.sep}`, "g");
const normalizePath$3 = function normalizePath$5(filename) {
	return filename.replace(normalizePathRegExp, posix$1.sep);
};
function getMatcherString$1(id, resolutionBase) {
	if (resolutionBase === false || isAbsolute$1(id) || id.startsWith("**")) return normalizePath$3(id);
	const basePath = normalizePath$3(resolve$1(resolutionBase || "")).replace(/[-^$*+?.()|[\]{}]/g, "\\$&");
	return posix$1.join(basePath, normalizePath$3(id));
}
const createFilter$2 = function createFilter$3(include, exclude, options$1) {
	const resolutionBase = options$1 && options$1.resolve;
	const getMatcher = (id) => id instanceof RegExp ? id : { test: (what) => {
		return picomatch(getMatcherString$1(id, resolutionBase), { dot: true })(what);
	} };
	const includeMatchers = ensureArray(include).map(getMatcher);
	const excludeMatchers = ensureArray(exclude).map(getMatcher);
	if (!includeMatchers.length && !excludeMatchers.length) return (id) => typeof id === "string" && !id.includes("\0");
	return function result(id) {
		if (typeof id !== "string") return false;
		if (id.includes("\0")) return false;
		const pathId = normalizePath$3(id);
		for (let i$1 = 0; i$1 < excludeMatchers.length; ++i$1) {
			const matcher = excludeMatchers[i$1];
			if (matcher instanceof RegExp) matcher.lastIndex = 0;
			if (matcher.test(pathId)) return false;
		}
		for (let i$1 = 0; i$1 < includeMatchers.length; ++i$1) {
			const matcher = includeMatchers[i$1];
			if (matcher instanceof RegExp) matcher.lastIndex = 0;
			if (matcher.test(pathId)) return true;
		}
		return !includeMatchers.length;
	};
};
const forbiddenIdentifiers = new Set(`break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl`.split(" "));
forbiddenIdentifiers.add("");
const makeLegalIdentifier = function makeLegalIdentifier$1(str) {
	let identifier = str.replace(/-(\w)/g, (_, letter) => letter.toUpperCase()).replace(/[^$_a-zA-Z0-9]/g, "_");
	if (/\d/.test(identifier[0]) || forbiddenIdentifiers.has(identifier)) identifier = `_${identifier}`;
	return identifier || "_";
};
function stringify$4(obj) {
	return (JSON.stringify(obj) || "undefined").replace(/[\u2028\u2029]/g, (char) => `\\u${`000${char.charCodeAt(0).toString(16)}`.slice(-4)}`);
}
function serializeArray(arr, indent, baseIndent) {
	let output = "[";
	const separator = indent ? `\n${baseIndent}${indent}` : "";
	for (let i$1 = 0; i$1 < arr.length; i$1++) {
		const key = arr[i$1];
		output += `${i$1 > 0 ? "," : ""}${separator}${serialize(key, indent, baseIndent + indent)}`;
	}
	return `${output}${indent ? `\n${baseIndent}` : ""}]`;
}
function serializeObject(obj, indent, baseIndent) {
	let output = "{";
	const separator = indent ? `\n${baseIndent}${indent}` : "";
	const entries = Object.entries(obj);
	for (let i$1 = 0; i$1 < entries.length; i$1++) {
		const [key, value$1] = entries[i$1];
		const stringKey = makeLegalIdentifier(key) === key ? key : stringify$4(key);
		output += `${i$1 > 0 ? "," : ""}${separator}${stringKey}:${indent ? " " : ""}${serialize(value$1, indent, baseIndent + indent)}`;
	}
	return `${output}${indent ? `\n${baseIndent}` : ""}}`;
}
function serialize(obj, indent, baseIndent) {
	if (typeof obj === "object" && obj !== null) {
		if (Array.isArray(obj)) return serializeArray(obj, indent, baseIndent);
		if (obj instanceof Date) return `new Date(${obj.getTime()})`;
		if (obj instanceof RegExp) return obj.toString();
		return serializeObject(obj, indent, baseIndent);
	}
	if (typeof obj === "number") {
		if (obj === Infinity) return "Infinity";
		if (obj === -Infinity) return "-Infinity";
		if (obj === 0) return 1 / obj === Infinity ? "0" : "-0";
		if (obj !== obj) return "NaN";
	}
	if (typeof obj === "symbol") {
		const key = Symbol.keyFor(obj);
		if (key !== void 0) return `Symbol.for(${stringify$4(key)})`;
	}
	if (typeof obj === "bigint") return `${obj}n`;
	return stringify$4(obj);
}
const hasStringIsWellFormed = "isWellFormed" in String.prototype;
function isWellFormedString(input) {
	if (hasStringIsWellFormed) return input.isWellFormed();
	return !/\p{Surrogate}/u.test(input);
}
const dataToEsm = function dataToEsm$1(data, options$1 = {}) {
	var _a, _b;
	const t$1 = options$1.compact ? "" : "indent" in options$1 ? options$1.indent : "	";
	const _ = options$1.compact ? "" : " ";
	const n$2 = options$1.compact ? "" : "\n";
	const declarationType = options$1.preferConst ? "const" : "var";
	if (options$1.namedExports === false || typeof data !== "object" || Array.isArray(data) || data instanceof Date || data instanceof RegExp || data === null) {
		const code = serialize(data, options$1.compact ? null : t$1, "");
		return `export default${_ || (/^[{[\-\/]/.test(code) ? "" : " ")}${code};`;
	}
	let maxUnderbarPrefixLength = 0;
	for (const key of Object.keys(data)) {
		const underbarPrefixLength = (_b = (_a = /^(_+)/.exec(key)) === null || _a === void 0 ? void 0 : _a[0].length) !== null && _b !== void 0 ? _b : 0;
		if (underbarPrefixLength > maxUnderbarPrefixLength) maxUnderbarPrefixLength = underbarPrefixLength;
	}
	const arbitraryNamePrefix = `${"_".repeat(maxUnderbarPrefixLength + 1)}arbitrary`;
	let namedExportCode = "";
	const defaultExportRows = [];
	const arbitraryNameExportRows = [];
	for (const [key, value$1] of Object.entries(data)) if (key === makeLegalIdentifier(key)) {
		if (options$1.objectShorthand) defaultExportRows.push(key);
		else defaultExportRows.push(`${key}:${_}${key}`);
		namedExportCode += `export ${declarationType} ${key}${_}=${_}${serialize(value$1, options$1.compact ? null : t$1, "")};${n$2}`;
	} else {
		defaultExportRows.push(`${stringify$4(key)}:${_}${serialize(value$1, options$1.compact ? null : t$1, "")}`);
		if (options$1.includeArbitraryNames && isWellFormedString(key)) {
			const variableName = `${arbitraryNamePrefix}${arbitraryNameExportRows.length}`;
			namedExportCode += `${declarationType} ${variableName}${_}=${_}${serialize(value$1, options$1.compact ? null : t$1, "")};${n$2}`;
			arbitraryNameExportRows.push(`${variableName} as ${JSON.stringify(key)}`);
		}
	}
	const arbitraryExportCode = arbitraryNameExportRows.length > 0 ? `export${_}{${n$2}${t$1}${arbitraryNameExportRows.join(`,${n$2}${t$1}`)}${n$2}};${n$2}` : "";
	const defaultExportCode = `export default${_}{${n$2}${t$1}${defaultExportRows.join(`,${n$2}${t$1}`)}${n$2}};${n$2}`;
	return `${namedExportCode}${arbitraryExportCode}${defaultExportCode}`;
};

//#endregion
//#region src/node/packages.ts
let pnp;
if (process.versions.pnp) try {
	pnp = createRequire(
		/** #__KEEP__ */
		import.meta.url
	)("pnpapi");
} catch {}
function invalidatePackageData(packageCache, pkgPath) {
	const pkgDir = normalizePath(path.dirname(pkgPath));
	packageCache.forEach((pkg, cacheKey) => {
		if (pkg.dir === pkgDir) packageCache.delete(cacheKey);
	});
}
function resolvePackageData(pkgName, basedir, preserveSymlinks = false, packageCache) {
	if (pnp) {
		const cacheKey = getRpdCacheKey(pkgName, basedir, preserveSymlinks);
		if (packageCache?.has(cacheKey)) return packageCache.get(cacheKey);
		try {
			const pkg = pnp.resolveToUnqualified(pkgName, basedir, { considerBuiltins: false });
			if (!pkg) return null;
			const pkgData = loadPackageData(path.join(pkg, "package.json"));
			packageCache?.set(cacheKey, pkgData);
			return pkgData;
		} catch {
			return null;
		}
	}
	const originalBasedir = basedir;
	while (basedir) {
		if (packageCache) {
			const cached = getRpdCache(packageCache, pkgName, basedir, originalBasedir, preserveSymlinks);
			if (cached) return cached;
		}
		const pkg = path.join(basedir, "node_modules", pkgName, "package.json");
		try {
			if (fs.existsSync(pkg)) {
				const pkgData = loadPackageData(preserveSymlinks ? pkg : safeRealpathSync(pkg));
				if (packageCache) setRpdCache(packageCache, pkgData, pkgName, basedir, originalBasedir, preserveSymlinks);
				return pkgData;
			}
		} catch {}
		const nextBasedir = path.dirname(basedir);
		if (nextBasedir === basedir) break;
		basedir = nextBasedir;
	}
	return null;
}
function findNearestPackageData(basedir, packageCache) {
	const originalBasedir = basedir;
	while (basedir) {
		if (packageCache) {
			const cached = getFnpdCache(packageCache, basedir, originalBasedir);
			if (cached) return cached;
		}
		const pkgPath = path.join(basedir, "package.json");
		if (tryStatSync(pkgPath)?.isFile()) try {
			const pkgData = loadPackageData(pkgPath);
			if (packageCache) setFnpdCache(packageCache, pkgData, basedir, originalBasedir);
			return pkgData;
		} catch {}
		const nextBasedir = path.dirname(basedir);
		if (nextBasedir === basedir) break;
		basedir = nextBasedir;
	}
	return null;
}
function findNearestMainPackageData(basedir, packageCache) {
	const nearestPackage = findNearestPackageData(basedir, packageCache);
	return nearestPackage && (nearestPackage.data.name ? nearestPackage : findNearestMainPackageData(path.dirname(nearestPackage.dir), packageCache));
}
function loadPackageData(pkgPath) {
	const data = JSON.parse(stripBomTag(fs.readFileSync(pkgPath, "utf-8")));
	const pkgDir = normalizePath(path.dirname(pkgPath));
	const { sideEffects } = data;
	let hasSideEffects;
	if (typeof sideEffects === "boolean") hasSideEffects = () => sideEffects;
	else if (Array.isArray(sideEffects)) if (sideEffects.length <= 0) hasSideEffects = () => false;
	else hasSideEffects = createFilter(sideEffects.map((sideEffect) => {
		if (sideEffect.includes("/")) return sideEffect;
		return `**/${sideEffect}`;
	}), null, { resolve: pkgDir });
	else hasSideEffects = () => null;
	const resolvedCache = {};
	return {
		dir: pkgDir,
		data,
		hasSideEffects,
		setResolvedCache(key, entry, options$1) {
			resolvedCache[getResolveCacheKey(key, options$1)] = entry;
		},
		getResolvedCache(key, options$1) {
			return resolvedCache[getResolveCacheKey(key, options$1)];
		}
	};
}
function getResolveCacheKey(key, options$1) {
	return [
		key,
		options$1.isRequire ? "1" : "0",
		options$1.conditions.join("_"),
		options$1.extensions.join("_"),
		options$1.mainFields.join("_")
	].join("|");
}
function findNearestNodeModules(basedir) {
	while (basedir) {
		const pkgPath = path.join(basedir, "node_modules");
		if (tryStatSync(pkgPath)?.isDirectory()) return pkgPath;
		const nextBasedir = path.dirname(basedir);
		if (nextBasedir === basedir) break;
		basedir = nextBasedir;
	}
	return null;
}
function watchPackageDataPlugin(packageCache) {
	const watchQueue = /* @__PURE__ */ new Set();
	const watchedDirs = /* @__PURE__ */ new Set();
	const watchFileStub = (id) => {
		watchQueue.add(id);
	};
	let watchFile = watchFileStub;
	const setPackageData = packageCache.set.bind(packageCache);
	packageCache.set = (id, pkg) => {
		if (!isInNodeModules(pkg.dir) && !watchedDirs.has(pkg.dir)) {
			watchedDirs.add(pkg.dir);
			watchFile(path.join(pkg.dir, "package.json"));
		}
		return setPackageData(id, pkg);
	};
	return {
		name: "vite:watch-package-data",
		buildStart() {
			watchFile = this.addWatchFile.bind(this);
			watchQueue.forEach(watchFile);
			watchQueue.clear();
		},
		buildEnd() {
			watchFile = watchFileStub;
		},
		watchChange(id) {
			if (id.endsWith("/package.json")) invalidatePackageData(packageCache, path.normalize(id));
		}
	};
}
/**
* Get cached `resolvePackageData` value based on `basedir`. When one is found,
* and we've already traversed some directories between `basedir` and `originalBasedir`,
* we cache the value for those in-between directories as well.
*
* This makes it so the fs is only read once for a shared `basedir`.
*/
function getRpdCache(packageCache, pkgName, basedir, originalBasedir, preserveSymlinks) {
	const cacheKey = getRpdCacheKey(pkgName, basedir, preserveSymlinks);
	const pkgData = packageCache.get(cacheKey);
	if (pkgData) {
		traverseBetweenDirs(originalBasedir, basedir, (dir) => {
			packageCache.set(getRpdCacheKey(pkgName, dir, preserveSymlinks), pkgData);
		});
		return pkgData;
	}
}
function setRpdCache(packageCache, pkgData, pkgName, basedir, originalBasedir, preserveSymlinks) {
	packageCache.set(getRpdCacheKey(pkgName, basedir, preserveSymlinks), pkgData);
	traverseBetweenDirs(originalBasedir, basedir, (dir) => {
		packageCache.set(getRpdCacheKey(pkgName, dir, preserveSymlinks), pkgData);
	});
}
function getRpdCacheKey(pkgName, basedir, preserveSymlinks) {
	return `rpd_${pkgName}_${basedir}_${preserveSymlinks}`;
}
/**
* Get cached `findNearestPackageData` value based on `basedir`. When one is found,
* and we've already traversed some directories between `basedir` and `originalBasedir`,
* we cache the value for those in-between directories as well.
*
* This makes it so the fs is only read once for a shared `basedir`.
*/
function getFnpdCache(packageCache, basedir, originalBasedir) {
	const cacheKey = getFnpdCacheKey(basedir);
	const pkgData = packageCache.get(cacheKey);
	if (pkgData) {
		traverseBetweenDirs(originalBasedir, basedir, (dir) => {
			packageCache.set(getFnpdCacheKey(dir), pkgData);
		});
		return pkgData;
	}
}
function setFnpdCache(packageCache, pkgData, basedir, originalBasedir) {
	packageCache.set(getFnpdCacheKey(basedir), pkgData);
	traverseBetweenDirs(originalBasedir, basedir, (dir) => {
		packageCache.set(getFnpdCacheKey(dir), pkgData);
	});
}
function getFnpdCacheKey(basedir) {
	return `fnpd_${basedir}`;
}
/**
* Traverse between `longerDir` (inclusive) and `shorterDir` (exclusive) and call `cb` for each dir.
* @param longerDir Longer dir path, e.g. `/User/foo/bar/baz`
* @param shorterDir Shorter dir path, e.g. `/User/foo`
*/
function traverseBetweenDirs(longerDir, shorterDir, cb) {
	while (longerDir !== shorterDir) {
		cb(longerDir);
		longerDir = path.dirname(longerDir);
	}
}

//#endregion
//#region src/node/utils.ts
var import_picocolors$33 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
var import_node = /* @__PURE__ */ __toESM(require_node$1(), 1);
const createFilter = createFilter$2;
const replaceSlashOrColonRE = /[/:]/g;
const replaceDotRE = /\./g;
const replaceNestedIdRE = /\s*>\s*/g;
const replaceHashRE = /#/g;
const flattenId = (id) => {
	return limitFlattenIdLength(id.replace(replaceSlashOrColonRE, "_").replace(replaceDotRE, "__").replace(replaceNestedIdRE, "___").replace(replaceHashRE, "____"));
};
const FLATTEN_ID_HASH_LENGTH = 8;
const FLATTEN_ID_MAX_FILE_LENGTH = 170;
const limitFlattenIdLength = (id, limit = FLATTEN_ID_MAX_FILE_LENGTH) => {
	if (id.length <= limit) return id;
	return id.slice(0, limit - (FLATTEN_ID_HASH_LENGTH + 1)) + "_" + getHash(id);
};
const normalizeId = (id) => id.replace(replaceNestedIdRE, " > ");
const NODE_BUILTIN_NAMESPACE = "node:";
const BUN_BUILTIN_NAMESPACE = "bun:";
const nodeBuiltins = builtinModules.filter((id) => !id.includes(":"));
const isBuiltinCache = /* @__PURE__ */ new WeakMap();
function isBuiltin(builtins, id) {
	let isBuiltin$1 = isBuiltinCache.get(builtins);
	if (!isBuiltin$1) {
		isBuiltin$1 = createIsBuiltin(builtins);
		isBuiltinCache.set(builtins, isBuiltin$1);
	}
	return isBuiltin$1(id);
}
function createIsBuiltin(builtins) {
	const plainBuiltinsSet = new Set(builtins.filter((builtin) => typeof builtin === "string"));
	const regexBuiltins = builtins.filter((builtin) => typeof builtin !== "string");
	return (id) => plainBuiltinsSet.has(id) || regexBuiltins.some((regexp) => regexp.test(id));
}
const nodeLikeBuiltins = [
	...nodeBuiltins,
	/* @__PURE__ */ new RegExp(`^${NODE_BUILTIN_NAMESPACE}`),
	/* @__PURE__ */ new RegExp(`^${BUN_BUILTIN_NAMESPACE}`)
];
function isNodeLikeBuiltin(id) {
	return isBuiltin(nodeLikeBuiltins, id);
}
function isNodeBuiltin(id) {
	if (id.startsWith(NODE_BUILTIN_NAMESPACE)) return true;
	return nodeBuiltins.includes(id);
}
function isInNodeModules(id) {
	return id.includes("node_modules");
}
function moduleListContains(moduleList, id) {
	return moduleList?.some((m$2) => m$2 === id || id.startsWith(withTrailingSlash(m$2)));
}
function isOptimizable(id, optimizeDeps$1) {
	const { extensions: extensions$1 } = optimizeDeps$1;
	return OPTIMIZABLE_ENTRY_RE.test(id) || (extensions$1?.some((ext) => id.endsWith(ext)) ?? false);
}
const bareImportRE = /^(?![a-zA-Z]:)[\w@](?!.*:\/\/)/;
const deepImportRE = /^([^@][^/]*)\/|^(@[^/]+\/[^/]+)\//;
const _require$1 = createRequire(
	/** #__KEEP__ */
	import.meta.url
);
const _dirname = path.dirname(fileURLToPath(
	/** #__KEEP__ */
	import.meta.url
));
const rollupVersion = resolvePackageData("rollup", _dirname, true)?.data.version ?? "";
const filter = process.env.VITE_DEBUG_FILTER;
const DEBUG = process.env.DEBUG;
function createDebugger(namespace, options$1 = {}) {
	const log$4 = (0, import_node.default)(namespace);
	const { onlyWhenFocused, depth } = options$1;
	if (depth && log$4.inspectOpts && log$4.inspectOpts.depth == null) log$4.inspectOpts.depth = options$1.depth;
	let enabled$1 = log$4.enabled;
	if (enabled$1 && onlyWhenFocused) enabled$1 = !!DEBUG?.includes(typeof onlyWhenFocused === "string" ? onlyWhenFocused : namespace);
	if (enabled$1) return (...args) => {
		if (!filter || args.some((a) => a?.includes?.(filter))) log$4(...args);
	};
}
function testCaseInsensitiveFS() {
	if (!CLIENT_ENTRY.endsWith("client.mjs")) throw new Error(`cannot test case insensitive FS, CLIENT_ENTRY const doesn't contain client.mjs`);
	if (!fs.existsSync(CLIENT_ENTRY)) throw new Error("cannot test case insensitive FS, CLIENT_ENTRY does not point to an existing file: " + CLIENT_ENTRY);
	return fs.existsSync(CLIENT_ENTRY.replace("client.mjs", "cLiEnT.mjs"));
}
const isCaseInsensitiveFS = testCaseInsensitiveFS();
const VOLUME_RE = /^[A-Z]:/i;
function normalizePath(id) {
	return path.posix.normalize(isWindows ? slash(id) : id);
}
function fsPathFromId(id) {
	const fsPath = normalizePath(id.startsWith(FS_PREFIX) ? id.slice(FS_PREFIX.length) : id);
	return fsPath[0] === "/" || VOLUME_RE.test(fsPath) ? fsPath : `/${fsPath}`;
}
function fsPathFromUrl(url$3) {
	return fsPathFromId(cleanUrl(url$3));
}
/**
* Check if dir is a parent of file
*
* Warning: parameters are not validated, only works with normalized absolute paths
*
* @param dir - normalized absolute path
* @param file - normalized absolute path
* @returns true if dir is a parent of file
*/
function isParentDirectory(dir, file) {
	dir = withTrailingSlash(dir);
	return file.startsWith(dir) || isCaseInsensitiveFS && file.toLowerCase().startsWith(dir.toLowerCase());
}
/**
* Check if 2 file name are identical
*
* Warning: parameters are not validated, only works with normalized absolute paths
*
* @param file1 - normalized absolute path
* @param file2 - normalized absolute path
* @returns true if both files url are identical
*/
function isSameFilePath(file1, file2) {
	return file1 === file2 || isCaseInsensitiveFS && file1.toLowerCase() === file2.toLowerCase();
}
const externalRE = /^([a-z]+:)?\/\//;
const isExternalUrl = (url$3) => externalRE.test(url$3);
const dataUrlRE = /^\s*data:/i;
const isDataUrl = (url$3) => dataUrlRE.test(url$3);
const virtualModuleRE = /^virtual-module:.*/;
const virtualModulePrefix = "virtual-module:";
const knownJsSrcRE = /\.(?:[jt]sx?|m[jt]s|vue|marko|svelte|astro|imba|mdx)(?:$|\?)/;
const isJSRequest = (url$3) => {
	url$3 = cleanUrl(url$3);
	if (knownJsSrcRE.test(url$3)) return true;
	if (!path.extname(url$3) && url$3[url$3.length - 1] !== "/") return true;
	return false;
};
const isCSSRequest = (request) => CSS_LANGS_RE.test(request);
const importQueryRE = /(\?|&)import=?(?:&|$)/;
const directRequestRE$1 = /(\?|&)direct=?(?:&|$)/;
const internalPrefixes = [
	FS_PREFIX,
	VALID_ID_PREFIX,
	CLIENT_PUBLIC_PATH,
	ENV_PUBLIC_PATH
];
const InternalPrefixRE = /* @__PURE__ */ new RegExp(`^(?:${internalPrefixes.join("|")})`);
const trailingSeparatorRE = /[?&]$/;
const isImportRequest = (url$3) => importQueryRE.test(url$3);
const isInternalRequest = (url$3) => InternalPrefixRE.test(url$3);
function removeImportQuery(url$3) {
	return url$3.replace(importQueryRE, "$1").replace(trailingSeparatorRE, "");
}
function removeDirectQuery(url$3) {
	return url$3.replace(directRequestRE$1, "$1").replace(trailingSeparatorRE, "");
}
const urlRE = /(\?|&)url(?:&|$)/;
const rawRE = /(\?|&)raw(?:&|$)/;
function removeUrlQuery(url$3) {
	return url$3.replace(urlRE, "$1").replace(trailingSeparatorRE, "");
}
function injectQuery(url$3, queryToInject) {
	const { file, postfix } = splitFileAndPostfix(url$3);
	return `${isWindows ? slash(file) : file}?${queryToInject}${postfix[0] === "?" ? `&${postfix.slice(1)}` : postfix}`;
}
const timestampRE = /\bt=\d{13}&?\b/;
function removeTimestampQuery(url$3) {
	return url$3.replace(timestampRE, "").replace(trailingSeparatorRE, "");
}
async function asyncReplace(input, re, replacer) {
	let match;
	let remaining = input;
	let rewritten = "";
	while (match = re.exec(remaining)) {
		rewritten += remaining.slice(0, match.index);
		rewritten += await replacer(match);
		remaining = remaining.slice(match.index + match[0].length);
	}
	rewritten += remaining;
	return rewritten;
}
function timeFrom(start, subtract = 0) {
	const time = performance$1.now() - start - subtract;
	const timeString = (time.toFixed(2) + `ms`).padEnd(5, " ");
	if (time < 10) return import_picocolors$33.default.green(timeString);
	else if (time < 50) return import_picocolors$33.default.yellow(timeString);
	else return import_picocolors$33.default.red(timeString);
}
/**
* pretty url for logging.
*/
function prettifyUrl(url$3, root) {
	url$3 = removeTimestampQuery(url$3);
	const isAbsoluteFile = url$3.startsWith(root);
	if (isAbsoluteFile || url$3.startsWith(FS_PREFIX)) {
		const file = path.posix.relative(root, isAbsoluteFile ? url$3 : fsPathFromId(url$3));
		return import_picocolors$33.default.dim(file);
	} else return import_picocolors$33.default.dim(url$3);
}
function isObject(value$1) {
	return Object.prototype.toString.call(value$1) === "[object Object]";
}
function isDefined(value$1) {
	return value$1 != null;
}
function tryStatSync(file) {
	try {
		return fs.statSync(file, { throwIfNoEntry: false });
	} catch {}
}
function lookupFile(dir, fileNames) {
	while (dir) {
		for (const fileName of fileNames) {
			const fullPath = path.join(dir, fileName);
			if (tryStatSync(fullPath)?.isFile()) return fullPath;
		}
		const parentDir$1 = path.dirname(dir);
		if (parentDir$1 === dir) return;
		dir = parentDir$1;
	}
}
function isFilePathESM(filePath, packageCache) {
	if (/\.m[jt]s$/.test(filePath)) return true;
	else if (/\.c[jt]s$/.test(filePath)) return false;
	else try {
		return findNearestPackageData(path.dirname(filePath), packageCache)?.data.type === "module";
	} catch {
		return false;
	}
}
const splitRE = /\r?\n/g;
const range = 2;
function pad$1(source, n$2 = 2) {
	return source.split(splitRE).map((l) => ` `.repeat(n$2) + l).join(`\n`);
}
function posToNumber(source, pos) {
	if (typeof pos === "number") return pos;
	const lines = source.split(splitRE);
	const { line, column } = pos;
	let start = 0;
	for (let i$1 = 0; i$1 < line - 1 && i$1 < lines.length; i$1++) start += lines[i$1].length + 1;
	return start + column;
}
function numberToPos(source, offset$1) {
	if (typeof offset$1 !== "number") return offset$1;
	if (offset$1 > source.length) throw new Error(`offset is longer than source length! offset ${offset$1} > length ${source.length}`);
	const lines = source.slice(0, offset$1).split(splitRE);
	return {
		line: lines.length,
		column: lines[lines.length - 1].length
	};
}
const MAX_DISPLAY_LEN = 120;
const ELLIPSIS = "...";
function generateCodeFrame(source, start = 0, end) {
	start = Math.max(posToNumber(source, start), 0);
	end = Math.min(end !== void 0 ? posToNumber(source, end) : start, source.length);
	const lastPosLine = end !== void 0 ? numberToPos(source, end).line : numberToPos(source, start).line + range;
	const lineNumberWidth = Math.max(3, String(lastPosLine).length + 1);
	const lines = source.split(splitRE);
	let count = 0;
	const res = [];
	for (let i$1 = 0; i$1 < lines.length; i$1++) {
		count += lines[i$1].length;
		if (count >= start) {
			for (let j = i$1 - range; j <= i$1 + range || end > count; j++) {
				if (j < 0 || j >= lines.length) continue;
				const line = j + 1;
				const lineLength = lines[j].length;
				const pad$2 = Math.max(start - (count - lineLength), 0);
				const underlineLength = Math.max(1, end > count ? lineLength - pad$2 : end - start);
				let displayLine = lines[j];
				let underlinePad = pad$2;
				if (lineLength > MAX_DISPLAY_LEN) {
					let startIdx = 0;
					if (j === i$1) {
						if (underlineLength > MAX_DISPLAY_LEN) startIdx = pad$2;
						else {
							const center = pad$2 + Math.floor(underlineLength / 2);
							startIdx = Math.max(0, center - Math.floor(MAX_DISPLAY_LEN / 2));
						}
						underlinePad = Math.max(0, pad$2 - startIdx) + (startIdx > 0 ? 3 : 0);
					}
					const prefix = startIdx > 0 ? ELLIPSIS : "";
					const suffix = lineLength - startIdx > MAX_DISPLAY_LEN ? ELLIPSIS : "";
					const sliceLen = MAX_DISPLAY_LEN - prefix.length - suffix.length;
					displayLine = prefix + displayLine.slice(startIdx, startIdx + sliceLen) + suffix;
				}
				res.push(`${line}${" ".repeat(lineNumberWidth - String(line).length)}|  ${displayLine}`);
				if (j === i$1) {
					const underline = "^".repeat(Math.min(underlineLength, MAX_DISPLAY_LEN));
					res.push(`${" ".repeat(lineNumberWidth)}|  ` + " ".repeat(underlinePad) + underline);
				} else if (j > i$1) {
					if (end > count) {
						const length = Math.max(Math.min(end - count, lineLength), 1);
						const underline = "^".repeat(Math.min(length, MAX_DISPLAY_LEN));
						res.push(`${" ".repeat(lineNumberWidth)}|  ` + underline);
					}
					count += lineLength + 1;
				}
			}
			break;
		}
		count++;
	}
	return res.join("\n");
}
function isFileReadable(filename) {
	if (!tryStatSync(filename)) return false;
	try {
		fs.accessSync(filename, fs.constants.R_OK);
		return true;
	} catch {
		return false;
	}
}
const splitFirstDirRE = /(.+?)[\\/](.+)/;
/**
* Delete every file and subdirectory. **The given directory must exist.**
* Pass an optional `skip` array to preserve files under the root directory.
*/
function emptyDir(dir, skip) {
	const skipInDir = [];
	let nested = null;
	if (skip?.length) for (const file of skip) if (path.dirname(file) !== ".") {
		const matched = splitFirstDirRE.exec(file);
		if (matched) {
			nested ??= /* @__PURE__ */ new Map();
			const [, nestedDir, skipPath] = matched;
			let nestedSkip = nested.get(nestedDir);
			if (!nestedSkip) {
				nestedSkip = [];
				nested.set(nestedDir, nestedSkip);
			}
			if (!nestedSkip.includes(skipPath)) nestedSkip.push(skipPath);
		}
	} else skipInDir.push(file);
	for (const file of fs.readdirSync(dir)) {
		if (skipInDir.includes(file)) continue;
		if (nested?.has(file)) emptyDir(path.resolve(dir, file), nested.get(file));
		else fs.rmSync(path.resolve(dir, file), {
			recursive: true,
			force: true
		});
	}
}
function copyDir(srcDir, destDir) {
	fs.mkdirSync(destDir, { recursive: true });
	for (const file of fs.readdirSync(srcDir)) {
		const srcFile = path.resolve(srcDir, file);
		if (srcFile === destDir) continue;
		const destFile = path.resolve(destDir, file);
		if (fs.statSync(srcFile).isDirectory()) copyDir(srcFile, destFile);
		else fs.copyFileSync(srcFile, destFile);
	}
}
const ERR_SYMLINK_IN_RECURSIVE_READDIR = "ERR_SYMLINK_IN_RECURSIVE_READDIR";
async function recursiveReaddir(dir) {
	if (!fs.existsSync(dir)) return [];
	let dirents;
	try {
		dirents = await fsp.readdir(dir, { withFileTypes: true });
	} catch (e$1) {
		if (e$1.code === "EACCES") return [];
		throw e$1;
	}
	if (dirents.some((dirent) => dirent.isSymbolicLink())) {
		const err$2 = /* @__PURE__ */ new Error("Symbolic links are not supported in recursiveReaddir");
		err$2.code = ERR_SYMLINK_IN_RECURSIVE_READDIR;
		throw err$2;
	}
	return (await Promise.all(dirents.map((dirent) => {
		const res = path.resolve(dir, dirent.name);
		return dirent.isDirectory() ? recursiveReaddir(res) : normalizePath(res);
	}))).flat(1);
}
let safeRealpathSync = isWindows ? windowsSafeRealPathSync : fs.realpathSync.native;
const windowsNetworkMap = /* @__PURE__ */ new Map();
function windowsMappedRealpathSync(path$13) {
	const realPath = fs.realpathSync.native(path$13);
	if (realPath.startsWith("\\\\")) {
		for (const [network, volume] of windowsNetworkMap) if (realPath.startsWith(network)) return realPath.replace(network, volume);
	}
	return realPath;
}
const parseNetUseRE = /^\w* +(\w:) +([^ ]+)\s/;
let firstSafeRealPathSyncRun = false;
function windowsSafeRealPathSync(path$13) {
	if (!firstSafeRealPathSyncRun) {
		optimizeSafeRealPathSync();
		firstSafeRealPathSyncRun = true;
	}
	return fs.realpathSync(path$13);
}
function optimizeSafeRealPathSync() {
	try {
		fs.realpathSync.native(path.resolve("./"));
	} catch (error$1) {
		if (error$1.message.includes("EISDIR: illegal operation on a directory")) {
			safeRealpathSync = fs.realpathSync;
			return;
		}
	}
	exec("net use", (error$1, stdout) => {
		if (error$1) return;
		const lines = stdout.split("\n");
		for (const line of lines) {
			const m$2 = parseNetUseRE.exec(line);
			if (m$2) windowsNetworkMap.set(m$2[2], m$2[1]);
		}
		if (windowsNetworkMap.size === 0) safeRealpathSync = fs.realpathSync.native;
		else safeRealpathSync = windowsMappedRealpathSync;
	});
}
function ensureWatchedFile(watcher, file, root) {
	if (file && !file.startsWith(withTrailingSlash(root)) && !file.includes("\0") && fs.existsSync(file)) watcher.add(path.resolve(file));
}
function joinSrcset(ret) {
	return ret.map(({ url: url$3, descriptor }) => url$3 + (descriptor ? ` ${descriptor}` : "")).join(", ");
}
/**
This regex represents a loose rule of an “image candidate string” and "image set options".

@see https://html.spec.whatwg.org/multipage/images.html#srcset-attribute
@see https://drafts.csswg.org/css-images-4/#image-set-notation

The Regex has named capturing groups `url` and `descriptor`.
The `url` group can be:
* any CSS function
* CSS string (single or double-quoted)
* URL string (unquoted)
The `descriptor` is anything after the space and before the comma.
*/
const imageCandidateRegex = /(?:^|\s|(?<=,))(?<url>[\w-]+\([^)]*\)|"[^"]*"|'[^']*'|[^,]\S*[^,])\s*(?:\s(?<descriptor>\w[^,]+))?(?:,|$)/g;
const escapedSpaceCharacters = /(?: |\\t|\\n|\\f|\\r)+/g;
function parseSrcset(string) {
	const matches$2 = string.trim().replace(escapedSpaceCharacters, " ").replace(/\r?\n/, "").replace(/,\s+/, ", ").replaceAll(/\s+/g, " ").matchAll(imageCandidateRegex);
	return Array.from(matches$2, ({ groups: groups$1 }) => ({
		url: groups$1?.url?.trim() ?? "",
		descriptor: groups$1?.descriptor?.trim() ?? ""
	})).filter(({ url: url$3 }) => !!url$3);
}
function processSrcSet(srcs, replacer) {
	return Promise.all(parseSrcset(srcs).map(async ({ url: url$3, descriptor }) => ({
		url: await replacer({
			url: url$3,
			descriptor
		}),
		descriptor
	}))).then(joinSrcset);
}
function processSrcSetSync(srcs, replacer) {
	return joinSrcset(parseSrcset(srcs).map(({ url: url$3, descriptor }) => ({
		url: replacer({
			url: url$3,
			descriptor
		}),
		descriptor
	})));
}
const windowsDriveRE = /^[A-Z]:/;
const replaceWindowsDriveRE = /^([A-Z]):\//;
const linuxAbsolutePathRE = /^\/[^/]/;
function escapeToLinuxLikePath(path$13) {
	if (windowsDriveRE.test(path$13)) return path$13.replace(replaceWindowsDriveRE, "/windows/$1/");
	if (linuxAbsolutePathRE.test(path$13)) return `/linux${path$13}`;
	return path$13;
}
const revertWindowsDriveRE = /^\/windows\/([A-Z])\//;
function unescapeToLinuxLikePath(path$13) {
	if (path$13.startsWith("/linux/")) return path$13.slice(6);
	if (path$13.startsWith("/windows/")) return path$13.replace(revertWindowsDriveRE, "$1:/");
	return path$13;
}
const nullSourceMap = {
	names: [],
	sources: [],
	mappings: "",
	version: 3
};
/**
* Combines multiple sourcemaps into a single sourcemap.
* Note that the length of sourcemapList must be 2.
*/
function combineSourcemaps(filename, sourcemapList) {
	if (sourcemapList.length === 0 || sourcemapList.every((m$2) => m$2.sources.length === 0)) return { ...nullSourceMap };
	sourcemapList = sourcemapList.map((sourcemap) => {
		const newSourcemaps = { ...sourcemap };
		newSourcemaps.sources = sourcemap.sources.map((source) => source ? escapeToLinuxLikePath(source) : null);
		if (sourcemap.sourceRoot) newSourcemaps.sourceRoot = escapeToLinuxLikePath(sourcemap.sourceRoot);
		return newSourcemaps;
	});
	const escapedFilename = escapeToLinuxLikePath(filename);
	let map$1;
	let mapIndex = 1;
	if (sourcemapList.slice(0, -1).find((m$2) => m$2.sources.length !== 1) === void 0) map$1 = remapping(sourcemapList, () => null);
	else map$1 = remapping(sourcemapList[0], function loader$1(sourcefile) {
		if (sourcefile === escapedFilename && sourcemapList[mapIndex]) return sourcemapList[mapIndex++];
		else return null;
	});
	if (!map$1.file) delete map$1.file;
	map$1.sources = map$1.sources.map((source) => source ? unescapeToLinuxLikePath(source) : source);
	map$1.file = filename;
	return map$1;
}
function unique(arr) {
	return Array.from(new Set(arr));
}
/**
* Returns resolved localhost address when `dns.lookup` result differs from DNS
*
* `dns.lookup` result is same when defaultResultOrder is `verbatim`.
* Even if defaultResultOrder is `ipv4first`, `dns.lookup` result maybe same.
* For example, when IPv6 is not supported on that machine/network.
*/
async function getLocalhostAddressIfDiffersFromDNS() {
	const [nodeResult, dnsResult] = await Promise.all([promises$1.lookup("localhost"), promises$1.lookup("localhost", { verbatim: true })]);
	return nodeResult.family === dnsResult.family && nodeResult.address === dnsResult.address ? void 0 : nodeResult.address;
}
function diffDnsOrderChange(oldUrls, newUrls) {
	return !(oldUrls === newUrls || oldUrls && newUrls && arrayEqual(oldUrls.local, newUrls.local) && arrayEqual(oldUrls.network, newUrls.network));
}
async function resolveHostname(optionsHost) {
	let host;
	if (optionsHost === void 0 || optionsHost === false) host = "localhost";
	else if (optionsHost === true) host = void 0;
	else host = optionsHost;
	let name = host === void 0 || wildcardHosts.has(host) ? "localhost" : host;
	if (host === "localhost") {
		const localhostAddr = await getLocalhostAddressIfDiffersFromDNS();
		if (localhostAddr) name = localhostAddr;
	}
	return {
		host,
		name
	};
}
function resolveServerUrls(server, options$1, hostname, httpsOptions, config$2) {
	const address = server.address();
	const isAddressInfo = (x) => x?.address;
	if (!isAddressInfo(address)) return {
		local: [],
		network: []
	};
	const local = [];
	const network = [];
	const protocol = options$1.https ? "https" : "http";
	const port = address.port;
	const base = config$2.rawBase === "./" || config$2.rawBase === "" ? "/" : config$2.rawBase;
	if (hostname.host !== void 0 && !wildcardHosts.has(hostname.host)) {
		let hostnameName = hostname.name;
		if (hostnameName.includes(":")) hostnameName = `[${hostnameName}]`;
		const address$1 = `${protocol}://${hostnameName}:${port}${base}`;
		if (loopbackHosts.has(hostname.host)) local.push(address$1);
		else network.push(address$1);
	} else Object.values(os.networkInterfaces()).flatMap((nInterface) => nInterface ?? []).filter((detail) => detail.address && detail.family === "IPv4").forEach((detail) => {
		let host = detail.address.replace("127.0.0.1", hostname.name);
		if (host.includes(":")) host = `[${host}]`;
		const url$3 = `${protocol}://${host}:${port}${base}`;
		if (detail.address.includes("127.0.0.1")) local.push(url$3);
		else network.push(url$3);
	});
	const cert = httpsOptions?.cert && !Array.isArray(httpsOptions.cert) ? new crypto.X509Certificate(httpsOptions.cert) : void 0;
	const hostnameFromCert = cert?.subjectAltName ? extractHostnamesFromSubjectAltName(cert.subjectAltName) : [];
	if (hostnameFromCert.length > 0) {
		const existings = new Set([...local, ...network]);
		local.push(...hostnameFromCert.map((hostname$1) => `https://${hostname$1}:${port}${base}`).filter((url$3) => !existings.has(url$3)));
	}
	return {
		local,
		network
	};
}
function extractHostnamesFromSubjectAltName(subjectAltName) {
	const hostnames = [];
	let remaining = subjectAltName;
	while (remaining) {
		const nameEndIndex = remaining.indexOf(":");
		const name = remaining.slice(0, nameEndIndex);
		remaining = remaining.slice(nameEndIndex + 1);
		if (!remaining) break;
		const isQuoted = remaining[0] === "\"";
		let value$1;
		if (isQuoted) {
			const endQuoteIndex = remaining.indexOf("\"", 1);
			value$1 = JSON.parse(remaining.slice(0, endQuoteIndex + 1));
			remaining = remaining.slice(endQuoteIndex + 1);
		} else {
			const maybeEndIndex = remaining.indexOf(",");
			const endIndex = maybeEndIndex === -1 ? remaining.length : maybeEndIndex;
			value$1 = remaining.slice(0, endIndex);
			remaining = remaining.slice(endIndex);
		}
		remaining = remaining.slice(1).trimStart();
		if (name === "DNS" && value$1 !== "[::1]" && !(value$1.startsWith("*.") && net.isIPv4(value$1.slice(2)))) hostnames.push(value$1.replace("*", "vite"));
	}
	return hostnames;
}
function arraify(target) {
	return Array.isArray(target) ? target : [target];
}
const multilineCommentsRE = /\/\*[^*]*\*+(?:[^/*][^*]*\*+)*\//g;
const singlelineCommentsRE = /\/\/.*/g;
const requestQuerySplitRE = /\?(?!.*[/|}])/;
const requestQueryMaybeEscapedSplitRE = /\\?\?(?!.*[/|}])/;
const blankReplacer = (match) => " ".repeat(match.length);
function getHash(text, length = 8) {
	const h$2 = crypto.hash("sha256", text, "hex").substring(0, length);
	if (length <= 64) return h$2;
	return h$2.padEnd(length, "_");
}
const requireResolveFromRootWithFallback = (root, id) => {
	if (!(resolvePackageData(id, root) || resolvePackageData(id, _dirname))) {
		const error$1 = /* @__PURE__ */ new Error(`${JSON.stringify(id)} not found.`);
		error$1.code = "MODULE_NOT_FOUND";
		throw error$1;
	}
	return _require$1.resolve(id, { paths: [root, _dirname] });
};
function emptyCssComments(raw) {
	return raw.replace(multilineCommentsRE, blankReplacer);
}
function backwardCompatibleWorkerPlugins(plugins$1) {
	if (Array.isArray(plugins$1)) return plugins$1;
	if (typeof plugins$1 === "function") return plugins$1();
	return [];
}
function deepClone(value$1) {
	if (Array.isArray(value$1)) return value$1.map((v) => deepClone(v));
	if (isObject(value$1)) {
		const cloned = {};
		for (const key in value$1) cloned[key] = deepClone(value$1[key]);
		return cloned;
	}
	if (typeof value$1 === "function") return value$1;
	if (value$1 instanceof RegExp) return new RegExp(value$1);
	if (typeof value$1 === "object" && value$1 != null) throw new Error("Cannot deep clone non-plain object");
	return value$1;
}
function mergeWithDefaultsRecursively(defaults, values) {
	const merged = defaults;
	for (const key in values) {
		const value$1 = values[key];
		if (value$1 === void 0) continue;
		const existing = merged[key];
		if (existing === void 0) {
			merged[key] = value$1;
			continue;
		}
		if (isObject(existing) && isObject(value$1)) {
			merged[key] = mergeWithDefaultsRecursively(existing, value$1);
			continue;
		}
		merged[key] = value$1;
	}
	return merged;
}
const environmentPathRE = /^environments\.[^.]+$/;
function mergeWithDefaults(defaults, values) {
	return mergeWithDefaultsRecursively(deepClone(defaults), values);
}
function mergeConfigRecursively(defaults, overrides, rootPath) {
	const merged = { ...defaults };
	for (const key in overrides) {
		const value$1 = overrides[key];
		if (value$1 == null) continue;
		const existing = merged[key];
		if (existing == null) {
			merged[key] = value$1;
			continue;
		}
		if (key === "alias" && (rootPath === "resolve" || rootPath === "")) {
			merged[key] = mergeAlias(existing, value$1);
			continue;
		} else if (key === "assetsInclude" && rootPath === "") {
			merged[key] = [].concat(existing, value$1);
			continue;
		} else if ((key === "noExternal" && (rootPath === "ssr" || rootPath === "resolve") || key === "allowedHosts" && rootPath === "server") && (existing === true || value$1 === true)) {
			merged[key] = true;
			continue;
		} else if (key === "plugins" && rootPath === "worker") {
			merged[key] = () => [...backwardCompatibleWorkerPlugins(existing), ...backwardCompatibleWorkerPlugins(value$1)];
			continue;
		} else if (key === "server" && rootPath === "server.hmr") {
			merged[key] = value$1;
			continue;
		}
		if (Array.isArray(existing) || Array.isArray(value$1)) {
			merged[key] = [...arraify(existing), ...arraify(value$1)];
			continue;
		}
		if (isObject(existing) && isObject(value$1)) {
			merged[key] = mergeConfigRecursively(existing, value$1, rootPath && !environmentPathRE.test(rootPath) ? `${rootPath}.${key}` : key);
			continue;
		}
		merged[key] = value$1;
	}
	return merged;
}
function mergeConfig(defaults, overrides, isRoot = true) {
	if (typeof defaults === "function" || typeof overrides === "function") throw new Error(`Cannot merge config in form of callback`);
	return mergeConfigRecursively(defaults, overrides, isRoot ? "" : ".");
}
function mergeAlias(a, b) {
	if (!a) return b;
	if (!b) return a;
	if (isObject(a) && isObject(b)) return {
		...a,
		...b
	};
	return [...normalizeAlias(b), ...normalizeAlias(a)];
}
function normalizeAlias(o$1 = []) {
	return Array.isArray(o$1) ? o$1.map(normalizeSingleAlias) : Object.keys(o$1).map((find$1) => normalizeSingleAlias({
		find: find$1,
		replacement: o$1[find$1]
	}));
}
function normalizeSingleAlias({ find: find$1, replacement, customResolver }) {
	if (typeof find$1 === "string" && find$1.endsWith("/") && replacement.endsWith("/")) {
		find$1 = find$1.slice(0, find$1.length - 1);
		replacement = replacement.slice(0, replacement.length - 1);
	}
	const alias$2 = {
		find: find$1,
		replacement
	};
	if (customResolver) alias$2.customResolver = customResolver;
	return alias$2;
}
/**
* Transforms transpiled code result where line numbers aren't altered,
* so we can skip sourcemap generation during dev
*/
function transformStableResult(s$2, id, config$2) {
	return {
		code: s$2.toString(),
		map: config$2.command === "build" && config$2.build.sourcemap ? s$2.generateMap({
			hires: "boundary",
			source: id
		}) : null
	};
}
async function asyncFlatten(arr) {
	do
		arr = (await Promise.all(arr)).flat(Infinity);
	while (arr.some((v) => v?.then));
	return arr;
}
function stripBomTag(content) {
	if (content.charCodeAt(0) === 65279) return content.slice(1);
	return content;
}
const windowsDrivePathPrefixRE = /^[A-Za-z]:[/\\]/;
/**
* path.isAbsolute also returns true for drive relative paths on windows (e.g. /something)
* this function returns false for them but true for absolute paths (e.g. C:/something)
*/
const isNonDriveRelativeAbsolutePath = (p) => {
	if (!isWindows) return p[0] === "/";
	return windowsDrivePathPrefixRE.test(p);
};
/**
* Determine if a file is being requested with the correct case, to ensure
* consistent behavior between dev and prod and across operating systems.
*/
function shouldServeFile(filePath, root) {
	if (!isCaseInsensitiveFS) return true;
	return hasCorrectCase(filePath, root);
}
/**
* Note that we can't use realpath here, because we don't want to follow
* symlinks.
*/
function hasCorrectCase(file, assets) {
	if (file === assets) return true;
	const parent = path.dirname(file);
	if (fs.readdirSync(parent).includes(path.basename(file))) return hasCorrectCase(parent, assets);
	return false;
}
function joinUrlSegments(a, b) {
	if (!a || !b) return a || b || "";
	if (a.endsWith("/")) a = a.substring(0, a.length - 1);
	if (b[0] !== "/") b = "/" + b;
	return a + b;
}
function removeLeadingSlash(str) {
	return str[0] === "/" ? str.slice(1) : str;
}
function stripBase(path$13, base) {
	if (path$13 === base) return "/";
	const devBase = withTrailingSlash(base);
	return path$13.startsWith(devBase) ? path$13.slice(devBase.length - 1) : path$13;
}
function arrayEqual(a, b) {
	if (a === b) return true;
	if (a.length !== b.length) return false;
	for (let i$1 = 0; i$1 < a.length; i$1++) if (a[i$1] !== b[i$1]) return false;
	return true;
}
function evalValue(rawValue) {
	return new Function(`
    var console, exports, global, module, process, require
    return (\n${rawValue}\n)
  `)();
}
function getNpmPackageName(importPath) {
	const parts = importPath.split("/");
	if (parts[0][0] === "@") {
		if (!parts[1]) return null;
		return `${parts[0]}/${parts[1]}`;
	} else return parts[0];
}
function getPkgName(name) {
	return name[0] === "@" ? name.split("/")[1] : name;
}
const escapeRegexRE$1 = /[-/\\^$*+?.()|[\]{}]/g;
function escapeRegex(str) {
	return str.replace(escapeRegexRE$1, "\\$&");
}
function getPackageManagerCommand(type = "install") {
	const packageManager = process.env.npm_config_user_agent?.split(" ")[0].split("/")[0] || "npm";
	switch (type) {
		case "install": return packageManager === "npm" ? "npm install" : `${packageManager} add`;
		case "uninstall": return packageManager === "npm" ? "npm uninstall" : `${packageManager} remove`;
		case "update": return packageManager === "yarn" ? "yarn upgrade" : `${packageManager} update`;
		default: throw new TypeError(`Unknown command type: ${type}`);
	}
}
function isDevServer(server) {
	return "pluginContainer" in server;
}
function createSerialPromiseQueue() {
	let previousTask;
	return { async run(f$1) {
		const thisTask = f$1();
		const depTasks = Promise.all([previousTask, thisTask]);
		previousTask = depTasks;
		const [, result] = await depTasks;
		if (previousTask === depTasks) previousTask = void 0;
		return result;
	} };
}
function sortObjectKeys(obj) {
	const sorted = {};
	for (const key of Object.keys(obj).sort()) sorted[key] = obj[key];
	return sorted;
}
function displayTime(time) {
	if (time < 1e3) return `${time}ms`;
	time = time / 1e3;
	if (time < 60) return `${time.toFixed(2)}s`;
	const mins = Math.floor(time / 60);
	const seconds = Math.round(time % 60);
	if (seconds === 60) return `${mins + 1}m`;
	return `${mins}m${seconds < 1 ? "" : ` ${seconds}s`}`;
}
/**
* Encodes the URI path portion (ignores part after ? or #)
*/
function encodeURIPath(uri) {
	if (uri.startsWith("data:")) return uri;
	const filePath = cleanUrl(uri);
	const postfix = filePath !== uri ? uri.slice(filePath.length) : "";
	return encodeURI(filePath) + postfix;
}
/**
* Like `encodeURIPath`, but only replacing `%` as `%25`. This is useful for environments
* that can handle un-encoded URIs, where `%` is the only ambiguous character.
*/
function partialEncodeURIPath(uri) {
	if (uri.startsWith("data:")) return uri;
	const filePath = cleanUrl(uri);
	const postfix = filePath !== uri ? uri.slice(filePath.length) : "";
	return filePath.replaceAll("%", "%25") + postfix;
}
function decodeURIIfPossible(input) {
	try {
		return decodeURI(input);
	} catch {
		return;
	}
}
const sigtermCallbacks = /* @__PURE__ */ new Set();
const parentSigtermCallback = async (signal, exitCode) => {
	await Promise.all([...sigtermCallbacks].map((cb) => cb(signal, exitCode)));
};
const setupSIGTERMListener = (callback) => {
	if (sigtermCallbacks.size === 0) {
		process.once("SIGTERM", parentSigtermCallback);
		if (process.env.CI !== "true") process.stdin.on("end", parentSigtermCallback);
	}
	sigtermCallbacks.add(callback);
};
const teardownSIGTERMListener = (callback) => {
	sigtermCallbacks.delete(callback);
	if (sigtermCallbacks.size === 0) {
		process.off("SIGTERM", parentSigtermCallback);
		if (process.env.CI !== "true") process.stdin.off("end", parentSigtermCallback);
	}
};
function getServerUrlByHost(resolvedUrls, host) {
	if (typeof host === "string") {
		const matchedUrl = [...resolvedUrls?.local ?? [], ...resolvedUrls?.network ?? []].find((url$3) => url$3.includes(host));
		if (matchedUrl) return matchedUrl;
	}
	return resolvedUrls?.local[0] ?? resolvedUrls?.network[0];
}
let lastDateNow = 0;
/**
* Similar to `Date.now()`, but strictly monotonically increasing.
*
* This function will never return the same value.
* Thus, the value may differ from the actual time.
*
* related: https://github.com/vitejs/vite/issues/19804
*/
function monotonicDateNow() {
	const now = Date.now();
	if (now > lastDateNow) {
		lastDateNow = now;
		return lastDateNow;
	}
	lastDateNow++;
	return lastDateNow;
}

//#endregion
//#region src/node/plugin.ts
async function resolveEnvironmentPlugins(environment) {
	const environmentPlugins = [];
	for (const plugin of environment.getTopLevelConfig().plugins) {
		if (plugin.applyToEnvironment) {
			const applied = await plugin.applyToEnvironment(environment);
			if (!applied) continue;
			if (applied !== true) {
				environmentPlugins.push(...(await asyncFlatten(arraify(applied))).filter(Boolean));
				continue;
			}
		}
		environmentPlugins.push(plugin);
	}
	return environmentPlugins;
}
/**
* @experimental
*/
function perEnvironmentPlugin(name, applyToEnvironment) {
	return {
		name,
		applyToEnvironment
	};
}

//#endregion
//#region ../../node_modules/.pnpm/commondir@1.0.1/node_modules/commondir/index.js
var require_commondir = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/commondir@1.0.1/node_modules/commondir/index.js": ((exports, module) => {
	var path$12 = __require("path");
	module.exports = function(basedir, relfiles) {
		if (relfiles) var files = relfiles.map(function(r$1) {
			return path$12.resolve(basedir, r$1);
		});
		else var files = basedir;
		var res = files.slice(1).reduce(function(ps, file) {
			if (!file.match(/^([A-Za-z]:)?\/|\\/)) throw new Error("relative path without a basedir");
			var xs = file.split(/\/+|\\+/);
			for (var i$1 = 0; ps[i$1] === xs[i$1] && i$1 < Math.min(ps.length, xs.length); i$1++);
			return ps.slice(0, i$1);
		}, files[0].split(/\/+|\\+/));
		return res.length > 1 ? res.join("/") : "/";
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/magic-string@0.30.19/node_modules/magic-string/dist/magic-string.es.mjs
var BitSet = class BitSet {
	constructor(arg) {
		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
	}
	add(n$2) {
		this.bits[n$2 >> 5] |= 1 << (n$2 & 31);
	}
	has(n$2) {
		return !!(this.bits[n$2 >> 5] & 1 << (n$2 & 31));
	}
};
var Chunk = class Chunk {
	constructor(start, end, content) {
		this.start = start;
		this.end = end;
		this.original = content;
		this.intro = "";
		this.outro = "";
		this.content = content;
		this.storeName = false;
		this.edited = false;
		this.previous = null;
		this.next = null;
	}
	appendLeft(content) {
		this.outro += content;
	}
	appendRight(content) {
		this.intro = this.intro + content;
	}
	clone() {
		const chunk = new Chunk(this.start, this.end, this.original);
		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;
		return chunk;
	}
	contains(index) {
		return this.start < index && index < this.end;
	}
	eachNext(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.next;
		}
	}
	eachPrevious(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.previous;
		}
	}
	edit(content, storeName, contentOnly) {
		this.content = content;
		if (!contentOnly) {
			this.intro = "";
			this.outro = "";
		}
		this.storeName = storeName;
		this.edited = true;
		return this;
	}
	prependLeft(content) {
		this.outro = content + this.outro;
	}
	prependRight(content) {
		this.intro = content + this.intro;
	}
	reset() {
		this.intro = "";
		this.outro = "";
		if (this.edited) {
			this.content = this.original;
			this.storeName = false;
			this.edited = false;
		}
	}
	split(index) {
		const sliceIndex = index - this.start;
		const originalBefore = this.original.slice(0, sliceIndex);
		const originalAfter = this.original.slice(sliceIndex);
		this.original = originalBefore;
		const newChunk = new Chunk(index, this.end, originalAfter);
		newChunk.outro = this.outro;
		this.outro = "";
		this.end = index;
		if (this.edited) {
			newChunk.edit("", false);
			this.content = "";
		} else this.content = originalBefore;
		newChunk.next = this.next;
		if (newChunk.next) newChunk.next.previous = newChunk;
		newChunk.previous = this;
		this.next = newChunk;
		return newChunk;
	}
	toString() {
		return this.intro + this.content + this.outro;
	}
	trimEnd(rx) {
		this.outro = this.outro.replace(rx, "");
		if (this.outro.length) return true;
		const trimmed = this.content.replace(rx, "");
		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.start + trimmed.length).edit("", void 0, true);
				if (this.edited) this.edit(trimmed, this.storeName, true);
			}
			return true;
		} else {
			this.edit("", void 0, true);
			this.intro = this.intro.replace(rx, "");
			if (this.intro.length) return true;
		}
	}
	trimStart(rx) {
		this.intro = this.intro.replace(rx, "");
		if (this.intro.length) return true;
		const trimmed = this.content.replace(rx, "");
		if (trimmed.length) {
			if (trimmed !== this.content) {
				const newChunk = this.split(this.end - trimmed.length);
				if (this.edited) newChunk.edit(trimmed, this.storeName, true);
				this.edit("", void 0, true);
			}
			return true;
		} else {
			this.edit("", void 0, true);
			this.outro = this.outro.replace(rx, "");
			if (this.outro.length) return true;
		}
	}
};
function getBtoa() {
	if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
	else if (typeof Buffer === "function") return (str) => Buffer.from(str, "utf-8").toString("base64");
	else return () => {
		throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
	};
}
const btoa$1 = /* @__PURE__ */ getBtoa();
var SourceMap = class {
	constructor(properties) {
		this.version = 3;
		this.file = properties.file;
		this.sources = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names = properties.names;
		this.mappings = encode$1(properties.mappings);
		if (typeof properties.x_google_ignoreList !== "undefined") this.x_google_ignoreList = properties.x_google_ignoreList;
		if (typeof properties.debugId !== "undefined") this.debugId = properties.debugId;
	}
	toString() {
		return JSON.stringify(this);
	}
	toUrl() {
		return "data:application/json;charset=utf-8;base64," + btoa$1(this.toString());
	}
};
function guessIndent(code) {
	const lines = code.split("\n");
	const tabbed = lines.filter((line) => /^\t+/.test(line));
	const spaced = lines.filter((line) => /^ {2,}/.test(line));
	if (tabbed.length === 0 && spaced.length === 0) return null;
	if (tabbed.length >= spaced.length) return "	";
	const min$1 = spaced.reduce((previous, current) => {
		const numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);
	return new Array(min$1 + 1).join(" ");
}
function getRelativePath(from, to) {
	const fromParts = from.split(/[/\\]/);
	const toParts = to.split(/[/\\]/);
	fromParts.pop();
	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}
	if (fromParts.length) {
		let i$1 = fromParts.length;
		while (i$1--) fromParts[i$1] = "..";
	}
	return fromParts.concat(toParts).join("/");
}
const toString$1 = Object.prototype.toString;
function isObject$2(thing) {
	return toString$1.call(thing) === "[object Object]";
}
function getLocator(source) {
	const originalLines = source.split("\n");
	const lineOffsets = [];
	for (let i$1 = 0, pos = 0; i$1 < originalLines.length; i$1++) {
		lineOffsets.push(pos);
		pos += originalLines[i$1].length + 1;
	}
	return function locate(index) {
		let i$1 = 0;
		let j = lineOffsets.length;
		while (i$1 < j) {
			const m$2 = i$1 + j >> 1;
			if (index < lineOffsets[m$2]) j = m$2;
			else i$1 = m$2 + 1;
		}
		const line = i$1 - 1;
		return {
			line,
			column: index - lineOffsets[line]
		};
	};
}
const wordRegex = /\w/;
var Mappings = class {
	constructor(hires) {
		this.hires = hires;
		this.generatedCodeLine = 0;
		this.generatedCodeColumn = 0;
		this.raw = [];
		this.rawSegments = this.raw[this.generatedCodeLine] = [];
		this.pending = null;
	}
	addEdit(sourceIndex, content, loc, nameIndex) {
		if (content.length) {
			const contentLengthMinusOne = content.length - 1;
			let contentLineEnd = content.indexOf("\n", 0);
			let previousContentLineEnd = -1;
			while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
				const segment$1 = [
					this.generatedCodeColumn,
					sourceIndex,
					loc.line,
					loc.column
				];
				if (nameIndex >= 0) segment$1.push(nameIndex);
				this.rawSegments.push(segment$1);
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				previousContentLineEnd = contentLineEnd;
				contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
			}
			const segment = [
				this.generatedCodeColumn,
				sourceIndex,
				loc.line,
				loc.column
			];
			if (nameIndex >= 0) segment.push(nameIndex);
			this.rawSegments.push(segment);
			this.advance(content.slice(previousContentLineEnd + 1));
		} else if (this.pending) {
			this.rawSegments.push(this.pending);
			this.advance(content);
		}
		this.pending = null;
	}
	addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
		let originalCharIndex = chunk.start;
		let first$2 = true;
		let charInHiresBoundary = false;
		while (originalCharIndex < chunk.end) {
			if (original[originalCharIndex] === "\n") {
				loc.line += 1;
				loc.column = 0;
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				first$2 = true;
				charInHiresBoundary = false;
			} else {
				if (this.hires || first$2 || sourcemapLocations.has(originalCharIndex)) {
					const segment = [
						this.generatedCodeColumn,
						sourceIndex,
						loc.line,
						loc.column
					];
					if (this.hires === "boundary") if (wordRegex.test(original[originalCharIndex])) {
						if (!charInHiresBoundary) {
							this.rawSegments.push(segment);
							charInHiresBoundary = true;
						}
					} else {
						this.rawSegments.push(segment);
						charInHiresBoundary = false;
					}
					else this.rawSegments.push(segment);
				}
				loc.column += 1;
				this.generatedCodeColumn += 1;
				first$2 = false;
			}
			originalCharIndex += 1;
		}
		this.pending = null;
	}
	advance(str) {
		if (!str) return;
		const lines = str.split("\n");
		if (lines.length > 1) {
			for (let i$1 = 0; i$1 < lines.length - 1; i$1++) {
				this.generatedCodeLine++;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
			}
			this.generatedCodeColumn = 0;
		}
		this.generatedCodeColumn += lines[lines.length - 1].length;
	}
};
const n$1 = "\n";
const warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false
};
var MagicString = class MagicString {
	constructor(string, options$1 = {}) {
		const chunk = new Chunk(0, string.length, string);
		Object.defineProperties(this, {
			original: {
				writable: true,
				value: string
			},
			outro: {
				writable: true,
				value: ""
			},
			intro: {
				writable: true,
				value: ""
			},
			firstChunk: {
				writable: true,
				value: chunk
			},
			lastChunk: {
				writable: true,
				value: chunk
			},
			lastSearchedChunk: {
				writable: true,
				value: chunk
			},
			byStart: {
				writable: true,
				value: {}
			},
			byEnd: {
				writable: true,
				value: {}
			},
			filename: {
				writable: true,
				value: options$1.filename
			},
			indentExclusionRanges: {
				writable: true,
				value: options$1.indentExclusionRanges
			},
			sourcemapLocations: {
				writable: true,
				value: new BitSet()
			},
			storedNames: {
				writable: true,
				value: {}
			},
			indentStr: {
				writable: true,
				value: void 0
			},
			ignoreList: {
				writable: true,
				value: options$1.ignoreList
			},
			offset: {
				writable: true,
				value: options$1.offset || 0
			}
		});
		this.byStart[0] = chunk;
		this.byEnd[string.length] = chunk;
	}
	addSourcemapLocation(char) {
		this.sourcemapLocations.add(char);
	}
	append(content) {
		if (typeof content !== "string") throw new TypeError("outro content must be a string");
		this.outro += content;
		return this;
	}
	appendLeft(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byEnd[index];
		if (chunk) chunk.appendLeft(content);
		else this.intro += content;
		return this;
	}
	appendRight(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byStart[index];
		if (chunk) chunk.appendRight(content);
		else this.outro += content;
		return this;
	}
	clone() {
		const cloned = new MagicString(this.original, {
			filename: this.filename,
			offset: this.offset
		});
		let originalChunk = this.firstChunk;
		let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
		while (originalChunk) {
			cloned.byStart[clonedChunk.start] = clonedChunk;
			cloned.byEnd[clonedChunk.end] = clonedChunk;
			const nextOriginalChunk = originalChunk.next;
			const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
			if (nextClonedChunk) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;
				clonedChunk = nextClonedChunk;
			}
			originalChunk = nextOriginalChunk;
		}
		cloned.lastChunk = clonedChunk;
		if (this.indentExclusionRanges) cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
		cloned.intro = this.intro;
		cloned.outro = this.outro;
		return cloned;
	}
	generateDecodedMap(options$1) {
		options$1 = options$1 || {};
		const sourceIndex = 0;
		const names = Object.keys(this.storedNames);
		const mappings = new Mappings(options$1.hires);
		const locate = getLocator(this.original);
		if (this.intro) mappings.advance(this.intro);
		this.firstChunk.eachNext((chunk) => {
			const loc = locate(chunk.start);
			if (chunk.intro.length) mappings.advance(chunk.intro);
			if (chunk.edited) mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
			else mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
			if (chunk.outro.length) mappings.advance(chunk.outro);
		});
		if (this.outro) mappings.advance(this.outro);
		return {
			file: options$1.file ? options$1.file.split(/[/\\]/).pop() : void 0,
			sources: [options$1.source ? getRelativePath(options$1.file || "", options$1.source) : options$1.file || ""],
			sourcesContent: options$1.includeContent ? [this.original] : void 0,
			names,
			mappings: mappings.raw,
			x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
		};
	}
	generateMap(options$1) {
		return new SourceMap(this.generateDecodedMap(options$1));
	}
	_ensureindentStr() {
		if (this.indentStr === void 0) this.indentStr = guessIndent(this.original);
	}
	_getRawIndentString() {
		this._ensureindentStr();
		return this.indentStr;
	}
	getIndentString() {
		this._ensureindentStr();
		return this.indentStr === null ? "	" : this.indentStr;
	}
	indent(indentStr, options$1) {
		const pattern = /^[^\r\n]/gm;
		if (isObject$2(indentStr)) {
			options$1 = indentStr;
			indentStr = void 0;
		}
		if (indentStr === void 0) {
			this._ensureindentStr();
			indentStr = this.indentStr || "	";
		}
		if (indentStr === "") return this;
		options$1 = options$1 || {};
		const isExcluded = {};
		if (options$1.exclude) (typeof options$1.exclude[0] === "number" ? [options$1.exclude] : options$1.exclude).forEach((exclusion) => {
			for (let i$1 = exclusion[0]; i$1 < exclusion[1]; i$1 += 1) isExcluded[i$1] = true;
		});
		let shouldIndentNextCharacter = options$1.indentStart !== false;
		const replacer = (match) => {
			if (shouldIndentNextCharacter) return `${indentStr}${match}`;
			shouldIndentNextCharacter = true;
			return match;
		};
		this.intro = this.intro.replace(pattern, replacer);
		let charIndex = 0;
		let chunk = this.firstChunk;
		while (chunk) {
			const end = chunk.end;
			if (chunk.edited) {
				if (!isExcluded[charIndex]) {
					chunk.content = chunk.content.replace(pattern, replacer);
					if (chunk.content.length) shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
				}
			} else {
				charIndex = chunk.start;
				while (charIndex < end) {
					if (!isExcluded[charIndex]) {
						const char = this.original[charIndex];
						if (char === "\n") shouldIndentNextCharacter = true;
						else if (char !== "\r" && shouldIndentNextCharacter) {
							shouldIndentNextCharacter = false;
							if (charIndex === chunk.start) chunk.prependRight(indentStr);
							else {
								this._splitChunk(chunk, charIndex);
								chunk = chunk.next;
								chunk.prependRight(indentStr);
							}
						}
					}
					charIndex += 1;
				}
			}
			charIndex = chunk.end;
			chunk = chunk.next;
		}
		this.outro = this.outro.replace(pattern, replacer);
		return this;
	}
	insert() {
		throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
	}
	insertLeft(index, content) {
		if (!warned.insertLeft) {
			console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
			warned.insertLeft = true;
		}
		return this.appendLeft(index, content);
	}
	insertRight(index, content) {
		if (!warned.insertRight) {
			console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
			warned.insertRight = true;
		}
		return this.prependRight(index, content);
	}
	move(start, end, index) {
		start = start + this.offset;
		end = end + this.offset;
		index = index + this.offset;
		if (index >= start && index <= end) throw new Error("Cannot move a selection inside itself");
		this._split(start);
		this._split(end);
		this._split(index);
		const first$2 = this.byStart[start];
		const last = this.byEnd[end];
		const oldLeft = first$2.previous;
		const oldRight = last.next;
		const newRight = this.byStart[index];
		if (!newRight && last === this.lastChunk) return this;
		const newLeft = newRight ? newRight.previous : this.lastChunk;
		if (oldLeft) oldLeft.next = oldRight;
		if (oldRight) oldRight.previous = oldLeft;
		if (newLeft) newLeft.next = first$2;
		if (newRight) newRight.previous = last;
		if (!first$2.previous) this.firstChunk = last.next;
		if (!last.next) {
			this.lastChunk = first$2.previous;
			this.lastChunk.next = null;
		}
		first$2.previous = newLeft;
		last.next = newRight || null;
		if (!newLeft) this.firstChunk = first$2;
		if (!newRight) this.lastChunk = last;
		return this;
	}
	overwrite(start, end, content, options$1) {
		options$1 = options$1 || {};
		return this.update(start, end, content, {
			...options$1,
			overwrite: !options$1.contentOnly
		});
	}
	update(start, end, content, options$1) {
		start = start + this.offset;
		end = end + this.offset;
		if (typeof content !== "string") throw new TypeError("replacement content must be a string");
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (end > this.original.length) throw new Error("end is out of bounds");
		if (start === end) throw new Error("Cannot overwrite a zero-length range – use appendLeft or prependRight instead");
		this._split(start);
		this._split(end);
		if (options$1 === true) {
			if (!warned.storeName) {
				console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
				warned.storeName = true;
			}
			options$1 = { storeName: true };
		}
		const storeName = options$1 !== void 0 ? options$1.storeName : false;
		const overwrite = options$1 !== void 0 ? options$1.overwrite : false;
		if (storeName) {
			const original = this.original.slice(start, end);
			Object.defineProperty(this.storedNames, original, {
				writable: true,
				value: true,
				enumerable: true
			});
		}
		const first$2 = this.byStart[start];
		const last = this.byEnd[end];
		if (first$2) {
			let chunk = first$2;
			while (chunk !== last) {
				if (chunk.next !== this.byStart[chunk.end]) throw new Error("Cannot overwrite across a split point");
				chunk = chunk.next;
				chunk.edit("", false);
			}
			first$2.edit(content, storeName, !overwrite);
		} else {
			const newChunk = new Chunk(start, end, "").edit(content, storeName);
			last.next = newChunk;
			newChunk.previous = last;
		}
		return this;
	}
	prepend(content) {
		if (typeof content !== "string") throw new TypeError("outro content must be a string");
		this.intro = content + this.intro;
		return this;
	}
	prependLeft(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byEnd[index];
		if (chunk) chunk.prependLeft(content);
		else this.intro = content + this.intro;
		return this;
	}
	prependRight(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byStart[index];
		if (chunk) chunk.prependRight(content);
		else this.outro = content + this.outro;
		return this;
	}
	remove(start, end) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (start === end) return this;
		if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
		if (start > end) throw new Error("end must be greater than start");
		this._split(start);
		this._split(end);
		let chunk = this.byStart[start];
		while (chunk) {
			chunk.intro = "";
			chunk.outro = "";
			chunk.edit("");
			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}
	reset(start, end) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (start === end) return this;
		if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
		if (start > end) throw new Error("end must be greater than start");
		this._split(start);
		this._split(end);
		let chunk = this.byStart[start];
		while (chunk) {
			chunk.reset();
			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}
	lastChar() {
		if (this.outro.length) return this.outro[this.outro.length - 1];
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
			if (chunk.content.length) return chunk.content[chunk.content.length - 1];
			if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
		} while (chunk = chunk.previous);
		if (this.intro.length) return this.intro[this.intro.length - 1];
		return "";
	}
	lastLine() {
		let lineIndex = this.outro.lastIndexOf(n$1);
		if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
		let lineStr = this.outro;
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length > 0) {
				lineIndex = chunk.outro.lastIndexOf(n$1);
				if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.outro + lineStr;
			}
			if (chunk.content.length > 0) {
				lineIndex = chunk.content.lastIndexOf(n$1);
				if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.content + lineStr;
			}
			if (chunk.intro.length > 0) {
				lineIndex = chunk.intro.lastIndexOf(n$1);
				if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.intro + lineStr;
			}
		} while (chunk = chunk.previous);
		lineIndex = this.intro.lastIndexOf(n$1);
		if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
		return this.intro + lineStr;
	}
	slice(start = 0, end = this.original.length - this.offset) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		let result = "";
		let chunk = this.firstChunk;
		while (chunk && (chunk.start > start || chunk.end <= start)) {
			if (chunk.start < end && chunk.end >= end) return result;
			chunk = chunk.next;
		}
		if (chunk && chunk.edited && chunk.start !== start) throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
		const startChunk = chunk;
		while (chunk) {
			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) result += chunk.intro;
			const containsEnd = chunk.start < end && chunk.end >= end;
			if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
			const sliceStart = startChunk === chunk ? start - chunk.start : 0;
			const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
			result += chunk.content.slice(sliceStart, sliceEnd);
			if (chunk.outro && (!containsEnd || chunk.end === end)) result += chunk.outro;
			if (containsEnd) break;
			chunk = chunk.next;
		}
		return result;
	}
	snip(start, end) {
		const clone$1 = this.clone();
		clone$1.remove(0, start);
		clone$1.remove(end, clone$1.original.length);
		return clone$1;
	}
	_split(index) {
		if (this.byStart[index] || this.byEnd[index]) return;
		let chunk = this.lastSearchedChunk;
		let previousChunk = chunk;
		const searchForward = index > chunk.end;
		while (chunk) {
			if (chunk.contains(index)) return this._splitChunk(chunk, index);
			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
			if (chunk === previousChunk) return;
			previousChunk = chunk;
		}
	}
	_splitChunk(chunk, index) {
		if (chunk.edited && chunk.content.length) {
			const loc = getLocator(this.original)(index);
			throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`);
		}
		const newChunk = chunk.split(index);
		this.byEnd[index] = chunk;
		this.byStart[index] = newChunk;
		this.byEnd[newChunk.end] = newChunk;
		if (chunk === this.lastChunk) this.lastChunk = newChunk;
		this.lastSearchedChunk = chunk;
		return true;
	}
	toString() {
		let str = this.intro;
		let chunk = this.firstChunk;
		while (chunk) {
			str += chunk.toString();
			chunk = chunk.next;
		}
		return str + this.outro;
	}
	isEmpty() {
		let chunk = this.firstChunk;
		do
			if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;
		while (chunk = chunk.next);
		return true;
	}
	length() {
		let chunk = this.firstChunk;
		let length = 0;
		do
			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
		while (chunk = chunk.next);
		return length;
	}
	trimLines() {
		return this.trim("[\\r\\n]");
	}
	trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	}
	trimEndAborted(charType) {
		const rx = /* @__PURE__ */ new RegExp((charType || "\\s") + "+$");
		this.outro = this.outro.replace(rx, "");
		if (this.outro.length) return true;
		let chunk = this.lastChunk;
		do {
			const end = chunk.end;
			const aborted = chunk.trimEnd(rx);
			if (chunk.end !== end) {
				if (this.lastChunk === chunk) this.lastChunk = chunk.next;
				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}
			if (aborted) return true;
			chunk = chunk.previous;
		} while (chunk);
		return false;
	}
	trimEnd(charType) {
		this.trimEndAborted(charType);
		return this;
	}
	trimStartAborted(charType) {
		const rx = /* @__PURE__ */ new RegExp("^" + (charType || "\\s") + "+");
		this.intro = this.intro.replace(rx, "");
		if (this.intro.length) return true;
		let chunk = this.firstChunk;
		do {
			const end = chunk.end;
			const aborted = chunk.trimStart(rx);
			if (chunk.end !== end) {
				if (chunk === this.lastChunk) this.lastChunk = chunk.next;
				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}
			if (aborted) return true;
			chunk = chunk.next;
		} while (chunk);
		return false;
	}
	trimStart(charType) {
		this.trimStartAborted(charType);
		return this;
	}
	hasChanged() {
		return this.original !== this.toString();
	}
	_replaceRegexp(searchValue, replacement) {
		function getReplacement(match, str) {
			if (typeof replacement === "string") return replacement.replace(/\$(\$|&|\d+)/g, (_, i$1) => {
				if (i$1 === "$") return "$";
				if (i$1 === "&") return match[0];
				if (+i$1 < match.length) return match[+i$1];
				return `$${i$1}`;
			});
			else return replacement(...match, match.index, str, match.groups);
		}
		function matchAll$1(re, str) {
			let match;
			const matches$2 = [];
			while (match = re.exec(str)) matches$2.push(match);
			return matches$2;
		}
		if (searchValue.global) matchAll$1(searchValue, this.original).forEach((match) => {
			if (match.index != null) {
				const replacement$1 = getReplacement(match, this.original);
				if (replacement$1 !== match[0]) this.overwrite(match.index, match.index + match[0].length, replacement$1);
			}
		});
		else {
			const match = this.original.match(searchValue);
			if (match && match.index != null) {
				const replacement$1 = getReplacement(match, this.original);
				if (replacement$1 !== match[0]) this.overwrite(match.index, match.index + match[0].length, replacement$1);
			}
		}
		return this;
	}
	_replaceString(string, replacement) {
		const { original } = this;
		const index = original.indexOf(string);
		if (index !== -1) {
			if (typeof replacement === "function") replacement = replacement(string, index, original);
			if (string !== replacement) this.overwrite(index, index + string.length, replacement);
		}
		return this;
	}
	replace(searchValue, replacement) {
		if (typeof searchValue === "string") return this._replaceString(searchValue, replacement);
		return this._replaceRegexp(searchValue, replacement);
	}
	_replaceAllString(string, replacement) {
		const { original } = this;
		const stringLength = string.length;
		for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {
			const previous = original.slice(index, index + stringLength);
			let _replacement = replacement;
			if (typeof replacement === "function") _replacement = replacement(previous, index, original);
			if (previous !== _replacement) this.overwrite(index, index + stringLength, _replacement);
		}
		return this;
	}
	replaceAll(searchValue, replacement) {
		if (typeof searchValue === "string") return this._replaceAllString(searchValue, replacement);
		if (!searchValue.global) throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");
		return this._replaceRegexp(searchValue, replacement);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/is-reference@1.2.1/node_modules/is-reference/dist/is-reference.js
var require_is_reference = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/is-reference@1.2.1/node_modules/is-reference/dist/is-reference.js": ((exports, module) => {
	(function(global$1, factory) {
		typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global$1 = global$1 || self, global$1.isReference = factory());
	})(exports, (function() {
		function isReference$1(node, parent) {
			if (node.type === "MemberExpression") return !node.computed && isReference$1(node.object, node);
			if (node.type === "Identifier") {
				if (!parent) return true;
				switch (parent.type) {
					case "MemberExpression": return parent.computed || node === parent.object;
					case "MethodDefinition": return parent.computed;
					case "FieldDefinition": return parent.computed || node === parent.value;
					case "Property": return parent.computed || node === parent.value;
					case "ExportSpecifier":
					case "ImportSpecifier": return node === parent.local;
					case "LabeledStatement":
					case "BreakStatement":
					case "ContinueStatement": return false;
					default: return true;
				}
			}
			return false;
		}
		return isReference$1;
	}));
}) });

//#endregion
//#region ../../node_modules/.pnpm/@rollup+plugin-commonjs@28.0.8_rollup@4.43.0/node_modules/@rollup/plugin-commonjs/dist/es/index.js
var import_commondir = /* @__PURE__ */ __toESM(require_commondir(), 1);
var import_is_reference = /* @__PURE__ */ __toESM(require_is_reference(), 1);
var version$1 = "28.0.8";
var peerDependencies = { rollup: "^2.68.0||^3.0.0||^4.0.0" };
function tryParse(parse$17, code, id) {
	try {
		return parse$17(code, { allowReturnOutsideFunction: true });
	} catch (err$2) {
		err$2.message += ` in ${id}`;
		throw err$2;
	}
}
const firstpassGlobal = /\b(?:require|module|exports|global)\b/;
const firstpassNoGlobal = /\b(?:require|module|exports)\b/;
function hasCjsKeywords(code, ignoreGlobal) {
	return (ignoreGlobal ? firstpassNoGlobal : firstpassGlobal).test(code);
}
function analyzeTopLevelStatements(parse$17, code, id) {
	const ast = tryParse(parse$17, code, id);
	let isEsModule = false;
	let hasDefaultExport = false;
	let hasNamedExports = false;
	for (const node of ast.body) switch (node.type) {
		case "ExportDefaultDeclaration":
			isEsModule = true;
			hasDefaultExport = true;
			break;
		case "ExportNamedDeclaration":
			isEsModule = true;
			if (node.declaration) hasNamedExports = true;
			else for (const specifier of node.specifiers) if (specifier.exported.name === "default") hasDefaultExport = true;
			else hasNamedExports = true;
			break;
		case "ExportAllDeclaration":
			isEsModule = true;
			if (node.exported && node.exported.name === "default") hasDefaultExport = true;
			else hasNamedExports = true;
			break;
		case "ImportDeclaration":
			isEsModule = true;
			break;
	}
	return {
		isEsModule,
		hasDefaultExport,
		hasNamedExports,
		ast
	};
}
function deconflict(scopes, globals, identifier) {
	let i$1 = 1;
	let deconflicted = makeLegalIdentifier(identifier);
	const hasConflicts = () => scopes.some((scope) => scope.contains(deconflicted)) || globals.has(deconflicted);
	while (hasConflicts()) {
		deconflicted = makeLegalIdentifier(`${identifier}_${i$1}`);
		i$1 += 1;
	}
	for (const scope of scopes) scope.declarations[deconflicted] = true;
	return deconflicted;
}
function getName(id) {
	const name = makeLegalIdentifier(basename$1(id, extname$1(id)));
	if (name !== "index") return name;
	return makeLegalIdentifier(basename$1(dirname$1(id)));
}
function normalizePathSlashes(path$13) {
	return path$13.replace(/\\/g, "/");
}
const getVirtualPathForDynamicRequirePath = (path$13, commonDir) => `/${normalizePathSlashes(relative$1(commonDir, path$13))}`;
function capitalize(name) {
	return name[0].toUpperCase() + name.slice(1);
}
function getStrictRequiresFilter({ strictRequires }) {
	switch (strictRequires) {
		case void 0:
		case true: return {
			strictRequiresFilter: () => true,
			detectCyclesAndConditional: false
		};
		case "auto":
		case "debug":
		case null: return {
			strictRequiresFilter: () => false,
			detectCyclesAndConditional: true
		};
		case false: return {
			strictRequiresFilter: () => false,
			detectCyclesAndConditional: false
		};
		default:
			if (typeof strictRequires === "string" || Array.isArray(strictRequires)) return {
				strictRequiresFilter: createFilter$2(strictRequires),
				detectCyclesAndConditional: false
			};
			throw new Error("Unexpected value for \"strictRequires\" option.");
	}
}
function getPackageEntryPoint(dirPath) {
	let entryPoint = "index.js";
	try {
		if (existsSync$1(join$1(dirPath, "package.json"))) entryPoint = JSON.parse(readFileSync$1(join$1(dirPath, "package.json"), { encoding: "utf8" })).main || entryPoint;
	} catch (ignored) {}
	return entryPoint;
}
function isDirectory$1(path$13) {
	try {
		if (statSync(path$13).isDirectory()) return true;
	} catch (ignored) {}
	return false;
}
function getDynamicRequireModules(patterns, dynamicRequireRoot) {
	const dynamicRequireModules = /* @__PURE__ */ new Map();
	const dirNames = /* @__PURE__ */ new Set();
	for (const pattern of !patterns || Array.isArray(patterns) ? patterns || [] : [patterns]) {
		const isNegated = pattern.startsWith("!");
		const modifyMap = (targetPath, resolvedPath) => isNegated ? dynamicRequireModules.delete(targetPath) : dynamicRequireModules.set(targetPath, resolvedPath);
		for (const path$13 of new fdir().withBasePath().withDirs().glob(isNegated ? pattern.substr(1) : pattern).crawl(relative$1(".", dynamicRequireRoot)).sync().sort((a, b) => a.localeCompare(b, "en"))) {
			const resolvedPath = resolve$1(path$13);
			const requirePath = normalizePathSlashes(resolvedPath);
			if (isDirectory$1(resolvedPath)) {
				dirNames.add(resolvedPath);
				const modulePath = resolve$1(join$1(resolvedPath, getPackageEntryPoint(path$13)));
				modifyMap(requirePath, modulePath);
				modifyMap(normalizePathSlashes(modulePath), modulePath);
			} else {
				dirNames.add(dirname$1(resolvedPath));
				modifyMap(requirePath, resolvedPath);
			}
		}
	}
	return {
		commonDir: dirNames.size ? (0, import_commondir.default)([...dirNames, dynamicRequireRoot]) : null,
		dynamicRequireModules
	};
}
const FAILED_REQUIRE_ERROR = `throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');`;
const COMMONJS_REQUIRE_EXPORT = "commonjsRequire";
const CREATE_COMMONJS_REQUIRE_EXPORT = "createCommonjsRequire";
function getDynamicModuleRegistry(isDynamicRequireModulesEnabled, dynamicRequireModules, commonDir, ignoreDynamicRequires) {
	if (!isDynamicRequireModulesEnabled) return `export function ${COMMONJS_REQUIRE_EXPORT}(path) {
	${FAILED_REQUIRE_ERROR}
}`;
	return `${[...dynamicRequireModules.values()].map((id, index) => `import ${id.endsWith(".json") ? `json${index}` : `{ __require as require${index} }`} from ${JSON.stringify(id)};`).join("\n")}

var dynamicModules;

function getDynamicModules() {
	return dynamicModules || (dynamicModules = {
${[...dynamicRequireModules.keys()].map((id, index) => `\t\t${JSON.stringify(getVirtualPathForDynamicRequirePath(id, commonDir))}: ${id.endsWith(".json") ? `function () { return json${index}; }` : `require${index}`}`).join(",\n")}
	});
}

export function ${CREATE_COMMONJS_REQUIRE_EXPORT}(originalModuleDir) {
	function handleRequire(path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return getDynamicModules()[resolvedPath]();
		}
		${ignoreDynamicRequires ? "return require(path);" : FAILED_REQUIRE_ERROR}
	}
	handleRequire.resolve = function (path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return resolvedPath;
		}
		return require.resolve(path);
	}
	return handleRequire;
}

function commonjsResolve (path, originalModuleDir) {
	var shouldTryNodeModules = isPossibleNodeModulesPath(path);
	path = normalize(path);
	var relPath;
	if (path[0] === '/') {
		originalModuleDir = '';
	}
	var modules = getDynamicModules();
	var checkedExtensions = ['', '.js', '.json'];
	while (true) {
		if (!shouldTryNodeModules) {
			relPath = normalize(originalModuleDir + '/' + path);
		} else {
			relPath = normalize(originalModuleDir + '/node_modules/' + path);
		}

		if (relPath.endsWith('/..')) {
			break; // Travelled too far up, avoid infinite loop
		}

		for (var extensionIndex = 0; extensionIndex < checkedExtensions.length; extensionIndex++) {
			var resolvedPath = relPath + checkedExtensions[extensionIndex];
			if (modules[resolvedPath]) {
				return resolvedPath;
			}
		}
		if (!shouldTryNodeModules) break;
		var nextDir = normalize(originalModuleDir + '/..');
		if (nextDir === originalModuleDir) break;
		originalModuleDir = nextDir;
	}
	return null;
}

function isPossibleNodeModulesPath (modulePath) {
	var c0 = modulePath[0];
	if (c0 === '/' || c0 === '\\\\') return false;
	var c1 = modulePath[1], c2 = modulePath[2];
	if ((c0 === '.' && (!c1 || c1 === '/' || c1 === '\\\\')) ||
		(c0 === '.' && c1 === '.' && (!c2 || c2 === '/' || c2 === '\\\\'))) return false;
	if (c1 === ':' && (c2 === '/' || c2 === '\\\\')) return false;
	return true;
}

function normalize (path) {
	path = path.replace(/\\\\/g, '/');
	var parts = path.split('/');
	var slashed = parts[0] === '';
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] === '.' || parts[i] === '') {
			parts.splice(i--, 1);
		}
	}
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] !== '..') continue;
		if (i > 0 && parts[i - 1] !== '..' && parts[i - 1] !== '.') {
			parts.splice(--i, 2);
			i--;
		}
	}
	path = parts.join('/');
	if (slashed && path[0] !== '/') path = '/' + path;
	else if (path.length === 0) path = '.';
	return path;
}`;
}
const isWrappedId = (id, suffix) => id.endsWith(suffix);
const wrapId$1 = (id, suffix) => `\0${id}${suffix}`;
const unwrapId$1 = (wrappedId, suffix) => wrappedId.slice(1, -suffix.length);
const PROXY_SUFFIX = "?commonjs-proxy";
const WRAPPED_SUFFIX = "?commonjs-wrapped";
const EXTERNAL_SUFFIX = "?commonjs-external";
const EXPORTS_SUFFIX = "?commonjs-exports";
const MODULE_SUFFIX = "?commonjs-module";
const ENTRY_SUFFIX = "?commonjs-entry";
const ES_IMPORT_SUFFIX = "?commonjs-es-import";
const DYNAMIC_MODULES_ID = "\0commonjs-dynamic-modules";
const HELPERS_ID = "\0commonjsHelpers.js";
const IS_WRAPPED_COMMONJS = "withRequireFunction";
const HELPERS = `
export var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

export function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

export function getDefaultExportFromNamespaceIfPresent (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

export function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

export function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			var isInstance = false;
      try {
        isInstance = this instanceof a;
      } catch {}
			if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}
`;
function getHelpersModule() {
	return HELPERS;
}
function getUnknownRequireProxy(id, requireReturnsDefault) {
	if (requireReturnsDefault === true || id.endsWith(".json")) return `export { default } from ${JSON.stringify(id)};`;
	const name = getName(id);
	const exported = requireReturnsDefault === "auto" ? `import { getDefaultExportFromNamespaceIfNotNamed } from "${HELPERS_ID}"; export default /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(${name});` : requireReturnsDefault === "preferred" ? `import { getDefaultExportFromNamespaceIfPresent } from "${HELPERS_ID}"; export default /*@__PURE__*/getDefaultExportFromNamespaceIfPresent(${name});` : !requireReturnsDefault ? `import { getAugmentedNamespace } from "${HELPERS_ID}"; export default /*@__PURE__*/getAugmentedNamespace(${name});` : `export default ${name};`;
	return `import * as ${name} from ${JSON.stringify(id)}; ${exported}`;
}
async function getStaticRequireProxy(id, requireReturnsDefault, loadModule) {
	const name = getName(id);
	const { meta: { commonjs: commonjsMeta } } = await loadModule({ id });
	if (!commonjsMeta) return getUnknownRequireProxy(id, requireReturnsDefault);
	if (commonjsMeta.isCommonJS) return `export { __moduleExports as default } from ${JSON.stringify(id)};`;
	if (!requireReturnsDefault) return `import { getAugmentedNamespace } from "${HELPERS_ID}"; import * as ${name} from ${JSON.stringify(id)}; export default /*@__PURE__*/getAugmentedNamespace(${name});`;
	if (requireReturnsDefault !== true && (requireReturnsDefault === "namespace" || !commonjsMeta.hasDefaultExport || requireReturnsDefault === "auto" && commonjsMeta.hasNamedExports)) return `import * as ${name} from ${JSON.stringify(id)}; export default ${name};`;
	return `export { default } from ${JSON.stringify(id)};`;
}
function getEntryProxy(id, defaultIsModuleExports, getModuleInfo, shebang) {
	const { meta: { commonjs: commonjsMeta }, hasDefaultExport } = getModuleInfo(id);
	if (!commonjsMeta || commonjsMeta.isCommonJS !== IS_WRAPPED_COMMONJS) {
		const stringifiedId = JSON.stringify(id);
		let code = `export * from ${stringifiedId};`;
		if (hasDefaultExport) code += `export { default } from ${stringifiedId};`;
		return shebang + code;
	}
	const result = getEsImportProxy(id, defaultIsModuleExports, true);
	return {
		...result,
		code: shebang + result.code
	};
}
function getEsImportProxy(id, defaultIsModuleExports, moduleSideEffects) {
	const name = getName(id);
	const exportsName = `${name}Exports`;
	const requireModule = `require${capitalize(name)}`;
	let code = `import { getDefaultExportFromCjs } from "${HELPERS_ID}";\nimport { __require as ${requireModule} } from ${JSON.stringify(id)};\nvar ${exportsName} = ${moduleSideEffects ? "" : "/*@__PURE__*/ "}${requireModule}();\nexport { ${exportsName} as __moduleExports };`;
	if (defaultIsModuleExports === true) code += `\nexport { ${exportsName} as default };`;
	else if (defaultIsModuleExports === false) code += `\nexport default ${exportsName}.default;`;
	else code += `\nexport default /*@__PURE__*/getDefaultExportFromCjs(${exportsName});`;
	return {
		code,
		syntheticNamedExports: "__moduleExports"
	};
}
function getExternalBuiltinRequireProxy(id) {
	return `import { createRequire } from 'node:module';
const require = createRequire(import.meta.url);
export function __require() { return require(${JSON.stringify(id)}); }`;
}
function getCandidatesForExtension(resolved, extension$1) {
	return [resolved + extension$1, `${resolved}${sep$1}index${extension$1}`];
}
function getCandidates(resolved, extensions$1) {
	return extensions$1.reduce((paths, extension$1) => paths.concat(getCandidatesForExtension(resolved, extension$1)), [resolved]);
}
function resolveExtensions(importee, importer, extensions$1) {
	if (importee[0] !== "." || !importer) return void 0;
	const candidates = getCandidates(resolve$1(dirname$1(importer), importee), extensions$1);
	for (let i$1 = 0; i$1 < candidates.length; i$1 += 1) try {
		if (statSync(candidates[i$1]).isFile()) return { id: candidates[i$1] };
	} catch (err$2) {}
}
function getResolveId(extensions$1, isPossibleCjsId) {
	const currentlyResolving = /* @__PURE__ */ new Map();
	return {
		currentlyResolving,
		async resolveId(importee, importer, resolveOptions) {
			if (resolveOptions.custom?.["node-resolve"]?.isRequire) return null;
			const currentlyResolvingForParent = currentlyResolving.get(importer);
			if (currentlyResolvingForParent && currentlyResolvingForParent.has(importee)) {
				this.warn({
					code: "THIS_RESOLVE_WITHOUT_OPTIONS",
					message: "It appears a plugin has implemented a \"resolveId\" hook that uses \"this.resolve\" without forwarding the third \"options\" parameter of \"resolveId\". This is problematic as it can lead to wrong module resolutions especially for the node-resolve plugin and in certain cases cause early exit errors for the commonjs plugin.\nIn rare cases, this warning can appear if the same file is both imported and required from the same mixed ES/CommonJS module, in which case it can be ignored.",
					url: "https://rollupjs.org/guide/en/#resolveid"
				});
				return null;
			}
			if (isWrappedId(importee, WRAPPED_SUFFIX)) return unwrapId$1(importee, WRAPPED_SUFFIX);
			if (importee.endsWith(ENTRY_SUFFIX) || isWrappedId(importee, MODULE_SUFFIX) || isWrappedId(importee, EXPORTS_SUFFIX) || isWrappedId(importee, PROXY_SUFFIX) || isWrappedId(importee, ES_IMPORT_SUFFIX) || isWrappedId(importee, EXTERNAL_SUFFIX) || importee.startsWith(HELPERS_ID) || importee === DYNAMIC_MODULES_ID) return importee;
			if (importer) {
				if (importer === DYNAMIC_MODULES_ID || isWrappedId(importer, PROXY_SUFFIX) || isWrappedId(importer, ES_IMPORT_SUFFIX) || importer.endsWith(ENTRY_SUFFIX)) return importee;
				if (isWrappedId(importer, EXTERNAL_SUFFIX)) {
					if (!await this.resolve(importee, importer, Object.assign({ skipSelf: true }, resolveOptions))) return null;
					return {
						id: importee,
						external: true
					};
				}
			}
			if (importee.startsWith("\0")) return null;
			const resolved = await this.resolve(importee, importer, Object.assign({ skipSelf: true }, resolveOptions)) || resolveExtensions(importee, importer, extensions$1);
			if (!resolved || resolved.external || resolved.id.endsWith(ENTRY_SUFFIX) || isWrappedId(resolved.id, ES_IMPORT_SUFFIX) || !isPossibleCjsId(resolved.id)) return resolved;
			const moduleInfo = await this.load(resolved);
			const { meta: { commonjs: commonjsMeta } } = moduleInfo;
			if (commonjsMeta) {
				const { isCommonJS } = commonjsMeta;
				if (isCommonJS) {
					if (resolveOptions.isEntry) {
						moduleInfo.moduleSideEffects = true;
						return resolved.id + ENTRY_SUFFIX;
					}
					if (isCommonJS === IS_WRAPPED_COMMONJS) return {
						id: wrapId$1(resolved.id, ES_IMPORT_SUFFIX),
						meta: { commonjs: { resolved } }
					};
				}
			}
			return resolved;
		}
	};
}
function getRequireResolver(extensions$1, detectCyclesAndConditional, currentlyResolving) {
	const knownCjsModuleTypes = Object.create(null);
	const requiredIds = Object.create(null);
	const unconditionallyRequiredIds = Object.create(null);
	const dependencies = Object.create(null);
	const getDependencies = (id) => dependencies[id] || (dependencies[id] = /* @__PURE__ */ new Set());
	const isCyclic = (id) => {
		const dependenciesToCheck = new Set(getDependencies(id));
		for (const dependency of dependenciesToCheck) {
			if (dependency === id) return true;
			for (const childDependency of getDependencies(dependency)) dependenciesToCheck.add(childDependency);
		}
		return false;
	};
	const fullyAnalyzedModules = Object.create(null);
	const getTypeForFullyAnalyzedModule = (id) => {
		const knownType = knownCjsModuleTypes[id];
		if (knownType !== true || !detectCyclesAndConditional || fullyAnalyzedModules[id]) return knownType;
		if (isCyclic(id)) return knownCjsModuleTypes[id] = IS_WRAPPED_COMMONJS;
		return knownType;
	};
	const setInitialParentType = (id, initialCommonJSType) => {
		if (fullyAnalyzedModules[id]) return;
		knownCjsModuleTypes[id] = initialCommonJSType;
		if (detectCyclesAndConditional && knownCjsModuleTypes[id] === true && requiredIds[id] && !unconditionallyRequiredIds[id]) knownCjsModuleTypes[id] = IS_WRAPPED_COMMONJS;
	};
	const analyzeRequiredModule = async (parentId, resolved, isConditional, loadModule) => {
		const childId = resolved.id;
		requiredIds[childId] = true;
		if (!(isConditional || knownCjsModuleTypes[parentId] === IS_WRAPPED_COMMONJS)) unconditionallyRequiredIds[childId] = true;
		getDependencies(parentId).add(childId);
		if (!isCyclic(childId)) await loadModule(resolved);
	};
	const getTypeForImportedModule = async (resolved, loadModule) => {
		if (resolved.id in knownCjsModuleTypes) return knownCjsModuleTypes[resolved.id];
		const { meta: { commonjs: commonjs$1 } } = await loadModule(resolved);
		return commonjs$1 && commonjs$1.isCommonJS || false;
	};
	return {
		getWrappedIds: () => Object.keys(knownCjsModuleTypes).filter((id) => knownCjsModuleTypes[id] === IS_WRAPPED_COMMONJS),
		isRequiredId: (id) => requiredIds[id],
		async shouldTransformCachedModule({ id: parentId, resolvedSources, meta: { commonjs: parentMeta } }) {
			if (!(parentMeta && parentMeta.isCommonJS)) knownCjsModuleTypes[parentId] = false;
			if (isWrappedId(parentId, ES_IMPORT_SUFFIX)) return false;
			const parentRequires = parentMeta && parentMeta.requires;
			if (parentRequires) {
				setInitialParentType(parentId, parentMeta.initialCommonJSType);
				await Promise.all(parentRequires.map(({ resolved, isConditional }) => analyzeRequiredModule(parentId, resolved, isConditional, this.load)));
				if (getTypeForFullyAnalyzedModule(parentId) !== parentMeta.isCommonJS) return true;
				for (const { resolved: { id } } of parentRequires) if (getTypeForFullyAnalyzedModule(id) !== parentMeta.isRequiredCommonJS[id]) return true;
				fullyAnalyzedModules[parentId] = true;
				for (const { resolved: { id } } of parentRequires) fullyAnalyzedModules[id] = true;
			}
			const parentRequireSet = new Set((parentRequires || []).map(({ resolved: { id } }) => id));
			return (await Promise.all(Object.keys(resolvedSources).map((source) => resolvedSources[source]).filter(({ id, external }) => !(external || parentRequireSet.has(id))).map(async (resolved) => {
				if (isWrappedId(resolved.id, ES_IMPORT_SUFFIX)) return await getTypeForImportedModule((await this.load(resolved)).meta.commonjs.resolved, this.load) !== IS_WRAPPED_COMMONJS;
				return await getTypeForImportedModule(resolved, this.load) === IS_WRAPPED_COMMONJS;
			}))).some((shouldTransform) => shouldTransform);
		},
		resolveRequireSourcesAndUpdateMeta: (rollupContext) => async (parentId, isParentCommonJS, parentMeta, sources) => {
			parentMeta.initialCommonJSType = isParentCommonJS;
			parentMeta.requires = [];
			parentMeta.isRequiredCommonJS = Object.create(null);
			setInitialParentType(parentId, isParentCommonJS);
			const currentlyResolvingForParent = currentlyResolving.get(parentId) || /* @__PURE__ */ new Set();
			currentlyResolving.set(parentId, currentlyResolvingForParent);
			const requireTargets = await Promise.all(sources.map(async ({ source, isConditional }) => {
				if (source.startsWith("\0")) return {
					id: source,
					allowProxy: false
				};
				currentlyResolvingForParent.add(source);
				const resolved = await rollupContext.resolve(source, parentId, {
					skipSelf: false,
					custom: { "node-resolve": { isRequire: true } }
				}) || resolveExtensions(source, parentId, extensions$1);
				currentlyResolvingForParent.delete(source);
				if (!resolved) return {
					id: wrapId$1(source, EXTERNAL_SUFFIX),
					allowProxy: false
				};
				const childId = resolved.id;
				if (resolved.external) return {
					id: wrapId$1(childId, EXTERNAL_SUFFIX),
					allowProxy: false
				};
				parentMeta.requires.push({
					resolved,
					isConditional
				});
				await analyzeRequiredModule(parentId, resolved, isConditional, rollupContext.load);
				return {
					id: childId,
					allowProxy: true
				};
			}));
			parentMeta.isCommonJS = getTypeForFullyAnalyzedModule(parentId);
			fullyAnalyzedModules[parentId] = true;
			return requireTargets.map(({ id: dependencyId, allowProxy }, index) => {
				let isCommonJS = parentMeta.isRequiredCommonJS[dependencyId] = getTypeForFullyAnalyzedModule(dependencyId);
				const isExternalWrapped = isWrappedId(dependencyId, EXTERNAL_SUFFIX);
				if (parentMeta.initialCommonJSType === IS_WRAPPED_COMMONJS && !allowProxy && isExternalWrapped) {
					if (unwrapId$1(dependencyId, EXTERNAL_SUFFIX).startsWith("node:")) {
						isCommonJS = IS_WRAPPED_COMMONJS;
						parentMeta.isRequiredCommonJS[dependencyId] = isCommonJS;
					}
				}
				const isWrappedCommonJS = isCommonJS === IS_WRAPPED_COMMONJS;
				fullyAnalyzedModules[dependencyId] = true;
				const moduleInfo = isWrappedCommonJS && !isExternalWrapped ? rollupContext.getModuleInfo(dependencyId) : null;
				return {
					wrappedModuleSideEffects: !isWrappedCommonJS ? false : moduleInfo?.moduleSideEffects ?? true,
					source: sources[index].source,
					id: allowProxy ? wrapId$1(dependencyId, isWrappedCommonJS ? WRAPPED_SUFFIX : PROXY_SUFFIX) : dependencyId,
					isCommonJS
				};
			});
		},
		isCurrentlyResolving(source, parentId) {
			const currentlyResolvingForParent = currentlyResolving.get(parentId);
			return currentlyResolvingForParent && currentlyResolvingForParent.has(source);
		}
	};
}
function validateVersion(actualVersion, peerDependencyVersion, name) {
	const versionRegexp = /\^(\d+\.\d+\.\d+)/g;
	let minMajor = Infinity;
	let minMinor = Infinity;
	let minPatch = Infinity;
	let foundVersion;
	while (foundVersion = versionRegexp.exec(peerDependencyVersion)) {
		const [foundMajor, foundMinor, foundPatch] = foundVersion[1].split(".").map(Number);
		if (foundMajor < minMajor) {
			minMajor = foundMajor;
			minMinor = foundMinor;
			minPatch = foundPatch;
		}
	}
	if (!actualVersion) throw new Error(`Insufficient ${name} version: "@rollup/plugin-commonjs" requires at least ${name}@${minMajor}.${minMinor}.${minPatch}.`);
	const [major, minor, patch] = actualVersion.split(".").map(Number);
	if (major < minMajor || major === minMajor && (minor < minMinor || minor === minMinor && patch < minPatch)) throw new Error(`Insufficient ${name} version: "@rollup/plugin-commonjs" requires at least ${name}@${minMajor}.${minMinor}.${minPatch} but found ${name}@${actualVersion}.`);
}
const operators = {
	"==": (x) => equals(x.left, x.right, false),
	"!=": (x) => not(operators["=="](x)),
	"===": (x) => equals(x.left, x.right, true),
	"!==": (x) => not(operators["==="](x)),
	"!": (x) => isFalsy(x.argument),
	"&&": (x) => isTruthy(x.left) && isTruthy(x.right),
	"||": (x) => isTruthy(x.left) || isTruthy(x.right)
};
function not(value$1) {
	return value$1 === null ? value$1 : !value$1;
}
function equals(a, b, strict) {
	if (a.type !== b.type) return null;
	if (a.type === "Literal") return strict ? a.value === b.value : a.value == b.value;
	return null;
}
function isTruthy(node) {
	if (!node) return false;
	if (node.type === "Literal") return !!node.value;
	if (node.type === "ParenthesizedExpression") return isTruthy(node.expression);
	if (node.operator in operators) return operators[node.operator](node);
	return null;
}
function isFalsy(node) {
	return not(isTruthy(node));
}
function getKeypath(node) {
	const parts = [];
	while (node.type === "MemberExpression") {
		if (node.computed) return null;
		parts.unshift(node.property.name);
		node = node.object;
	}
	if (node.type !== "Identifier") return null;
	const { name } = node;
	parts.unshift(name);
	return {
		name,
		keypath: parts.join(".")
	};
}
const KEY_COMPILED_ESM = "__esModule";
function getDefineCompiledEsmType(node) {
	const definedPropertyWithExports = getDefinePropertyCallName(node, "exports");
	const definedProperty = definedPropertyWithExports || getDefinePropertyCallName(node, "module.exports");
	if (definedProperty && definedProperty.key === KEY_COMPILED_ESM) return isTruthy(definedProperty.value) ? definedPropertyWithExports ? "exports" : "module" : false;
	return false;
}
function getDefinePropertyCallName(node, targetName) {
	const { callee: { object, property } } = node;
	if (!object || object.type !== "Identifier" || object.name !== "Object") return;
	if (!property || property.type !== "Identifier" || property.name !== "defineProperty") return;
	if (node.arguments.length !== 3) return;
	const targetNames = targetName.split(".");
	const [target, key, value$1] = node.arguments;
	if (targetNames.length === 1) {
		if (target.type !== "Identifier" || target.name !== targetNames[0]) return;
	}
	if (targetNames.length === 2) {
		if (target.type !== "MemberExpression" || target.object.name !== targetNames[0] || target.property.name !== targetNames[1]) return;
	}
	if (value$1.type !== "ObjectExpression" || !value$1.properties) return;
	const valueProperty = value$1.properties.find((p) => p.key && p.key.name === "value");
	if (!valueProperty || !valueProperty.value) return;
	return {
		key: key.value,
		value: valueProperty.value
	};
}
function isShorthandProperty(parent) {
	return parent && parent.type === "Property" && parent.shorthand;
}
function wrapCode(magicString, uses, moduleName, exportsName, indentExclusionRanges) {
	const args = [];
	const passedArgs = [];
	if (uses.module) {
		args.push("module");
		passedArgs.push(moduleName);
	}
	if (uses.exports) {
		args.push("exports");
		passedArgs.push(uses.module ? `${moduleName}.exports` : exportsName);
	}
	magicString.trim().indent("	", { exclude: indentExclusionRanges }).prepend(`(function (${args.join(", ")}) {\n`).append(` \n} (${passedArgs.join(", ")}));`);
}
function rewriteExportsAndGetExportsBlock(magicString, moduleName, exportsName, exportedExportsName, wrapped, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsAssignmentsByName, topLevelAssignments, defineCompiledEsmExpressions, deconflictedExportNames, code, HELPERS_NAME, exportMode, defaultIsModuleExports, usesRequireWrapper, requireName) {
	const exports$1 = [];
	const exportDeclarations = [];
	if (usesRequireWrapper) getExportsWhenUsingRequireWrapper(magicString, wrapped, exportMode, exports$1, moduleExportsAssignments, exportsAssignmentsByName, moduleName, exportsName, requireName, defineCompiledEsmExpressions);
	else if (exportMode === "replace") getExportsForReplacedModuleExports(magicString, exports$1, exportDeclarations, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsName, defaultIsModuleExports, HELPERS_NAME);
	else {
		if (exportMode === "module") {
			exportDeclarations.push(`var ${exportedExportsName} = ${moduleName}.exports`);
			exports$1.push(`${exportedExportsName} as __moduleExports`);
		} else exports$1.push(`${exportsName} as __moduleExports`);
		if (wrapped) exportDeclarations.push(getDefaultExportDeclaration(exportedExportsName, defaultIsModuleExports, HELPERS_NAME));
		else getExports(magicString, exports$1, exportDeclarations, moduleExportsAssignments, exportsAssignmentsByName, deconflictedExportNames, topLevelAssignments, moduleName, exportsName, exportedExportsName, defineCompiledEsmExpressions, HELPERS_NAME, defaultIsModuleExports, exportMode);
	}
	if (exports$1.length) exportDeclarations.push(`export { ${exports$1.join(", ")} }`);
	return `\n\n${exportDeclarations.join(";\n")};`;
}
function getExportsWhenUsingRequireWrapper(magicString, wrapped, exportMode, exports$1, moduleExportsAssignments, exportsAssignmentsByName, moduleName, exportsName, requireName, defineCompiledEsmExpressions) {
	exports$1.push(`${requireName} as __require`);
	if (wrapped) return;
	if (exportMode === "replace") rewriteModuleExportsAssignments(magicString, moduleExportsAssignments, exportsName);
	else {
		rewriteModuleExportsAssignments(magicString, moduleExportsAssignments, `${moduleName}.exports`);
		for (const [exportName, { nodes }] of exportsAssignmentsByName) for (const { node, type } of nodes) magicString.overwrite(node.start, node.left.end, `${exportMode === "module" && type === "module" ? `${moduleName}.exports` : exportsName}.${exportName}`);
		replaceDefineCompiledEsmExpressionsAndGetIfRestorable(defineCompiledEsmExpressions, magicString, exportMode, moduleName, exportsName);
	}
}
function getExportsForReplacedModuleExports(magicString, exports$1, exportDeclarations, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsName, defaultIsModuleExports, HELPERS_NAME) {
	for (const { left } of moduleExportsAssignments) magicString.overwrite(left.start, left.end, exportsName);
	magicString.prependRight(firstTopLevelModuleExportsAssignment.left.start, "var ");
	exports$1.push(`${exportsName} as __moduleExports`);
	exportDeclarations.push(getDefaultExportDeclaration(exportsName, defaultIsModuleExports, HELPERS_NAME));
}
function getDefaultExportDeclaration(exportedExportsName, defaultIsModuleExports, HELPERS_NAME) {
	return `export default ${defaultIsModuleExports === true ? exportedExportsName : defaultIsModuleExports === false ? `${exportedExportsName}.default` : `/*@__PURE__*/${HELPERS_NAME}.getDefaultExportFromCjs(${exportedExportsName})`}`;
}
function getExports(magicString, exports$1, exportDeclarations, moduleExportsAssignments, exportsAssignmentsByName, deconflictedExportNames, topLevelAssignments, moduleName, exportsName, exportedExportsName, defineCompiledEsmExpressions, HELPERS_NAME, defaultIsModuleExports, exportMode) {
	let deconflictedDefaultExportName;
	for (const { left } of moduleExportsAssignments) magicString.overwrite(left.start, left.end, `${moduleName}.exports`);
	for (const [exportName, { nodes }] of exportsAssignmentsByName) {
		const deconflicted = deconflictedExportNames[exportName];
		let needsDeclaration = true;
		for (const { node, type } of nodes) {
			let replacement = `${deconflicted} = ${exportMode === "module" && type === "module" ? `${moduleName}.exports` : exportsName}.${exportName}`;
			if (needsDeclaration && topLevelAssignments.has(node)) {
				replacement = `var ${replacement}`;
				needsDeclaration = false;
			}
			magicString.overwrite(node.start, node.left.end, replacement);
		}
		if (needsDeclaration) magicString.prepend(`var ${deconflicted};\n`);
		if (exportName === "default") deconflictedDefaultExportName = deconflicted;
		else exports$1.push(exportName === deconflicted ? exportName : `${deconflicted} as ${exportName}`);
	}
	const isRestorableCompiledEsm = replaceDefineCompiledEsmExpressionsAndGetIfRestorable(defineCompiledEsmExpressions, magicString, exportMode, moduleName, exportsName);
	if (defaultIsModuleExports === false || defaultIsModuleExports === "auto" && isRestorableCompiledEsm && moduleExportsAssignments.length === 0) exports$1.push(`${deconflictedDefaultExportName || exportedExportsName} as default`);
	else if (defaultIsModuleExports === true || !isRestorableCompiledEsm && moduleExportsAssignments.length === 0) exports$1.push(`${exportedExportsName} as default`);
	else exportDeclarations.push(getDefaultExportDeclaration(exportedExportsName, defaultIsModuleExports, HELPERS_NAME));
}
function rewriteModuleExportsAssignments(magicString, moduleExportsAssignments, exportsName) {
	for (const { left } of moduleExportsAssignments) magicString.overwrite(left.start, left.end, exportsName);
}
function replaceDefineCompiledEsmExpressionsAndGetIfRestorable(defineCompiledEsmExpressions, magicString, exportMode, moduleName, exportsName) {
	let isRestorableCompiledEsm = false;
	for (const { node, type } of defineCompiledEsmExpressions) {
		isRestorableCompiledEsm = true;
		const moduleExportsExpression = node.type === "CallExpression" ? node.arguments[0] : node.left.object;
		magicString.overwrite(moduleExportsExpression.start, moduleExportsExpression.end, exportMode === "module" && type === "module" ? `${moduleName}.exports` : exportsName);
	}
	return isRestorableCompiledEsm;
}
function isRequireExpression(node, scope) {
	if (!node) return false;
	if (node.type !== "CallExpression") return false;
	if (node.arguments.length === 0) return false;
	return isRequire(node.callee, scope);
}
function isRequire(node, scope) {
	return node.type === "Identifier" && node.name === "require" && !scope.contains("require") || node.type === "MemberExpression" && isModuleRequire(node, scope);
}
function isModuleRequire({ object, property }, scope) {
	return object.type === "Identifier" && object.name === "module" && property.type === "Identifier" && property.name === "require" && !scope.contains("module");
}
function hasDynamicArguments(node) {
	return node.arguments.length > 1 || node.arguments[0].type !== "Literal" && (node.arguments[0].type !== "TemplateLiteral" || node.arguments[0].expressions.length > 0);
}
const reservedMethod = {
	resolve: true,
	cache: true,
	main: true
};
function isNodeRequirePropertyAccess(parent) {
	return parent && parent.property && reservedMethod[parent.property.name];
}
function getRequireStringArg(node) {
	return node.arguments[0].type === "Literal" ? node.arguments[0].value : node.arguments[0].quasis[0].value.cooked;
}
function getRequireHandlers() {
	const requireExpressions = [];
	function addRequireExpression(sourceId, node, scope, usesReturnValue, isInsideTryBlock, isInsideConditional, toBeRemoved) {
		requireExpressions.push({
			sourceId,
			node,
			scope,
			usesReturnValue,
			isInsideTryBlock,
			isInsideConditional,
			toBeRemoved
		});
	}
	async function rewriteRequireExpressionsAndGetImportBlock(magicString, topLevelDeclarations, reassignedNames, helpersName, dynamicRequireName, moduleName, exportsName, id, exportMode, resolveRequireSourcesAndUpdateMeta, needsRequireWrapper, isEsModule, isDynamicRequireModulesEnabled, getIgnoreTryCatchRequireStatementMode, commonjsMeta) {
		const imports = [];
		imports.push(`import * as ${helpersName} from "${HELPERS_ID}"`);
		if (dynamicRequireName) imports.push(`import { ${isDynamicRequireModulesEnabled ? CREATE_COMMONJS_REQUIRE_EXPORT : COMMONJS_REQUIRE_EXPORT} as ${dynamicRequireName} } from "${DYNAMIC_MODULES_ID}"`);
		if (exportMode === "module") imports.push(`import { __module as ${moduleName} } from ${JSON.stringify(wrapId$1(id, MODULE_SUFFIX))}`, `var ${exportsName} = ${moduleName}.exports`);
		else if (exportMode === "exports") imports.push(`import { __exports as ${exportsName} } from ${JSON.stringify(wrapId$1(id, EXPORTS_SUFFIX))}`);
		const requiresBySource = collectSources(requireExpressions);
		processRequireExpressions(imports, await resolveRequireSourcesAndUpdateMeta(id, needsRequireWrapper ? IS_WRAPPED_COMMONJS : !isEsModule, commonjsMeta, Object.keys(requiresBySource).map((source) => {
			return {
				source,
				isConditional: requiresBySource[source].every((require$1) => require$1.isInsideConditional)
			};
		})), requiresBySource, getIgnoreTryCatchRequireStatementMode, magicString);
		return imports.length ? `${imports.join(";\n")};\n\n` : "";
	}
	return {
		addRequireExpression,
		rewriteRequireExpressionsAndGetImportBlock
	};
}
function collectSources(requireExpressions) {
	const requiresBySource = Object.create(null);
	for (const requireExpression of requireExpressions) {
		const { sourceId } = requireExpression;
		if (!requiresBySource[sourceId]) requiresBySource[sourceId] = [];
		requiresBySource[sourceId].push(requireExpression);
	}
	return requiresBySource;
}
function processRequireExpressions(imports, requireTargets, requiresBySource, getIgnoreTryCatchRequireStatementMode, magicString) {
	const generateRequireName = getGenerateRequireName();
	for (const { source, id: resolvedId, isCommonJS, wrappedModuleSideEffects } of requireTargets) {
		const requires = requiresBySource[source];
		const name = generateRequireName(requires);
		let usesRequired = false;
		let needsImport = false;
		for (const { node, usesReturnValue, toBeRemoved, isInsideTryBlock } of requires) {
			const { canConvertRequire, shouldRemoveRequire } = isInsideTryBlock && isWrappedId(resolvedId, EXTERNAL_SUFFIX) ? getIgnoreTryCatchRequireStatementMode(source) : {
				canConvertRequire: true,
				shouldRemoveRequire: false
			};
			if (shouldRemoveRequire) if (usesReturnValue) magicString.overwrite(node.start, node.end, "undefined");
			else magicString.remove(toBeRemoved.start, toBeRemoved.end);
			else if (canConvertRequire) {
				needsImport = true;
				if (isCommonJS === IS_WRAPPED_COMMONJS) magicString.overwrite(node.start, node.end, `${wrappedModuleSideEffects ? "" : "/*@__PURE__*/ "}${name}()`);
				else if (usesReturnValue) {
					usesRequired = true;
					magicString.overwrite(node.start, node.end, name);
				} else magicString.remove(toBeRemoved.start, toBeRemoved.end);
			}
		}
		if (needsImport) if (isCommonJS === IS_WRAPPED_COMMONJS) imports.push(`import { __require as ${name} } from ${JSON.stringify(resolvedId)}`);
		else imports.push(`import ${usesRequired ? `${name} from ` : ""}${JSON.stringify(resolvedId)}`);
	}
}
function getGenerateRequireName() {
	let uid = 0;
	return (requires) => {
		let name;
		const hasNameConflict = ({ scope }) => scope.contains(name);
		do {
			name = `require$$${uid}`;
			uid += 1;
		} while (requires.some(hasNameConflict));
		return name;
	};
}
const exportsPattern = /^(?:module\.)?exports(?:\.([a-zA-Z_$][a-zA-Z_$0-9]*))?$/;
const functionType = /^(?:FunctionDeclaration|FunctionExpression|ArrowFunctionExpression)$/;
async function transformCommonjs(parse$17, code, id, isEsModule, ignoreGlobal, ignoreRequire, ignoreDynamicRequires, getIgnoreTryCatchRequireStatementMode, sourceMap, isDynamicRequireModulesEnabled, dynamicRequireModules, commonDir, astCache, defaultIsModuleExports, needsRequireWrapper, resolveRequireSourcesAndUpdateMeta, isRequired, checkDynamicRequire, commonjsMeta) {
	const ast = astCache || tryParse(parse$17, code, id);
	const magicString = new MagicString(code);
	const uses = {
		module: false,
		exports: false,
		global: false,
		require: false
	};
	const virtualDynamicRequirePath = isDynamicRequireModulesEnabled && getVirtualPathForDynamicRequirePath(dirname$1(id), commonDir);
	let scope = attachScopes(ast, "scope");
	let lexicalDepth = 0;
	let programDepth = 0;
	let classBodyDepth = 0;
	let currentTryBlockEnd = null;
	let shouldWrap = false;
	const globals = /* @__PURE__ */ new Set();
	let currentConditionalNodeEnd = null;
	const conditionalNodes = /* @__PURE__ */ new Set();
	const { addRequireExpression, rewriteRequireExpressionsAndGetImportBlock } = getRequireHandlers();
	const reassignedNames = /* @__PURE__ */ new Set();
	const topLevelDeclarations = [];
	const skippedNodes = /* @__PURE__ */ new Set();
	const moduleAccessScopes = new Set([scope]);
	const exportsAccessScopes = new Set([scope]);
	const moduleExportsAssignments = [];
	let firstTopLevelModuleExportsAssignment = null;
	const exportsAssignmentsByName = /* @__PURE__ */ new Map();
	const topLevelAssignments = /* @__PURE__ */ new Set();
	const topLevelDefineCompiledEsmExpressions = [];
	const replacedGlobal = [];
	const replacedThis = [];
	const replacedDynamicRequires = [];
	const importedVariables = /* @__PURE__ */ new Set();
	const indentExclusionRanges = [];
	walk$2(ast, {
		enter(node, parent) {
			if (skippedNodes.has(node)) {
				this.skip();
				return;
			}
			if (currentTryBlockEnd !== null && node.start > currentTryBlockEnd) currentTryBlockEnd = null;
			if (currentConditionalNodeEnd !== null && node.start > currentConditionalNodeEnd) currentConditionalNodeEnd = null;
			if (currentConditionalNodeEnd === null && conditionalNodes.has(node)) currentConditionalNodeEnd = node.end;
			programDepth += 1;
			if (node.scope) ({scope} = node);
			if (functionType.test(node.type)) lexicalDepth += 1;
			if (sourceMap) {
				magicString.addSourcemapLocation(node.start);
				magicString.addSourcemapLocation(node.end);
			}
			switch (node.type) {
				case "AssignmentExpression":
					if (node.left.type === "MemberExpression") {
						const flattened = getKeypath(node.left);
						if (!flattened || scope.contains(flattened.name)) return;
						const exportsPatternMatch = exportsPattern.exec(flattened.keypath);
						if (!exportsPatternMatch || flattened.keypath === "exports") return;
						const [, exportName] = exportsPatternMatch;
						uses[flattened.name] = true;
						if (flattened.keypath === "module.exports") {
							moduleExportsAssignments.push(node);
							if (programDepth > 3) moduleAccessScopes.add(scope);
							else if (!firstTopLevelModuleExportsAssignment) firstTopLevelModuleExportsAssignment = node;
						} else if (exportName === KEY_COMPILED_ESM) if (programDepth > 3) shouldWrap = true;
						else topLevelDefineCompiledEsmExpressions.push({
							node,
							type: flattened.name
						});
						else {
							const exportsAssignments = exportsAssignmentsByName.get(exportName) || {
								nodes: [],
								scopes: /* @__PURE__ */ new Set()
							};
							exportsAssignments.nodes.push({
								node,
								type: flattened.name
							});
							exportsAssignments.scopes.add(scope);
							exportsAccessScopes.add(scope);
							exportsAssignmentsByName.set(exportName, exportsAssignments);
							if (programDepth <= 3) topLevelAssignments.add(node);
						}
						skippedNodes.add(node.left);
					} else for (const name of extractAssignedNames(node.left)) reassignedNames.add(name);
					return;
				case "CallExpression": {
					const defineCompiledEsmType = getDefineCompiledEsmType(node);
					if (defineCompiledEsmType) {
						if (programDepth === 3 && parent.type === "ExpressionStatement") {
							skippedNodes.add(node.arguments[0]);
							topLevelDefineCompiledEsmExpressions.push({
								node,
								type: defineCompiledEsmType
							});
						} else shouldWrap = true;
						return;
					}
					if (isDynamicRequireModulesEnabled && node.callee.object && isRequire(node.callee.object, scope) && node.callee.property.name === "resolve") {
						checkDynamicRequire(node.start);
						uses.require = true;
						replacedDynamicRequires.push(node.callee.object);
						skippedNodes.add(node.callee);
						return;
					}
					if (!isRequireExpression(node, scope)) {
						const keypath = getKeypath(node.callee);
						if (keypath && importedVariables.has(keypath.name)) currentConditionalNodeEnd = Infinity;
						return;
					}
					skippedNodes.add(node.callee);
					uses.require = true;
					if (hasDynamicArguments(node)) {
						if (isDynamicRequireModulesEnabled) checkDynamicRequire(node.start);
						if (!ignoreDynamicRequires) replacedDynamicRequires.push(node.callee);
						return;
					}
					const requireStringArg = getRequireStringArg(node);
					if (!ignoreRequire(requireStringArg)) {
						addRequireExpression(requireStringArg, node, scope, parent.type !== "ExpressionStatement", currentTryBlockEnd !== null, currentConditionalNodeEnd !== null, parent.type === "ExpressionStatement" && (!currentConditionalNodeEnd || currentTryBlockEnd !== null && currentTryBlockEnd < currentConditionalNodeEnd) ? parent : node);
						if (parent.type === "VariableDeclarator" && parent.id.type === "Identifier") for (const name of extractAssignedNames(parent.id)) importedVariables.add(name);
					}
					return;
				}
				case "ClassBody":
					classBodyDepth += 1;
					return;
				case "ConditionalExpression":
				case "IfStatement":
					if (isFalsy(node.test)) skippedNodes.add(node.consequent);
					else if (isTruthy(node.test)) {
						if (node.alternate) skippedNodes.add(node.alternate);
					} else {
						conditionalNodes.add(node.consequent);
						if (node.alternate) conditionalNodes.add(node.alternate);
					}
					return;
				case "ArrowFunctionExpression":
				case "FunctionDeclaration":
				case "FunctionExpression":
					if (currentConditionalNodeEnd === null && !(parent.type === "CallExpression" && parent.callee === node)) currentConditionalNodeEnd = node.end;
					return;
				case "Identifier": {
					const { name } = node;
					if (!(0, import_is_reference.default)(node, parent) || scope.contains(name) || parent.type === "PropertyDefinition" && parent.key === node) return;
					switch (name) {
						case "require":
							uses.require = true;
							if (isNodeRequirePropertyAccess(parent)) return;
							if (!ignoreDynamicRequires) {
								if (isShorthandProperty(parent)) {
									skippedNodes.add(parent.value);
									magicString.prependRight(node.start, "require: ");
								}
								replacedDynamicRequires.push(node);
							}
							return;
						case "module":
						case "exports":
							shouldWrap = true;
							uses[name] = true;
							return;
						case "global":
							uses.global = true;
							if (!ignoreGlobal) replacedGlobal.push(node);
							return;
						case "define":
							magicString.overwrite(node.start, node.end, "undefined", { storeName: true });
							return;
						default:
							globals.add(name);
							return;
					}
				}
				case "LogicalExpression":
					if (node.operator === "&&") {
						if (isFalsy(node.left)) skippedNodes.add(node.right);
						else if (!isTruthy(node.left)) conditionalNodes.add(node.right);
					} else if (node.operator === "||") {
						if (isTruthy(node.left)) skippedNodes.add(node.right);
						else if (!isFalsy(node.left)) conditionalNodes.add(node.right);
					}
					return;
				case "MemberExpression":
					if (!isDynamicRequireModulesEnabled && isModuleRequire(node, scope)) {
						uses.require = true;
						replacedDynamicRequires.push(node);
						skippedNodes.add(node.object);
						skippedNodes.add(node.property);
					}
					return;
				case "ReturnStatement":
					if (lexicalDepth === 0) shouldWrap = true;
					return;
				case "ThisExpression":
					if (lexicalDepth === 0 && !classBodyDepth) {
						uses.global = true;
						if (!ignoreGlobal) replacedThis.push(node);
					}
					return;
				case "TryStatement":
					if (currentTryBlockEnd === null) currentTryBlockEnd = node.block.end;
					if (currentConditionalNodeEnd === null) currentConditionalNodeEnd = node.end;
					return;
				case "UnaryExpression":
					if (node.operator === "typeof") {
						const flattened = getKeypath(node.argument);
						if (!flattened) return;
						if (scope.contains(flattened.name)) return;
						if (!isEsModule && (flattened.keypath === "module.exports" || flattened.keypath === "module" || flattened.keypath === "exports")) magicString.overwrite(node.start, node.end, `'object'`, { storeName: false });
					}
					return;
				case "VariableDeclaration":
					if (!scope.parent) topLevelDeclarations.push(node);
					return;
				case "TemplateElement": if (node.value.raw.includes("\n")) indentExclusionRanges.push([node.start, node.end]);
			}
		},
		leave(node) {
			programDepth -= 1;
			if (node.scope) scope = scope.parent;
			if (functionType.test(node.type)) lexicalDepth -= 1;
			if (node.type === "ClassBody") classBodyDepth -= 1;
		}
	});
	const nameBase = getName(id);
	const exportsName = deconflict([...exportsAccessScopes], globals, nameBase);
	const moduleName = deconflict([...moduleAccessScopes], globals, `${nameBase}Module`);
	const requireName = deconflict([scope], globals, `require${capitalize(nameBase)}`);
	const isRequiredName = deconflict([scope], globals, `hasRequired${capitalize(nameBase)}`);
	const helpersName = deconflict([scope], globals, "commonjsHelpers");
	const dynamicRequireName = replacedDynamicRequires.length > 0 && deconflict([scope], globals, isDynamicRequireModulesEnabled ? CREATE_COMMONJS_REQUIRE_EXPORT : COMMONJS_REQUIRE_EXPORT);
	const deconflictedExportNames = Object.create(null);
	for (const [exportName, { scopes }] of exportsAssignmentsByName) deconflictedExportNames[exportName] = deconflict([...scopes], globals, exportName);
	for (const node of replacedGlobal) magicString.overwrite(node.start, node.end, `${helpersName}.commonjsGlobal`, { storeName: true });
	for (const node of replacedThis) magicString.overwrite(node.start, node.end, exportsName, { storeName: true });
	for (const node of replacedDynamicRequires) magicString.overwrite(node.start, node.end, isDynamicRequireModulesEnabled ? `${dynamicRequireName}(${JSON.stringify(virtualDynamicRequirePath)})` : dynamicRequireName, {
		contentOnly: true,
		storeName: true
	});
	shouldWrap = !isEsModule && (shouldWrap || uses.exports && moduleExportsAssignments.length > 0);
	if (!(shouldWrap || isRequired || needsRequireWrapper || uses.module || uses.exports || uses.require || topLevelDefineCompiledEsmExpressions.length > 0) && (ignoreGlobal || !uses.global)) return { meta: { commonjs: { isCommonJS: false } } };
	let leadingComment = "";
	if (code.startsWith("/*")) {
		const commentEnd = code.indexOf("*/", 2) + 2;
		leadingComment = `${code.slice(0, commentEnd)}\n`;
		magicString.remove(0, commentEnd).trim();
	}
	let shebang = "";
	if (code.startsWith("#!")) {
		const shebangEndPosition = code.indexOf("\n") + 1;
		shebang = code.slice(0, shebangEndPosition);
		magicString.remove(0, shebangEndPosition).trim();
	}
	const exportMode = isEsModule ? "none" : shouldWrap ? uses.module ? "module" : "exports" : firstTopLevelModuleExportsAssignment ? exportsAssignmentsByName.size === 0 && topLevelDefineCompiledEsmExpressions.length === 0 ? "replace" : "module" : moduleExportsAssignments.length === 0 ? "exports" : "module";
	const exportedExportsName = exportMode === "module" ? deconflict([], globals, `${nameBase}Exports`) : exportsName;
	const importBlock = await rewriteRequireExpressionsAndGetImportBlock(magicString, topLevelDeclarations, reassignedNames, helpersName, dynamicRequireName, moduleName, exportsName, id, exportMode, resolveRequireSourcesAndUpdateMeta, needsRequireWrapper, isEsModule, isDynamicRequireModulesEnabled, getIgnoreTryCatchRequireStatementMode, commonjsMeta);
	const usesRequireWrapper = commonjsMeta.isCommonJS === IS_WRAPPED_COMMONJS;
	const exportBlock = isEsModule ? "" : rewriteExportsAndGetExportsBlock(magicString, moduleName, exportsName, exportedExportsName, shouldWrap, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsAssignmentsByName, topLevelAssignments, topLevelDefineCompiledEsmExpressions, deconflictedExportNames, code, helpersName, exportMode, defaultIsModuleExports, usesRequireWrapper, requireName);
	if (shouldWrap) wrapCode(magicString, uses, moduleName, exportsName, indentExclusionRanges);
	if (usesRequireWrapper) {
		magicString.trim().indent("	", { exclude: indentExclusionRanges });
		const exported = exportMode === "module" ? `${moduleName}.exports` : exportsName;
		magicString.prepend(`var ${isRequiredName};

function ${requireName} () {
\tif (${isRequiredName}) return ${exported};
\t${isRequiredName} = 1;
`).append(`
\treturn ${exported};
}`);
		if (exportMode === "replace") magicString.prepend(`var ${exportsName};\n`);
	}
	magicString.trim().prepend(shebang + leadingComment + importBlock).append(exportBlock);
	return {
		code: magicString.toString(),
		map: sourceMap ? magicString.generateMap() : null,
		syntheticNamedExports: isEsModule || usesRequireWrapper ? false : "__moduleExports",
		meta: { commonjs: {
			...commonjsMeta,
			shebang
		} }
	};
}
const PLUGIN_NAME = "commonjs";
function commonjs(options$1 = {}) {
	const { ignoreGlobal, ignoreDynamicRequires, requireReturnsDefault: requireReturnsDefaultOption, defaultIsModuleExports: defaultIsModuleExportsOption, esmExternals } = options$1;
	const extensions$1 = options$1.extensions || [".js"];
	const filter$1 = createFilter$2(options$1.include, options$1.exclude);
	const isPossibleCjsId = (id) => {
		const extName = extname$1(id);
		return extName === ".cjs" || extensions$1.includes(extName) && filter$1(id);
	};
	const { strictRequiresFilter, detectCyclesAndConditional } = getStrictRequiresFilter(options$1);
	const getRequireReturnsDefault = typeof requireReturnsDefaultOption === "function" ? requireReturnsDefaultOption : () => requireReturnsDefaultOption;
	let esmExternalIds;
	const isEsmExternal = typeof esmExternals === "function" ? esmExternals : Array.isArray(esmExternals) ? (esmExternalIds = new Set(esmExternals), (id) => esmExternalIds.has(id)) : () => esmExternals;
	const getDefaultIsModuleExports = typeof defaultIsModuleExportsOption === "function" ? defaultIsModuleExportsOption : () => typeof defaultIsModuleExportsOption === "boolean" ? defaultIsModuleExportsOption : "auto";
	const dynamicRequireRoot = typeof options$1.dynamicRequireRoot === "string" ? resolve$1(options$1.dynamicRequireRoot) : process.cwd();
	const { commonDir, dynamicRequireModules } = getDynamicRequireModules(options$1.dynamicRequireTargets, dynamicRequireRoot);
	const isDynamicRequireModulesEnabled = dynamicRequireModules.size > 0;
	const ignoreRequire = typeof options$1.ignore === "function" ? options$1.ignore : Array.isArray(options$1.ignore) ? (id) => options$1.ignore.includes(id) : () => false;
	const getIgnoreTryCatchRequireStatementMode = (id) => {
		const mode = typeof options$1.ignoreTryCatch === "function" ? options$1.ignoreTryCatch(id) : Array.isArray(options$1.ignoreTryCatch) ? options$1.ignoreTryCatch.includes(id) : typeof options$1.ignoreTryCatch !== "undefined" ? options$1.ignoreTryCatch : true;
		return {
			canConvertRequire: mode !== "remove" && mode !== true,
			shouldRemoveRequire: mode === "remove"
		};
	};
	const { currentlyResolving, resolveId } = getResolveId(extensions$1, isPossibleCjsId);
	const sourceMap = options$1.sourceMap !== false;
	let requireResolver;
	function transformAndCheckExports(code, id) {
		const normalizedId = normalizePathSlashes(id);
		const { isEsModule, hasDefaultExport, hasNamedExports, ast } = analyzeTopLevelStatements(this.parse, code, id);
		const commonjsMeta = this.getModuleInfo(id).meta.commonjs || {};
		if (hasDefaultExport) commonjsMeta.hasDefaultExport = true;
		if (hasNamedExports) commonjsMeta.hasNamedExports = true;
		if (!dynamicRequireModules.has(normalizedId) && (!(hasCjsKeywords(code, ignoreGlobal) || requireResolver.isRequiredId(id)) || isEsModule && !options$1.transformMixedEsModules)) {
			commonjsMeta.isCommonJS = false;
			return { meta: { commonjs: commonjsMeta } };
		}
		const needsRequireWrapper = !isEsModule && (dynamicRequireModules.has(normalizedId) || strictRequiresFilter(id));
		const checkDynamicRequire = (position) => {
			const normalizedDynamicRequireRoot = normalizePathSlashes(dynamicRequireRoot);
			if (normalizedId.indexOf(normalizedDynamicRequireRoot) !== 0) this.error({
				code: "DYNAMIC_REQUIRE_OUTSIDE_ROOT",
				normalizedId,
				normalizedDynamicRequireRoot,
				message: `"${normalizedId}" contains dynamic require statements but it is not within the current dynamicRequireRoot "${normalizedDynamicRequireRoot}". You should set dynamicRequireRoot to "${dirname$1(normalizedId)}" or one of its parent directories.`
			}, position);
		};
		return transformCommonjs(this.parse, code, id, isEsModule, ignoreGlobal || isEsModule, ignoreRequire, ignoreDynamicRequires && !isDynamicRequireModulesEnabled, getIgnoreTryCatchRequireStatementMode, sourceMap, isDynamicRequireModulesEnabled, dynamicRequireModules, commonDir, ast, getDefaultIsModuleExports(id), needsRequireWrapper, requireResolver.resolveRequireSourcesAndUpdateMeta(this), requireResolver.isRequiredId(id), checkDynamicRequire, commonjsMeta);
	}
	return {
		name: PLUGIN_NAME,
		version: version$1,
		options(rawOptions) {
			const plugins$1 = Array.isArray(rawOptions.plugins) ? [...rawOptions.plugins] : rawOptions.plugins ? [rawOptions.plugins] : [];
			plugins$1.unshift({
				name: "commonjs--resolver",
				resolveId
			});
			return {
				...rawOptions,
				plugins: plugins$1
			};
		},
		buildStart({ plugins: plugins$1 }) {
			validateVersion(this.meta.rollupVersion, peerDependencies.rollup, "rollup");
			const nodeResolve = plugins$1.find(({ name }) => name === "node-resolve");
			if (nodeResolve) validateVersion(nodeResolve.version, "^13.0.6", "@rollup/plugin-node-resolve");
			if (options$1.namedExports != null) this.warn("The namedExports option from \"@rollup/plugin-commonjs\" is deprecated. Named exports are now handled automatically.");
			requireResolver = getRequireResolver(extensions$1, detectCyclesAndConditional, currentlyResolving);
		},
		buildEnd() {
			if (options$1.strictRequires === "debug") {
				const wrappedIds = requireResolver.getWrappedIds();
				if (wrappedIds.length) this.warn({
					code: "WRAPPED_IDS",
					ids: wrappedIds,
					message: `The commonjs plugin automatically wrapped the following files:\n[\n${wrappedIds.map((id) => `\t${JSON.stringify(relative$1(process.cwd(), id))}`).join(",\n")}\n]`
				});
				else this.warn({
					code: "WRAPPED_IDS",
					ids: wrappedIds,
					message: "The commonjs plugin did not wrap any files."
				});
			}
		},
		async load(id) {
			if (id === HELPERS_ID) return getHelpersModule();
			if (isWrappedId(id, MODULE_SUFFIX)) {
				const name = getName(unwrapId$1(id, MODULE_SUFFIX));
				return {
					code: `var ${name} = {exports: {}}; export {${name} as __module}`,
					meta: { commonjs: { isCommonJS: false } }
				};
			}
			if (isWrappedId(id, EXPORTS_SUFFIX)) {
				const name = getName(unwrapId$1(id, EXPORTS_SUFFIX));
				return {
					code: `var ${name} = {}; export {${name} as __exports}`,
					meta: { commonjs: { isCommonJS: false } }
				};
			}
			if (isWrappedId(id, EXTERNAL_SUFFIX)) {
				const actualId = unwrapId$1(id, EXTERNAL_SUFFIX);
				if (actualId.startsWith("node:")) return getExternalBuiltinRequireProxy(actualId);
				return getUnknownRequireProxy(actualId, isEsmExternal(actualId) ? getRequireReturnsDefault(actualId) : true);
			}
			if (id.endsWith(ENTRY_SUFFIX)) {
				const acutalId = id.slice(0, -15);
				const { meta: { commonjs: commonjsMeta } } = this.getModuleInfo(acutalId);
				const shebang = commonjsMeta?.shebang ?? "";
				return getEntryProxy(acutalId, getDefaultIsModuleExports(acutalId), this.getModuleInfo, shebang);
			}
			if (isWrappedId(id, ES_IMPORT_SUFFIX)) {
				const actualId = unwrapId$1(id, ES_IMPORT_SUFFIX);
				return getEsImportProxy(actualId, getDefaultIsModuleExports(actualId), (await this.load({ id: actualId })).moduleSideEffects);
			}
			if (id === DYNAMIC_MODULES_ID) return getDynamicModuleRegistry(isDynamicRequireModulesEnabled, dynamicRequireModules, commonDir, ignoreDynamicRequires);
			if (isWrappedId(id, PROXY_SUFFIX)) {
				const actualId = unwrapId$1(id, PROXY_SUFFIX);
				return getStaticRequireProxy(actualId, getRequireReturnsDefault(actualId), this.load);
			}
			return null;
		},
		shouldTransformCachedModule(...args) {
			return requireResolver.shouldTransformCachedModule.call(this, ...args);
		},
		transform(code, id) {
			if (!isPossibleCjsId(id)) return null;
			try {
				return transformAndCheckExports.call(this, code, id);
			} catch (err$2) {
				return this.error(err$2, err$2.pos);
			}
		}
	};
}

//#endregion
//#region src/node/environment.ts
/**
* Creates a function that hides the complexities of a WeakMap with an initial value
* to implement object metadata. Used by plugins to implement cross hooks per
* environment metadata
*
* @experimental
*/
function perEnvironmentState(initial) {
	const stateMap = /* @__PURE__ */ new WeakMap();
	return function(context) {
		const { environment } = context;
		let state = stateMap.get(environment);
		if (!state) {
			state = initial(environment);
			stateMap.set(environment, state);
		}
		return state;
	};
}

//#endregion
//#region src/node/plugins/reporter.ts
var import_picocolors$32 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const groups = [
	{
		name: "Assets",
		color: import_picocolors$32.default.green
	},
	{
		name: "CSS",
		color: import_picocolors$32.default.magenta
	},
	{
		name: "JS",
		color: import_picocolors$32.default.cyan
	}
];
const COMPRESSIBLE_ASSETS_RE = /\.(?:html|json|svg|txt|xml|xhtml|wasm)$/;
function buildReporterPlugin(config$2) {
	const compress = promisify(gzip);
	const numberFormatter = new Intl.NumberFormat("en", {
		maximumFractionDigits: 2,
		minimumFractionDigits: 2
	});
	const displaySize = (bytes) => {
		return `${numberFormatter.format(bytes / 1e3)} kB`;
	};
	const tty$2 = process.stdout.isTTY && !process.env.CI;
	const shouldLogInfo = LogLevels[config$2.logLevel || "info"] >= LogLevels.info;
	const modulesReporter = shouldLogInfo ? perEnvironmentState((environment) => {
		let hasTransformed = false;
		let transformedCount = 0;
		const logTransform = throttle((id) => {
			writeLine(`transforming (${transformedCount}) ${import_picocolors$32.default.dim(path.relative(config$2.root, id))}`);
		});
		return {
			reset() {
				transformedCount = 0;
			},
			register(id) {
				transformedCount++;
				if (!tty$2) {
					if (!hasTransformed) config$2.logger.info(`transforming...`);
				} else {
					if (id.includes(`?`)) return;
					logTransform(id);
				}
				hasTransformed = true;
			},
			log() {
				if (tty$2) clearLine$1();
				environment.logger.info(`${import_picocolors$32.default.green(`✓`)} ${transformedCount} modules transformed.`);
			}
		};
	}) : void 0;
	const chunksReporter = perEnvironmentState((environment) => {
		let hasRenderedChunk = false;
		let hasCompressChunk = false;
		let chunkCount = 0;
		let compressedCount = 0;
		async function getCompressedSize(code) {
			if (environment.config.consumer !== "client" || !environment.config.build.reportCompressedSize) return null;
			if (shouldLogInfo && !hasCompressChunk) {
				if (!tty$2) config$2.logger.info("computing gzip size...");
				else writeLine("computing gzip size (0)...");
				hasCompressChunk = true;
			}
			const compressed = await compress(typeof code === "string" ? code : Buffer.from(code));
			compressedCount++;
			if (shouldLogInfo && tty$2) writeLine(`computing gzip size (${compressedCount})...`);
			return compressed.length;
		}
		return {
			reset() {
				chunkCount = 0;
				compressedCount = 0;
			},
			register() {
				chunkCount++;
				if (shouldLogInfo) {
					if (!tty$2) {
						if (!hasRenderedChunk) environment.logger.info("rendering chunks...");
					} else writeLine(`rendering chunks (${chunkCount})...`);
					hasRenderedChunk = true;
				}
			},
			async log(output, outDir) {
				const chunkLimit = environment.config.build.chunkSizeWarningLimit;
				let hasLargeChunks = false;
				if (shouldLogInfo) {
					const entries = (await Promise.all(Object.values(output).map(async (chunk) => {
						if (chunk.type === "chunk") return {
							name: chunk.fileName,
							group: "JS",
							size: Buffer.byteLength(chunk.code),
							compressedSize: await getCompressedSize(chunk.code),
							mapSize: chunk.map ? Buffer.byteLength(chunk.map.toString()) : null
						};
						else {
							if (chunk.fileName.endsWith(".map")) return null;
							const isCSS = chunk.fileName.endsWith(".css");
							const isCompressible = isCSS || COMPRESSIBLE_ASSETS_RE.test(chunk.fileName);
							return {
								name: chunk.fileName,
								group: isCSS ? "CSS" : "Assets",
								size: Buffer.byteLength(chunk.source),
								mapSize: null,
								compressedSize: isCompressible ? await getCompressedSize(chunk.source) : null
							};
						}
					}))).filter(isDefined);
					if (tty$2) clearLine$1();
					let longest = 0;
					let biggestSize = 0;
					let biggestMap = 0;
					let biggestCompressSize = 0;
					for (const entry of entries) {
						if (entry.name.length > longest) longest = entry.name.length;
						if (entry.size > biggestSize) biggestSize = entry.size;
						if (entry.mapSize && entry.mapSize > biggestMap) biggestMap = entry.mapSize;
						if (entry.compressedSize && entry.compressedSize > biggestCompressSize) biggestCompressSize = entry.compressedSize;
					}
					const sizePad = displaySize(biggestSize).length;
					const mapPad = displaySize(biggestMap).length;
					const compressPad = displaySize(biggestCompressSize).length;
					const relativeOutDir = normalizePath(path.relative(config$2.root, path.resolve(config$2.root, outDir ?? environment.config.build.outDir)));
					const assetsDir = path.join(environment.config.build.assetsDir, "/");
					for (const group of groups) {
						const filtered = entries.filter((e$1) => e$1.group === group.name);
						if (!filtered.length) continue;
						for (const entry of filtered.sort((a, z) => a.size - z.size)) {
							const isLarge = group.name === "JS" && entry.size / 1e3 > chunkLimit;
							if (isLarge) hasLargeChunks = true;
							const sizeColor = isLarge ? import_picocolors$32.default.yellow : import_picocolors$32.default.dim;
							let log$4 = import_picocolors$32.default.dim(withTrailingSlash(relativeOutDir));
							log$4 += !config$2.build.lib && entry.name.startsWith(withTrailingSlash(assetsDir)) ? import_picocolors$32.default.dim(assetsDir) + group.color(entry.name.slice(assetsDir.length).padEnd(longest + 2 - assetsDir.length)) : group.color(entry.name.padEnd(longest + 2));
							log$4 += import_picocolors$32.default.bold(sizeColor(displaySize(entry.size).padStart(sizePad)));
							if (entry.compressedSize) log$4 += import_picocolors$32.default.dim(` │ gzip: ${displaySize(entry.compressedSize).padStart(compressPad)}`);
							if (entry.mapSize) log$4 += import_picocolors$32.default.dim(` │ map: ${displaySize(entry.mapSize).padStart(mapPad)}`);
							config$2.logger.info(log$4);
						}
					}
				} else hasLargeChunks = Object.values(output).some((chunk) => {
					return chunk.type === "chunk" && chunk.code.length / 1e3 > chunkLimit;
				});
				if (hasLargeChunks && environment.config.build.minify && !config$2.build.lib && environment.config.consumer === "client") environment.logger.warn(import_picocolors$32.default.yellow(`\n(!) Some chunks are larger than ${chunkLimit} kB after minification. Consider:\n- Using dynamic import() to code-split the application\n- Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/configuration-options/#output-manualchunks\n- Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.`));
			}
		};
	});
	return {
		name: "vite:reporter",
		sharedDuringBuild: true,
		perEnvironmentStartEndDuringDev: true,
		...modulesReporter ? {
			transform(_, id) {
				modulesReporter(this).register(id);
			},
			buildStart() {
				modulesReporter(this).reset();
			},
			buildEnd() {
				modulesReporter(this).log();
			}
		} : {},
		renderStart() {
			chunksReporter(this).reset();
		},
		renderChunk(_, chunk, options$1) {
			if (!options$1.inlineDynamicImports) for (const id of chunk.moduleIds) {
				const module$1 = this.getModuleInfo(id);
				if (!module$1) continue;
				if (module$1.importers.length && module$1.dynamicImporters.length) {
					if (module$1.dynamicImporters.some((id$1) => !isInNodeModules(id$1) && chunk.moduleIds.includes(id$1))) this.warn(`\n(!) ${module$1.id} is dynamically imported by ${module$1.dynamicImporters.join(", ")} but also statically imported by ${module$1.importers.join(", ")}, dynamic import will not move module into another chunk.\n`);
				}
			}
			chunksReporter(this).register();
		},
		generateBundle() {
			if (shouldLogInfo && tty$2) clearLine$1();
		},
		async writeBundle({ dir }, output) {
			await chunksReporter(this).log(output, dir);
		}
	};
}
function writeLine(output) {
	clearLine$1();
	if (output.length < process.stdout.columns) process.stdout.write(output);
	else process.stdout.write(output.substring(0, process.stdout.columns - 1));
}
function clearLine$1() {
	process.stdout.clearLine(0);
	process.stdout.cursorTo(0);
}
function throttle(fn) {
	let timerHandle = null;
	return (...args) => {
		if (timerHandle) return;
		fn(...args);
		timerHandle = setTimeout(() => {
			timerHandle = null;
		}, 100);
	};
}

//#endregion
//#region ../../node_modules/.pnpm/tsconfck@3.1.6_typescript@5.9.2/node_modules/tsconfck/src/util.js
const POSIX_SEP_RE = new RegExp("\\" + path.posix.sep, "g");
const NATIVE_SEP_RE = new RegExp("\\" + path.sep, "g");
/** @type {Map<string,RegExp>}*/
const PATTERN_REGEX_CACHE = /* @__PURE__ */ new Map();
const GLOB_ALL_PATTERN = `**/*`;
const TS_EXTENSIONS = [
	".ts",
	".tsx",
	".mts",
	".cts"
];
const TSJS_EXTENSIONS = TS_EXTENSIONS.concat([
	".js",
	".jsx",
	".mjs",
	".cjs"
]);
const TS_EXTENSIONS_RE_GROUP = `\\.(?:${TS_EXTENSIONS.map((ext) => ext.substring(1)).join("|")})`;
const TSJS_EXTENSIONS_RE_GROUP = `\\.(?:${TSJS_EXTENSIONS.map((ext) => ext.substring(1)).join("|")})`;
const IS_POSIX = path.posix.sep === path.sep;
/**
* @template T
* @returns {{resolve:(result:T)=>void, reject:(error:any)=>void, promise: Promise<T>}}
*/
function makePromise() {
	let resolve$4, reject;
	return {
		promise: new Promise((res, rej) => {
			resolve$4 = res;
			reject = rej;
		}),
		resolve: resolve$4,
		reject
	};
}
/**
* @param {string} filename
* @param {import('./cache.js').TSConfckCache} [cache]
* @returns {Promise<string|void>}
*/
async function resolveTSConfigJson(filename, cache$1) {
	if (path.extname(filename) !== ".json") return;
	const tsconfig = path.resolve(filename);
	if (cache$1 && (cache$1.hasParseResult(tsconfig) || cache$1.hasParseResult(filename))) return tsconfig;
	return promises.stat(tsconfig).then((stat$4) => {
		if (stat$4.isFile() || stat$4.isFIFO()) return tsconfig;
		else throw new Error(`${filename} exists but is not a regular file.`);
	});
}
/**
*
* @param {string} dir an absolute directory path
* @returns {boolean}  if dir path includes a node_modules segment
*/
const isInNodeModules$1 = IS_POSIX ? (dir) => dir.includes("/node_modules/") : (dir) => dir.match(/[/\\]node_modules[/\\]/);
/**
* convert posix separator to native separator
*
* eg.
* windows: C:/foo/bar -> c:\foo\bar
* linux: /foo/bar -> /foo/bar
*
* @param {string} filename with posix separators
* @returns {string} filename with native separators
*/
const posix2native = IS_POSIX ? (filename) => filename : (filename) => filename.replace(POSIX_SEP_RE, path.sep);
/**
* convert native separator to posix separator
*
* eg.
* windows: C:\foo\bar -> c:/foo/bar
* linux: /foo/bar -> /foo/bar
*
* @param {string} filename - filename with native separators
* @returns {string} filename with posix separators
*/
const native2posix = IS_POSIX ? (filename) => filename : (filename) => filename.replace(NATIVE_SEP_RE, path.posix.sep);
/**
* converts params to native separator, resolves path and converts native back to posix
*
* needed on windows to handle posix paths in tsconfig
*
* @param dir {string|null} directory to resolve from
* @param filename {string} filename or pattern to resolve
* @returns string
*/
const resolve2posix = IS_POSIX ? (dir, filename) => dir ? path.resolve(dir, filename) : path.resolve(filename) : (dir, filename) => native2posix(dir ? path.resolve(posix2native(dir), posix2native(filename)) : path.resolve(posix2native(filename)));
/**
*
* @param {import('./public.d.ts').TSConfckParseResult} result
* @param {import('./public.d.ts').TSConfckParseOptions} [options]
* @returns {string[]}
*/
function resolveReferencedTSConfigFiles(result, options$1) {
	const dir = path.dirname(result.tsconfigFile);
	return result.tsconfig.references.map((ref) => {
		return resolve2posix(dir, ref.path.endsWith(".json") ? ref.path : path.join(ref.path, options$1?.configName ?? "tsconfig.json"));
	});
}
/**
* @param {string} filename
* @param {import('./public.d.ts').TSConfckParseResult} result
* @returns {import('./public.d.ts').TSConfckParseResult}
*/
function resolveSolutionTSConfig(filename, result) {
	if (result.referenced && (result.tsconfig.compilerOptions?.allowJs ? TSJS_EXTENSIONS : TS_EXTENSIONS).some((ext) => filename.endsWith(ext)) && !isIncluded(filename, result)) {
		const solutionTSConfig = result.referenced.find((referenced) => isIncluded(filename, referenced));
		if (solutionTSConfig) return solutionTSConfig;
	}
	return result;
}
/**
*
* @param {string} filename
* @param {import('./public.d.ts').TSConfckParseResult} result
* @returns {boolean}
*/
function isIncluded(filename, result) {
	const dir = native2posix(path.dirname(result.tsconfigFile));
	const files = (result.tsconfig.files || []).map((file) => resolve2posix(dir, file));
	const absoluteFilename = resolve2posix(null, filename);
	if (files.includes(filename)) return true;
	const allowJs = result.tsconfig.compilerOptions?.allowJs;
	if (isGlobMatch(absoluteFilename, dir, result.tsconfig.include || (result.tsconfig.files ? [] : [GLOB_ALL_PATTERN]), allowJs)) return !isGlobMatch(absoluteFilename, dir, result.tsconfig.exclude || [], allowJs);
	return false;
}
/**
* test filenames agains glob patterns in tsconfig
*
* @param filename {string} posix style abolute path to filename to test
* @param dir {string} posix style absolute path to directory of tsconfig containing patterns
* @param patterns {string[]} glob patterns to match against
* @param allowJs {boolean} allowJs setting in tsconfig to include js extensions in checks
* @returns {boolean} true when at least one pattern matches filename
*/
function isGlobMatch(filename, dir, patterns, allowJs) {
	const extensions$1 = allowJs ? TSJS_EXTENSIONS : TS_EXTENSIONS;
	return patterns.some((pattern) => {
		let lastWildcardIndex = pattern.length;
		let hasWildcard = false;
		let hasExtension = false;
		let hasSlash = false;
		let lastSlashIndex = -1;
		for (let i$1 = pattern.length - 1; i$1 > -1; i$1--) {
			const c = pattern[i$1];
			if (!hasWildcard) {
				if (c === "*" || c === "?") {
					lastWildcardIndex = i$1;
					hasWildcard = true;
				}
			}
			if (!hasSlash) {
				if (c === ".") hasExtension = true;
				else if (c === "/") {
					lastSlashIndex = i$1;
					hasSlash = true;
				}
			}
			if (hasWildcard && hasSlash) break;
		}
		if (!hasExtension && (!hasWildcard || lastWildcardIndex < lastSlashIndex)) {
			pattern += `${pattern.endsWith("/") ? "" : "/"}${GLOB_ALL_PATTERN}`;
			lastWildcardIndex = pattern.length - 1;
			hasWildcard = true;
		}
		if (lastWildcardIndex < pattern.length - 1 && !filename.endsWith(pattern.slice(lastWildcardIndex + 1))) return false;
		if (pattern.endsWith("*") && !extensions$1.some((ext) => filename.endsWith(ext))) return false;
		if (pattern === GLOB_ALL_PATTERN) return filename.startsWith(`${dir}/`);
		const resolvedPattern = resolve2posix(dir, pattern);
		let firstWildcardIndex = -1;
		for (let i$1 = 0; i$1 < resolvedPattern.length; i$1++) if (resolvedPattern[i$1] === "*" || resolvedPattern[i$1] === "?") {
			firstWildcardIndex = i$1;
			hasWildcard = true;
			break;
		}
		if (firstWildcardIndex > 1 && !filename.startsWith(resolvedPattern.slice(0, firstWildcardIndex - 1))) return false;
		if (!hasWildcard) return filename === resolvedPattern;
		else if (firstWildcardIndex + GLOB_ALL_PATTERN.length === resolvedPattern.length - (pattern.length - 1 - lastWildcardIndex) && resolvedPattern.slice(firstWildcardIndex, firstWildcardIndex + GLOB_ALL_PATTERN.length) === GLOB_ALL_PATTERN) return true;
		if (PATTERN_REGEX_CACHE.has(resolvedPattern)) return PATTERN_REGEX_CACHE.get(resolvedPattern).test(filename);
		const regex = pattern2regex(resolvedPattern, allowJs);
		PATTERN_REGEX_CACHE.set(resolvedPattern, regex);
		return regex.test(filename);
	});
}
/**
* @param {string} resolvedPattern
* @param {boolean} allowJs
* @returns {RegExp}
*/
function pattern2regex(resolvedPattern, allowJs) {
	let regexStr = "^";
	for (let i$1 = 0; i$1 < resolvedPattern.length; i$1++) {
		const char = resolvedPattern[i$1];
		if (char === "?") {
			regexStr += "[^\\/]";
			continue;
		}
		if (char === "*") {
			if (resolvedPattern[i$1 + 1] === "*" && resolvedPattern[i$1 + 2] === "/") {
				i$1 += 2;
				regexStr += "(?:[^\\/]*\\/)*";
				continue;
			}
			regexStr += "[^\\/]*";
			continue;
		}
		if ("/.+^${}()|[]\\".includes(char)) regexStr += `\\`;
		regexStr += char;
	}
	if (resolvedPattern.endsWith("*")) regexStr += allowJs ? TSJS_EXTENSIONS_RE_GROUP : TS_EXTENSIONS_RE_GROUP;
	regexStr += "$";
	return new RegExp(regexStr);
}
/**
* replace tokens like ${configDir}
* @param {import('./public.d.ts').TSConfckParseResult} result
*/
function replaceTokens(result) {
	if (result.tsconfig) result.tsconfig = JSON.parse(JSON.stringify(result.tsconfig).replaceAll(/"\${configDir}/g, `"${native2posix(path.dirname(result.tsconfigFile))}`));
}

//#endregion
//#region ../../node_modules/.pnpm/tsconfck@3.1.6_typescript@5.9.2/node_modules/tsconfck/src/find.js
/**
* find the closest tsconfig.json file
*
* @param {string} filename - path to file to find tsconfig for (absolute or relative to cwd)
* @param {import('./public.d.ts').TSConfckFindOptions} [options] - options
* @returns {Promise<string|null>} absolute path to closest tsconfig.json or null if not found
*/
async function find(filename, options$1) {
	let dir = path.dirname(path.resolve(filename));
	if (options$1?.ignoreNodeModules && isInNodeModules$1(dir)) return null;
	const cache$1 = options$1?.cache;
	const configName = options$1?.configName ?? "tsconfig.json";
	if (cache$1?.hasConfigPath(dir, configName)) return cache$1.getConfigPath(dir, configName);
	const { promise, resolve: resolve$4, reject } = makePromise();
	if (options$1?.root && !path.isAbsolute(options$1.root)) options$1.root = path.resolve(options$1.root);
	findUp(dir, {
		promise,
		resolve: resolve$4,
		reject
	}, options$1);
	return promise;
}
/**
*
* @param {string} dir
* @param {{promise:Promise<string|null>,resolve:(result:string|null)=>void,reject:(err:any)=>void}} madePromise
* @param {import('./public.d.ts').TSConfckFindOptions} [options] - options
*/
function findUp(dir, { resolve: resolve$4, reject, promise }, options$1) {
	const { cache: cache$1, root, configName } = options$1 ?? {};
	if (cache$1) if (cache$1.hasConfigPath(dir, configName)) {
		let cached;
		try {
			cached = cache$1.getConfigPath(dir, configName);
		} catch (e$1) {
			reject(e$1);
			return;
		}
		if (cached?.then) cached.then(resolve$4).catch(reject);
		else resolve$4(cached);
	} else cache$1.setConfigPath(dir, promise, configName);
	const tsconfig = path.join(dir, options$1?.configName ?? "tsconfig.json");
	fs.stat(tsconfig, (err$2, stats) => {
		if (stats && (stats.isFile() || stats.isFIFO())) resolve$4(tsconfig);
		else if (err$2?.code !== "ENOENT") reject(err$2);
		else {
			let parent;
			if (root === dir || (parent = path.dirname(dir)) === dir) resolve$4(null);
			else findUp(parent, {
				promise,
				resolve: resolve$4,
				reject
			}, options$1);
		}
	});
}

//#endregion
//#region ../../node_modules/.pnpm/tsconfck@3.1.6_typescript@5.9.2/node_modules/tsconfck/src/to-json.js
/**
* convert content of tsconfig.json to regular json
*
* @param {string} tsconfigJson - content of tsconfig.json
* @returns {string} content as regular json, comments and dangling commas have been replaced with whitespace
*/
function toJson(tsconfigJson) {
	const stripped = stripDanglingComma(stripJsonComments(stripBom(tsconfigJson)));
	if (stripped.trim() === "") return "{}";
	else return stripped;
}
/**
* replace dangling commas from pseudo-json string with single space
* implementation heavily inspired by strip-json-comments
*
* @param {string} pseudoJson
* @returns {string}
*/
function stripDanglingComma(pseudoJson) {
	let insideString = false;
	let offset$1 = 0;
	let result = "";
	let danglingCommaPos = null;
	for (let i$1 = 0; i$1 < pseudoJson.length; i$1++) {
		const currentCharacter = pseudoJson[i$1];
		if (currentCharacter === "\"") {
			if (!isEscaped(pseudoJson, i$1)) insideString = !insideString;
		}
		if (insideString) {
			danglingCommaPos = null;
			continue;
		}
		if (currentCharacter === ",") {
			danglingCommaPos = i$1;
			continue;
		}
		if (danglingCommaPos) {
			if (currentCharacter === "}" || currentCharacter === "]") {
				result += pseudoJson.slice(offset$1, danglingCommaPos) + " ";
				offset$1 = danglingCommaPos + 1;
				danglingCommaPos = null;
			} else if (!currentCharacter.match(/\s/)) danglingCommaPos = null;
		}
	}
	return result + pseudoJson.substring(offset$1);
}
/**
*
* @param {string} jsonString
* @param {number} quotePosition
* @returns {boolean}
*/
function isEscaped(jsonString, quotePosition) {
	let index = quotePosition - 1;
	let backslashCount = 0;
	while (jsonString[index] === "\\") {
		index -= 1;
		backslashCount += 1;
	}
	return Boolean(backslashCount % 2);
}
/**
*
* @param {string} string
* @param {number?} start
* @param {number?} end
*/
function strip(string, start, end) {
	return string.slice(start, end).replace(/\S/g, " ");
}
const singleComment = Symbol("singleComment");
const multiComment = Symbol("multiComment");
/**
* @param {string} jsonString
* @returns {string}
*/
function stripJsonComments(jsonString) {
	let isInsideString = false;
	/** @type {false | symbol} */
	let isInsideComment = false;
	let offset$1 = 0;
	let result = "";
	for (let index = 0; index < jsonString.length; index++) {
		const currentCharacter = jsonString[index];
		const nextCharacter = jsonString[index + 1];
		if (!isInsideComment && currentCharacter === "\"") {
			if (!isEscaped(jsonString, index)) isInsideString = !isInsideString;
		}
		if (isInsideString) continue;
		if (!isInsideComment && currentCharacter + nextCharacter === "//") {
			result += jsonString.slice(offset$1, index);
			offset$1 = index;
			isInsideComment = singleComment;
			index++;
		} else if (isInsideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
			index++;
			isInsideComment = false;
			result += strip(jsonString, offset$1, index);
			offset$1 = index;
		} else if (isInsideComment === singleComment && currentCharacter === "\n") {
			isInsideComment = false;
			result += strip(jsonString, offset$1, index);
			offset$1 = index;
		} else if (!isInsideComment && currentCharacter + nextCharacter === "/*") {
			result += jsonString.slice(offset$1, index);
			offset$1 = index;
			isInsideComment = multiComment;
			index++;
		} else if (isInsideComment === multiComment && currentCharacter + nextCharacter === "*/") {
			index++;
			isInsideComment = false;
			result += strip(jsonString, offset$1, index + 1);
			offset$1 = index + 1;
		}
	}
	return result + (isInsideComment ? strip(jsonString.slice(offset$1)) : jsonString.slice(offset$1));
}
/**
* @param {string} string
* @returns {string}
*/
function stripBom(string) {
	if (string.charCodeAt(0) === 65279) return string.slice(1);
	return string;
}

//#endregion
//#region ../../node_modules/.pnpm/tsconfck@3.1.6_typescript@5.9.2/node_modules/tsconfck/src/parse.js
const not_found_result = {
	tsconfigFile: null,
	tsconfig: {}
};
/**
* parse the closest tsconfig.json file
*
* @param {string} filename - path to a tsconfig .json or a source file or directory (absolute or relative to cwd)
* @param {import('./public.d.ts').TSConfckParseOptions} [options] - options
* @returns {Promise<import('./public.d.ts').TSConfckParseResult>}
* @throws {TSConfckParseError}
*/
async function parse$14(filename, options$1) {
	/** @type {import('./cache.js').TSConfckCache} */
	const cache$1 = options$1?.cache;
	if (cache$1?.hasParseResult(filename)) return getParsedDeep(filename, cache$1, options$1);
	const { resolve: resolve$4, reject, promise } = makePromise();
	cache$1?.setParseResult(filename, promise, true);
	try {
		let tsconfigFile = await resolveTSConfigJson(filename, cache$1) || await find(filename, options$1);
		if (!tsconfigFile) {
			resolve$4(not_found_result);
			return promise;
		}
		let result;
		if (filename !== tsconfigFile && cache$1?.hasParseResult(tsconfigFile)) result = await getParsedDeep(tsconfigFile, cache$1, options$1);
		else {
			result = await parseFile$1(tsconfigFile, cache$1, filename === tsconfigFile);
			await Promise.all([parseExtends(result, cache$1), parseReferences(result, options$1)]);
		}
		replaceTokens(result);
		resolve$4(resolveSolutionTSConfig(filename, result));
	} catch (e$1) {
		reject(e$1);
	}
	return promise;
}
/**
* ensure extends and references are parsed
*
* @param {string} filename - cached file
* @param {import('./cache.js').TSConfckCache} cache - cache
* @param {import('./public.d.ts').TSConfckParseOptions} options - options
*/
async function getParsedDeep(filename, cache$1, options$1) {
	const result = await cache$1.getParseResult(filename);
	if (result.tsconfig.extends && !result.extended || result.tsconfig.references && !result.referenced) {
		const promise = Promise.all([parseExtends(result, cache$1), parseReferences(result, options$1)]).then(() => result);
		cache$1.setParseResult(filename, promise, true);
		return promise;
	}
	return result;
}
/**
*
* @param {string} tsconfigFile - path to tsconfig file
* @param {import('./cache.js').TSConfckCache} [cache] - cache
* @param {boolean} [skipCache] - skip cache
* @returns {Promise<import('./public.d.ts').TSConfckParseResult>}
*/
async function parseFile$1(tsconfigFile, cache$1, skipCache) {
	if (!skipCache && cache$1?.hasParseResult(tsconfigFile) && !cache$1.getParseResult(tsconfigFile)._isRootFile_) return cache$1.getParseResult(tsconfigFile);
	const promise = promises.readFile(tsconfigFile, "utf-8").then(toJson).then((json) => {
		const parsed = JSON.parse(json);
		applyDefaults(parsed, tsconfigFile);
		return {
			tsconfigFile,
			tsconfig: normalizeTSConfig(parsed, path.dirname(tsconfigFile))
		};
	}).catch((e$1) => {
		throw new TSConfckParseError(`parsing ${tsconfigFile} failed: ${e$1}`, "PARSE_FILE", tsconfigFile, e$1);
	});
	if (!skipCache && (!cache$1?.hasParseResult(tsconfigFile) || !cache$1.getParseResult(tsconfigFile)._isRootFile_)) cache$1?.setParseResult(tsconfigFile, promise);
	return promise;
}
/**
* normalize to match the output of ts.parseJsonConfigFileContent
*
* @param {any} tsconfig - typescript tsconfig output
* @param {string} dir - directory
*/
function normalizeTSConfig(tsconfig, dir) {
	const baseUrl = tsconfig.compilerOptions?.baseUrl;
	if (baseUrl && !baseUrl.startsWith("${") && !path.isAbsolute(baseUrl)) tsconfig.compilerOptions.baseUrl = resolve2posix(dir, baseUrl);
	return tsconfig;
}
/**
*
* @param {import('./public.d.ts').TSConfckParseResult} result
* @param {import('./public.d.ts').TSConfckParseOptions} [options]
* @returns {Promise<void>}
*/
async function parseReferences(result, options$1) {
	if (!result.tsconfig.references) return;
	const referencedFiles = resolveReferencedTSConfigFiles(result, options$1);
	const referenced = await Promise.all(referencedFiles.map((file) => parseFile$1(file, options$1?.cache)));
	await Promise.all(referenced.map((ref) => parseExtends(ref, options$1?.cache)));
	referenced.forEach((ref) => {
		ref.solution = result;
		replaceTokens(ref);
	});
	result.referenced = referenced;
}
/**
* @param {import('./public.d.ts').TSConfckParseResult} result
* @param {import('./cache.js').TSConfckCache}[cache]
* @returns {Promise<void>}
*/
async function parseExtends(result, cache$1) {
	if (!result.tsconfig.extends) return;
	/** @type {import('./public.d.ts').TSConfckParseResult[]} */
	const extended = [{
		tsconfigFile: result.tsconfigFile,
		tsconfig: JSON.parse(JSON.stringify(result.tsconfig))
	}];
	let pos = 0;
	/** @type {string[]} */
	const extendsPath = [];
	let currentBranchDepth = 0;
	while (pos < extended.length) {
		const extending = extended[pos];
		extendsPath.push(extending.tsconfigFile);
		if (extending.tsconfig.extends) {
			currentBranchDepth += 1;
			/** @type {string[]} */
			let resolvedExtends;
			if (!Array.isArray(extending.tsconfig.extends)) resolvedExtends = [resolveExtends(extending.tsconfig.extends, extending.tsconfigFile)];
			else resolvedExtends = extending.tsconfig.extends.reverse().map((ex) => resolveExtends(ex, extending.tsconfigFile));
			const circularExtends = resolvedExtends.find((tsconfigFile) => extendsPath.includes(tsconfigFile));
			if (circularExtends) throw new TSConfckParseError(`Circular dependency in "extends": ${extendsPath.concat([circularExtends]).join(" -> ")}`, "EXTENDS_CIRCULAR", result.tsconfigFile);
			extended.splice(pos + 1, 0, ...await Promise.all(resolvedExtends.map((file) => parseFile$1(file, cache$1))));
		} else {
			extendsPath.splice(-currentBranchDepth);
			currentBranchDepth = 0;
		}
		pos = pos + 1;
	}
	result.extended = extended;
	for (const ext of result.extended.slice(1)) extendTSConfig(result, ext);
}
/**
*
* @param {string} extended
* @param {string} from
* @returns {string}
*/
function resolveExtends(extended, from) {
	if ([".", ".."].includes(extended)) extended = extended + "/tsconfig.json";
	const req$4 = createRequire$1(from);
	let error$1;
	try {
		return req$4.resolve(extended);
	} catch (e$1) {
		error$1 = e$1;
	}
	if (extended[0] !== "." && !path.isAbsolute(extended)) try {
		return req$4.resolve(`${extended}/tsconfig.json`);
	} catch (e$1) {
		error$1 = e$1;
	}
	throw new TSConfckParseError(`failed to resolve "extends":"${extended}" in ${from}`, "EXTENDS_RESOLVE", from, error$1);
}
const EXTENDABLE_KEYS = [
	"compilerOptions",
	"files",
	"include",
	"exclude",
	"watchOptions",
	"compileOnSave",
	"typeAcquisition",
	"buildOptions"
];
/**
*
* @param {import('./public.d.ts').TSConfckParseResult} extending
* @param {import('./public.d.ts').TSConfckParseResult} extended
* @returns void
*/
function extendTSConfig(extending, extended) {
	const extendingConfig = extending.tsconfig;
	const extendedConfig = extended.tsconfig;
	const relativePath = native2posix(path.relative(path.dirname(extending.tsconfigFile), path.dirname(extended.tsconfigFile)));
	for (const key of Object.keys(extendedConfig).filter((key$1) => EXTENDABLE_KEYS.includes(key$1))) if (key === "compilerOptions") {
		if (!extendingConfig.compilerOptions) extendingConfig.compilerOptions = {};
		for (const option of Object.keys(extendedConfig.compilerOptions)) {
			if (Object.prototype.hasOwnProperty.call(extendingConfig.compilerOptions, option)) continue;
			extendingConfig.compilerOptions[option] = rebaseRelative(option, extendedConfig.compilerOptions[option], relativePath);
		}
	} else if (extendingConfig[key] === void 0) if (key === "watchOptions") {
		extendingConfig.watchOptions = {};
		for (const option of Object.keys(extendedConfig.watchOptions)) extendingConfig.watchOptions[option] = rebaseRelative(option, extendedConfig.watchOptions[option], relativePath);
	} else extendingConfig[key] = rebaseRelative(key, extendedConfig[key], relativePath);
}
const REBASE_KEYS = [
	"files",
	"include",
	"exclude",
	"baseUrl",
	"rootDir",
	"rootDirs",
	"typeRoots",
	"outDir",
	"outFile",
	"declarationDir",
	"excludeDirectories",
	"excludeFiles"
];
/** @typedef {string | string[]} PathValue */
/**
*
* @param {string} key
* @param {PathValue} value
* @param {string} prependPath
* @returns {PathValue}
*/
function rebaseRelative(key, value$1, prependPath) {
	if (!REBASE_KEYS.includes(key)) return value$1;
	if (Array.isArray(value$1)) return value$1.map((x) => rebasePath(x, prependPath));
	else return rebasePath(value$1, prependPath);
}
/**
*
* @param {string} value
* @param {string} prependPath
* @returns {string}
*/
function rebasePath(value$1, prependPath) {
	if (path.isAbsolute(value$1) || value$1.startsWith("${configDir}")) return value$1;
	else return path.posix.normalize(path.posix.join(prependPath, value$1));
}
var TSConfckParseError = class TSConfckParseError extends Error {
	/**
	* error code
	* @type {string}
	*/
	code;
	/**
	* error cause
	* @type { Error | undefined}
	*/
	cause;
	/**
	* absolute path of tsconfig file where the error happened
	* @type {string}
	*/
	tsconfigFile;
	/**
	*
	* @param {string} message - error message
	* @param {string} code - error code
	* @param {string} tsconfigFile - path to tsconfig file
	* @param {Error?} cause - cause of this error
	*/
	constructor(message, code, tsconfigFile, cause) {
		super(message);
		Object.setPrototypeOf(this, TSConfckParseError.prototype);
		this.name = TSConfckParseError.name;
		this.code = code;
		this.cause = cause;
		this.tsconfigFile = tsconfigFile;
	}
};
/**
*
* @param {any} tsconfig
* @param {string} tsconfigFile
*/
function applyDefaults(tsconfig, tsconfigFile) {
	if (isJSConfig(tsconfigFile)) tsconfig.compilerOptions = {
		...DEFAULT_JSCONFIG_COMPILER_OPTIONS,
		...tsconfig.compilerOptions
	};
}
const DEFAULT_JSCONFIG_COMPILER_OPTIONS = {
	allowJs: true,
	maxNodeModuleJsDepth: 2,
	allowSyntheticDefaultImports: true,
	skipLibCheck: true,
	noEmit: true
};
/**
* @param {string} configFileName
*/
function isJSConfig(configFileName) {
	return path.basename(configFileName) === "jsconfig.json";
}

//#endregion
//#region ../../node_modules/.pnpm/tsconfck@3.1.6_typescript@5.9.2/node_modules/tsconfck/src/parse-native.js
/** @typedef TSDiagnosticError {
code: number;
category: number;
messageText: string;
start?: number;
} TSDiagnosticError */

//#endregion
//#region ../../node_modules/.pnpm/tsconfck@3.1.6_typescript@5.9.2/node_modules/tsconfck/src/cache.js
/** @template T */
var TSConfckCache = class {
	/**
	* clear cache, use this if you have a long running process and tsconfig files have been added,changed or deleted
	*/
	clear() {
		this.#configPaths.clear();
		this.#parsed.clear();
	}
	/**
	* has cached closest config for files in dir
	* @param {string} dir
	* @param {string} [configName=tsconfig.json]
	* @returns {boolean}
	*/
	hasConfigPath(dir, configName = "tsconfig.json") {
		return this.#configPaths.has(`${dir}/${configName}`);
	}
	/**
	* get cached closest tsconfig for files in dir
	* @param {string} dir
	* @param {string} [configName=tsconfig.json]
	* @returns {Promise<string|null>|string|null}
	* @throws {unknown} if cached value is an error
	*/
	getConfigPath(dir, configName = "tsconfig.json") {
		const key = `${dir}/${configName}`;
		const value$1 = this.#configPaths.get(key);
		if (value$1 == null || value$1.length || value$1.then) return value$1;
		else throw value$1;
	}
	/**
	* has parsed tsconfig for file
	* @param {string} file
	* @returns {boolean}
	*/
	hasParseResult(file) {
		return this.#parsed.has(file);
	}
	/**
	* get parsed tsconfig for file
	* @param {string} file
	* @returns {Promise<T>|T}
	* @throws {unknown} if cached value is an error
	*/
	getParseResult(file) {
		const value$1 = this.#parsed.get(file);
		if (value$1.then || value$1.tsconfig) return value$1;
		else throw value$1;
	}
	/**
	* @internal
	* @private
	* @param file
	* @param {boolean} isRootFile a flag to check if current file which involking the parse() api, used to distinguish the normal cache which only parsed by parseFile()
	* @param {Promise<T>} result
	*/
	setParseResult(file, result, isRootFile = false) {
		Object.defineProperty(result, "_isRootFile_", {
			value: isRootFile,
			writable: false,
			enumerable: false,
			configurable: false
		});
		this.#parsed.set(file, result);
		result.then((parsed) => {
			if (this.#parsed.get(file) === result) this.#parsed.set(file, parsed);
		}).catch((e$1) => {
			if (this.#parsed.get(file) === result) this.#parsed.set(file, e$1);
		});
	}
	/**
	* @internal
	* @private
	* @param {string} dir
	* @param {Promise<string|null>} configPath
	* @param {string} [configName=tsconfig.json]
	*/
	setConfigPath(dir, configPath, configName = "tsconfig.json") {
		const key = `${dir}/${configName}`;
		this.#configPaths.set(key, configPath);
		configPath.then((path$13) => {
			if (this.#configPaths.get(key) === configPath) this.#configPaths.set(key, path$13);
		}).catch((e$1) => {
			if (this.#configPaths.get(key) === configPath) this.#configPaths.set(key, e$1);
		});
	}
	/**
	* map directories to their closest tsconfig.json
	* @internal
	* @private
	* @type{Map<string,(Promise<string|null>|string|null)>}
	*/
	#configPaths = /* @__PURE__ */ new Map();
	/**
	* map files to their parsed tsconfig result
	* @internal
	* @private
	* @type {Map<string,(Promise<T>|T)> }
	*/
	#parsed = /* @__PURE__ */ new Map();
};

//#endregion
//#region src/node/plugins/esbuild.ts
var import_picocolors$31 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const debug$17 = createDebugger("vite:esbuild");
const IIFE_BEGIN_RE = /(?:const|var)\s+\S+\s*=\s*\(?function\([^()]*\)\s*\{\s*"use strict";/;
const validExtensionRE = /\.\w+$/;
const jsxExtensionsRE = /\.(?:j|t)sx\b/;
const defaultEsbuildSupported = {
	"dynamic-import": true,
	"import-meta": true
};
async function transformWithEsbuild(code, filename, options$1, inMap, config$2, watcher) {
	let loader$1 = options$1?.loader;
	if (!loader$1) {
		const ext = path.extname(validExtensionRE.test(filename) ? filename : cleanUrl(filename)).slice(1);
		if (ext === "cjs" || ext === "mjs") loader$1 = "js";
		else if (ext === "cts" || ext === "mts") loader$1 = "ts";
		else loader$1 = ext;
	}
	let tsconfigRaw = options$1?.tsconfigRaw;
	if (typeof tsconfigRaw !== "string") {
		const meaningfulFields = [
			"alwaysStrict",
			"experimentalDecorators",
			"importsNotUsedAsValues",
			"jsx",
			"jsxFactory",
			"jsxFragmentFactory",
			"jsxImportSource",
			"preserveValueImports",
			"target",
			"useDefineForClassFields",
			"verbatimModuleSyntax"
		];
		const compilerOptionsForFile = {};
		if (loader$1 === "ts" || loader$1 === "tsx") try {
			const { tsconfig: loadedTsconfig, tsconfigFile } = await loadTsconfigJsonForFile(filename, config$2);
			if (watcher && tsconfigFile && config$2) ensureWatchedFile(watcher, tsconfigFile, config$2.root);
			const loadedCompilerOptions = loadedTsconfig.compilerOptions ?? {};
			for (const field of meaningfulFields) if (field in loadedCompilerOptions) compilerOptionsForFile[field] = loadedCompilerOptions[field];
		} catch (e$1) {
			if (e$1 instanceof TSConfckParseError) {
				if (watcher && e$1.tsconfigFile && config$2) ensureWatchedFile(watcher, e$1.tsconfigFile, config$2.root);
			}
			throw e$1;
		}
		const compilerOptions = {
			...compilerOptionsForFile,
			...tsconfigRaw?.compilerOptions
		};
		if (compilerOptions.useDefineForClassFields === void 0 && compilerOptions.target === void 0) compilerOptions.useDefineForClassFields = false;
		if (options$1) {
			if (options$1.jsx) compilerOptions.jsx = void 0;
			if (options$1.jsxFactory) compilerOptions.jsxFactory = void 0;
			if (options$1.jsxFragment) compilerOptions.jsxFragmentFactory = void 0;
			if (options$1.jsxImportSource) compilerOptions.jsxImportSource = void 0;
		}
		tsconfigRaw = {
			...tsconfigRaw,
			compilerOptions
		};
	}
	const resolvedOptions = {
		sourcemap: true,
		sourcefile: filename,
		...options$1,
		loader: loader$1,
		tsconfigRaw
	};
	delete resolvedOptions.include;
	delete resolvedOptions.exclude;
	delete resolvedOptions.jsxInject;
	try {
		const result = await transform(code, resolvedOptions);
		let map$1;
		if (inMap && resolvedOptions.sourcemap) {
			const nextMap = JSON.parse(result.map);
			nextMap.sourcesContent = [];
			map$1 = combineSourcemaps(filename, [nextMap, inMap]);
		} else map$1 = resolvedOptions.sourcemap && resolvedOptions.sourcemap !== "inline" ? JSON.parse(result.map) : { mappings: "" };
		return {
			...result,
			map: map$1
		};
	} catch (e$1) {
		debug$17?.(`esbuild error with options used: `, resolvedOptions);
		if (e$1.errors) {
			e$1.frame = "";
			e$1.errors.forEach((m$2) => {
				if (m$2.text === "Experimental decorators are not currently enabled" || m$2.text === "Parameter decorators only work when experimental decorators are enabled") m$2.text += ". Vite 5 now uses esbuild 0.18 and you need to enable them by adding \"experimentalDecorators\": true in your \"tsconfig.json\" file.";
				e$1.frame += `\n` + prettifyMessage(m$2, code);
			});
			e$1.loc = e$1.errors[0].location;
		}
		throw e$1;
	}
}
function esbuildPlugin(config$2) {
	const { jsxInject, include, exclude,...esbuildTransformOptions } = config$2.esbuild;
	const filter$1 = createFilter(include || /\.(m?ts|[jt]sx)$/, exclude || /\.js$/);
	const transformOptions = {
		target: "esnext",
		charset: "utf8",
		...esbuildTransformOptions,
		minify: false,
		minifyIdentifiers: false,
		minifySyntax: false,
		minifyWhitespace: false,
		treeShaking: false,
		keepNames: false,
		supported: {
			...defaultEsbuildSupported,
			...esbuildTransformOptions.supported
		}
	};
	let server;
	return {
		name: "vite:esbuild",
		configureServer(_server) {
			server = _server;
		},
		async transform(code, id) {
			if (filter$1(id) || filter$1(cleanUrl(id))) {
				const result = await transformWithEsbuild(code, id, transformOptions, void 0, config$2, server?.watcher);
				if (result.warnings.length) result.warnings.forEach((m$2) => {
					this.warn(prettifyMessage(m$2, code));
				});
				if (jsxInject && jsxExtensionsRE.test(id)) result.code = jsxInject + ";" + result.code;
				return {
					code: result.code,
					map: result.map
				};
			}
		}
	};
}
const rollupToEsbuildFormatMap = {
	es: "esm",
	cjs: "cjs",
	iife: void 0
};
const injectEsbuildHelpers = (esbuildCode, format$3) => {
	const contentIndex = format$3 === "iife" ? Math.max(esbuildCode.search(IIFE_BEGIN_RE), 0) : format$3 === "umd" ? esbuildCode.indexOf(`(function(`) : 0;
	if (contentIndex > 0) {
		const esbuildHelpers = esbuildCode.slice(0, contentIndex);
		return esbuildCode.slice(contentIndex).replace("\"use strict\";", (m$2) => m$2 + esbuildHelpers);
	}
	return esbuildCode;
};
const buildEsbuildPlugin = () => {
	return {
		name: "vite:esbuild-transpile",
		applyToEnvironment(environment) {
			return environment.config.esbuild !== false;
		},
		async renderChunk(code, chunk, opts) {
			if (opts.__vite_skip_esbuild__) return null;
			const config$2 = this.environment.config;
			const options$1 = resolveEsbuildTranspileOptions(config$2, opts.format);
			if (!options$1) return null;
			const res = await transformWithEsbuild(code, chunk.fileName, options$1, void 0, config$2);
			if (config$2.build.lib) res.code = injectEsbuildHelpers(res.code, opts.format);
			return res;
		}
	};
};
function resolveEsbuildTranspileOptions(config$2, format$3) {
	const target = config$2.build.target;
	const minify = config$2.build.minify === "esbuild";
	if ((!target || target === "esnext") && !minify) return null;
	const isEsLibBuild = config$2.build.lib && format$3 === "es";
	const esbuildOptions = config$2.esbuild || {};
	const options$1 = {
		charset: "utf8",
		...esbuildOptions,
		loader: "js",
		target: target || void 0,
		format: rollupToEsbuildFormatMap[format$3],
		supported: {
			...defaultEsbuildSupported,
			...esbuildOptions.supported
		}
	};
	if (!minify) return {
		...options$1,
		minify: false,
		minifyIdentifiers: false,
		minifySyntax: false,
		minifyWhitespace: false,
		treeShaking: false
	};
	if (options$1.minifyIdentifiers != null || options$1.minifySyntax != null || options$1.minifyWhitespace != null) if (isEsLibBuild) return {
		...options$1,
		minify: false,
		minifyIdentifiers: options$1.minifyIdentifiers ?? true,
		minifySyntax: options$1.minifySyntax ?? true,
		minifyWhitespace: false,
		treeShaking: true
	};
	else return {
		...options$1,
		minify: false,
		minifyIdentifiers: options$1.minifyIdentifiers ?? true,
		minifySyntax: options$1.minifySyntax ?? true,
		minifyWhitespace: options$1.minifyWhitespace ?? true,
		treeShaking: true
	};
	if (isEsLibBuild) return {
		...options$1,
		minify: false,
		minifyIdentifiers: true,
		minifySyntax: true,
		minifyWhitespace: false,
		treeShaking: true
	};
	else return {
		...options$1,
		minify: true,
		treeShaking: true
	};
}
function prettifyMessage(m$2, code) {
	let res = import_picocolors$31.default.yellow(m$2.text);
	if (m$2.location) res += `\n` + generateCodeFrame(code, m$2.location);
	return res + `\n`;
}
let globalTSConfckCache;
const tsconfckCacheMap = /* @__PURE__ */ new WeakMap();
function getTSConfckCache(config$2) {
	if (!config$2) return globalTSConfckCache ??= new TSConfckCache();
	let cache$1 = tsconfckCacheMap.get(config$2);
	if (!cache$1) {
		cache$1 = new TSConfckCache();
		tsconfckCacheMap.set(config$2, cache$1);
	}
	return cache$1;
}
async function loadTsconfigJsonForFile(filename, config$2) {
	const { tsconfig, tsconfigFile } = await parse$14(filename, {
		cache: getTSConfckCache(config$2),
		ignoreNodeModules: true
	});
	return {
		tsconfigFile,
		tsconfig
	};
}
async function reloadOnTsconfigChange(server, changedFile) {
	if (changedFile.endsWith(".json")) {
		const cache$1 = getTSConfckCache(server.config);
		if (changedFile.endsWith("/tsconfig.json") || cache$1.hasParseResult(changedFile)) {
			server.config.logger.info(`changed tsconfig file detected: ${changedFile} - Clearing cache and forcing full-reload to ensure TypeScript is compiled with updated config values.`, {
				clear: server.config.clearScreen,
				timestamp: true
			});
			for (const environment of Object.values(server.environments)) environment.moduleGraph.invalidateAll();
			cache$1.clear();
			for (const environment of Object.values(server.environments)) environment.hot.send({
				type: "full-reload",
				path: "*"
			});
		}
	}
}

//#endregion
//#region ../../node_modules/.pnpm/artichokie@0.4.2/node_modules/artichokie/dist/index.js
const AsyncFunction = async function() {}.constructor;
const codeToDataUrl = (code) => `data:application/javascript,${encodeURIComponent(code + "\n//# sourceURL=[worker-eval(artichokie)]")}`;
const viteSsrDynamicImport = "__vite_ssr_dynamic_import__";
const stackBlitzImport = "𝐢𝐦𝐩𝐨𝐫𝐭";
var Worker$1 = class {
	/** @internal */
	_isModule;
	/** @internal */
	_code;
	/** @internal */
	_parentFunctions;
	/** @internal */
	_max;
	/** @internal */
	_pool;
	/** @internal */
	_idlePool;
	/** @internal */
	_queue;
	constructor(fn, options$1 = {}) {
		this._isModule = options$1.type === "module";
		this._code = genWorkerCode(fn, this._isModule, 5 * 1e3, options$1.parentFunctions ?? {});
		this._parentFunctions = options$1.parentFunctions ?? {};
		const defaultMax = Math.max(1, (os.availableParallelism?.() ?? os.cpus().length) - 1);
		this._max = options$1.max || defaultMax;
		this._pool = [];
		this._idlePool = [];
		this._queue = [];
	}
	async run(...args) {
		const worker = await this._getAvailableWorker();
		return new Promise((resolve$4, reject) => {
			worker.currentResolve = resolve$4;
			worker.currentReject = reject;
			worker.postMessage({ args });
		});
	}
	stop() {
		this._pool.forEach((w$1) => w$1.unref());
		this._queue.forEach(([, reject]) => reject(/* @__PURE__ */ new Error("Main worker pool stopped before a worker was available.")));
		this._pool = [];
		this._idlePool = [];
		this._queue = [];
	}
	/** @internal */
	_createWorker(parentFunctionSyncMessagePort, parentFunctionAsyncMessagePort, lockState) {
		const options$1 = {
			workerData: [
				parentFunctionSyncMessagePort,
				parentFunctionAsyncMessagePort,
				lockState
			],
			transferList: [parentFunctionSyncMessagePort, parentFunctionAsyncMessagePort]
		};
		if (this._isModule) return new Worker(new URL(codeToDataUrl(this._code)), options$1);
		return new Worker(this._code, {
			...options$1,
			eval: true
		});
	}
	/** @internal */
	async _getAvailableWorker() {
		if (this._idlePool.length) return this._idlePool.shift();
		if (this._pool.length < this._max) {
			const parentFunctionResponder = createParentFunctionResponder(this._parentFunctions);
			const worker = this._createWorker(parentFunctionResponder.workerPorts.sync, parentFunctionResponder.workerPorts.async, parentFunctionResponder.lockState);
			worker.on("message", async (args) => {
				if ("result" in args) {
					worker.currentResolve?.(args.result);
					worker.currentResolve = null;
				} else {
					if (args.error instanceof ReferenceError) args.error.message += ". Maybe you forgot to pass the function to parentFunction?";
					worker.currentReject?.(args.error);
					worker.currentReject = null;
				}
				this._assignDoneWorker(worker);
			});
			worker.on("error", (err$2) => {
				worker.currentReject?.(err$2);
				worker.currentReject = null;
				parentFunctionResponder.close();
			});
			worker.on("exit", (code) => {
				const i$1 = this._pool.indexOf(worker);
				if (i$1 > -1) this._pool.splice(i$1, 1);
				if (code !== 0 && worker.currentReject) {
					worker.currentReject(/* @__PURE__ */ new Error(`Worker stopped with non-0 exit code ${code}`));
					worker.currentReject = null;
					parentFunctionResponder.close();
				}
			});
			this._pool.push(worker);
			return worker;
		}
		let resolve$4;
		let reject;
		const onWorkerAvailablePromise = new Promise((r$1, rj) => {
			resolve$4 = r$1;
			reject = rj;
		});
		this._queue.push([resolve$4, reject]);
		return onWorkerAvailablePromise;
	}
	/** @internal */
	_assignDoneWorker(worker) {
		if (this._queue.length) {
			const [resolve$4] = this._queue.shift();
			resolve$4(worker);
			return;
		}
		this._idlePool.push(worker);
	}
};
function createParentFunctionResponder(parentFunctions) {
	const lockState = new Int32Array(new SharedArrayBuffer(4));
	const unlock = () => {
		Atomics.store(lockState, 0, 0);
		Atomics.notify(lockState, 0);
	};
	const parentFunctionSyncMessageChannel = new MessageChannel();
	const parentFunctionAsyncMessageChannel = new MessageChannel();
	const parentFunctionSyncMessagePort = parentFunctionSyncMessageChannel.port1;
	const parentFunctionAsyncMessagePort = parentFunctionAsyncMessageChannel.port1;
	const syncResponse = (data) => {
		parentFunctionSyncMessagePort.postMessage(data);
		unlock();
	};
	parentFunctionSyncMessagePort.on("message", async (args) => {
		let syncResult;
		try {
			syncResult = parentFunctions[args.name](...args.args);
		} catch (error$1) {
			syncResponse({
				id: args.id,
				error: error$1
			});
			return;
		}
		if (!(typeof syncResult === "object" && syncResult !== null && "then" in syncResult && typeof syncResult.then === "function")) {
			syncResponse({
				id: args.id,
				result: syncResult
			});
			return;
		}
		syncResponse({
			id: args.id,
			isAsync: true
		});
		try {
			const result = await syncResult;
			parentFunctionAsyncMessagePort.postMessage({
				id: args.id,
				result
			});
		} catch (error$1) {
			parentFunctionAsyncMessagePort.postMessage({
				id: args.id,
				error: error$1
			});
		}
	});
	parentFunctionSyncMessagePort.unref();
	return {
		close: () => {
			parentFunctionSyncMessagePort.close();
			parentFunctionAsyncMessagePort.close();
		},
		lockState,
		workerPorts: {
			sync: parentFunctionSyncMessageChannel.port2,
			async: parentFunctionAsyncMessageChannel.port2
		}
	};
}
function genWorkerCode(fn, isModule, waitTimeout, parentFunctions) {
	const createLock = (performance$2, lockState) => {
		return {
			lock: () => {
				Atomics.store(lockState, 0, 1);
			},
			waitUnlock: () => {
				let utilizationBefore;
				while (true) {
					const status$1 = Atomics.wait(lockState, 0, 1, waitTimeout);
					if (status$1 === "timed-out") {
						if (utilizationBefore === void 0) {
							utilizationBefore = performance$2.eventLoopUtilization();
							continue;
						}
						utilizationBefore = performance$2.eventLoopUtilization(utilizationBefore);
						if (utilizationBefore.utilization > .9) continue;
						throw new Error(status$1);
					}
					break;
				}
			}
		};
	};
	const createParentFunctionRequester = (syncPort, asyncPort, receive, lock) => {
		let id = 0;
		const resolvers = /* @__PURE__ */ new Map();
		const call$1 = (key) => (...args) => {
			id++;
			lock.lock();
			syncPort.postMessage({
				id,
				name: key,
				args
			});
			lock.waitUnlock();
			const resArgs = receive(syncPort).message;
			if (resArgs.isAsync) {
				let resolve$4, reject;
				const promise = new Promise((res, rej) => {
					resolve$4 = res;
					reject = rej;
				});
				resolvers.set(id, {
					resolve: resolve$4,
					reject
				});
				return promise;
			}
			if ("error" in resArgs) throw resArgs.error;
			else return resArgs.result;
		};
		asyncPort.on("message", (args) => {
			const id$1 = args.id;
			if (resolvers.has(id$1)) {
				const { resolve: resolve$4, reject } = resolvers.get(id$1);
				resolvers.delete(id$1);
				if ("result" in args) resolve$4(args.result);
				else reject(args.error);
			}
		});
		return { call: call$1 };
	};
	const fnString = fn.toString().replaceAll(stackBlitzImport, "import").replaceAll(viteSsrDynamicImport, "import");
	return `
${isModule ? "import { parentPort, receiveMessageOnPort, workerData } from 'worker_threads'" : "const { parentPort, receiveMessageOnPort, workerData } = require('worker_threads')"}
${isModule ? "import { performance } from 'node:perf_hooks'" : "const { performance } = require('node:perf_hooks')"}
const [parentFunctionSyncMessagePort, parentFunctionAsyncMessagePort, lockState] = workerData
const waitTimeout = ${waitTimeout}
const createLock = ${createLock.toString()}
const parentFunctionRequester = (${createParentFunctionRequester.toString()})(
  parentFunctionSyncMessagePort,
  parentFunctionAsyncMessagePort,
  receiveMessageOnPort,
  createLock(performance, lockState)
)

const doWorkPromise = (async () => {
  ${Object.keys(parentFunctions).map((key) => `const ${key} = parentFunctionRequester.call(${JSON.stringify(key)});`).join("\n")}
  return await (${fnString})()
})()
let doWork

parentPort.on('message', async (args) => {
  doWork ||= await doWorkPromise

  try {
    const res = await doWork(...args.args)
    parentPort.postMessage({ result: res })
  } catch (e) {
    parentPort.postMessage({ error: e })
  }
})
  `;
}
const importRe = /\bimport\s*\(/g;
const internalImportName = "__artichokie_local_import__";
var FakeWorker = class {
	/** @internal */
	_fn;
	constructor(fn, options$1 = {}) {
		const declareRequire = options$1.type !== "module";
		const argsAndCode = genFakeWorkerArgsAndCode(fn, declareRequire, options$1.parentFunctions ?? {});
		const localImport = (specifier) => import(specifier);
		const args = [
			...declareRequire ? [createRequire(import.meta.url)] : [],
			localImport,
			options$1.parentFunctions
		];
		this._fn = new AsyncFunction(...argsAndCode)(...args);
	}
	async run(...args) {
		try {
			return await (await this._fn)(...args);
		} catch (err$2) {
			if (err$2 instanceof ReferenceError) err$2.message += ". Maybe you forgot to pass the function to parentFunction?";
			throw err$2;
		}
	}
	stop() {}
};
function genFakeWorkerArgsAndCode(fn, declareRequire, parentFunctions) {
	const fnString = fn.toString().replace(importRe, `${internalImportName}(`).replaceAll(stackBlitzImport, internalImportName).replaceAll(viteSsrDynamicImport, internalImportName);
	return [
		...declareRequire ? ["require"] : [],
		internalImportName,
		"parentFunctions",
		`
${Object.keys(parentFunctions).map((key) => `const ${key} = parentFunctions[${JSON.stringify(key)}];`).join("\n")}
return await (${fnString})()
  `
	];
}
var WorkerWithFallback = class {
	/** @internal */
	_disableReal;
	/** @internal */
	_realWorker;
	/** @internal */
	_fakeWorker;
	/** @internal */
	_shouldUseFake;
	constructor(fn, options$1) {
		this._disableReal = options$1.max !== void 0 && options$1.max <= 0;
		this._realWorker = new Worker$1(fn, options$1);
		this._fakeWorker = new FakeWorker(fn, options$1);
		this._shouldUseFake = options$1.shouldUseFake;
	}
	async run(...args) {
		const useFake = this._disableReal || this._shouldUseFake(...args);
		return this[useFake ? "_fakeWorker" : "_realWorker"].run(...args);
	}
	stop() {
		this._realWorker.stop();
		this._fakeWorker.stop();
	}
};

//#endregion
//#region src/node/plugins/terser.ts
let terserPath;
const loadTerserPath = (root) => {
	if (terserPath) return terserPath;
	try {
		terserPath = requireResolveFromRootWithFallback(root, "terser");
	} catch (e$1) {
		if (e$1.code === "MODULE_NOT_FOUND") throw new Error("terser not found. Since Vite v3, terser has become an optional dependency. You need to install it.");
		else {
			const message = /* @__PURE__ */ new Error(`terser failed to load:\n${e$1.message}`);
			message.stack = e$1.stack + "\n" + message.stack;
			throw message;
		}
	}
	return terserPath;
};
function terserPlugin(config$2) {
	const { maxWorkers,...terserOptions } = config$2.build.terserOptions;
	const makeWorker = () => new WorkerWithFallback(() => async (terserPath$1, code, options$1) => {
		const terser = (await import(terserPath$1)).default;
		try {
			return await terser.minify(code, options$1);
		} catch (e$1) {
			throw {
				stack: e$1.stack,
				...e$1
			};
		}
	}, {
		shouldUseFake(_terserPath, _code, options$1) {
			return !!(typeof options$1.mangle === "object" && (options$1.mangle.nth_identifier?.get || typeof options$1.mangle.properties === "object" && options$1.mangle.properties.nth_identifier?.get) || typeof options$1.format?.comments === "function" || typeof options$1.output?.comments === "function" || options$1.nameCache);
		},
		max: maxWorkers
	});
	let worker;
	return {
		name: "vite:terser",
		applyToEnvironment(environment) {
			return !!environment.config.build.minify;
		},
		async renderChunk(code, chunk, outputOptions) {
			if (config$2.build.minify !== "terser" && !outputOptions.__vite_force_terser__) return null;
			if (config$2.build.lib && outputOptions.format === "es") return null;
			worker ||= makeWorker();
			const terserPath$1 = pathToFileURL(loadTerserPath(config$2.root)).href;
			try {
				const res = await worker.run(terserPath$1, code, {
					safari10: true,
					...terserOptions,
					sourceMap: !!outputOptions.sourcemap,
					module: outputOptions.format.startsWith("es"),
					toplevel: outputOptions.format === "cjs"
				});
				return {
					code: res.code,
					map: res.map
				};
			} catch (e$1) {
				if (e$1.line !== void 0 && e$1.col !== void 0) e$1.loc = {
					file: chunk.fileName,
					line: e$1.line,
					column: e$1.col
				};
				if (e$1.pos !== void 0) e$1.frame = generateCodeFrame(code, e$1.pos);
				throw e$1;
			}
		},
		closeBundle() {
			worker?.stop();
		}
	};
}

//#endregion
//#region ../../node_modules/.pnpm/mrmime@2.0.1/node_modules/mrmime/index.mjs
const mimes = {
	"3g2": "video/3gpp2",
	"3gp": "video/3gpp",
	"3gpp": "video/3gpp",
	"3mf": "model/3mf",
	"aac": "audio/aac",
	"ac": "application/pkix-attr-cert",
	"adp": "audio/adpcm",
	"adts": "audio/aac",
	"ai": "application/postscript",
	"aml": "application/automationml-aml+xml",
	"amlx": "application/automationml-amlx+zip",
	"amr": "audio/amr",
	"apng": "image/apng",
	"appcache": "text/cache-manifest",
	"appinstaller": "application/appinstaller",
	"appx": "application/appx",
	"appxbundle": "application/appxbundle",
	"asc": "application/pgp-keys",
	"atom": "application/atom+xml",
	"atomcat": "application/atomcat+xml",
	"atomdeleted": "application/atomdeleted+xml",
	"atomsvc": "application/atomsvc+xml",
	"au": "audio/basic",
	"avci": "image/avci",
	"avcs": "image/avcs",
	"avif": "image/avif",
	"aw": "application/applixware",
	"bdoc": "application/bdoc",
	"bin": "application/octet-stream",
	"bmp": "image/bmp",
	"bpk": "application/octet-stream",
	"btf": "image/prs.btif",
	"btif": "image/prs.btif",
	"buffer": "application/octet-stream",
	"ccxml": "application/ccxml+xml",
	"cdfx": "application/cdfx+xml",
	"cdmia": "application/cdmi-capability",
	"cdmic": "application/cdmi-container",
	"cdmid": "application/cdmi-domain",
	"cdmio": "application/cdmi-object",
	"cdmiq": "application/cdmi-queue",
	"cer": "application/pkix-cert",
	"cgm": "image/cgm",
	"cjs": "application/node",
	"class": "application/java-vm",
	"coffee": "text/coffeescript",
	"conf": "text/plain",
	"cpl": "application/cpl+xml",
	"cpt": "application/mac-compactpro",
	"crl": "application/pkix-crl",
	"css": "text/css",
	"csv": "text/csv",
	"cu": "application/cu-seeme",
	"cwl": "application/cwl",
	"cww": "application/prs.cww",
	"davmount": "application/davmount+xml",
	"dbk": "application/docbook+xml",
	"deb": "application/octet-stream",
	"def": "text/plain",
	"deploy": "application/octet-stream",
	"dib": "image/bmp",
	"disposition-notification": "message/disposition-notification",
	"dist": "application/octet-stream",
	"distz": "application/octet-stream",
	"dll": "application/octet-stream",
	"dmg": "application/octet-stream",
	"dms": "application/octet-stream",
	"doc": "application/msword",
	"dot": "application/msword",
	"dpx": "image/dpx",
	"drle": "image/dicom-rle",
	"dsc": "text/prs.lines.tag",
	"dssc": "application/dssc+der",
	"dtd": "application/xml-dtd",
	"dump": "application/octet-stream",
	"dwd": "application/atsc-dwd+xml",
	"ear": "application/java-archive",
	"ecma": "application/ecmascript",
	"elc": "application/octet-stream",
	"emf": "image/emf",
	"eml": "message/rfc822",
	"emma": "application/emma+xml",
	"emotionml": "application/emotionml+xml",
	"eps": "application/postscript",
	"epub": "application/epub+zip",
	"exe": "application/octet-stream",
	"exi": "application/exi",
	"exp": "application/express",
	"exr": "image/aces",
	"ez": "application/andrew-inset",
	"fdf": "application/fdf",
	"fdt": "application/fdt+xml",
	"fits": "image/fits",
	"g3": "image/g3fax",
	"gbr": "application/rpki-ghostbusters",
	"geojson": "application/geo+json",
	"gif": "image/gif",
	"glb": "model/gltf-binary",
	"gltf": "model/gltf+json",
	"gml": "application/gml+xml",
	"gpx": "application/gpx+xml",
	"gram": "application/srgs",
	"grxml": "application/srgs+xml",
	"gxf": "application/gxf",
	"gz": "application/gzip",
	"h261": "video/h261",
	"h263": "video/h263",
	"h264": "video/h264",
	"heic": "image/heic",
	"heics": "image/heic-sequence",
	"heif": "image/heif",
	"heifs": "image/heif-sequence",
	"hej2": "image/hej2k",
	"held": "application/atsc-held+xml",
	"hjson": "application/hjson",
	"hlp": "application/winhlp",
	"hqx": "application/mac-binhex40",
	"hsj2": "image/hsj2",
	"htm": "text/html",
	"html": "text/html",
	"ics": "text/calendar",
	"ief": "image/ief",
	"ifb": "text/calendar",
	"iges": "model/iges",
	"igs": "model/iges",
	"img": "application/octet-stream",
	"in": "text/plain",
	"ini": "text/plain",
	"ink": "application/inkml+xml",
	"inkml": "application/inkml+xml",
	"ipfix": "application/ipfix",
	"iso": "application/octet-stream",
	"its": "application/its+xml",
	"jade": "text/jade",
	"jar": "application/java-archive",
	"jhc": "image/jphc",
	"jls": "image/jls",
	"jp2": "image/jp2",
	"jpe": "image/jpeg",
	"jpeg": "image/jpeg",
	"jpf": "image/jpx",
	"jpg": "image/jpeg",
	"jpg2": "image/jp2",
	"jpgm": "image/jpm",
	"jpgv": "video/jpeg",
	"jph": "image/jph",
	"jpm": "image/jpm",
	"jpx": "image/jpx",
	"js": "text/javascript",
	"json": "application/json",
	"json5": "application/json5",
	"jsonld": "application/ld+json",
	"jsonml": "application/jsonml+json",
	"jsx": "text/jsx",
	"jt": "model/jt",
	"jxl": "image/jxl",
	"jxr": "image/jxr",
	"jxra": "image/jxra",
	"jxrs": "image/jxrs",
	"jxs": "image/jxs",
	"jxsc": "image/jxsc",
	"jxsi": "image/jxsi",
	"jxss": "image/jxss",
	"kar": "audio/midi",
	"ktx": "image/ktx",
	"ktx2": "image/ktx2",
	"less": "text/less",
	"lgr": "application/lgr+xml",
	"list": "text/plain",
	"litcoffee": "text/coffeescript",
	"log": "text/plain",
	"lostxml": "application/lost+xml",
	"lrf": "application/octet-stream",
	"m1v": "video/mpeg",
	"m21": "application/mp21",
	"m2a": "audio/mpeg",
	"m2t": "video/mp2t",
	"m2ts": "video/mp2t",
	"m2v": "video/mpeg",
	"m3a": "audio/mpeg",
	"m4a": "audio/mp4",
	"m4p": "application/mp4",
	"m4s": "video/iso.segment",
	"ma": "application/mathematica",
	"mads": "application/mads+xml",
	"maei": "application/mmt-aei+xml",
	"man": "text/troff",
	"manifest": "text/cache-manifest",
	"map": "application/json",
	"mar": "application/octet-stream",
	"markdown": "text/markdown",
	"mathml": "application/mathml+xml",
	"mb": "application/mathematica",
	"mbox": "application/mbox",
	"md": "text/markdown",
	"mdx": "text/mdx",
	"me": "text/troff",
	"mesh": "model/mesh",
	"meta4": "application/metalink4+xml",
	"metalink": "application/metalink+xml",
	"mets": "application/mets+xml",
	"mft": "application/rpki-manifest",
	"mid": "audio/midi",
	"midi": "audio/midi",
	"mime": "message/rfc822",
	"mj2": "video/mj2",
	"mjp2": "video/mj2",
	"mjs": "text/javascript",
	"mml": "text/mathml",
	"mods": "application/mods+xml",
	"mov": "video/quicktime",
	"mp2": "audio/mpeg",
	"mp21": "application/mp21",
	"mp2a": "audio/mpeg",
	"mp3": "audio/mpeg",
	"mp4": "video/mp4",
	"mp4a": "audio/mp4",
	"mp4s": "application/mp4",
	"mp4v": "video/mp4",
	"mpd": "application/dash+xml",
	"mpe": "video/mpeg",
	"mpeg": "video/mpeg",
	"mpf": "application/media-policy-dataset+xml",
	"mpg": "video/mpeg",
	"mpg4": "video/mp4",
	"mpga": "audio/mpeg",
	"mpp": "application/dash-patch+xml",
	"mrc": "application/marc",
	"mrcx": "application/marcxml+xml",
	"ms": "text/troff",
	"mscml": "application/mediaservercontrol+xml",
	"msh": "model/mesh",
	"msi": "application/octet-stream",
	"msix": "application/msix",
	"msixbundle": "application/msixbundle",
	"msm": "application/octet-stream",
	"msp": "application/octet-stream",
	"mtl": "model/mtl",
	"mts": "video/mp2t",
	"musd": "application/mmt-usd+xml",
	"mxf": "application/mxf",
	"mxmf": "audio/mobile-xmf",
	"mxml": "application/xv+xml",
	"n3": "text/n3",
	"nb": "application/mathematica",
	"nq": "application/n-quads",
	"nt": "application/n-triples",
	"obj": "model/obj",
	"oda": "application/oda",
	"oga": "audio/ogg",
	"ogg": "audio/ogg",
	"ogv": "video/ogg",
	"ogx": "application/ogg",
	"omdoc": "application/omdoc+xml",
	"onepkg": "application/onenote",
	"onetmp": "application/onenote",
	"onetoc": "application/onenote",
	"onetoc2": "application/onenote",
	"opf": "application/oebps-package+xml",
	"opus": "audio/ogg",
	"otf": "font/otf",
	"owl": "application/rdf+xml",
	"oxps": "application/oxps",
	"p10": "application/pkcs10",
	"p7c": "application/pkcs7-mime",
	"p7m": "application/pkcs7-mime",
	"p7s": "application/pkcs7-signature",
	"p8": "application/pkcs8",
	"pdf": "application/pdf",
	"pfr": "application/font-tdpfr",
	"pgp": "application/pgp-encrypted",
	"pkg": "application/octet-stream",
	"pki": "application/pkixcmp",
	"pkipath": "application/pkix-pkipath",
	"pls": "application/pls+xml",
	"png": "image/png",
	"prc": "model/prc",
	"prf": "application/pics-rules",
	"provx": "application/provenance+xml",
	"ps": "application/postscript",
	"pskcxml": "application/pskc+xml",
	"pti": "image/prs.pti",
	"qt": "video/quicktime",
	"raml": "application/raml+yaml",
	"rapd": "application/route-apd+xml",
	"rdf": "application/rdf+xml",
	"relo": "application/p2p-overlay+xml",
	"rif": "application/reginfo+xml",
	"rl": "application/resource-lists+xml",
	"rld": "application/resource-lists-diff+xml",
	"rmi": "audio/midi",
	"rnc": "application/relax-ng-compact-syntax",
	"rng": "application/xml",
	"roa": "application/rpki-roa",
	"roff": "text/troff",
	"rq": "application/sparql-query",
	"rs": "application/rls-services+xml",
	"rsat": "application/atsc-rsat+xml",
	"rsd": "application/rsd+xml",
	"rsheet": "application/urc-ressheet+xml",
	"rss": "application/rss+xml",
	"rtf": "text/rtf",
	"rtx": "text/richtext",
	"rusd": "application/route-usd+xml",
	"s3m": "audio/s3m",
	"sbml": "application/sbml+xml",
	"scq": "application/scvp-cv-request",
	"scs": "application/scvp-cv-response",
	"sdp": "application/sdp",
	"senmlx": "application/senml+xml",
	"sensmlx": "application/sensml+xml",
	"ser": "application/java-serialized-object",
	"setpay": "application/set-payment-initiation",
	"setreg": "application/set-registration-initiation",
	"sgi": "image/sgi",
	"sgm": "text/sgml",
	"sgml": "text/sgml",
	"shex": "text/shex",
	"shf": "application/shf+xml",
	"shtml": "text/html",
	"sieve": "application/sieve",
	"sig": "application/pgp-signature",
	"sil": "audio/silk",
	"silo": "model/mesh",
	"siv": "application/sieve",
	"slim": "text/slim",
	"slm": "text/slim",
	"sls": "application/route-s-tsid+xml",
	"smi": "application/smil+xml",
	"smil": "application/smil+xml",
	"snd": "audio/basic",
	"so": "application/octet-stream",
	"spdx": "text/spdx",
	"spp": "application/scvp-vp-response",
	"spq": "application/scvp-vp-request",
	"spx": "audio/ogg",
	"sql": "application/sql",
	"sru": "application/sru+xml",
	"srx": "application/sparql-results+xml",
	"ssdl": "application/ssdl+xml",
	"ssml": "application/ssml+xml",
	"stk": "application/hyperstudio",
	"stl": "model/stl",
	"stpx": "model/step+xml",
	"stpxz": "model/step-xml+zip",
	"stpz": "model/step+zip",
	"styl": "text/stylus",
	"stylus": "text/stylus",
	"svg": "image/svg+xml",
	"svgz": "image/svg+xml",
	"swidtag": "application/swid+xml",
	"t": "text/troff",
	"t38": "image/t38",
	"td": "application/urc-targetdesc+xml",
	"tei": "application/tei+xml",
	"teicorpus": "application/tei+xml",
	"text": "text/plain",
	"tfi": "application/thraud+xml",
	"tfx": "image/tiff-fx",
	"tif": "image/tiff",
	"tiff": "image/tiff",
	"toml": "application/toml",
	"tr": "text/troff",
	"trig": "application/trig",
	"ts": "video/mp2t",
	"tsd": "application/timestamped-data",
	"tsv": "text/tab-separated-values",
	"ttc": "font/collection",
	"ttf": "font/ttf",
	"ttl": "text/turtle",
	"ttml": "application/ttml+xml",
	"txt": "text/plain",
	"u3d": "model/u3d",
	"u8dsn": "message/global-delivery-status",
	"u8hdr": "message/global-headers",
	"u8mdn": "message/global-disposition-notification",
	"u8msg": "message/global",
	"ubj": "application/ubjson",
	"uri": "text/uri-list",
	"uris": "text/uri-list",
	"urls": "text/uri-list",
	"vcard": "text/vcard",
	"vrml": "model/vrml",
	"vtt": "text/vtt",
	"vxml": "application/voicexml+xml",
	"war": "application/java-archive",
	"wasm": "application/wasm",
	"wav": "audio/wav",
	"weba": "audio/webm",
	"webm": "video/webm",
	"webmanifest": "application/manifest+json",
	"webp": "image/webp",
	"wgsl": "text/wgsl",
	"wgt": "application/widget",
	"wif": "application/watcherinfo+xml",
	"wmf": "image/wmf",
	"woff": "font/woff",
	"woff2": "font/woff2",
	"wrl": "model/vrml",
	"wsdl": "application/wsdl+xml",
	"wspolicy": "application/wspolicy+xml",
	"x3d": "model/x3d+xml",
	"x3db": "model/x3d+fastinfoset",
	"x3dbz": "model/x3d+binary",
	"x3dv": "model/x3d-vrml",
	"x3dvz": "model/x3d+vrml",
	"x3dz": "model/x3d+xml",
	"xaml": "application/xaml+xml",
	"xav": "application/xcap-att+xml",
	"xca": "application/xcap-caps+xml",
	"xcs": "application/calendar+xml",
	"xdf": "application/xcap-diff+xml",
	"xdssc": "application/dssc+xml",
	"xel": "application/xcap-el+xml",
	"xenc": "application/xenc+xml",
	"xer": "application/patch-ops-error+xml",
	"xfdf": "application/xfdf",
	"xht": "application/xhtml+xml",
	"xhtml": "application/xhtml+xml",
	"xhvml": "application/xv+xml",
	"xlf": "application/xliff+xml",
	"xm": "audio/xm",
	"xml": "text/xml",
	"xns": "application/xcap-ns+xml",
	"xop": "application/xop+xml",
	"xpl": "application/xproc+xml",
	"xsd": "application/xml",
	"xsf": "application/prs.xsf+xml",
	"xsl": "application/xml",
	"xslt": "application/xml",
	"xspf": "application/xspf+xml",
	"xvm": "application/xv+xml",
	"xvml": "application/xv+xml",
	"yaml": "text/yaml",
	"yang": "application/yang",
	"yin": "application/yin+xml",
	"yml": "text/yaml",
	"zip": "application/zip"
};
function lookup(extn) {
	let tmp = ("" + extn).trim().toLowerCase();
	let idx = tmp.lastIndexOf(".");
	return mimes[!~idx ? tmp : tmp.substring(++idx)];
}

//#endregion
//#region src/node/publicDir.ts
const publicFilesMap = /* @__PURE__ */ new WeakMap();
async function initPublicFiles(config$2) {
	let fileNames;
	try {
		fileNames = await recursiveReaddir(config$2.publicDir);
	} catch (e$1) {
		if (e$1.code === ERR_SYMLINK_IN_RECURSIVE_READDIR) return;
		throw e$1;
	}
	const publicFiles = new Set(fileNames.map((fileName) => fileName.slice(config$2.publicDir.length)));
	publicFilesMap.set(config$2, publicFiles);
	return publicFiles;
}
function getPublicFiles(config$2) {
	return publicFilesMap.get(config$2);
}
function checkPublicFile(url$3, config$2) {
	const { publicDir } = config$2;
	if (!publicDir || url$3[0] !== "/") return;
	const fileName = cleanUrl(url$3);
	const publicFiles = getPublicFiles(config$2);
	if (publicFiles) return publicFiles.has(fileName) ? normalizePath(path.join(publicDir, fileName)) : void 0;
	const publicFile = normalizePath(path.join(publicDir, fileName));
	if (!publicFile.startsWith(withTrailingSlash(publicDir))) return;
	return tryStatSync(publicFile)?.isFile() ? publicFile : void 0;
}

//#endregion
//#region src/node/plugins/asset.ts
var import_picocolors$30 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const assetUrlRE = /__VITE_ASSET__([\w$]+)__(?:\$_(.*?)__)?/g;
const jsSourceMapRE = /\.[cm]?js\.map$/;
const noInlineRE = /[?&]no-inline\b/;
const inlineRE$3 = /[?&]inline\b/;
const assetCache = /* @__PURE__ */ new WeakMap();
/** a set of referenceId for entry CSS assets for each environment */
const cssEntriesMap = /* @__PURE__ */ new WeakMap();
function registerCustomMime() {
	mimes.ico = "image/x-icon";
	mimes.cur = "image/x-icon";
	mimes.flac = "audio/flac";
	mimes.eot = "application/vnd.ms-fontobject";
}
function renderAssetUrlInJS(pluginContext, chunk, opts, code) {
	const { environment } = pluginContext;
	const toRelativeRuntime = createToImportMetaURLBasedRelativeRuntime(opts.format, environment.config.isWorker);
	let match;
	let s$2;
	assetUrlRE.lastIndex = 0;
	while (match = assetUrlRE.exec(code)) {
		s$2 ||= new MagicString(code);
		const [full, referenceId, postfix = ""] = match;
		const file = pluginContext.getFileName(referenceId);
		chunk.viteMetadata.importedAssets.add(cleanUrl(file));
		const replacement = toOutputFilePathInJS(environment, file + postfix, "asset", chunk.fileName, "js", toRelativeRuntime);
		const replacementString = typeof replacement === "string" ? JSON.stringify(encodeURIPath(replacement)).slice(1, -1) : `"+${replacement.runtime}+"`;
		s$2.update(match.index, match.index + full.length, replacementString);
	}
	const publicAssetUrlMap = publicAssetUrlCache.get(environment.getTopLevelConfig());
	publicAssetUrlRE.lastIndex = 0;
	while (match = publicAssetUrlRE.exec(code)) {
		s$2 ||= new MagicString(code);
		const [full, hash$1] = match;
		const replacement = toOutputFilePathInJS(environment, publicAssetUrlMap.get(hash$1).slice(1), "public", chunk.fileName, "js", toRelativeRuntime);
		const replacementString = typeof replacement === "string" ? JSON.stringify(encodeURIPath(replacement)).slice(1, -1) : `"+${replacement.runtime}+"`;
		s$2.update(match.index, match.index + full.length, replacementString);
	}
	return s$2;
}
/**
* Also supports loading plain strings with import text from './foo.txt?raw'
*/
function assetPlugin(config$2) {
	registerCustomMime();
	return {
		name: "vite:asset",
		perEnvironmentStartEndDuringDev: true,
		buildStart() {
			assetCache.set(this.environment, /* @__PURE__ */ new Map());
			cssEntriesMap.set(this.environment, /* @__PURE__ */ new Set());
		},
		resolveId: { handler(id) {
			if (!config$2.assetsInclude(cleanUrl(id)) && !urlRE.test(id)) return;
			if (checkPublicFile(id, config$2)) return id;
		} },
		load: {
			filter: { id: { exclude: /^\0/ } },
			async handler(id) {
				if (rawRE.test(id)) {
					const file = checkPublicFile(id, config$2) || cleanUrl(id);
					this.addWatchFile(file);
					return `export default ${JSON.stringify(await fsp.readFile(file, "utf-8"))}`;
				}
				if (!urlRE.test(id) && !config$2.assetsInclude(cleanUrl(id))) return;
				id = removeUrlQuery(id);
				let url$3 = await fileToUrl$1(this, id);
				if (!url$3.startsWith("data:") && this.environment.mode === "dev") {
					const mod = this.environment.moduleGraph.getModuleById(id);
					if (mod && mod.lastHMRTimestamp > 0) url$3 = injectQuery(url$3, `t=${mod.lastHMRTimestamp}`);
				}
				return {
					code: `export default ${JSON.stringify(encodeURIPath(url$3))}`,
					moduleSideEffects: config$2.command === "build" && this.getModuleInfo(id)?.isEntry ? "no-treeshake" : false,
					meta: config$2.command === "build" ? { "vite:asset": true } : void 0
				};
			}
		},
		renderChunk(code, chunk, opts) {
			const s$2 = renderAssetUrlInJS(this, chunk, opts, code);
			if (s$2) return {
				code: s$2.toString(),
				map: this.environment.config.build.sourcemap ? s$2.generateMap({ hires: "boundary" }) : null
			};
			else return null;
		},
		generateBundle(_, bundle) {
			let importedFiles;
			for (const file in bundle) {
				const chunk = bundle[file];
				if (chunk.type === "chunk" && chunk.isEntry && chunk.moduleIds.length === 1 && config$2.assetsInclude(chunk.moduleIds[0]) && this.getModuleInfo(chunk.moduleIds[0])?.meta["vite:asset"]) {
					if (!importedFiles) {
						importedFiles = /* @__PURE__ */ new Set();
						for (const file$1 in bundle) {
							const chunk$1 = bundle[file$1];
							if (chunk$1.type === "chunk") {
								for (const importedFile of chunk$1.imports) importedFiles.add(importedFile);
								for (const importedFile of chunk$1.dynamicImports) importedFiles.add(importedFile);
							}
						}
					}
					if (!importedFiles.has(file)) delete bundle[file];
				}
			}
			if (config$2.command === "build" && !this.environment.config.build.emitAssets) {
				for (const file in bundle) if (bundle[file].type === "asset" && !file.endsWith("ssr-manifest.json") && !jsSourceMapRE.test(file)) delete bundle[file];
			}
		}
	};
}
async function fileToUrl$1(pluginContext, id) {
	const { environment } = pluginContext;
	if (environment.config.command === "serve") return fileToDevUrl(environment, id);
	else return fileToBuiltUrl(pluginContext, id);
}
async function fileToDevUrl(environment, id, skipBase = false) {
	const config$2 = environment.getTopLevelConfig();
	const publicFile = checkPublicFile(id, config$2);
	if (inlineRE$3.test(id)) {
		const file = publicFile || cleanUrl(id);
		return assetToDataURL(environment, file, await fsp.readFile(file));
	}
	const cleanedId = cleanUrl(id);
	if (cleanedId.endsWith(".svg")) {
		const file = publicFile || cleanedId;
		const content = await fsp.readFile(file);
		if (shouldInline(environment, file, id, content, void 0, void 0)) return assetToDataURL(environment, file, content);
	}
	let rtn;
	if (publicFile) rtn = id;
	else if (id.startsWith(withTrailingSlash(config$2.root))) rtn = "/" + path.posix.relative(config$2.root, id);
	else rtn = path.posix.join(FS_PREFIX, id);
	if (skipBase) return rtn;
	return joinUrlSegments(joinUrlSegments(config$2.server.origin ?? "", config$2.decodedBase), removeLeadingSlash(rtn));
}
function getPublicAssetFilename(hash$1, config$2) {
	return publicAssetUrlCache.get(config$2)?.get(hash$1);
}
const publicAssetUrlCache = /* @__PURE__ */ new WeakMap();
const publicAssetUrlRE = /__VITE_PUBLIC_ASSET__([a-z\d]{8})__/g;
function publicFileToBuiltUrl(url$3, config$2) {
	if (config$2.command !== "build") return joinUrlSegments(config$2.decodedBase, url$3);
	const hash$1 = getHash(url$3);
	let cache$1 = publicAssetUrlCache.get(config$2);
	if (!cache$1) {
		cache$1 = /* @__PURE__ */ new Map();
		publicAssetUrlCache.set(config$2, cache$1);
	}
	if (!cache$1.get(hash$1)) cache$1.set(hash$1, url$3);
	return `__VITE_PUBLIC_ASSET__${hash$1}__`;
}
const GIT_LFS_PREFIX = Buffer$1.from("version https://git-lfs.github.com");
function isGitLfsPlaceholder(content) {
	if (content.length < GIT_LFS_PREFIX.length) return false;
	return GIT_LFS_PREFIX.compare(content, 0, GIT_LFS_PREFIX.length) === 0;
}
/**
* Register an asset to be emitted as part of the bundle (if necessary)
* and returns the resolved public URL
*/
async function fileToBuiltUrl(pluginContext, id, skipPublicCheck = false, forceInline) {
	const environment = pluginContext.environment;
	const topLevelConfig = environment.getTopLevelConfig();
	if (!skipPublicCheck) {
		const publicFile = checkPublicFile(id, topLevelConfig);
		if (publicFile) if (inlineRE$3.test(id)) id = publicFile;
		else return publicFileToBuiltUrl(id, topLevelConfig);
	}
	const cache$1 = assetCache.get(environment);
	const cached = cache$1.get(id);
	if (cached) return cached;
	let { file, postfix } = splitFileAndPostfix(id);
	const content = await fsp.readFile(file);
	let url$3;
	if (shouldInline(environment, file, id, content, pluginContext, forceInline)) url$3 = assetToDataURL(environment, file, content);
	else {
		const originalFileName = normalizePath(path.relative(environment.config.root, file));
		const referenceId = pluginContext.emitFile({
			type: "asset",
			name: path.basename(file),
			originalFileName,
			source: content
		});
		if (environment.config.command === "build" && noInlineRE.test(postfix)) postfix = postfix.replace(noInlineRE, "").replace(/^&/, "?");
		url$3 = `__VITE_ASSET__${referenceId}__${postfix ? `$_${postfix}__` : ``}`;
	}
	cache$1.set(id, url$3);
	return url$3;
}
async function urlToBuiltUrl(pluginContext, url$3, importer, forceInline) {
	const topLevelConfig = pluginContext.environment.getTopLevelConfig();
	if (checkPublicFile(url$3, topLevelConfig)) return publicFileToBuiltUrl(url$3, topLevelConfig);
	return fileToBuiltUrl(pluginContext, normalizePath(url$3[0] === "/" ? path.join(topLevelConfig.root, url$3) : path.join(path.dirname(importer), url$3)), true, forceInline);
}
function shouldInline(environment, file, id, content, buildPluginContext, forceInline) {
	if (noInlineRE.test(id)) return false;
	if (inlineRE$3.test(id)) return true;
	if (buildPluginContext) {
		if (environment.config.build.lib) return true;
		if (buildPluginContext.getModuleInfo(id)?.isEntry) return false;
	}
	if (forceInline !== void 0) return forceInline;
	if (file.endsWith(".html")) return false;
	if (file.endsWith(".svg") && id.includes("#")) return false;
	let limit;
	const { assetsInlineLimit } = environment.config.build;
	if (typeof assetsInlineLimit === "function") {
		const userShouldInline = assetsInlineLimit(file, content);
		if (userShouldInline != null) return userShouldInline;
		limit = DEFAULT_ASSETS_INLINE_LIMIT;
	} else limit = Number(assetsInlineLimit);
	return content.length < limit && !isGitLfsPlaceholder(content);
}
function assetToDataURL(environment, file, content) {
	if (environment.config.build.lib && isGitLfsPlaceholder(content)) environment.logger.warn(import_picocolors$30.default.yellow(`Inlined file ${file} was not downloaded via Git LFS`));
	if (file.endsWith(".svg")) return svgToDataURL(content);
	else return `data:${lookup(file) ?? "application/octet-stream"};base64,${content.toString("base64")}`;
}
const nestedQuotesRE = /"[^"']*'[^"]*"|'[^'"]*"[^']*'/;
function svgToDataURL(content) {
	const stringContent = content.toString();
	if (stringContent.includes("<text") || stringContent.includes("<foreignObject") || nestedQuotesRE.test(stringContent)) return `data:image/svg+xml;base64,${content.toString("base64")}`;
	else return "data:image/svg+xml," + stringContent.trim().replaceAll(/>\s+</g, "><").replaceAll("\"", "'").replaceAll("%", "%25").replaceAll("#", "%23").replaceAll("<", "%3c").replaceAll(">", "%3e").replaceAll(/\s+/g, "%20");
}

//#endregion
//#region src/node/plugins/manifest.ts
const endsWithJSRE = /\.[cm]?js$/;
function manifestPlugin() {
	const getState = perEnvironmentState(() => {
		return {
			manifest: {},
			outputCount: 0,
			reset() {
				this.manifest = {};
				this.outputCount = 0;
			}
		};
	});
	return {
		name: "vite:manifest",
		perEnvironmentStartEndDuringDev: true,
		applyToEnvironment(environment) {
			return !!environment.config.build.manifest;
		},
		buildStart() {
			getState(this).reset();
		},
		generateBundle({ format: format$3 }, bundle) {
			const state = getState(this);
			const { manifest } = state;
			const { root } = this.environment.config;
			const buildOptions = this.environment.config.build;
			function getChunkName(chunk) {
				return getChunkOriginalFileName(chunk, root, format$3) ?? `_${path.basename(chunk.fileName)}`;
			}
			function getInternalImports(imports) {
				const filteredImports = [];
				for (const file of imports) {
					if (bundle[file] === void 0) continue;
					filteredImports.push(getChunkName(bundle[file]));
				}
				return filteredImports;
			}
			function createChunk(chunk) {
				const manifestChunk = {
					file: chunk.fileName,
					name: chunk.name
				};
				if (chunk.facadeModuleId) manifestChunk.src = getChunkName(chunk);
				if (chunk.isEntry) manifestChunk.isEntry = true;
				if (chunk.isDynamicEntry) manifestChunk.isDynamicEntry = true;
				if (chunk.imports.length) {
					const internalImports = getInternalImports(chunk.imports);
					if (internalImports.length > 0) manifestChunk.imports = internalImports;
				}
				if (chunk.dynamicImports.length) {
					const internalImports = getInternalImports(chunk.dynamicImports);
					if (internalImports.length > 0) manifestChunk.dynamicImports = internalImports;
				}
				if (chunk.viteMetadata?.importedCss.size) manifestChunk.css = [...chunk.viteMetadata.importedCss];
				if (chunk.viteMetadata?.importedAssets.size) manifestChunk.assets = [...chunk.viteMetadata.importedAssets];
				return manifestChunk;
			}
			function createAsset(asset, src, isEntry) {
				const manifestChunk = {
					file: asset.fileName,
					src
				};
				if (isEntry) {
					manifestChunk.isEntry = true;
					manifestChunk.names = asset.names;
				}
				return manifestChunk;
			}
			const entryCssReferenceIds = cssEntriesMap.get(this.environment);
			const entryCssAssetFileNames = /* @__PURE__ */ new Set();
			for (const id of entryCssReferenceIds) try {
				const fileName = this.getFileName(id);
				entryCssAssetFileNames.add(fileName);
			} catch {}
			for (const file in bundle) {
				const chunk = bundle[file];
				if (chunk.type === "chunk") manifest[getChunkName(chunk)] = createChunk(chunk);
				else if (chunk.type === "asset" && chunk.names.length > 0) {
					const src = chunk.originalFileNames.length > 0 ? chunk.originalFileNames[0] : `_${path.basename(chunk.fileName)}`;
					const asset = createAsset(chunk, src, entryCssAssetFileNames.has(chunk.fileName));
					const file$1 = manifest[src]?.file;
					if (!(file$1 && endsWithJSRE.test(file$1))) manifest[src] = asset;
					for (const originalFileName of chunk.originalFileNames.slice(1)) {
						const file$2 = manifest[originalFileName]?.file;
						if (!(file$2 && endsWithJSRE.test(file$2))) manifest[originalFileName] = asset;
					}
				}
			}
			state.outputCount++;
			const output = buildOptions.rollupOptions.output;
			if (state.outputCount >= (Array.isArray(output) ? output.length : 1)) this.emitFile({
				fileName: typeof buildOptions.manifest === "string" ? buildOptions.manifest : ".vite/manifest.json",
				type: "asset",
				source: JSON.stringify(sortObjectKeys(manifest), void 0, 2)
			});
		}
	};
}
function getChunkOriginalFileName(chunk, root, format$3) {
	if (chunk.facadeModuleId) {
		let name = normalizePath(path.relative(root, chunk.facadeModuleId));
		if (format$3 === "system" && !chunk.name.includes("-legacy")) {
			const ext = path.extname(name);
			const endPos = ext.length !== 0 ? -ext.length : void 0;
			name = `${name.slice(0, endPos)}-legacy${ext}`;
		}
		return name.replace(/\0/g, "");
	}
}

//#endregion
//#region src/node/plugins/dataUri.ts
const dataUriRE = /^([^/]+\/[^;,]+)(;base64)?,([\s\S]*)$/;
const base64RE = /base64/i;
const dataUriPrefix = `\0/@data-uri/`;
/**
* Build only, since importing from a data URI works natively.
*/
function dataURIPlugin() {
	let resolved;
	return {
		name: "vite:data-uri",
		buildStart() {
			resolved = /* @__PURE__ */ new Map();
		},
		resolveId(id) {
			if (!id.trimStart().startsWith("data:")) return;
			const uri = new URL$1(id);
			if (uri.protocol !== "data:") return;
			const match = dataUriRE.exec(uri.pathname);
			if (!match) return;
			const [, mime, format$3, data] = match;
			if (mime !== "text/javascript") throw new Error(`data URI with non-JavaScript mime type is not supported. If you're using legacy JavaScript MIME types (such as 'application/javascript'), please use 'text/javascript' instead.`);
			const content = format$3 && base64RE.test(format$3.substring(1)) ? Buffer.from(data, "base64").toString("utf-8") : data;
			resolved.set(id, content);
			return dataUriPrefix + id;
		},
		load(id) {
			if (id.startsWith(dataUriPrefix)) return resolved.get(id.slice(dataUriPrefix.length));
		}
	};
}

//#endregion
//#region ../../node_modules/.pnpm/es-module-lexer@1.7.0/node_modules/es-module-lexer/dist/lexer.js
var ImportType;
(function(A$1) {
	A$1[A$1.Static = 1] = "Static", A$1[A$1.Dynamic = 2] = "Dynamic", A$1[A$1.ImportMeta = 3] = "ImportMeta", A$1[A$1.StaticSourcePhase = 4] = "StaticSourcePhase", A$1[A$1.DynamicSourcePhase = 5] = "DynamicSourcePhase", A$1[A$1.StaticDeferPhase = 6] = "StaticDeferPhase", A$1[A$1.DynamicDeferPhase = 7] = "DynamicDeferPhase";
})(ImportType || (ImportType = {}));
const A = 1 === new Uint8Array(new Uint16Array([1]).buffer)[0];
function parse(E$1, g = "@") {
	if (!C) return init.then((() => parse(E$1)));
	const I = E$1.length + 1, w$1 = (C.__heap_base.value || C.__heap_base) + 4 * I - C.memory.buffer.byteLength;
	w$1 > 0 && C.memory.grow(Math.ceil(w$1 / 65536));
	const K = C.sa(I - 1);
	if ((A ? B : Q)(E$1, new Uint16Array(C.memory.buffer, K, I)), !C.parse()) throw Object.assign(/* @__PURE__ */ new Error(`Parse error ${g}:${E$1.slice(0, C.e()).split("\n").length}:${C.e() - E$1.lastIndexOf("\n", C.e() - 1)}`), { idx: C.e() });
	const o$1 = [], D = [];
	for (; C.ri();) {
		const A$1 = C.is(), Q$1 = C.ie(), B$1 = C.it(), g$1 = C.ai(), I$1 = C.id(), w$2 = C.ss(), K$1 = C.se();
		let D$1;
		C.ip() && (D$1 = k(E$1.slice(-1 === I$1 ? A$1 - 1 : A$1, -1 === I$1 ? Q$1 + 1 : Q$1))), o$1.push({
			n: D$1,
			t: B$1,
			s: A$1,
			e: Q$1,
			ss: w$2,
			se: K$1,
			d: I$1,
			a: g$1
		});
	}
	for (; C.re();) {
		const A$1 = C.es(), Q$1 = C.ee(), B$1 = C.els(), g$1 = C.ele(), I$1 = E$1.slice(A$1, Q$1), w$2 = I$1[0], K$1 = B$1 < 0 ? void 0 : E$1.slice(B$1, g$1), o$2 = K$1 ? K$1[0] : "";
		D.push({
			s: A$1,
			e: Q$1,
			ls: B$1,
			le: g$1,
			n: "\"" === w$2 || "'" === w$2 ? k(I$1) : I$1,
			ln: "\"" === o$2 || "'" === o$2 ? k(K$1) : K$1
		});
	}
	function k(A$1) {
		try {
			return (0, eval)(A$1);
		} catch (A$2) {}
	}
	return [
		o$1,
		D,
		!!C.f(),
		!!C.ms()
	];
}
function Q(A$1, Q$1) {
	const B$1 = A$1.length;
	let C$1 = 0;
	for (; C$1 < B$1;) {
		const B$2 = A$1.charCodeAt(C$1);
		Q$1[C$1++] = (255 & B$2) << 8 | B$2 >>> 8;
	}
}
function B(A$1, Q$1) {
	const B$1 = A$1.length;
	let C$1 = 0;
	for (; C$1 < B$1;) Q$1[C$1] = A$1.charCodeAt(C$1++);
}
let C;
const E = () => {
	return A$1 = "AGFzbQEAAAABKwhgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gA39/fwADMTAAAQECAgICAgICAgICAgICAgICAgIAAwMDBAQAAAUAAAAAAAMDAwAGAAAABwAGAgUEBQFwAQEBBQMBAAEGDwJ/AUHA8gALfwBBwPIACwd6FQZtZW1vcnkCAAJzYQAAAWUAAwJpcwAEAmllAAUCc3MABgJzZQAHAml0AAgCYWkACQJpZAAKAmlwAAsCZXMADAJlZQANA2VscwAOA2VsZQAPAnJpABACcmUAEQFmABICbXMAEwVwYXJzZQAUC19faGVhcF9iYXNlAwEKzkQwaAEBf0EAIAA2AoAKQQAoAtwJIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgKECkEAIAA2AogKQQBBADYC4AlBAEEANgLwCUEAQQA2AugJQQBBADYC5AlBAEEANgL4CUEAQQA2AuwJIAEL0wEBA39BACgC8AkhBEEAQQAoAogKIgU2AvAJQQAgBDYC9AlBACAFQSRqNgKICiAEQSBqQeAJIAQbIAU2AgBBACgC1AkhBEEAKALQCSEGIAUgATYCACAFIAA2AgggBSACIAJBAmpBACAGIANGIgAbIAQgA0YiBBs2AgwgBSADNgIUIAVBADYCECAFIAI2AgQgBUEANgIgIAVBA0EBQQIgABsgBBs2AhwgBUEAKALQCSADRiICOgAYAkACQCACDQBBACgC1AkgA0cNAQtBAEEBOgCMCgsLXgEBf0EAKAL4CSIEQRBqQeQJIAQbQQAoAogKIgQ2AgBBACAENgL4CUEAIARBFGo2AogKQQBBAToAjAogBEEANgIQIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCAAsIAEEAKAKQCgsVAEEAKALoCSgCAEEAKALcCWtBAXULHgEBf0EAKALoCSgCBCIAQQAoAtwJa0EBdUF/IAAbCxUAQQAoAugJKAIIQQAoAtwJa0EBdQseAQF/QQAoAugJKAIMIgBBACgC3AlrQQF1QX8gABsLCwBBACgC6AkoAhwLHgEBf0EAKALoCSgCECIAQQAoAtwJa0EBdUF/IAAbCzsBAX8CQEEAKALoCSgCFCIAQQAoAtAJRw0AQX8PCwJAIABBACgC1AlHDQBBfg8LIABBACgC3AlrQQF1CwsAQQAoAugJLQAYCxUAQQAoAuwJKAIAQQAoAtwJa0EBdQsVAEEAKALsCSgCBEEAKALcCWtBAXULHgEBf0EAKALsCSgCCCIAQQAoAtwJa0EBdUF/IAAbCx4BAX9BACgC7AkoAgwiAEEAKALcCWtBAXVBfyAAGwslAQF/QQBBACgC6AkiAEEgakHgCSAAGygCACIANgLoCSAAQQBHCyUBAX9BAEEAKALsCSIAQRBqQeQJIAAbKAIAIgA2AuwJIABBAEcLCABBAC0AlAoLCABBAC0AjAoL3Q0BBX8jAEGA0ABrIgAkAEEAQQE6AJQKQQBBACgC2Ak2ApwKQQBBACgC3AlBfmoiATYCsApBACABQQAoAoAKQQF0aiICNgK0CkEAQQA6AIwKQQBBADsBlgpBAEEAOwGYCkEAQQA6AKAKQQBBADYCkApBAEEAOgD8CUEAIABBgBBqNgKkCkEAIAA2AqgKQQBBADoArAoCQAJAAkACQANAQQAgAUECaiIDNgKwCiABIAJPDQECQCADLwEAIgJBd2pBBUkNAAJAAkACQAJAAkAgAkGbf2oOBQEICAgCAAsgAkEgRg0EIAJBL0YNAyACQTtGDQIMBwtBAC8BmAoNASADEBVFDQEgAUEEakGCCEEKEC8NARAWQQAtAJQKDQFBAEEAKAKwCiIBNgKcCgwHCyADEBVFDQAgAUEEakGMCEEKEC8NABAXC0EAQQAoArAKNgKcCgwBCwJAIAEvAQQiA0EqRg0AIANBL0cNBBAYDAELQQEQGQtBACgCtAohAkEAKAKwCiEBDAALC0EAIQIgAyEBQQAtAPwJDQIMAQtBACABNgKwCkEAQQA6AJQKCwNAQQAgAUECaiIDNgKwCgJAAkACQAJAAkACQAJAIAFBACgCtApPDQAgAy8BACICQXdqQQVJDQYCQAJAAkACQAJAAkACQAJAAkACQCACQWBqDgoQDwYPDw8PBQECAAsCQAJAAkACQCACQaB/ag4KCxISAxIBEhISAgALIAJBhX9qDgMFEQYJC0EALwGYCg0QIAMQFUUNECABQQRqQYIIQQoQLw0QEBYMEAsgAxAVRQ0PIAFBBGpBjAhBChAvDQ8QFwwPCyADEBVFDQ4gASkABELsgISDsI7AOVINDiABLwEMIgNBd2oiAUEXSw0MQQEgAXRBn4CABHFFDQwMDQtBAEEALwGYCiIBQQFqOwGYCkEAKAKkCiABQQN0aiIBQQE2AgAgAUEAKAKcCjYCBAwNC0EALwGYCiIDRQ0JQQAgA0F/aiIDOwGYCkEALwGWCiICRQ0MQQAoAqQKIANB//8DcUEDdGooAgBBBUcNDAJAIAJBAnRBACgCqApqQXxqKAIAIgMoAgQNACADQQAoApwKQQJqNgIEC0EAIAJBf2o7AZYKIAMgAUEEajYCDAwMCwJAQQAoApwKIgEvAQBBKUcNAEEAKALwCSIDRQ0AIAMoAgQgAUcNAEEAQQAoAvQJIgM2AvAJAkAgA0UNACADQQA2AiAMAQtBAEEANgLgCQtBAEEALwGYCiIDQQFqOwGYCkEAKAKkCiADQQN0aiIDQQZBAkEALQCsChs2AgAgAyABNgIEQQBBADoArAoMCwtBAC8BmAoiAUUNB0EAIAFBf2oiATsBmApBACgCpAogAUH//wNxQQN0aigCAEEERg0EDAoLQScQGgwJC0EiEBoMCAsgAkEvRw0HAkACQCABLwEEIgFBKkYNACABQS9HDQEQGAwKC0EBEBkMCQsCQAJAAkACQEEAKAKcCiIBLwEAIgMQG0UNAAJAAkAgA0FVag4EAAkBAwkLIAFBfmovAQBBK0YNAwwICyABQX5qLwEAQS1GDQIMBwsgA0EpRw0BQQAoAqQKQQAvAZgKIgJBA3RqKAIEEBxFDQIMBgsgAUF+ai8BAEFQakH//wNxQQpPDQULQQAvAZgKIQILAkACQCACQf//A3EiAkUNACADQeYARw0AQQAoAqQKIAJBf2pBA3RqIgQoAgBBAUcNACABQX5qLwEAQe8ARw0BIAQoAgRBlghBAxAdRQ0BDAULIANB/QBHDQBBACgCpAogAkEDdGoiAigCBBAeDQQgAigCAEEGRg0ECyABEB8NAyADRQ0DIANBL0ZBAC0AoApBAEdxDQMCQEEAKAL4CSICRQ0AIAEgAigCAEkNACABIAIoAgRNDQQLIAFBfmohAUEAKALcCSECAkADQCABQQJqIgQgAk0NAUEAIAE2ApwKIAEvAQAhAyABQX5qIgQhASADECBFDQALIARBAmohBAsCQCADQf//A3EQIUUNACAEQX5qIQECQANAIAFBAmoiAyACTQ0BQQAgATYCnAogAS8BACEDIAFBfmoiBCEBIAMQIQ0ACyAEQQJqIQMLIAMQIg0EC0EAQQE6AKAKDAcLQQAoAqQKQQAvAZgKIgFBA3QiA2pBACgCnAo2AgRBACABQQFqOwGYCkEAKAKkCiADakEDNgIACxAjDAULQQAtAPwJQQAvAZYKQQAvAZgKcnJFIQIMBwsQJEEAQQA6AKAKDAMLECVBACECDAULIANBoAFHDQELQQBBAToArAoLQQBBACgCsAo2ApwKC0EAKAKwCiEBDAALCyAAQYDQAGokACACCxoAAkBBACgC3AkgAEcNAEEBDwsgAEF+ahAmC/4KAQZ/QQBBACgCsAoiAEEMaiIBNgKwCkEAKAL4CSECQQEQKSEDAkACQAJAAkACQAJAAkACQAJAQQAoArAKIgQgAUcNACADEChFDQELAkACQAJAAkACQAJAAkAgA0EqRg0AIANB+wBHDQFBACAEQQJqNgKwCkEBECkhA0EAKAKwCiEEA0ACQAJAIANB//8DcSIDQSJGDQAgA0EnRg0AIAMQLBpBACgCsAohAwwBCyADEBpBAEEAKAKwCkECaiIDNgKwCgtBARApGgJAIAQgAxAtIgNBLEcNAEEAQQAoArAKQQJqNgKwCkEBECkhAwsgA0H9AEYNA0EAKAKwCiIFIARGDQ8gBSEEIAVBACgCtApNDQAMDwsLQQAgBEECajYCsApBARApGkEAKAKwCiIDIAMQLRoMAgtBAEEAOgCUCgJAAkACQAJAAkACQCADQZ9/ag4MAgsEAQsDCwsLCwsFAAsgA0H2AEYNBAwKC0EAIARBDmoiAzYCsAoCQAJAAkBBARApQZ9/ag4GABICEhIBEgtBACgCsAoiBSkAAkLzgOSD4I3AMVINESAFLwEKECFFDRFBACAFQQpqNgKwCkEAECkaC0EAKAKwCiIFQQJqQbIIQQ4QLw0QIAUvARAiAkF3aiIBQRdLDQ1BASABdEGfgIAEcUUNDQwOC0EAKAKwCiIFKQACQuyAhIOwjsA5Ug0PIAUvAQoiAkF3aiIBQRdNDQYMCgtBACAEQQpqNgKwCkEAECkaQQAoArAKIQQLQQAgBEEQajYCsAoCQEEBECkiBEEqRw0AQQBBACgCsApBAmo2ArAKQQEQKSEEC0EAKAKwCiEDIAQQLBogA0EAKAKwCiIEIAMgBBACQQBBACgCsApBfmo2ArAKDwsCQCAEKQACQuyAhIOwjsA5Ug0AIAQvAQoQIEUNAEEAIARBCmo2ArAKQQEQKSEEQQAoArAKIQMgBBAsGiADQQAoArAKIgQgAyAEEAJBAEEAKAKwCkF+ajYCsAoPC0EAIARBBGoiBDYCsAoLQQAgBEEGajYCsApBAEEAOgCUCkEBECkhBEEAKAKwCiEDIAQQLCEEQQAoArAKIQIgBEHf/wNxIgFB2wBHDQNBACACQQJqNgKwCkEBECkhBUEAKAKwCiEDQQAhBAwEC0EAQQE6AIwKQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0AQQAgA0EIajYCsAogAEEBEClBABArIAJBEGpB5AkgAhshAwNAIAMoAgAiA0UNBSADQgA3AgggA0EQaiEDDAALC0EAIANBfmo2ArAKDAMLQQEgAXRBn4CABHFFDQMMBAtBASEECwNAAkACQCAEDgIAAQELIAVB//8DcRAsGkEBIQQMAQsCQAJAQQAoArAKIgQgA0YNACADIAQgAyAEEAJBARApIQQCQCABQdsARw0AIARBIHJB/QBGDQQLQQAoArAKIQMCQCAEQSxHDQBBACADQQJqNgKwCkEBECkhBUEAKAKwCiEDIAVBIHJB+wBHDQILQQAgA0F+ajYCsAoLIAFB2wBHDQJBACACQX5qNgKwCg8LQQAhBAwACwsPCyACQaABRg0AIAJB+wBHDQQLQQAgBUEKajYCsApBARApIgVB+wBGDQMMAgsCQCACQVhqDgMBAwEACyACQaABRw0CC0EAIAVBEGo2ArAKAkBBARApIgVBKkcNAEEAQQAoArAKQQJqNgKwCkEBECkhBQsgBUEoRg0BC0EAKAKwCiEBIAUQLBpBACgCsAoiBSABTQ0AIAQgAyABIAUQAkEAQQAoArAKQX5qNgKwCg8LIAQgA0EAQQAQAkEAIARBDGo2ArAKDwsQJQuFDAEKf0EAQQAoArAKIgBBDGoiATYCsApBARApIQJBACgCsAohAwJAAkACQAJAAkACQAJAAkAgAkEuRw0AQQAgA0ECajYCsAoCQEEBECkiAkHkAEYNAAJAIAJB8wBGDQAgAkHtAEcNB0EAKAKwCiICQQJqQZwIQQYQLw0HAkBBACgCnAoiAxAqDQAgAy8BAEEuRg0ICyAAIAAgAkEIakEAKALUCRABDwtBACgCsAoiAkECakGiCEEKEC8NBgJAQQAoApwKIgMQKg0AIAMvAQBBLkYNBwtBACEEQQAgAkEMajYCsApBASEFQQUhBkEBECkhAkEAIQdBASEIDAILQQAoArAKIgIpAAJC5YCYg9CMgDlSDQUCQEEAKAKcCiIDECoNACADLwEAQS5GDQYLQQAhBEEAIAJBCmo2ArAKQQIhCEEHIQZBASEHQQEQKSECQQEhBQwBCwJAAkACQAJAIAJB8wBHDQAgAyABTQ0AIANBAmpBoghBChAvDQACQCADLwEMIgRBd2oiB0EXSw0AQQEgB3RBn4CABHENAgsgBEGgAUYNAQtBACEHQQchBkEBIQQgAkHkAEYNAQwCC0EAIQRBACADQQxqIgI2ArAKQQEhBUEBECkhCQJAQQAoArAKIgYgAkYNAEHmACECAkAgCUHmAEYNAEEFIQZBACEHQQEhCCAJIQIMBAtBACEHQQEhCCAGQQJqQawIQQYQLw0EIAYvAQgQIEUNBAtBACEHQQAgAzYCsApBByEGQQEhBEEAIQVBACEIIAkhAgwCCyADIABBCmpNDQBBACEIQeQAIQICQCADKQACQuWAmIPQjIA5Ug0AAkACQCADLwEKIgRBd2oiB0EXSw0AQQEgB3RBn4CABHENAQtBACEIIARBoAFHDQELQQAhBUEAIANBCmo2ArAKQSohAkEBIQdBAiEIQQEQKSIJQSpGDQRBACADNgKwCkEBIQRBACEHQQAhCCAJIQIMAgsgAyEGQQAhBwwCC0EAIQVBACEICwJAIAJBKEcNAEEAKAKkCkEALwGYCiICQQN0aiIDQQAoArAKNgIEQQAgAkEBajsBmAogA0EFNgIAQQAoApwKLwEAQS5GDQRBAEEAKAKwCiIDQQJqNgKwCkEBECkhAiAAQQAoArAKQQAgAxABAkACQCAFDQBBACgC8AkhAQwBC0EAKALwCSIBIAY2AhwLQQBBAC8BlgoiA0EBajsBlgpBACgCqAogA0ECdGogATYCAAJAIAJBIkYNACACQSdGDQBBAEEAKAKwCkF+ajYCsAoPCyACEBpBAEEAKAKwCkECaiICNgKwCgJAAkACQEEBEClBV2oOBAECAgACC0EAQQAoArAKQQJqNgKwCkEBECkaQQAoAvAJIgMgAjYCBCADQQE6ABggA0EAKAKwCiICNgIQQQAgAkF+ajYCsAoPC0EAKALwCSIDIAI2AgQgA0EBOgAYQQBBAC8BmApBf2o7AZgKIANBACgCsApBAmo2AgxBAEEALwGWCkF/ajsBlgoPC0EAQQAoArAKQX5qNgKwCg8LAkAgBEEBcyACQfsAR3INAEEAKAKwCiECQQAvAZgKDQUDQAJAAkACQCACQQAoArQKTw0AQQEQKSICQSJGDQEgAkEnRg0BIAJB/QBHDQJBAEEAKAKwCkECajYCsAoLQQEQKSEDQQAoArAKIQICQCADQeYARw0AIAJBAmpBrAhBBhAvDQcLQQAgAkEIajYCsAoCQEEBECkiAkEiRg0AIAJBJ0cNBwsgACACQQAQKw8LIAIQGgtBAEEAKAKwCkECaiICNgKwCgwACwsCQAJAIAJBWWoOBAMBAQMACyACQSJGDQILQQAoArAKIQYLIAYgAUcNAEEAIABBCmo2ArAKDwsgAkEqRyAHcQ0DQQAvAZgKQf//A3ENA0EAKAKwCiECQQAoArQKIQEDQCACIAFPDQECQAJAIAIvAQAiA0EnRg0AIANBIkcNAQsgACADIAgQKw8LQQAgAkECaiICNgKwCgwACwsQJQsPC0EAIAJBfmo2ArAKDwtBAEEAKAKwCkF+ajYCsAoLRwEDf0EAKAKwCkECaiEAQQAoArQKIQECQANAIAAiAkF+aiABTw0BIAJBAmohACACLwEAQXZqDgQBAAABAAsLQQAgAjYCsAoLmAEBA39BAEEAKAKwCiIBQQJqNgKwCiABQQZqIQFBACgCtAohAgNAAkACQAJAIAFBfGogAk8NACABQX5qLwEAIQMCQAJAIAANACADQSpGDQEgA0F2ag4EAgQEAgQLIANBKkcNAwsgAS8BAEEvRw0CQQAgAUF+ajYCsAoMAQsgAUF+aiEBC0EAIAE2ArAKDwsgAUECaiEBDAALC4gBAQR/QQAoArAKIQFBACgCtAohAgJAAkADQCABIgNBAmohASADIAJPDQEgAS8BACIEIABGDQICQCAEQdwARg0AIARBdmoOBAIBAQIBCyADQQRqIQEgAy8BBEENRw0AIANBBmogASADLwEGQQpGGyEBDAALC0EAIAE2ArAKECUPC0EAIAE2ArAKC2wBAX8CQAJAIABBX2oiAUEFSw0AQQEgAXRBMXENAQsgAEFGakH//wNxQQZJDQAgAEEpRyAAQVhqQf//A3FBB0lxDQACQCAAQaV/ag4EAQAAAQALIABB/QBHIABBhX9qQf//A3FBBElxDwtBAQsuAQF/QQEhAQJAIABBpglBBRAdDQAgAEGWCEEDEB0NACAAQbAJQQIQHSEBCyABC0YBA39BACEDAkAgACACQQF0IgJrIgRBAmoiAEEAKALcCSIFSQ0AIAAgASACEC8NAAJAIAAgBUcNAEEBDwsgBBAmIQMLIAMLgwEBAn9BASEBAkACQAJAAkACQAJAIAAvAQAiAkFFag4EBQQEAQALAkAgAkGbf2oOBAMEBAIACyACQSlGDQQgAkH5AEcNAyAAQX5qQbwJQQYQHQ8LIABBfmovAQBBPUYPCyAAQX5qQbQJQQQQHQ8LIABBfmpByAlBAxAdDwtBACEBCyABC7QDAQJ/QQAhAQJAAkACQAJAAkACQAJAAkACQAJAIAAvAQBBnH9qDhQAAQIJCQkJAwkJBAUJCQYJBwkJCAkLAkACQCAAQX5qLwEAQZd/ag4EAAoKAQoLIABBfGpByghBAhAdDwsgAEF8akHOCEEDEB0PCwJAAkACQCAAQX5qLwEAQY1/ag4DAAECCgsCQCAAQXxqLwEAIgJB4QBGDQAgAkHsAEcNCiAAQXpqQeUAECcPCyAAQXpqQeMAECcPCyAAQXxqQdQIQQQQHQ8LIABBfGpB3AhBBhAdDwsgAEF+ai8BAEHvAEcNBiAAQXxqLwEAQeUARw0GAkAgAEF6ai8BACICQfAARg0AIAJB4wBHDQcgAEF4akHoCEEGEB0PCyAAQXhqQfQIQQIQHQ8LIABBfmpB+AhBBBAdDwtBASEBIABBfmoiAEHpABAnDQQgAEGACUEFEB0PCyAAQX5qQeQAECcPCyAAQX5qQYoJQQcQHQ8LIABBfmpBmAlBBBAdDwsCQCAAQX5qLwEAIgJB7wBGDQAgAkHlAEcNASAAQXxqQe4AECcPCyAAQXxqQaAJQQMQHSEBCyABCzQBAX9BASEBAkAgAEF3akH//wNxQQVJDQAgAEGAAXJBoAFGDQAgAEEuRyAAEChxIQELIAELMAEBfwJAAkAgAEF3aiIBQRdLDQBBASABdEGNgIAEcQ0BCyAAQaABRg0AQQAPC0EBC04BAn9BACEBAkACQCAALwEAIgJB5QBGDQAgAkHrAEcNASAAQX5qQfgIQQQQHQ8LIABBfmovAQBB9QBHDQAgAEF8akHcCEEGEB0hAQsgAQveAQEEf0EAKAKwCiEAQQAoArQKIQECQAJAAkADQCAAIgJBAmohACACIAFPDQECQAJAAkAgAC8BACIDQaR/ag4FAgMDAwEACyADQSRHDQIgAi8BBEH7AEcNAkEAIAJBBGoiADYCsApBAEEALwGYCiICQQFqOwGYCkEAKAKkCiACQQN0aiICQQQ2AgAgAiAANgIEDwtBACAANgKwCkEAQQAvAZgKQX9qIgA7AZgKQQAoAqQKIABB//8DcUEDdGooAgBBA0cNAwwECyACQQRqIQAMAAsLQQAgADYCsAoLECULC3ABAn8CQAJAA0BBAEEAKAKwCiIAQQJqIgE2ArAKIABBACgCtApPDQECQAJAAkAgAS8BACIBQaV/ag4CAQIACwJAIAFBdmoOBAQDAwQACyABQS9HDQIMBAsQLhoMAQtBACAAQQRqNgKwCgwACwsQJQsLNQEBf0EAQQE6APwJQQAoArAKIQBBAEEAKAK0CkECajYCsApBACAAQQAoAtwJa0EBdTYCkAoLQwECf0EBIQECQCAALwEAIgJBd2pB//8DcUEFSQ0AIAJBgAFyQaABRg0AQQAhASACEChFDQAgAkEuRyAAECpyDwsgAQs9AQJ/QQAhAgJAQQAoAtwJIgMgAEsNACAALwEAIAFHDQACQCADIABHDQBBAQ8LIABBfmovAQAQICECCyACC2gBAn9BASEBAkACQCAAQV9qIgJBBUsNAEEBIAJ0QTFxDQELIABB+P8DcUEoRg0AIABBRmpB//8DcUEGSQ0AAkAgAEGlf2oiAkEDSw0AIAJBAUcNAQsgAEGFf2pB//8DcUEESSEBCyABC5wBAQN/QQAoArAKIQECQANAAkACQCABLwEAIgJBL0cNAAJAIAEvAQIiAUEqRg0AIAFBL0cNBBAYDAILIAAQGQwBCwJAAkAgAEUNACACQXdqIgFBF0sNAUEBIAF0QZ+AgARxRQ0BDAILIAIQIUUNAwwBCyACQaABRw0CC0EAQQAoArAKIgNBAmoiATYCsAogA0EAKAK0CkkNAAsLIAILMQEBf0EAIQECQCAALwEAQS5HDQAgAEF+ai8BAEEuRw0AIABBfGovAQBBLkYhAQsgAQumBAEBfwJAIAFBIkYNACABQSdGDQAQJQ8LQQAoArAKIQMgARAaIAAgA0ECakEAKAKwCkEAKALQCRABAkAgAkEBSA0AQQAoAvAJQQRBBiACQQFGGzYCHAtBAEEAKAKwCkECajYCsAoCQAJAAkACQEEAECkiAUHhAEYNACABQfcARg0BQQAoArAKIQEMAgtBACgCsAoiAUECakHACEEKEC8NAUEGIQIMAgtBACgCsAoiAS8BAkHpAEcNACABLwEEQfQARw0AQQQhAiABLwEGQegARg0BC0EAIAFBfmo2ArAKDwtBACABIAJBAXRqNgKwCgJAQQEQKUH7AEYNAEEAIAE2ArAKDwtBACgCsAoiACECA0BBACACQQJqNgKwCgJAAkACQEEBECkiAkEiRg0AIAJBJ0cNAUEnEBpBAEEAKAKwCkECajYCsApBARApIQIMAgtBIhAaQQBBACgCsApBAmo2ArAKQQEQKSECDAELIAIQLCECCwJAIAJBOkYNAEEAIAE2ArAKDwtBAEEAKAKwCkECajYCsAoCQEEBECkiAkEiRg0AIAJBJ0YNAEEAIAE2ArAKDwsgAhAaQQBBACgCsApBAmo2ArAKAkACQEEBECkiAkEsRg0AIAJB/QBGDQFBACABNgKwCg8LQQBBACgCsApBAmo2ArAKQQEQKUH9AEYNAEEAKAKwCiECDAELC0EAKALwCSIBIAA2AhAgAUEAKAKwCkECajYCDAttAQJ/AkACQANAAkAgAEH//wNxIgFBd2oiAkEXSw0AQQEgAnRBn4CABHENAgsgAUGgAUYNASAAIQIgARAoDQJBACECQQBBACgCsAoiAEECajYCsAogAC8BAiIADQAMAgsLIAAhAgsgAkH//wNxC6sBAQR/AkACQEEAKAKwCiICLwEAIgNB4QBGDQAgASEEIAAhBQwBC0EAIAJBBGo2ArAKQQEQKSECQQAoArAKIQUCQAJAIAJBIkYNACACQSdGDQAgAhAsGkEAKAKwCiEEDAELIAIQGkEAQQAoArAKQQJqIgQ2ArAKC0EBECkhA0EAKAKwCiECCwJAIAIgBUYNACAFIARBACAAIAAgAUYiAhtBACABIAIbEAILIAMLcgEEf0EAKAKwCiEAQQAoArQKIQECQAJAA0AgAEECaiECIAAgAU8NAQJAAkAgAi8BACIDQaR/ag4CAQQACyACIQAgA0F2ag4EAgEBAgELIABBBGohAAwACwtBACACNgKwChAlQQAPC0EAIAI2ArAKQd0AC0kBA39BACEDAkAgAkUNAAJAA0AgAC0AACIEIAEtAAAiBUcNASABQQFqIQEgAEEBaiEAIAJBf2oiAg0ADAILCyAEIAVrIQMLIAMLC+wBAgBBgAgLzgEAAHgAcABvAHIAdABtAHAAbwByAHQAZgBvAHIAZQB0AGEAbwB1AHIAYwBlAHIAbwBtAHUAbgBjAHQAaQBvAG4AcwBzAGUAcgB0AHYAbwB5AGkAZQBkAGUAbABlAGMAbwBuAHQAaQBuAGkAbgBzAHQAYQBuAHQAeQBiAHIAZQBhAHIAZQB0AHUAcgBkAGUAYgB1AGcAZwBlAGEAdwBhAGkAdABoAHIAdwBoAGkAbABlAGkAZgBjAGEAdABjAGYAaQBuAGEAbABsAGUAbABzAABB0AkLEAEAAAACAAAAAAQAAEA5AAA=", "undefined" != typeof Buffer ? Buffer.from(A$1, "base64") : Uint8Array.from(atob(A$1), ((A$2) => A$2.charCodeAt(0)));
	var A$1;
};
const init = WebAssembly.compile(E()).then(WebAssembly.instantiate).then((({ exports: A$1 }) => {
	C = A$1;
}));

//#endregion
//#region ../../node_modules/.pnpm/convert-source-map@2.0.0/node_modules/convert-source-map/index.js
var require_convert_source_map = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/convert-source-map@2.0.0/node_modules/convert-source-map/index.js": ((exports) => {
	Object.defineProperty(exports, "commentRegex", { get: function getCommentRegex() {
		return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/gm;
	} });
	Object.defineProperty(exports, "mapFileCommentRegex", { get: function getMapFileCommentRegex() {
		return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/gm;
	} });
	var decodeBase64;
	if (typeof Buffer !== "undefined") if (typeof Buffer.from === "function") decodeBase64 = decodeBase64WithBufferFrom;
	else decodeBase64 = decodeBase64WithNewBuffer;
	else decodeBase64 = decodeBase64WithAtob;
	function decodeBase64WithBufferFrom(base64) {
		return Buffer.from(base64, "base64").toString();
	}
	function decodeBase64WithNewBuffer(base64) {
		if (typeof value === "number") throw new TypeError("The value to decode must not be of type number.");
		return new Buffer(base64, "base64").toString();
	}
	function decodeBase64WithAtob(base64) {
		return decodeURIComponent(escape(atob(base64)));
	}
	function stripComment(sm) {
		return sm.split(",").pop();
	}
	function readFromFileMap(sm, read) {
		var r$1 = exports.mapFileCommentRegex.exec(sm);
		var filename = r$1[1] || r$1[2];
		try {
			var sm = read(filename);
			if (sm != null && typeof sm.catch === "function") return sm.catch(throwError);
			else return sm;
		} catch (e$1) {
			throwError(e$1);
		}
		function throwError(e$1) {
			throw new Error("An error occurred while trying to read the map file at " + filename + "\n" + e$1.stack);
		}
	}
	function Converter(sm, opts) {
		opts = opts || {};
		if (opts.hasComment) sm = stripComment(sm);
		if (opts.encoding === "base64") sm = decodeBase64(sm);
		else if (opts.encoding === "uri") sm = decodeURIComponent(sm);
		if (opts.isJSON || opts.encoding) sm = JSON.parse(sm);
		this.sourcemap = sm;
	}
	Converter.prototype.toJSON = function(space) {
		return JSON.stringify(this.sourcemap, null, space);
	};
	if (typeof Buffer !== "undefined") if (typeof Buffer.from === "function") Converter.prototype.toBase64 = encodeBase64WithBufferFrom;
	else Converter.prototype.toBase64 = encodeBase64WithNewBuffer;
	else Converter.prototype.toBase64 = encodeBase64WithBtoa;
	function encodeBase64WithBufferFrom() {
		var json = this.toJSON();
		return Buffer.from(json, "utf8").toString("base64");
	}
	function encodeBase64WithNewBuffer() {
		var json = this.toJSON();
		if (typeof json === "number") throw new TypeError("The json to encode must not be of type number.");
		return new Buffer(json, "utf8").toString("base64");
	}
	function encodeBase64WithBtoa() {
		var json = this.toJSON();
		return btoa(unescape(encodeURIComponent(json)));
	}
	Converter.prototype.toURI = function() {
		var json = this.toJSON();
		return encodeURIComponent(json);
	};
	Converter.prototype.toComment = function(options$1) {
		var encoding, content, data;
		if (options$1 != null && options$1.encoding === "uri") {
			encoding = "";
			content = this.toURI();
		} else {
			encoding = ";base64";
			content = this.toBase64();
		}
		data = "sourceMappingURL=data:application/json;charset=utf-8" + encoding + "," + content;
		return options$1 != null && options$1.multiline ? "/*# " + data + " */" : "//# " + data;
	};
	Converter.prototype.toObject = function() {
		return JSON.parse(this.toJSON());
	};
	Converter.prototype.addProperty = function(key, value$1) {
		if (this.sourcemap.hasOwnProperty(key)) throw new Error("property \"" + key + "\" already exists on the sourcemap, use set property instead");
		return this.setProperty(key, value$1);
	};
	Converter.prototype.setProperty = function(key, value$1) {
		this.sourcemap[key] = value$1;
		return this;
	};
	Converter.prototype.getProperty = function(key) {
		return this.sourcemap[key];
	};
	exports.fromObject = function(obj) {
		return new Converter(obj);
	};
	exports.fromJSON = function(json) {
		return new Converter(json, { isJSON: true });
	};
	exports.fromURI = function(uri) {
		return new Converter(uri, { encoding: "uri" });
	};
	exports.fromBase64 = function(base64) {
		return new Converter(base64, { encoding: "base64" });
	};
	exports.fromComment = function(comment) {
		var m$2, encoding;
		comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
		m$2 = exports.commentRegex.exec(comment);
		encoding = m$2 && m$2[4] || "uri";
		return new Converter(comment, {
			encoding,
			hasComment: true
		});
	};
	function makeConverter(sm) {
		return new Converter(sm, { isJSON: true });
	}
	exports.fromMapFileComment = function(comment, read) {
		if (typeof read === "string") throw new Error("String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");
		var sm = readFromFileMap(comment, read);
		if (sm != null && typeof sm.then === "function") return sm.then(makeConverter);
		else return makeConverter(sm);
	};
	exports.fromSource = function(content) {
		var m$2 = content.match(exports.commentRegex);
		return m$2 ? exports.fromComment(m$2.pop()) : null;
	};
	exports.fromMapFileSource = function(content, read) {
		if (typeof read === "string") throw new Error("String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");
		var m$2 = content.match(exports.mapFileCommentRegex);
		return m$2 ? exports.fromMapFileComment(m$2.pop(), read) : null;
	};
	exports.removeComments = function(src) {
		return src.replace(exports.commentRegex, "");
	};
	exports.removeMapFileComments = function(src) {
		return src.replace(exports.mapFileCommentRegex, "");
	};
	exports.generateMapFileComment = function(file, options$1) {
		var data = "sourceMappingURL=" + file;
		return options$1 && options$1.multiline ? "/*# " + data + " */" : "//# " + data;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/@rolldown+pluginutils@1.0.0-beta.43/node_modules/@rolldown/pluginutils/dist/index.mjs
/**
* Constructs a RegExp that matches the exact string specified.
*
* This is useful for plugin hook filters.
*
* @param str the string to match.
* @param flags flags for the RegExp.
*
* @example
* ```ts
* import { exactRegex } from '@rolldown/pluginutils';
* const plugin = {
*   name: 'plugin',
*   resolveId: {
*     filter: { id: exactRegex('foo') },
*     handler(id) {} // will only be called for `foo`
*   }
* }
* ```
*/
function exactRegex(str, flags) {
	return new RegExp(`^${escapeRegex$1(str)}$`, flags);
}
/**
* Constructs a RegExp that matches a value that has the specified prefix.
*
* This is useful for plugin hook filters.
*
* @param str the string to match.
* @param flags flags for the RegExp.
*
* @example
* ```ts
* import { prefixRegex } from '@rolldown/pluginutils';
* const plugin = {
*   name: 'plugin',
*   resolveId: {
*     filter: { id: prefixRegex('foo') },
*     handler(id) {} // will only be called for IDs starting with `foo`
*   }
* }
* ```
*/
function prefixRegex(str, flags) {
	return new RegExp(`^${escapeRegex$1(str)}`, flags);
}
const escapeRegexRE = /[-/\\^$*+?.()|[\]{}]/g;
function escapeRegex$1(str) {
	return str.replace(escapeRegexRE, "\\$&");
}

//#endregion
//#region src/node/server/sourcemap.ts
var import_convert_source_map$2 = /* @__PURE__ */ __toESM(require_convert_source_map(), 1);
const debug$16 = createDebugger("vite:sourcemap", { onlyWhenFocused: true });
const virtualSourceRE = /^(?:dep:|browser-external:|virtual:)|\0/;
async function computeSourceRoute(map$1, file) {
	let sourceRoot;
	try {
		sourceRoot = await fsp.realpath(path.resolve(path.dirname(file), map$1.sourceRoot || ""));
	} catch {}
	return sourceRoot;
}
async function injectSourcesContent(map$1, file, logger) {
	let sourceRootPromise;
	const missingSources = [];
	const sourcesContent = map$1.sourcesContent || [];
	const sourcesContentPromises = [];
	for (let index = 0; index < map$1.sources.length; index++) {
		const sourcePath = map$1.sources[index];
		if (sourcesContent[index] == null && sourcePath && !virtualSourceRE.test(sourcePath)) sourcesContentPromises.push((async () => {
			sourceRootPromise ??= computeSourceRoute(map$1, file);
			const sourceRoot = await sourceRootPromise;
			let resolvedSourcePath = cleanUrl(decodeURI(sourcePath));
			if (sourceRoot) resolvedSourcePath = path.resolve(sourceRoot, resolvedSourcePath);
			sourcesContent[index] = await fsp.readFile(resolvedSourcePath, "utf-8").catch(() => {
				missingSources.push(resolvedSourcePath);
				return null;
			});
		})());
	}
	await Promise.all(sourcesContentPromises);
	map$1.sourcesContent = sourcesContent;
	if (missingSources.length) {
		logger.warnOnce(`Sourcemap for "${file}" points to missing source files`);
		debug$16?.(`Missing sources:\n  ` + missingSources.join(`\n  `));
	}
}
function genSourceMapUrl(map$1) {
	if (typeof map$1 !== "string") map$1 = JSON.stringify(map$1);
	return `data:application/json;base64,${Buffer.from(map$1).toString("base64")}`;
}
function getCodeWithSourcemap(type, code, map$1) {
	if (debug$16) code += `\n/*${JSON.stringify(map$1, null, 2).replace(/\*\//g, "*\\/")}*/\n`;
	if (type === "js") code += `\n//# sourceMappingURL=${genSourceMapUrl(map$1)}`;
	else if (type === "css") code += `\n/*# sourceMappingURL=${genSourceMapUrl(map$1)} */`;
	return code;
}
function applySourcemapIgnoreList(map$1, sourcemapPath, sourcemapIgnoreList, logger) {
	let { x_google_ignoreList } = map$1;
	if (x_google_ignoreList === void 0) x_google_ignoreList = [];
	for (let sourcesIndex = 0; sourcesIndex < map$1.sources.length; ++sourcesIndex) {
		const sourcePath = map$1.sources[sourcesIndex];
		if (!sourcePath) continue;
		const ignoreList = sourcemapIgnoreList(path.isAbsolute(sourcePath) ? sourcePath : path.resolve(path.dirname(sourcemapPath), sourcePath), sourcemapPath);
		if (logger && typeof ignoreList !== "boolean") logger.warn("sourcemapIgnoreList function must return a boolean.");
		if (ignoreList && !x_google_ignoreList.includes(sourcesIndex)) x_google_ignoreList.push(sourcesIndex);
	}
	if (x_google_ignoreList.length > 0) {
		if (!map$1.x_google_ignoreList) map$1.x_google_ignoreList = x_google_ignoreList;
	}
}
async function extractSourcemapFromFile(code, filePath) {
	const map$1 = (import_convert_source_map$2.fromSource(code) || await import_convert_source_map$2.fromMapFileSource(code, createConvertSourceMapReadMap(filePath)))?.toObject();
	if (map$1) return {
		code: code.replace(import_convert_source_map$2.default.mapFileCommentRegex, blankReplacer),
		map: map$1
	};
}
function createConvertSourceMapReadMap(originalFileName) {
	return (filename) => {
		return fsp.readFile(path.resolve(path.dirname(originalFileName), filename), "utf-8");
	};
}

//#endregion
//#region ../../node_modules/.pnpm/lilconfig@3.1.3/node_modules/lilconfig/src/index.js
var require_src$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/lilconfig@3.1.3/node_modules/lilconfig/src/index.js": ((exports, module) => {
	const path$11 = __require("path");
	const fs$11 = __require("fs");
	const os$4 = __require("os");
	const url$2 = __require("url");
	const fsReadFileAsync = fs$11.promises.readFile;
	/** @type {(name: string, sync: boolean) => string[]} */
	function getDefaultSearchPlaces(name, sync$3) {
		return [
			"package.json",
			`.${name}rc.json`,
			`.${name}rc.js`,
			`.${name}rc.cjs`,
			...sync$3 ? [] : [`.${name}rc.mjs`],
			`.config/${name}rc`,
			`.config/${name}rc.json`,
			`.config/${name}rc.js`,
			`.config/${name}rc.cjs`,
			...sync$3 ? [] : [`.config/${name}rc.mjs`],
			`${name}.config.js`,
			`${name}.config.cjs`,
			...sync$3 ? [] : [`${name}.config.mjs`]
		];
	}
	/**
	* @type {(p: string) => string}
	*
	* see #17
	* On *nix, if cwd is not under homedir,
	* the last path will be '', ('/build' -> '')
	* but it should be '/' actually.
	* And on Windows, this will never happen. ('C:\build' -> 'C:')
	*/
	function parentDir(p) {
		return path$11.dirname(p) || path$11.sep;
	}
	/** @type {import('./index').LoaderSync} */
	const jsonLoader = (_, content) => JSON.parse(content);
	const requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
	/** @type {import('./index').LoadersSync} */
	const defaultLoadersSync = Object.freeze({
		".js": requireFunc,
		".json": requireFunc,
		".cjs": requireFunc,
		noExt: jsonLoader
	});
	module.exports.defaultLoadersSync = defaultLoadersSync;
	/** @type {import('./index').Loader} */
	const dynamicImport = async (id) => {
		try {
			return (await import(url$2.pathToFileURL(id).href)).default;
		} catch (e$1) {
			try {
				return requireFunc(id);
			} catch (requireE) {
				if (requireE.code === "ERR_REQUIRE_ESM" || requireE instanceof SyntaxError && requireE.toString().includes("Cannot use import statement outside a module")) throw e$1;
				throw requireE;
			}
		}
	};
	/** @type {import('./index').Loaders} */
	const defaultLoaders = Object.freeze({
		".js": dynamicImport,
		".mjs": dynamicImport,
		".cjs": dynamicImport,
		".json": jsonLoader,
		noExt: jsonLoader
	});
	module.exports.defaultLoaders = defaultLoaders;
	/**
	* @param {string} name
	* @param {import('./index').Options | import('./index').OptionsSync} options
	* @param {boolean} sync
	* @returns {Required<import('./index').Options | import('./index').OptionsSync>}
	*/
	function getOptions(name, options$1, sync$3) {
		/** @type {Required<import('./index').Options>} */
		const conf = {
			stopDir: os$4.homedir(),
			searchPlaces: getDefaultSearchPlaces(name, sync$3),
			ignoreEmptySearchPlaces: true,
			cache: true,
			transform: (x) => x,
			packageProp: [name],
			...options$1,
			loaders: {
				...sync$3 ? defaultLoadersSync : defaultLoaders,
				...options$1.loaders
			}
		};
		conf.searchPlaces.forEach((place) => {
			const key = path$11.extname(place) || "noExt";
			const loader$1 = conf.loaders[key];
			if (!loader$1) throw new Error(`Missing loader for extension "${place}"`);
			if (typeof loader$1 !== "function") throw new Error(`Loader for extension "${place}" is not a function: Received ${typeof loader$1}.`);
		});
		return conf;
	}
	/** @type {(props: string | string[], obj: Record<string, any>) => unknown} */
	function getPackageProp(props, obj) {
		if (typeof props === "string" && props in obj) return obj[props];
		return (Array.isArray(props) ? props : props.split(".")).reduce((acc, prop) => acc === void 0 ? acc : acc[prop], obj) || null;
	}
	/** @param {string} filepath */
	function validateFilePath(filepath) {
		if (!filepath) throw new Error("load must pass a non-empty string");
	}
	/** @type {(loader: import('./index').Loader, ext: string) => void} */
	function validateLoader(loader$1, ext) {
		if (!loader$1) throw new Error(`No loader specified for extension "${ext}"`);
		if (typeof loader$1 !== "function") throw new Error("loader is not a function");
	}
	/** @type {(enableCache: boolean) => <T>(c: Map<string, T>, filepath: string, res: T) => T} */
	const makeEmplace = (enableCache) => (c, filepath, res) => {
		if (enableCache) c.set(filepath, res);
		return res;
	};
	/** @type {import('./index').lilconfig} */
	module.exports.lilconfig = function lilconfig(name, options$1) {
		const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform: transform$2, cache: cache$1 } = getOptions(name, options$1 ?? {}, false);
		const searchCache = /* @__PURE__ */ new Map();
		const loadCache = /* @__PURE__ */ new Map();
		const emplace = makeEmplace(cache$1);
		return {
			async search(searchFrom = process.cwd()) {
				/** @type {import('./index').LilconfigResult} */
				const result = {
					config: null,
					filepath: ""
				};
				/** @type {Set<string>} */
				const visited = /* @__PURE__ */ new Set();
				let dir = searchFrom;
				dirLoop: while (true) {
					if (cache$1) {
						const r$1 = searchCache.get(dir);
						if (r$1 !== void 0) {
							for (const p of visited) searchCache.set(p, r$1);
							return r$1;
						}
						visited.add(dir);
					}
					for (const searchPlace of searchPlaces) {
						const filepath = path$11.join(dir, searchPlace);
						try {
							await fs$11.promises.access(filepath);
						} catch {
							continue;
						}
						const content = String(await fsReadFileAsync(filepath));
						const loaderKey = path$11.extname(searchPlace) || "noExt";
						const loader$1 = loaders[loaderKey];
						if (searchPlace === "package.json") {
							const maybeConfig = getPackageProp(packageProp, await loader$1(filepath, content));
							if (maybeConfig != null) {
								result.config = maybeConfig;
								result.filepath = filepath;
								break dirLoop;
							}
							continue;
						}
						const isEmpty = content.trim() === "";
						if (isEmpty && ignoreEmptySearchPlaces) continue;
						if (isEmpty) {
							result.isEmpty = true;
							result.config = void 0;
						} else {
							validateLoader(loader$1, loaderKey);
							result.config = await loader$1(filepath, content);
						}
						result.filepath = filepath;
						break dirLoop;
					}
					if (dir === stopDir || dir === parentDir(dir)) break dirLoop;
					dir = parentDir(dir);
				}
				const transformed = result.filepath === "" && result.config === null ? transform$2(null) : transform$2(result);
				if (cache$1) for (const p of visited) searchCache.set(p, transformed);
				return transformed;
			},
			async load(filepath) {
				validateFilePath(filepath);
				const absPath = path$11.resolve(process.cwd(), filepath);
				if (cache$1 && loadCache.has(absPath)) return loadCache.get(absPath);
				const { base, ext } = path$11.parse(absPath);
				const loaderKey = ext || "noExt";
				const loader$1 = loaders[loaderKey];
				validateLoader(loader$1, loaderKey);
				const content = String(await fsReadFileAsync(absPath));
				if (base === "package.json") return emplace(loadCache, absPath, transform$2({
					config: getPackageProp(packageProp, await loader$1(absPath, content)),
					filepath: absPath
				}));
				/** @type {import('./index').LilconfigResult} */
				const result = {
					config: null,
					filepath: absPath
				};
				const isEmpty = content.trim() === "";
				if (isEmpty && ignoreEmptySearchPlaces) return emplace(loadCache, absPath, transform$2({
					config: void 0,
					filepath: absPath,
					isEmpty: true
				}));
				result.config = isEmpty ? void 0 : await loader$1(absPath, content);
				return emplace(loadCache, absPath, transform$2(isEmpty ? {
					...result,
					isEmpty,
					config: void 0
				} : result));
			},
			clearLoadCache() {
				if (cache$1) loadCache.clear();
			},
			clearSearchCache() {
				if (cache$1) searchCache.clear();
			},
			clearCaches() {
				if (cache$1) {
					loadCache.clear();
					searchCache.clear();
				}
			}
		};
	};
	/** @type {import('./index').lilconfigSync} */
	module.exports.lilconfigSync = function lilconfigSync(name, options$1) {
		const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform: transform$2, cache: cache$1 } = getOptions(name, options$1 ?? {}, true);
		const searchCache = /* @__PURE__ */ new Map();
		const loadCache = /* @__PURE__ */ new Map();
		const emplace = makeEmplace(cache$1);
		return {
			search(searchFrom = process.cwd()) {
				/** @type {import('./index').LilconfigResult} */
				const result = {
					config: null,
					filepath: ""
				};
				/** @type {Set<string>} */
				const visited = /* @__PURE__ */ new Set();
				let dir = searchFrom;
				dirLoop: while (true) {
					if (cache$1) {
						const r$1 = searchCache.get(dir);
						if (r$1 !== void 0) {
							for (const p of visited) searchCache.set(p, r$1);
							return r$1;
						}
						visited.add(dir);
					}
					for (const searchPlace of searchPlaces) {
						const filepath = path$11.join(dir, searchPlace);
						try {
							fs$11.accessSync(filepath);
						} catch {
							continue;
						}
						const loaderKey = path$11.extname(searchPlace) || "noExt";
						const loader$1 = loaders[loaderKey];
						const content = String(fs$11.readFileSync(filepath));
						if (searchPlace === "package.json") {
							const maybeConfig = getPackageProp(packageProp, loader$1(filepath, content));
							if (maybeConfig != null) {
								result.config = maybeConfig;
								result.filepath = filepath;
								break dirLoop;
							}
							continue;
						}
						const isEmpty = content.trim() === "";
						if (isEmpty && ignoreEmptySearchPlaces) continue;
						if (isEmpty) {
							result.isEmpty = true;
							result.config = void 0;
						} else {
							validateLoader(loader$1, loaderKey);
							result.config = loader$1(filepath, content);
						}
						result.filepath = filepath;
						break dirLoop;
					}
					if (dir === stopDir || dir === parentDir(dir)) break dirLoop;
					dir = parentDir(dir);
				}
				const transformed = result.filepath === "" && result.config === null ? transform$2(null) : transform$2(result);
				if (cache$1) for (const p of visited) searchCache.set(p, transformed);
				return transformed;
			},
			load(filepath) {
				validateFilePath(filepath);
				const absPath = path$11.resolve(process.cwd(), filepath);
				if (cache$1 && loadCache.has(absPath)) return loadCache.get(absPath);
				const { base, ext } = path$11.parse(absPath);
				const loaderKey = ext || "noExt";
				const loader$1 = loaders[loaderKey];
				validateLoader(loader$1, loaderKey);
				const content = String(fs$11.readFileSync(absPath));
				if (base === "package.json") return transform$2({
					config: getPackageProp(packageProp, loader$1(absPath, content)),
					filepath: absPath
				});
				const result = {
					config: null,
					filepath: absPath
				};
				const isEmpty = content.trim() === "";
				if (isEmpty && ignoreEmptySearchPlaces) return emplace(loadCache, absPath, transform$2({
					filepath: absPath,
					config: void 0,
					isEmpty: true
				}));
				result.config = isEmpty ? void 0 : loader$1(absPath, content);
				return emplace(loadCache, absPath, transform$2(isEmpty ? {
					...result,
					isEmpty,
					config: void 0
				} : result));
			},
			clearLoadCache() {
				if (cache$1) loadCache.clear();
			},
			clearSearchCache() {
				if (cache$1) searchCache.clear();
			},
			clearCaches() {
				if (cache$1) {
					loadCache.clear();
					searchCache.clear();
				}
			}
		};
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_tsx@4.20.6_yaml@2.8.1/node_modules/postcss-load-config/src/req.js
var require_req = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_tsx@4.20.6_yaml@2.8.1/node_modules/postcss-load-config/src/req.js": ((exports, module) => {
	const { createRequire: createRequire$2 } = __require("node:module");
	const { fileURLToPath: fileURLToPath$1, pathToFileURL: pathToFileURL$1 } = __require("node:url");
	const TS_EXT_RE = /\.[mc]?ts$/;
	let tsx;
	let jiti;
	let importError = [];
	/**
	* @param {string} name
	* @param {string} rootFile
	* @returns {Promise<any>}
	*/
	async function req$3(name, rootFile = fileURLToPath$1(import.meta.url)) {
		let url$3 = createRequire$2(rootFile).resolve(name);
		try {
			return (await import(`${pathToFileURL$1(url$3)}?t=${Date.now()}`)).default;
		} catch (err$2) {
			if (!TS_EXT_RE.test(url$3))
 /* c8 ignore start */
			throw err$2;
		}
		if (tsx === void 0) try {
			tsx = await import("tsx/cjs/api");
		} catch (error$1) {
			importError.push(error$1);
		}
		if (tsx) {
			let loaded = tsx.require(name, rootFile);
			return loaded && "__esModule" in loaded ? loaded.default : loaded;
		}
		if (jiti === void 0) try {
			jiti = (await import("jiti")).default;
		} catch (error$1) {
			importError.push(error$1);
		}
		if (jiti) return jiti(rootFile, { interopDefault: true })(name);
		throw new Error(`'tsx' or 'jiti' is required for the TypeScript configuration files. Make sure it is installed\nError: ${importError.map((error$1) => error$1.message).join("\n")}`);
	}
	module.exports = req$3;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_tsx@4.20.6_yaml@2.8.1/node_modules/postcss-load-config/src/options.js
var require_options = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_tsx@4.20.6_yaml@2.8.1/node_modules/postcss-load-config/src/options.js": ((exports, module) => {
	const req$2 = require_req();
	/**
	* Load Options
	*
	* @private
	* @method options
	*
	* @param  {Object} config  PostCSS Config
	*
	* @return {Promise<Object>} options PostCSS Options
	*/
	async function options(config$2, file) {
		if (config$2.parser && typeof config$2.parser === "string") try {
			config$2.parser = await req$2(config$2.parser, file);
		} catch (err$2) {
			throw new Error(`Loading PostCSS Parser failed: ${err$2.message}\n\n(@${file})`);
		}
		if (config$2.syntax && typeof config$2.syntax === "string") try {
			config$2.syntax = await req$2(config$2.syntax, file);
		} catch (err$2) {
			throw new Error(`Loading PostCSS Syntax failed: ${err$2.message}\n\n(@${file})`);
		}
		if (config$2.stringifier && typeof config$2.stringifier === "string") try {
			config$2.stringifier = await req$2(config$2.stringifier, file);
		} catch (err$2) {
			throw new Error(`Loading PostCSS Stringifier failed: ${err$2.message}\n\n(@${file})`);
		}
		return config$2;
	}
	module.exports = options;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_tsx@4.20.6_yaml@2.8.1/node_modules/postcss-load-config/src/plugins.js
var require_plugins = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_tsx@4.20.6_yaml@2.8.1/node_modules/postcss-load-config/src/plugins.js": ((exports, module) => {
	const req$1 = require_req();
	/**
	* Plugin Loader
	*
	* @private
	* @method load
	*
	* @param  {String} plugin PostCSS Plugin Name
	* @param  {Object} options PostCSS Plugin Options
	*
	* @return {Promise<Function>} PostCSS Plugin
	*/
	async function load$1(plugin, options$1, file) {
		try {
			if (options$1 === null || options$1 === void 0 || Object.keys(options$1).length === 0) return await req$1(plugin, file);
			else return (await req$1(plugin, file))(options$1);
		} catch (err$2) {
			throw new Error(`Loading PostCSS Plugin failed: ${err$2.message}\n\n(@${file})`);
		}
	}
	/**
	* Load Plugins
	*
	* @private
	* @method plugins
	*
	* @param {Object} config PostCSS Config Plugins
	*
	* @return {Promise<Array>} plugins PostCSS Plugins
	*/
	async function plugins(config$2, file) {
		let list = [];
		if (Array.isArray(config$2.plugins)) list = config$2.plugins.filter(Boolean);
		else {
			list = Object.entries(config$2.plugins).filter(([, options$1]) => {
				return options$1 !== false;
			}).map(([plugin, options$1]) => {
				return load$1(plugin, options$1, file);
			});
			list = await Promise.all(list);
		}
		if (list.length && list.length > 0) list.forEach((plugin, i$1) => {
			if (plugin.default) plugin = plugin.default;
			if (plugin.postcss === true) plugin = plugin();
			else if (plugin.postcss) plugin = plugin.postcss;
			if (!(typeof plugin === "object" && Array.isArray(plugin.plugins) || typeof plugin === "object" && plugin.postcssPlugin || typeof plugin === "function")) throw new TypeError(`Invalid PostCSS Plugin found at: plugins[${i$1}]\n\n(@${file})`);
		});
		return list;
	}
	module.exports = plugins;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_tsx@4.20.6_yaml@2.8.1/node_modules/postcss-load-config/src/index.js
var require_src = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_tsx@4.20.6_yaml@2.8.1/node_modules/postcss-load-config/src/index.js": ((exports, module) => {
	const { resolve: resolve$2 } = __require("node:path");
	const config$1 = require_src$1();
	const loadOptions = require_options();
	const loadPlugins = require_plugins();
	const req = require_req();
	const interopRequireDefault = (obj) => obj && obj.__esModule ? obj : { default: obj };
	/**
	* Process the result from cosmiconfig
	*
	* @param  {Object} ctx Config Context
	* @param  {Object} result Cosmiconfig result
	*
	* @return {Promise<Object>} PostCSS Config
	*/
	async function processResult(ctx, result) {
		let file = result.filepath || "";
		let projectConfig = interopRequireDefault(result.config).default || {};
		if (typeof projectConfig === "function") projectConfig = projectConfig(ctx);
		else projectConfig = Object.assign({}, projectConfig, ctx);
		if (!projectConfig.plugins) projectConfig.plugins = [];
		let res = {
			file,
			options: await loadOptions(projectConfig, file),
			plugins: await loadPlugins(projectConfig, file)
		};
		delete projectConfig.plugins;
		return res;
	}
	/**
	* Builds the Config Context
	*
	* @param  {Object} ctx Config Context
	*
	* @return {Object} Config Context
	*/
	function createContext(ctx) {
		/**
		* @type {Object}
		*
		* @prop {String} cwd=process.cwd() Config search start location
		* @prop {String} env=process.env.NODE_ENV Config Enviroment, will be set to `development` by `postcss-load-config` if `process.env.NODE_ENV` is `undefined`
		*/
		ctx = Object.assign({
			cwd: process.cwd(),
			env: process.env.NODE_ENV
		}, ctx);
		if (!ctx.env) process.env.NODE_ENV = "development";
		return ctx;
	}
	async function loader(filepath) {
		return req(filepath);
	}
	let yaml;
	async function yamlLoader(_, content) {
		if (!yaml) try {
			yaml = await import("yaml");
		} catch (e$1) {
			/* c8 ignore start */
			throw new Error(`'yaml' is required for the YAML configuration files. Make sure it is installed\nError: ${e$1.message}`);
		}
		return yaml.parse(content);
	}
	/** @return {import('lilconfig').Options} */
	const withLoaders = (options$1 = {}) => {
		let moduleName = "postcss";
		return {
			...options$1,
			loaders: {
				...options$1.loaders,
				".cjs": loader,
				".cts": loader,
				".js": loader,
				".mjs": loader,
				".mts": loader,
				".ts": loader,
				".yaml": yamlLoader,
				".yml": yamlLoader
			},
			searchPlaces: [
				...options$1.searchPlaces || [],
				"package.json",
				`.${moduleName}rc`,
				`.${moduleName}rc.json`,
				`.${moduleName}rc.yaml`,
				`.${moduleName}rc.yml`,
				`.${moduleName}rc.ts`,
				`.${moduleName}rc.cts`,
				`.${moduleName}rc.mts`,
				`.${moduleName}rc.js`,
				`.${moduleName}rc.cjs`,
				`.${moduleName}rc.mjs`,
				`${moduleName}.config.ts`,
				`${moduleName}.config.cts`,
				`${moduleName}.config.mts`,
				`${moduleName}.config.js`,
				`${moduleName}.config.cjs`,
				`${moduleName}.config.mjs`
			]
		};
	};
	/**
	* Load Config
	*
	* @method rc
	*
	* @param  {Object} ctx Config Context
	* @param  {String} path Config Path
	* @param  {Object} options Config Options
	*
	* @return {Promise} config PostCSS Config
	*/
	function rc(ctx, path$13, options$1) {
		/**
		* @type {Object} The full Config Context
		*/
		ctx = createContext(ctx);
		/**
		* @type {String} `process.cwd()`
		*/
		path$13 = path$13 ? resolve$2(path$13) : process.cwd();
		return config$1.lilconfig("postcss", withLoaders(options$1)).search(path$13).then((result) => {
			if (!result) throw new Error(`No PostCSS Config found in: ${path$13}`);
			return processResult(ctx, result);
		});
	}
	/**
	* Autoload Config for PostCSS
	*
	* @author Michael Ciniawsky @michael-ciniawsky <michael.ciniawsky@gmail.com>
	* @license MIT
	*
	* @module postcss-load-config
	* @version 2.1.0
	*
	* @requires comsiconfig
	* @requires ./options
	* @requires ./plugins
	*/
	module.exports = rc;
}) });

//#endregion
//#region ../../node_modules/.pnpm/@rollup+plugin-alias@5.1.1_rollup@4.43.0/node_modules/@rollup/plugin-alias/dist/es/index.js
function matches$1(pattern, importee) {
	if (pattern instanceof RegExp) return pattern.test(importee);
	if (importee.length < pattern.length) return false;
	if (importee === pattern) return true;
	return importee.startsWith(pattern + "/");
}
function getEntries({ entries, customResolver }) {
	if (!entries) return [];
	const resolverFunctionFromOptions = resolveCustomResolver(customResolver);
	if (Array.isArray(entries)) return entries.map((entry) => {
		return {
			find: entry.find,
			replacement: entry.replacement,
			resolverFunction: resolveCustomResolver(entry.customResolver) || resolverFunctionFromOptions
		};
	});
	return Object.entries(entries).map(([key, value$1]) => {
		return {
			find: key,
			replacement: value$1,
			resolverFunction: resolverFunctionFromOptions
		};
	});
}
function getHookFunction(hook) {
	if (typeof hook === "function") return hook;
	if (hook && "handler" in hook && typeof hook.handler === "function") return hook.handler;
	return null;
}
function resolveCustomResolver(customResolver) {
	if (typeof customResolver === "function") return customResolver;
	if (customResolver) return getHookFunction(customResolver.resolveId);
	return null;
}
function alias(options$1 = {}) {
	const entries = getEntries(options$1);
	if (entries.length === 0) return {
		name: "alias",
		resolveId: () => null
	};
	return {
		name: "alias",
		async buildStart(inputOptions) {
			await Promise.all([...Array.isArray(options$1.entries) ? options$1.entries : [], options$1].map(({ customResolver }) => {
				var _a;
				return customResolver && ((_a = getHookFunction(customResolver.buildStart)) === null || _a === void 0 ? void 0 : _a.call(this, inputOptions));
			}));
		},
		resolveId(importee, importer, resolveOptions) {
			const matchedEntry = entries.find((entry) => matches$1(entry.find, importee));
			if (!matchedEntry) return null;
			const updatedId = importee.replace(matchedEntry.find, matchedEntry.replacement);
			if (matchedEntry.resolverFunction) return matchedEntry.resolverFunction.call(this, updatedId, importer, resolveOptions);
			return this.resolve(updatedId, importer, Object.assign({ skipSelf: true }, resolveOptions)).then((resolved) => {
				if (resolved) return resolved;
				if (!path$1.isAbsolute(updatedId)) this.warn(`rewrote ${importee} to ${updatedId} but was not an abolute path and was not handled by other plugins. This will lead to duplicated modules for the same path. To avoid duplicating modules, you should resolve to an absolute path.`);
				return { id: updatedId };
			});
		}
	};
}

//#endregion
//#region src/node/plugins/json.ts
const jsonExtRE = /\.json(?:$|\?)(?!commonjs-(?:proxy|external))/;
const jsonObjRE = /^\s*\{/;
const jsonLangRE = new RegExp(`\\.(?:json|json5)(?:$|\\?)`);
const isJSONRequest = (request) => jsonLangRE.test(request);
function jsonPlugin(options$1, isBuild) {
	return {
		name: "vite:json",
		transform: {
			filter: { id: {
				include: jsonExtRE,
				exclude: SPECIAL_QUERY_RE
			} },
			handler(json, id) {
				if (inlineRE$3.test(id) || noInlineRE.test(id)) this.warn("\nUsing ?inline or ?no-inline for JSON imports will have no effect.\nPlease use ?url&inline or ?url&no-inline to control JSON file inlining behavior.\n");
				json = stripBomTag(json);
				try {
					if (options$1.stringify !== false) {
						if (options$1.namedExports && jsonObjRE.test(json)) {
							const parsed = JSON.parse(json);
							const keys = Object.keys(parsed);
							let code = "";
							let defaultObjectCode = "{\n";
							for (const key of keys) if (key === makeLegalIdentifier(key)) {
								code += `export const ${key} = ${serializeValue(parsed[key])};\n`;
								defaultObjectCode += `  ${key},\n`;
							} else defaultObjectCode += `  ${JSON.stringify(key)}: ${serializeValue(parsed[key])},\n`;
							defaultObjectCode += "}";
							code += `export default ${defaultObjectCode};\n`;
							return {
								code,
								map: { mappings: "" }
							};
						}
						if (options$1.stringify === true || json.length > 10 * 1e3) {
							if (isBuild) json = JSON.stringify(JSON.parse(json));
							return {
								code: `export default /* #__PURE__ */ JSON.parse(${JSON.stringify(json)})`,
								map: { mappings: "" }
							};
						}
					}
					return {
						code: dataToEsm(JSON.parse(json), {
							preferConst: true,
							namedExports: options$1.namedExports
						}),
						map: { mappings: "" }
					};
				} catch (e$1) {
					const position = extractJsonErrorPosition(e$1.message, json.length);
					const msg = position ? `, invalid JSON syntax found at position ${position}` : `.`;
					this.error(`Failed to parse JSON file` + msg, position);
				}
			}
		}
	};
}
function serializeValue(value$1) {
	const valueAsString = JSON.stringify(value$1);
	if (typeof value$1 === "object" && value$1 != null && valueAsString.length > 10 * 1e3) return `/* #__PURE__ */ JSON.parse(${JSON.stringify(valueAsString)})`;
	return valueAsString;
}
function extractJsonErrorPosition(errorMessage, inputLength) {
	if (errorMessage.startsWith("Unexpected end of JSON input")) return inputLength - 1;
	const errorMessageList = /at position (\d+)/.exec(errorMessage);
	return errorMessageList ? Math.max(parseInt(errorMessageList[1], 10) - 1, 0) : void 0;
}

//#endregion
//#region ../../node_modules/.pnpm/resolve.exports@2.0.3/node_modules/resolve.exports/dist/index.mjs
function e(e$1, n$2, r$1) {
	throw new Error(r$1 ? `No known conditions for "${n$2}" specifier in "${e$1}" package` : `Missing "${n$2}" specifier in "${e$1}" package`);
}
function n(n$2, i$1, o$1, f$1) {
	let s$2, u, l = r(n$2, o$1), c = function(e$1) {
		let n$3 = new Set(["default", ...e$1.conditions || []]);
		return e$1.unsafe || n$3.add(e$1.require ? "require" : "import"), e$1.unsafe || n$3.add(e$1.browser ? "browser" : "node"), n$3;
	}(f$1 || {}), a = i$1[l];
	if (void 0 === a) {
		let e$1, n$3, r$1, t$1;
		for (t$1 in i$1) n$3 && t$1.length < n$3.length || ("/" === t$1[t$1.length - 1] && l.startsWith(t$1) ? (u = l.substring(t$1.length), n$3 = t$1) : t$1.length > 1 && (r$1 = t$1.indexOf("*", 1), ~r$1 && (e$1 = RegExp("^" + t$1.substring(0, r$1) + "(.*)" + t$1.substring(1 + r$1) + "$").exec(l), e$1 && e$1[1] && (u = e$1[1], n$3 = t$1))));
		a = i$1[n$3];
	}
	return a || e(n$2, l), s$2 = t(a, c), s$2 || e(n$2, l, 1), u && function(e$1, n$3) {
		let r$1, t$1 = 0, i$2 = e$1.length, o$2 = /[*]/g, f$2 = /[/]$/;
		for (; t$1 < i$2; t$1++) e$1[t$1] = o$2.test(r$1 = e$1[t$1]) ? r$1.replace(o$2, n$3) : f$2.test(r$1) ? r$1 + n$3 : r$1;
	}(s$2, u), s$2;
}
function r(e$1, n$2, r$1) {
	if (e$1 === n$2 || "." === n$2) return ".";
	let t$1 = e$1 + "/", i$1 = t$1.length, o$1 = n$2.slice(0, i$1) === t$1, f$1 = o$1 ? n$2.slice(i$1) : n$2;
	return "#" === f$1[0] ? f$1 : o$1 || !r$1 ? "./" === f$1.slice(0, 2) ? f$1 : "./" + f$1 : f$1;
}
function t(e$1, n$2, r$1) {
	if (e$1) {
		if ("string" == typeof e$1) return r$1 && r$1.add(e$1), [e$1];
		let i$1, o$1;
		if (Array.isArray(e$1)) {
			for (o$1 = r$1 || /* @__PURE__ */ new Set(), i$1 = 0; i$1 < e$1.length; i$1++) t(e$1[i$1], n$2, o$1);
			if (!r$1 && o$1.size) return [...o$1];
		} else for (i$1 in e$1) if (n$2.has(i$1)) return t(e$1[i$1], n$2, r$1);
	}
}
function o(e$1, r$1, t$1) {
	let i$1, o$1 = e$1.exports;
	if (o$1) {
		if ("string" == typeof o$1) o$1 = { ".": o$1 };
		else for (i$1 in o$1) {
			"." !== i$1[0] && (o$1 = { ".": o$1 });
			break;
		}
		return n(e$1.name, o$1, r$1 || ".", t$1);
	}
}
function f(e$1, r$1, t$1) {
	if (e$1.imports) return n(e$1.name, e$1.imports, r$1, t$1);
}

//#endregion
//#region ../../node_modules/.pnpm/ufo@1.6.1/node_modules/ufo/dist/index.mjs
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const PLUS_RE = /\+/g;
const ENC_CARET_RE = /%5e/gi;
const ENC_BACKTICK_RE = /%60/gi;
const ENC_PIPE_RE = /%7c/gi;
const ENC_SPACE_RE = /%20/gi;
function encode(text) {
	return encodeURI("" + text).replace(ENC_PIPE_RE, "|");
}
function encodeQueryValue(input) {
	return encode(typeof input === "string" ? input : JSON.stringify(input)).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CARET_RE, "^").replace(SLASH_RE, "%2F");
}
function encodeQueryKey(text) {
	return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodeQueryItem(key, value$1) {
	if (typeof value$1 === "number" || typeof value$1 === "boolean") value$1 = String(value$1);
	if (!value$1) return encodeQueryKey(key);
	if (Array.isArray(value$1)) return value$1.map((_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`).join("&");
	return `${encodeQueryKey(key)}=${encodeQueryValue(value$1)}`;
}
function stringifyQuery(query) {
	return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join("&");
}
const protocolRelative = Symbol.for("ufo:protocolRelative");

//#endregion
//#region ../../node_modules/.pnpm/mlly@1.8.0/node_modules/mlly/dist/index.mjs
const BUILTIN_MODULES = new Set(builtinModules);
function clearImports(imports) {
	return (imports || "").replace(/\/\/[^\n]*\n|\/\*.*\*\//g, "").replace(/\s+/g, " ");
}
function getImportNames(cleanedImports) {
	const topLevelImports = cleanedImports.replace(/{[^}]*}/, "");
	return {
		namespacedImport: topLevelImports.match(/\* as \s*(\S*)/)?.[1],
		defaultImport: topLevelImports.split(",").find((index) => !/[*{}]/.test(index))?.trim() || void 0
	};
}
/**
* @typedef ErrnoExceptionFields
* @property {number | undefined} [errnode]
* @property {string | undefined} [code]
* @property {string | undefined} [path]
* @property {string | undefined} [syscall]
* @property {string | undefined} [url]
*
* @typedef {Error & ErrnoExceptionFields} ErrnoException
*/
const own$1 = {}.hasOwnProperty;
const classRegExp = /^([A-Z][a-z\d]*)+$/;
const kTypes = new Set([
	"string",
	"function",
	"number",
	"object",
	"Function",
	"Object",
	"boolean",
	"bigint",
	"symbol"
]);
const codes$1 = {};
/**
* Create a list string in the form like 'A and B' or 'A, B, ..., and Z'.
* We cannot use Intl.ListFormat because it's not available in
* --without-intl builds.
*
* @param {Array<string>} array
*   An array of strings.
* @param {string} [type]
*   The list type to be inserted before the last element.
* @returns {string}
*/
function formatList(array, type = "and") {
	return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
}
/** @type {Map<string, MessageFunction | string>} */
const messages = /* @__PURE__ */ new Map();
const nodeInternalPrefix = "__node_internal_";
/** @type {number} */
let userStackTraceLimit;
codes$1.ERR_INVALID_ARG_TYPE = createError(
	"ERR_INVALID_ARG_TYPE",
	/**
	* @param {string} name
	* @param {Array<string> | string} expected
	* @param {unknown} actual
	*/
	(name, expected, actual) => {
		assert(typeof name === "string", "'name' must be a string");
		if (!Array.isArray(expected)) expected = [expected];
		let message = "The ";
		if (name.endsWith(" argument")) message += `${name} `;
		else {
			const type = name.includes(".") ? "property" : "argument";
			message += `"${name}" ${type} `;
		}
		message += "must be ";
		/** @type {Array<string>} */
		const types = [];
		/** @type {Array<string>} */
		const instances = [];
		/** @type {Array<string>} */
		const other = [];
		for (const value$1 of expected) {
			assert(typeof value$1 === "string", "All expected entries have to be of type string");
			if (kTypes.has(value$1)) types.push(value$1.toLowerCase());
			else if (classRegExp.exec(value$1) === null) {
				assert(value$1 !== "object", "The value \"object\" should be written as \"Object\"");
				other.push(value$1);
			} else instances.push(value$1);
		}
		if (instances.length > 0) {
			const pos = types.indexOf("object");
			if (pos !== -1) {
				types.slice(pos, 1);
				instances.push("Object");
			}
		}
		if (types.length > 0) {
			message += `${types.length > 1 ? "one of type" : "of type"} ${formatList(types, "or")}`;
			if (instances.length > 0 || other.length > 0) message += " or ";
		}
		if (instances.length > 0) {
			message += `an instance of ${formatList(instances, "or")}`;
			if (other.length > 0) message += " or ";
		}
		if (other.length > 0) if (other.length > 1) message += `one of ${formatList(other, "or")}`;
		else {
			if (other[0].toLowerCase() !== other[0]) message += "an ";
			message += `${other[0]}`;
		}
		message += `. Received ${determineSpecificType(actual)}`;
		return message;
	},
	TypeError
);
codes$1.ERR_INVALID_MODULE_SPECIFIER = createError(
	"ERR_INVALID_MODULE_SPECIFIER",
	/**
	* @param {string} request
	* @param {string} reason
	* @param {string} [base]
	*/
	(request, reason, base = void 0) => {
		return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
	},
	TypeError
);
codes$1.ERR_INVALID_PACKAGE_CONFIG = createError(
	"ERR_INVALID_PACKAGE_CONFIG",
	/**
	* @param {string} path
	* @param {string} [base]
	* @param {string} [message]
	*/
	(path$13, base, message) => {
		return `Invalid package config ${path$13}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
	},
	Error
);
codes$1.ERR_INVALID_PACKAGE_TARGET = createError(
	"ERR_INVALID_PACKAGE_TARGET",
	/**
	* @param {string} packagePath
	* @param {string} key
	* @param {unknown} target
	* @param {boolean} [isImport=false]
	* @param {string} [base]
	*/
	(packagePath, key, target, isImport = false, base = void 0) => {
		const relatedError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
		if (key === ".") {
			assert(isImport === false);
			return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? "; targets must start with \"./\"" : ""}`;
		}
		return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? "; targets must start with \"./\"" : ""}`;
	},
	Error
);
codes$1.ERR_MODULE_NOT_FOUND = createError(
	"ERR_MODULE_NOT_FOUND",
	/**
	* @param {string} path
	* @param {string} base
	* @param {boolean} [exactUrl]
	*/
	(path$13, base, exactUrl = false) => {
		return `Cannot find ${exactUrl ? "module" : "package"} '${path$13}' imported from ${base}`;
	},
	Error
);
codes$1.ERR_NETWORK_IMPORT_DISALLOWED = createError("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error);
codes$1.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
	"ERR_PACKAGE_IMPORT_NOT_DEFINED",
	/**
	* @param {string} specifier
	* @param {string} packagePath
	* @param {string} base
	*/
	(specifier, packagePath, base) => {
		return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
	},
	TypeError
);
codes$1.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
	"ERR_PACKAGE_PATH_NOT_EXPORTED",
	/**
	* @param {string} packagePath
	* @param {string} subpath
	* @param {string} [base]
	*/
	(packagePath, subpath, base = void 0) => {
		if (subpath === ".") return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
		return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
	},
	Error
);
codes$1.ERR_UNSUPPORTED_DIR_IMPORT = createError("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error);
codes$1.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError("ERR_UNSUPPORTED_RESOLVE_REQUEST", "Failed to resolve module specifier \"%s\" from \"%s\": Invalid relative URL or base scheme is not hierarchical.", TypeError);
codes$1.ERR_UNKNOWN_FILE_EXTENSION = createError(
	"ERR_UNKNOWN_FILE_EXTENSION",
	/**
	* @param {string} extension
	* @param {string} path
	*/
	(extension$1, path$13) => {
		return `Unknown file extension "${extension$1}" for ${path$13}`;
	},
	TypeError
);
codes$1.ERR_INVALID_ARG_VALUE = createError(
	"ERR_INVALID_ARG_VALUE",
	/**
	* @param {string} name
	* @param {unknown} value
	* @param {string} [reason='is invalid']
	*/
	(name, value$1, reason = "is invalid") => {
		let inspected = inspect(value$1);
		if (inspected.length > 128) inspected = `${inspected.slice(0, 128)}...`;
		return `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
	},
	TypeError
);
/**
* Utility function for registering the error codes. Only used here. Exported
* *only* to allow for testing.
* @param {string} sym
* @param {MessageFunction | string} value
* @param {ErrorConstructor} constructor
* @returns {new (...parameters: Array<any>) => Error}
*/
function createError(sym, value$1, constructor) {
	messages.set(sym, value$1);
	return makeNodeErrorWithCode(constructor, sym);
}
/**
* @param {ErrorConstructor} Base
* @param {string} key
* @returns {ErrorConstructor}
*/
function makeNodeErrorWithCode(Base, key) {
	return NodeError;
	/**
	* @param {Array<unknown>} parameters
	*/
	function NodeError(...parameters) {
		const limit = Error.stackTraceLimit;
		if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
		const error$1 = new Base();
		if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
		const message = getMessage(key, parameters, error$1);
		Object.defineProperties(error$1, {
			message: {
				value: message,
				enumerable: false,
				writable: true,
				configurable: true
			},
			toString: {
				value() {
					return `${this.name} [${key}]: ${this.message}`;
				},
				enumerable: false,
				writable: true,
				configurable: true
			}
		});
		captureLargerStackTrace(error$1);
		error$1.code = key;
		return error$1;
	}
}
/**
* @returns {boolean}
*/
function isErrorStackTraceLimitWritable() {
	try {
		if (v8.startupSnapshot.isBuildingSnapshot()) return false;
	} catch {}
	const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
	if (desc === void 0) return Object.isExtensible(Error);
	return own$1.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
/**
* This function removes unnecessary frames from Node.js core errors.
* @template {(...parameters: unknown[]) => unknown} T
* @param {T} wrappedFunction
* @returns {T}
*/
function hideStackFrames(wrappedFunction) {
	const hidden = nodeInternalPrefix + wrappedFunction.name;
	Object.defineProperty(wrappedFunction, "name", { value: hidden });
	return wrappedFunction;
}
const captureLargerStackTrace = hideStackFrames(
	/**
	* @param {Error} error
	* @returns {Error}
	*/
	function(error$1) {
		const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
		if (stackTraceLimitIsWritable) {
			userStackTraceLimit = Error.stackTraceLimit;
			Error.stackTraceLimit = Number.POSITIVE_INFINITY;
		}
		Error.captureStackTrace(error$1);
		if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
		return error$1;
	}
);
/**
* @param {string} key
* @param {Array<unknown>} parameters
* @param {Error} self
* @returns {string}
*/
function getMessage(key, parameters, self$1) {
	const message = messages.get(key);
	assert(message !== void 0, "expected `message` to be found");
	if (typeof message === "function") {
		assert(message.length <= parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`);
		return Reflect.apply(message, self$1, parameters);
	}
	const regex = /%[dfijoOs]/g;
	let expectedLength = 0;
	while (regex.exec(message) !== null) expectedLength++;
	assert(expectedLength === parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`);
	if (parameters.length === 0) return message;
	parameters.unshift(message);
	return Reflect.apply(format, null, parameters);
}
/**
* Determine the specific type of a value for type-mismatch errors.
* @param {unknown} value
* @returns {string}
*/
function determineSpecificType(value$1) {
	if (value$1 === null || value$1 === void 0) return String(value$1);
	if (typeof value$1 === "function" && value$1.name) return `function ${value$1.name}`;
	if (typeof value$1 === "object") {
		if (value$1.constructor && value$1.constructor.name) return `an instance of ${value$1.constructor.name}`;
		return `${inspect(value$1, { depth: -1 })}`;
	}
	let inspected = inspect(value$1, { colors: false });
	if (inspected.length > 28) inspected = `${inspected.slice(0, 25)}...`;
	return `type ${typeof value$1} (${inspected})`;
}
const ESM_STATIC_IMPORT_RE = /(?<=\s|^|;|\})import\s*(?:[\s"']*(?<imports>[\p{L}\p{M}\w\t\n\r $*,/{}@.]+)from\s*)?["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][\s;]*/gmu;
const TYPE_RE = /^\s*?type\s/;
function parseStaticImport(matched) {
	const cleanedImports = clearImports(matched.imports);
	const namedImports = {};
	const _matches = cleanedImports.match(/{([^}]*)}/)?.[1]?.split(",") || [];
	for (const namedImport of _matches) {
		const _match = namedImport.match(/^\s*(\S*) as (\S*)\s*$/);
		const source = _match?.[1] || namedImport.trim();
		const importName = _match?.[2] || source;
		if (source && !TYPE_RE.test(source)) namedImports[source] = importName;
	}
	const { namespacedImport, defaultImport } = getImportNames(cleanedImports);
	return {
		...matched,
		defaultImport,
		namespacedImport,
		namedImports
	};
}
const ESM_RE = /(?:[\s;]|^)(?:import[\s\w*,{}]*from|import\s*["'*{]|export\b\s*(?:[*{]|default|class|type|function|const|var|let|async function)|import\.meta\b)/m;
const COMMENT_RE = /\/\*.+?\*\/|\/\/.*(?=[nr])/g;
function hasESMSyntax(code, opts = {}) {
	if (opts.stripComments) code = code.replace(COMMENT_RE, "");
	return ESM_RE.test(code);
}

//#endregion
//#region src/node/optimizer/esbuildDepPlugin.ts
const externalWithConversionNamespace = "vite:dep-pre-bundle:external-conversion";
const convertedExternalPrefix = "vite-dep-pre-bundle-external:";
const cjsExternalFacadeNamespace = "vite:cjs-external-facade";
const nonFacadePrefix = "vite-cjs-external-facade:";
const externalTypes = [
	"css",
	"less",
	"sass",
	"scss",
	"styl",
	"stylus",
	"pcss",
	"postcss",
	"wasm",
	"vue",
	"svelte",
	"marko",
	"astro",
	"imba",
	"jsx",
	"tsx",
	...KNOWN_ASSET_TYPES
];
function esbuildDepPlugin(environment, qualified, external) {
	const { isProduction } = environment.config;
	const { extensions: extensions$1 } = environment.config.optimizeDeps;
	const allExternalTypes = extensions$1 ? externalTypes.filter((type) => !extensions$1.includes("." + type)) : externalTypes;
	const esmPackageCache = /* @__PURE__ */ new Map();
	const cjsPackageCache = /* @__PURE__ */ new Map();
	const _resolve = createBackCompatIdResolver(environment.getTopLevelConfig(), {
		asSrc: false,
		scan: true,
		packageCache: esmPackageCache
	});
	const _resolveRequire = createBackCompatIdResolver(environment.getTopLevelConfig(), {
		asSrc: false,
		isRequire: true,
		scan: true,
		packageCache: cjsPackageCache
	});
	const resolve$4 = (id, importer, kind, resolveDir) => {
		let _importer;
		if (resolveDir) _importer = normalizePath(path.join(resolveDir, "*"));
		else _importer = importer in qualified ? qualified[importer] : importer;
		return (kind.startsWith("require") ? _resolveRequire : _resolve)(environment, id, _importer);
	};
	const resolveResult = (id, resolved) => {
		if (resolved.startsWith(browserExternalId)) return {
			path: id,
			namespace: "browser-external"
		};
		if (resolved.startsWith(optionalPeerDepId)) return {
			path: resolved,
			namespace: "optional-peer-dep"
		};
		if (isBuiltin(environment.config.resolve.builtins, resolved)) return;
		if (isExternalUrl(resolved)) return {
			path: resolved,
			external: true
		};
		return { path: path.resolve(resolved) };
	};
	return {
		name: "vite:dep-pre-bundle",
		setup(build$3) {
			build$3.onEnd(() => {
				esmPackageCache.clear();
				cjsPackageCache.clear();
			});
			build$3.onResolve({ filter: /* @__PURE__ */ new RegExp(`\\.(` + allExternalTypes.join("|") + `)(\\?.*)?$`) }, async ({ path: id, importer, kind }) => {
				if (id.startsWith(convertedExternalPrefix)) return {
					path: id.slice(29),
					external: true
				};
				const resolved = await resolve$4(id, importer, kind);
				if (resolved) {
					if (JS_TYPES_RE.test(resolved)) return {
						path: resolved,
						external: false
					};
					if (kind === "require-call") return {
						path: resolved,
						namespace: externalWithConversionNamespace
					};
					return {
						path: resolved,
						external: true
					};
				}
			});
			build$3.onLoad({
				filter: /./,
				namespace: externalWithConversionNamespace
			}, (args) => {
				const modulePath = `"${convertedExternalPrefix}${args.path}"`;
				return {
					contents: isCSSRequest(args.path) && !isModuleCSSRequest(args.path) ? `import ${modulePath};` : `export { default } from ${modulePath};export * from ${modulePath};`,
					loader: "js"
				};
			});
			function resolveEntry(id) {
				const flatId = flattenId(id);
				if (flatId in qualified) return { path: qualified[flatId] };
			}
			build$3.onResolve({ filter: /^[\w@][^:]/ }, async ({ path: id, importer, kind }) => {
				if (moduleListContains(external, id)) return {
					path: id,
					external: true
				};
				let entry;
				if (!importer) {
					if (entry = resolveEntry(id)) return entry;
					const aliased = await _resolve(environment, id, void 0, true);
					if (aliased && (entry = resolveEntry(aliased))) return entry;
				}
				const resolved = await resolve$4(id, importer, kind);
				if (resolved) return resolveResult(id, resolved);
			});
			build$3.onLoad({
				filter: /.*/,
				namespace: "browser-external"
			}, ({ path: path$13 }) => {
				if (isProduction) return { contents: "module.exports = {}" };
				else return { contents: `\
module.exports = Object.create(new Proxy({}, {
  get(_, key) {
    if (
      key !== '__esModule' &&
      key !== '__proto__' &&
      key !== 'constructor' &&
      key !== 'splice'
    ) {
      console.warn(\`Module "${path$13}" has been externalized for browser compatibility. Cannot access "${path$13}.\${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.\`)
    }
  }
}))` };
			});
			build$3.onLoad({
				filter: /.*/,
				namespace: "optional-peer-dep"
			}, ({ path: path$13 }) => {
				const [, peerDep, parentDep] = path$13.split(":");
				return { contents: `module.exports = {};throw new Error(\`Could not resolve "${peerDep}" imported by "${parentDep}".${isProduction ? "" : " Is it installed?"}\`)` };
			});
		}
	};
}
const matchesEntireLine = (text) => `^${escapeRegex(text)}$`;
function esbuildCjsExternalPlugin(externals, platform$2) {
	return {
		name: "cjs-external",
		setup(build$3) {
			const filter$1 = new RegExp(externals.map(matchesEntireLine).join("|"));
			build$3.onResolve({ filter: /* @__PURE__ */ new RegExp(`^${nonFacadePrefix}`) }, (args) => {
				return {
					path: args.path.slice(25),
					external: true
				};
			});
			build$3.onResolve({ filter: filter$1 }, (args) => {
				if (args.kind === "require-call" && platform$2 !== "node") return {
					path: args.path,
					namespace: cjsExternalFacadeNamespace
				};
				return {
					path: args.path,
					external: true
				};
			});
			build$3.onLoad({
				filter: /.*/,
				namespace: cjsExternalFacadeNamespace
			}, (args) => ({ contents: `\
import * as m from ${JSON.stringify(nonFacadePrefix + args.path)};
module.exports = ${isNodeBuiltin(args.path) ? "m.default" : "{ ...m }"};
` }));
		}
	};
}

//#endregion
//#region src/node/baseEnvironment.ts
var import_picocolors$29 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const environmentColors = [
	import_picocolors$29.default.blue,
	import_picocolors$29.default.magenta,
	import_picocolors$29.default.green,
	import_picocolors$29.default.gray
];
var PartialEnvironment = class {
	name;
	getTopLevelConfig() {
		return this._topLevelConfig;
	}
	config;
	logger;
	/**
	* @internal
	*/
	_options;
	/**
	* @internal
	*/
	_topLevelConfig;
	constructor(name, topLevelConfig, options$1 = topLevelConfig.environments[name]) {
		if (!/^[\w$]+$/.test(name)) throw new Error(`Invalid environment name "${name}". Environment names must only contain alphanumeric characters and "$", "_".`);
		this.name = name;
		this._topLevelConfig = topLevelConfig;
		this._options = options$1;
		this.config = new Proxy(options$1, { get: (target, prop) => {
			if (prop === "logger") return this.logger;
			if (prop in target) return this._options[prop];
			return this._topLevelConfig[prop];
		} });
		const environment = import_picocolors$29.default.dim(`(${this.name})`);
		const infoColor = environmentColors[[...this.name].reduce((acc, c) => acc + c.charCodeAt(0), 0) % environmentColors.length || 0];
		this.logger = {
			get hasWarned() {
				return topLevelConfig.logger.hasWarned;
			},
			info(msg, opts) {
				return topLevelConfig.logger.info(msg, {
					...opts,
					environment: infoColor(environment)
				});
			},
			warn(msg, opts) {
				return topLevelConfig.logger.warn(msg, {
					...opts,
					environment: import_picocolors$29.default.yellow(environment)
				});
			},
			warnOnce(msg, opts) {
				return topLevelConfig.logger.warnOnce(msg, {
					...opts,
					environment: import_picocolors$29.default.yellow(environment)
				});
			},
			error(msg, opts) {
				return topLevelConfig.logger.error(msg, {
					...opts,
					environment: import_picocolors$29.default.red(environment)
				});
			},
			clearScreen(type) {
				return topLevelConfig.logger.clearScreen(type);
			},
			hasErrorLogged(error$1) {
				return topLevelConfig.logger.hasErrorLogged(error$1);
			}
		};
	}
};
var BaseEnvironment = class extends PartialEnvironment {
	get plugins() {
		return this.config.plugins;
	}
	/**
	* @internal
	*/
	_initiated = false;
	constructor(name, config$2, options$1 = config$2.environments[name]) {
		super(name, config$2, options$1);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/js-tokens@9.0.1/node_modules/js-tokens/index.js
var require_js_tokens = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/js-tokens@9.0.1/node_modules/js-tokens/index.js": ((exports, module) => {
	var HashbangComment, Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:[^\]\\\n\r\u2028\u2029]+|\\.)*\]?|[^\/[\\\n\r\u2028\u2029]+|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/uy, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
	Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
	Identifier = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]+|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/uy;
	StringLiteral = /(['"])(?:[^'"\\\n\r]+|(?!\1)['"]|\\(?:\r\n|[^]))*(\1)?/y;
	NumericLiteral = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
	Template = /[`}](?:[^`\\$]+|\\[^]|\$(?!\{))*(`|\$\{)?/y;
	WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/uy;
	LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y;
	MultiLineComment = /\/\*(?:[^*]+|\*(?!\/))*(\*\/)?/y;
	SingleLineComment = /\/\/.*/y;
	HashbangComment = /^#!.*/;
	JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y;
	JSXIdentifier = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/uy;
	JSXString = /(['"])(?:[^'"]+|(?!\1)['"])*(\1)?/y;
	JSXText = /[^<>{}]+/y;
	TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
	TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
	KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
	KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
	Newline = RegExp(LineTerminatorSequence.source);
	module.exports = function* (input, { jsx = false } = {}) {
		var braces$2, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;
		({length} = input);
		lastIndex = 0;
		lastSignificantToken = "";
		stack = [{ tag: "JS" }];
		braces$2 = [];
		parenNesting = 0;
		postfixIncDec = false;
		if (match = HashbangComment.exec(input)) {
			yield {
				type: "HashbangComment",
				value: match[0]
			};
			lastIndex = match[0].length;
		}
		while (lastIndex < length) {
			mode = stack[stack.length - 1];
			switch (mode.tag) {
				case "JS":
				case "JSNonExpressionParen":
				case "InterpolationInTemplate":
				case "InterpolationInJSX":
					if (input[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
						RegularExpressionLiteral.lastIndex = lastIndex;
						if (match = RegularExpressionLiteral.exec(input)) {
							lastIndex = RegularExpressionLiteral.lastIndex;
							lastSignificantToken = match[0];
							postfixIncDec = true;
							yield {
								type: "RegularExpressionLiteral",
								value: match[0],
								closed: match[1] !== void 0 && match[1] !== "\\"
							};
							continue;
						}
					}
					Punctuator.lastIndex = lastIndex;
					if (match = Punctuator.exec(input)) {
						punctuator = match[0];
						nextLastIndex = Punctuator.lastIndex;
						nextLastSignificantToken = punctuator;
						switch (punctuator) {
							case "(":
								if (lastSignificantToken === "?NonExpressionParenKeyword") stack.push({
									tag: "JSNonExpressionParen",
									nesting: parenNesting
								});
								parenNesting++;
								postfixIncDec = false;
								break;
							case ")":
								parenNesting--;
								postfixIncDec = true;
								if (mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting) {
									stack.pop();
									nextLastSignificantToken = "?NonExpressionParenEnd";
									postfixIncDec = false;
								}
								break;
							case "{":
								Punctuator.lastIndex = 0;
								isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));
								braces$2.push(isExpression);
								postfixIncDec = false;
								break;
							case "}":
								switch (mode.tag) {
									case "InterpolationInTemplate":
										if (braces$2.length === mode.nesting) {
											Template.lastIndex = lastIndex;
											match = Template.exec(input);
											lastIndex = Template.lastIndex;
											lastSignificantToken = match[0];
											if (match[1] === "${") {
												lastSignificantToken = "?InterpolationInTemplate";
												postfixIncDec = false;
												yield {
													type: "TemplateMiddle",
													value: match[0]
												};
											} else {
												stack.pop();
												postfixIncDec = true;
												yield {
													type: "TemplateTail",
													value: match[0],
													closed: match[1] === "`"
												};
											}
											continue;
										}
										break;
									case "InterpolationInJSX": if (braces$2.length === mode.nesting) {
										stack.pop();
										lastIndex += 1;
										lastSignificantToken = "}";
										yield {
											type: "JSXPunctuator",
											value: "}"
										};
										continue;
									}
								}
								postfixIncDec = braces$2.pop();
								nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
								break;
							case "]":
								postfixIncDec = true;
								break;
							case "++":
							case "--":
								nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
								break;
							case "<":
								if (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
									stack.push({ tag: "JSXTag" });
									lastIndex += 1;
									lastSignificantToken = "<";
									yield {
										type: "JSXPunctuator",
										value: punctuator
									};
									continue;
								}
								postfixIncDec = false;
								break;
							default: postfixIncDec = false;
						}
						lastIndex = nextLastIndex;
						lastSignificantToken = nextLastSignificantToken;
						yield {
							type: "Punctuator",
							value: punctuator
						};
						continue;
					}
					Identifier.lastIndex = lastIndex;
					if (match = Identifier.exec(input)) {
						lastIndex = Identifier.lastIndex;
						nextLastSignificantToken = match[0];
						switch (match[0]) {
							case "for":
							case "if":
							case "while":
							case "with": if (lastSignificantToken !== "." && lastSignificantToken !== "?.") nextLastSignificantToken = "?NonExpressionParenKeyword";
						}
						lastSignificantToken = nextLastSignificantToken;
						postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
						yield {
							type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
							value: match[0]
						};
						continue;
					}
					StringLiteral.lastIndex = lastIndex;
					if (match = StringLiteral.exec(input)) {
						lastIndex = StringLiteral.lastIndex;
						lastSignificantToken = match[0];
						postfixIncDec = true;
						yield {
							type: "StringLiteral",
							value: match[0],
							closed: match[2] !== void 0
						};
						continue;
					}
					NumericLiteral.lastIndex = lastIndex;
					if (match = NumericLiteral.exec(input)) {
						lastIndex = NumericLiteral.lastIndex;
						lastSignificantToken = match[0];
						postfixIncDec = true;
						yield {
							type: "NumericLiteral",
							value: match[0]
						};
						continue;
					}
					Template.lastIndex = lastIndex;
					if (match = Template.exec(input)) {
						lastIndex = Template.lastIndex;
						lastSignificantToken = match[0];
						if (match[1] === "${") {
							lastSignificantToken = "?InterpolationInTemplate";
							stack.push({
								tag: "InterpolationInTemplate",
								nesting: braces$2.length
							});
							postfixIncDec = false;
							yield {
								type: "TemplateHead",
								value: match[0]
							};
						} else {
							postfixIncDec = true;
							yield {
								type: "NoSubstitutionTemplate",
								value: match[0],
								closed: match[1] === "`"
							};
						}
						continue;
					}
					break;
				case "JSXTag":
				case "JSXTagEnd":
					JSXPunctuator.lastIndex = lastIndex;
					if (match = JSXPunctuator.exec(input)) {
						lastIndex = JSXPunctuator.lastIndex;
						nextLastSignificantToken = match[0];
						switch (match[0]) {
							case "<":
								stack.push({ tag: "JSXTag" });
								break;
							case ">":
								stack.pop();
								if (lastSignificantToken === "/" || mode.tag === "JSXTagEnd") {
									nextLastSignificantToken = "?JSX";
									postfixIncDec = true;
								} else stack.push({ tag: "JSXChildren" });
								break;
							case "{":
								stack.push({
									tag: "InterpolationInJSX",
									nesting: braces$2.length
								});
								nextLastSignificantToken = "?InterpolationInJSX";
								postfixIncDec = false;
								break;
							case "/": if (lastSignificantToken === "<") {
								stack.pop();
								if (stack[stack.length - 1].tag === "JSXChildren") stack.pop();
								stack.push({ tag: "JSXTagEnd" });
							}
						}
						lastSignificantToken = nextLastSignificantToken;
						yield {
							type: "JSXPunctuator",
							value: match[0]
						};
						continue;
					}
					JSXIdentifier.lastIndex = lastIndex;
					if (match = JSXIdentifier.exec(input)) {
						lastIndex = JSXIdentifier.lastIndex;
						lastSignificantToken = match[0];
						yield {
							type: "JSXIdentifier",
							value: match[0]
						};
						continue;
					}
					JSXString.lastIndex = lastIndex;
					if (match = JSXString.exec(input)) {
						lastIndex = JSXString.lastIndex;
						lastSignificantToken = match[0];
						yield {
							type: "JSXString",
							value: match[0],
							closed: match[2] !== void 0
						};
						continue;
					}
					break;
				case "JSXChildren":
					JSXText.lastIndex = lastIndex;
					if (match = JSXText.exec(input)) {
						lastIndex = JSXText.lastIndex;
						lastSignificantToken = match[0];
						yield {
							type: "JSXText",
							value: match[0]
						};
						continue;
					}
					switch (input[lastIndex]) {
						case "<":
							stack.push({ tag: "JSXTag" });
							lastIndex++;
							lastSignificantToken = "<";
							yield {
								type: "JSXPunctuator",
								value: "<"
							};
							continue;
						case "{":
							stack.push({
								tag: "InterpolationInJSX",
								nesting: braces$2.length
							});
							lastIndex++;
							lastSignificantToken = "?InterpolationInJSX";
							postfixIncDec = false;
							yield {
								type: "JSXPunctuator",
								value: "{"
							};
							continue;
					}
			}
			WhiteSpace.lastIndex = lastIndex;
			if (match = WhiteSpace.exec(input)) {
				lastIndex = WhiteSpace.lastIndex;
				yield {
					type: "WhiteSpace",
					value: match[0]
				};
				continue;
			}
			LineTerminatorSequence.lastIndex = lastIndex;
			if (match = LineTerminatorSequence.exec(input)) {
				lastIndex = LineTerminatorSequence.lastIndex;
				postfixIncDec = false;
				if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) lastSignificantToken = "?NoLineTerminatorHere";
				yield {
					type: "LineTerminatorSequence",
					value: match[0]
				};
				continue;
			}
			MultiLineComment.lastIndex = lastIndex;
			if (match = MultiLineComment.exec(input)) {
				lastIndex = MultiLineComment.lastIndex;
				if (Newline.test(match[0])) {
					postfixIncDec = false;
					if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) lastSignificantToken = "?NoLineTerminatorHere";
				}
				yield {
					type: "MultiLineComment",
					value: match[0],
					closed: match[1] !== void 0
				};
				continue;
			}
			SingleLineComment.lastIndex = lastIndex;
			if (match = SingleLineComment.exec(input)) {
				lastIndex = SingleLineComment.lastIndex;
				postfixIncDec = false;
				yield {
					type: "SingleLineComment",
					value: match[0]
				};
				continue;
			}
			firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));
			lastIndex += firstCodePoint.length;
			lastSignificantToken = firstCodePoint;
			postfixIncDec = false;
			yield {
				type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
				value: firstCodePoint
			};
		}
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/strip-literal@3.1.0/node_modules/strip-literal/dist/index.mjs
var import_js_tokens = /* @__PURE__ */ __toESM(require_js_tokens(), 1);
const FILL_COMMENT = " ";
function stripLiteralFromToken(token, fillChar, filter$1) {
	if (token.type === "SingleLineComment") return FILL_COMMENT.repeat(token.value.length);
	if (token.type === "MultiLineComment") return token.value.replace(/[^\n]/g, FILL_COMMENT);
	if (token.type === "StringLiteral") {
		if (!token.closed) return token.value;
		const body = token.value.slice(1, -1);
		if (filter$1(body)) return token.value[0] + fillChar.repeat(body.length) + token.value[token.value.length - 1];
	}
	if (token.type === "NoSubstitutionTemplate") {
		const body = token.value.slice(1, -1);
		if (filter$1(body)) return `\`${body.replace(/[^\n]/g, fillChar)}\``;
	}
	if (token.type === "RegularExpressionLiteral") {
		const body = token.value;
		if (filter$1(body)) return body.replace(/\/(.*)\/(\w?)$/g, (_, $1, $2) => `/${fillChar.repeat($1.length)}/${$2}`);
	}
	if (token.type === "TemplateHead") {
		const body = token.value.slice(1, -2);
		if (filter$1(body)) return `\`${body.replace(/[^\n]/g, fillChar)}\${`;
	}
	if (token.type === "TemplateTail") {
		const body = token.value.slice(0, -2);
		if (filter$1(body)) return `}${body.replace(/[^\n]/g, fillChar)}\``;
	}
	if (token.type === "TemplateMiddle") {
		const body = token.value.slice(1, -2);
		if (filter$1(body)) return `}${body.replace(/[^\n]/g, fillChar)}\${`;
	}
	return token.value;
}
function optionsWithDefaults(options$1) {
	return {
		fillChar: options$1?.fillChar ?? " ",
		filter: options$1?.filter ?? (() => true)
	};
}
function stripLiteral(code, options$1) {
	let result = "";
	const _options = optionsWithDefaults(options$1);
	for (const token of (0, import_js_tokens.default)(code, { jsx: false })) result += stripLiteralFromToken(token, _options.fillChar, _options.filter);
	return result;
}

//#endregion
//#region src/node/plugins/importMetaGlob.ts
var import_picocolors$28 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
function importGlobPlugin(config$2) {
	const importGlobMaps = /* @__PURE__ */ new Map();
	return {
		name: "vite:import-glob",
		buildStart() {
			importGlobMaps.clear();
		},
		transform: {
			filter: { code: "import.meta.glob" },
			async handler(code, id) {
				const result = await transformGlobImport(code, id, config$2.root, (im, _, options$1) => this.resolve(im, id, options$1).then((i$1) => i$1?.id || im), config$2.experimental.importGlobRestoreExtension, config$2.logger);
				if (result) {
					const allGlobs = result.matches.map((i$1) => i$1.globsResolved);
					if (!importGlobMaps.has(this.environment)) importGlobMaps.set(this.environment, /* @__PURE__ */ new Map());
					const globMatchers = allGlobs.map((globs) => {
						const affirmed = [];
						const negated = [];
						for (const glob$1 of globs) if (glob$1[0] === "!") negated.push(glob$1.slice(1));
						else affirmed.push(glob$1);
						const affirmedMatcher = picomatch(affirmed);
						const negatedMatcher = picomatch(negated);
						return (file) => {
							return (affirmed.length === 0 || affirmedMatcher(file)) && !(negated.length > 0 && negatedMatcher(file));
						};
					});
					importGlobMaps.get(this.environment).set(id, globMatchers);
					return transformStableResult(result.s, id, config$2);
				}
			}
		},
		hotUpdate({ type, file, modules: oldModules }) {
			if (type === "update") return;
			const importGlobMap = importGlobMaps.get(this.environment);
			if (!importGlobMap) return;
			const modules = [];
			for (const [id, globMatchers] of importGlobMap) if (globMatchers.some((matcher) => matcher(file))) {
				const mod = this.environment.moduleGraph.getModuleById(id);
				if (mod) modules.push(mod);
			}
			return modules.length > 0 ? [...oldModules, ...modules] : void 0;
		}
	};
}
const importGlobRE = /\bimport\.meta\.glob(?:<\w+>)?\s*\(/g;
const objectKeysRE = /\bObject\.keys\(\s*$/;
const objectValuesRE = /\bObject\.values\(\s*$/;
const knownOptions = {
	as: ["string"],
	eager: ["boolean"],
	import: ["string"],
	exhaustive: ["boolean"],
	query: ["object", "string"],
	base: ["string"]
};
const forceDefaultAs = ["raw", "url"];
function err$1(e$1, pos) {
	const error$1 = new Error(e$1);
	error$1.pos = pos;
	return error$1;
}
function parseGlobOptions(rawOpts, optsStartIndex, logger) {
	let opts = {};
	try {
		opts = evalValue(rawOpts);
	} catch {
		throw err$1("Vite is unable to parse the glob options as the value is not static", optsStartIndex);
	}
	if (opts == null) return {};
	for (const key in opts) {
		if (!(key in knownOptions)) throw err$1(`Unknown glob option "${key}"`, optsStartIndex);
		const allowedTypes = knownOptions[key];
		const valueType = typeof opts[key];
		if (!allowedTypes.includes(valueType)) throw err$1(`Expected glob option "${key}" to be of type ${allowedTypes.join(" or ")}, but got ${valueType}`, optsStartIndex);
	}
	if (opts.base) {
		if (opts.base[0] === "!") throw err$1("Option \"base\" cannot start with \"!\"", optsStartIndex);
		else if (opts.base[0] !== "/" && !opts.base.startsWith("./") && !opts.base.startsWith("../")) throw err$1(`Option "base" must start with '/', './' or '../', but got "${opts.base}"`, optsStartIndex);
	}
	if (typeof opts.query === "object") {
		for (const key in opts.query) {
			const value$1 = opts.query[key];
			if (![
				"string",
				"number",
				"boolean"
			].includes(typeof value$1)) throw err$1(`Expected glob option "query.${key}" to be of type string, number, or boolean, but got ${typeof value$1}`, optsStartIndex);
		}
		opts.query = stringifyQuery(opts.query);
	}
	if (opts.as && logger) {
		const importSuggestion = forceDefaultAs.includes(opts.as) ? `, import: 'default'` : "";
		logger.warn(import_picocolors$28.default.yellow(`The glob option "as" has been deprecated in favour of "query". Please update \`as: '${opts.as}'\` to \`query: '?${opts.as}'${importSuggestion}\`.`));
	}
	if (opts.as && forceDefaultAs.includes(opts.as)) {
		if (opts.import && opts.import !== "default" && opts.import !== "*") throw err$1(`Option "import" can only be "default" or "*" when "as" is "${opts.as}", but got "${opts.import}"`, optsStartIndex);
		opts.import = opts.import || "default";
	}
	if (opts.as && opts.query) throw err$1("Options \"as\" and \"query\" cannot be used together", optsStartIndex);
	if (opts.as) opts.query = opts.as;
	if (opts.query && opts.query[0] !== "?") opts.query = `?${opts.query}`;
	return opts;
}
async function parseImportGlob(code, importer, root, resolveId, logger) {
	let cleanCode;
	try {
		cleanCode = stripLiteral(code);
	} catch {
		return [];
	}
	const tasks = Array.from(cleanCode.matchAll(importGlobRE)).map(async (match, index) => {
		const start = match.index;
		const err$2 = (msg) => {
			const e$1 = /* @__PURE__ */ new Error(`Invalid glob import syntax: ${msg}`);
			e$1.pos = start;
			return e$1;
		};
		const end = findCorrespondingCloseParenthesisPosition(cleanCode, start + match[0].length) + 1;
		if (end <= 0) throw err$2("Close parenthesis not found");
		const rootAst = (await parseAstAsync(code.slice(start, end))).body[0];
		if (rootAst.type !== "ExpressionStatement") throw err$2(`Expect CallExpression, got ${rootAst.type}`);
		const ast = rootAst.expression;
		if (ast.type !== "CallExpression") throw err$2(`Expect CallExpression, got ${ast.type}`);
		if (ast.arguments.length < 1 || ast.arguments.length > 2) throw err$2(`Expected 1-2 arguments, but got ${ast.arguments.length}`);
		const arg1 = ast.arguments[0];
		const arg2 = ast.arguments[1];
		const globs = [];
		const validateLiteral = (element) => {
			if (!element) return;
			if (element.type === "Literal") {
				if (typeof element.value !== "string") throw err$2(`Expected glob to be a string, but got "${typeof element.value}"`);
				globs.push(element.value);
			} else if (element.type === "TemplateLiteral") {
				if (element.expressions.length !== 0) throw err$2(`Expected glob to be a string, but got dynamic template literal`);
				globs.push(element.quasis[0].value.raw);
			} else throw err$2("Could only use literals");
		};
		if (arg1.type === "ArrayExpression") for (const element of arg1.elements) validateLiteral(element);
		else validateLiteral(arg1);
		let options$1 = {};
		if (arg2) {
			if (arg2.type !== "ObjectExpression") throw err$2(`Expected the second argument to be an object literal, but got "${arg2.type}"`);
			options$1 = parseGlobOptions(code.slice(start + arg2.start, start + arg2.end), start + arg2.start, logger);
		}
		const globsResolved = await Promise.all(globs.map((glob$1) => toAbsoluteGlob(glob$1, root, importer, resolveId, options$1.base)));
		const isRelative$1 = globs.every((i$1) => ".!".includes(i$1[0]));
		const sliceCode = cleanCode.slice(0, start);
		const onlyKeys = objectKeysRE.test(sliceCode);
		let onlyValues = false;
		if (!onlyKeys) onlyValues = objectValuesRE.test(sliceCode);
		return {
			index,
			globs,
			globsResolved,
			isRelative: isRelative$1,
			options: options$1,
			start,
			end,
			onlyKeys,
			onlyValues
		};
	});
	return (await Promise.all(tasks)).filter(Boolean);
}
function findCorrespondingCloseParenthesisPosition(cleanCode, openPos) {
	const closePos = cleanCode.indexOf(")", openPos);
	if (closePos < 0) return -1;
	if (!cleanCode.slice(openPos, closePos).includes("(")) return closePos;
	let remainingParenthesisCount = 0;
	const cleanCodeLen = cleanCode.length;
	for (let pos = openPos; pos < cleanCodeLen; pos++) switch (cleanCode[pos]) {
		case "(":
			remainingParenthesisCount++;
			break;
		case ")":
			remainingParenthesisCount--;
			if (remainingParenthesisCount <= 0) return pos;
	}
	return -1;
}
const importPrefix = "__vite_glob_";
const { basename: basename$2, dirname: dirname$2, relative: relative$2 } = posix;
/**
* @param optimizeExport for dynamicImportVar plugin don't need to optimize export.
*/
async function transformGlobImport(code, id, root, resolveId, restoreQueryExtension = false, logger) {
	id = slash(id);
	root = slash(root);
	const isVirtual = isVirtualModule(id);
	const dir = isVirtual ? void 0 : dirname$2(id);
	const matches$2 = await parseImportGlob(code, isVirtual ? void 0 : id, root, resolveId, logger);
	const matchedFiles = /* @__PURE__ */ new Set();
	if (!matches$2.length) return null;
	const s$2 = new MagicString(code);
	const staticImports = (await Promise.all(matches$2.map(async ({ globsResolved, isRelative: isRelative$1, options: options$1, index, start, end, onlyKeys, onlyValues }) => {
		const files = (await glob(globsResolved, {
			absolute: true,
			cwd: getCommonBase(globsResolved) ?? root,
			dot: !!options$1.exhaustive,
			expandDirectories: false,
			ignore: options$1.exhaustive ? [] : ["**/node_modules/**"]
		})).filter((file) => file !== id).sort();
		const objectProps = [];
		const staticImports$1 = [];
		const resolvePaths = (file) => {
			if (!dir) {
				if (!options$1.base && isRelative$1) throw new Error("In virtual modules, all globs must start with '/'");
				const importPath$1 = `/${relative$2(root, file)}`;
				let filePath$1 = options$1.base ? `${relative$2(posix.join(root, options$1.base), file)}` : importPath$1;
				if (options$1.base && !filePath$1.startsWith("./") && !filePath$1.startsWith("../")) filePath$1 = `./${filePath$1}`;
				return {
					filePath: filePath$1,
					importPath: importPath$1
				};
			}
			let importPath = relative$2(dir, file);
			if (!importPath.startsWith("./") && !importPath.startsWith("../")) importPath = `./${importPath}`;
			let filePath;
			if (options$1.base) {
				filePath = relative$2(posix.join(options$1.base[0] === "/" ? root : dir, options$1.base), file);
				if (!filePath.startsWith("./") && !filePath.startsWith("../")) filePath = `./${filePath}`;
				if (options$1.base[0] === "/") importPath = `/${relative$2(root, file)}`;
			} else if (isRelative$1) filePath = importPath;
			else {
				filePath = relative$2(root, file);
				if (!filePath.startsWith("./") && !filePath.startsWith("../")) filePath = `/${filePath}`;
			}
			return {
				filePath,
				importPath
			};
		};
		files.forEach((file, i$1) => {
			const paths = resolvePaths(file);
			const filePath = paths.filePath;
			let importPath = paths.importPath;
			let importQuery = options$1.query ?? "";
			if (onlyKeys) {
				objectProps.push(`${JSON.stringify(filePath)}: 0`);
				return;
			}
			if (importQuery && importQuery !== "?raw") {
				const fileExtension = basename$2(file).split(".").slice(-1)[0];
				if (fileExtension && restoreQueryExtension) importQuery = `${importQuery}&lang.${fileExtension}`;
			}
			importPath = `${importPath}${importQuery}`;
			const importKey = options$1.import && options$1.import !== "*" ? options$1.import : void 0;
			if (options$1.eager) {
				const variableName = `${importPrefix}${index}_${i$1}`;
				const expression = importKey ? `{ ${importKey} as ${variableName} }` : `* as ${variableName}`;
				staticImports$1.push(`import ${expression} from ${JSON.stringify(importPath)}`);
				objectProps.push(onlyValues ? `${variableName}` : `${JSON.stringify(filePath)}: ${variableName}`);
			} else {
				let importStatement = `import(${JSON.stringify(importPath)})`;
				if (importKey) importStatement += `.then(m => m[${JSON.stringify(importKey)}])`;
				objectProps.push(onlyValues ? `() => ${importStatement}` : `${JSON.stringify(filePath)}: () => ${importStatement}`);
			}
		});
		files.forEach((i$1) => matchedFiles.add(i$1));
		const originalLineBreakCount = code.slice(start, end).match(/\n/g)?.length ?? 0;
		const lineBreaks = originalLineBreakCount > 0 ? "\n".repeat(originalLineBreakCount) : "";
		let replacement = "";
		if (onlyKeys) replacement = `{${objectProps.join(",")}${lineBreaks}}`;
		else if (onlyValues) replacement = `[${objectProps.join(",")}${lineBreaks}]`;
		else replacement = `/* #__PURE__ */ Object.assign({${objectProps.join(",")}${lineBreaks}})`;
		s$2.overwrite(start, end, replacement);
		return staticImports$1;
	}))).flat();
	if (staticImports.length) s$2.prepend(`${staticImports.join(";")};`);
	return {
		s: s$2,
		matches: matches$2,
		files: matchedFiles
	};
}
function globSafePath(path$13) {
	return escapePath(normalizePath(path$13));
}
function lastNthChar(str, n$2) {
	return str.charAt(str.length - 1 - n$2);
}
function globSafeResolvedPath(resolved, glob$1) {
	let numEqual = 0;
	const maxEqual = Math.min(resolved.length, glob$1.length);
	while (numEqual < maxEqual && lastNthChar(resolved, numEqual) === lastNthChar(glob$1, numEqual)) numEqual += 1;
	const staticPartEnd = resolved.length - numEqual;
	const staticPart = resolved.slice(0, staticPartEnd);
	const dynamicPart = resolved.slice(staticPartEnd);
	return globSafePath(staticPart) + dynamicPart;
}
async function toAbsoluteGlob(glob$1, root, importer, resolveId, base) {
	let pre = "";
	if (glob$1[0] === "!") {
		pre = "!";
		glob$1 = glob$1.slice(1);
	}
	root = globSafePath(root);
	let dir;
	if (base) if (base[0] === "/") dir = posix.join(root, base);
	else dir = posix.resolve(importer ? globSafePath(dirname$2(importer)) : root, base);
	else dir = importer ? globSafePath(dirname$2(importer)) : root;
	if (glob$1[0] === "/") return pre + posix.join(root, glob$1.slice(1));
	if (glob$1.startsWith("./")) return pre + posix.join(dir, glob$1.slice(2));
	if (glob$1.startsWith("../")) return pre + posix.join(dir, glob$1);
	if (glob$1.startsWith("**")) return pre + glob$1;
	const isSubImportsPattern = glob$1[0] === "#" && glob$1.includes("*");
	const resolved = normalizePath(await resolveId(glob$1, importer, { custom: { "vite:import-glob": { isSubImportsPattern } } }) || glob$1);
	if (isAbsolute(resolved)) return pre + globSafeResolvedPath(resolved, glob$1);
	throw new Error(`Invalid glob: "${glob$1}" (resolved: "${resolved}"). It must start with '/' or './'`);
}
function getCommonBase(globsResolved) {
	const bases = globsResolved.filter((g) => g[0] !== "!").map((glob$1) => {
		let { base } = picomatch.scan(glob$1);
		if (posix.basename(base).includes(".")) base = posix.dirname(base);
		return base;
	});
	if (!bases.length) return null;
	let commonAncestor = "";
	const dirS = bases[0].split("/");
	for (let i$1 = 0; i$1 < dirS.length; i$1++) {
		const candidate = dirS.slice(0, i$1 + 1).join("/");
		if (bases.every((base) => base.startsWith(candidate))) commonAncestor = candidate;
		else break;
	}
	if (!commonAncestor) commonAncestor = "/";
	return commonAncestor;
}
function isVirtualModule(id) {
	return id.startsWith("virtual:") || id[0] === "\0" || !id.includes("/");
}

//#endregion
//#region src/node/optimizer/scan.ts
var import_picocolors$27 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
var ScanEnvironment = class extends BaseEnvironment {
	mode = "scan";
	get pluginContainer() {
		if (!this._pluginContainer) throw new Error(`${this.name} environment.pluginContainer called before initialized`);
		return this._pluginContainer;
	}
	/**
	* @internal
	*/
	_pluginContainer;
	async init() {
		if (this._initiated) return;
		this._initiated = true;
		this._pluginContainer = await createEnvironmentPluginContainer(this, this.plugins, void 0, false);
	}
};
function devToScanEnvironment(environment) {
	return {
		mode: "scan",
		get name() {
			return environment.name;
		},
		getTopLevelConfig() {
			return environment.getTopLevelConfig();
		},
		get config() {
			return environment.config;
		},
		get logger() {
			return environment.logger;
		},
		get pluginContainer() {
			return environment.pluginContainer;
		},
		get plugins() {
			return environment.plugins;
		}
	};
}
const debug$15 = createDebugger("vite:deps");
const htmlTypesRE = /\.(html|vue|svelte|astro|imba)$/;
const importsRE = /(?<!\/\/.*)(?<=^|;|\*\/)\s*import(?!\s+type)(?:[\w*{}\n\r\t, ]+from)?\s*("[^"]+"|'[^']+')\s*(?=$|;|\/\/|\/\*)/gm;
function scanImports(environment) {
	const start = performance$1.now();
	const { config: config$2 } = environment;
	const scanContext = { cancelled: false };
	let esbuildContext;
	async function cancel() {
		scanContext.cancelled = true;
		return esbuildContext?.then((context) => context?.cancel());
	}
	async function scan() {
		const entries = await computeEntries(environment);
		if (!entries.length) {
			if (!config$2.optimizeDeps.entries && !config$2.optimizeDeps.include) environment.logger.warn(import_picocolors$27.default.yellow("(!) Could not auto-determine entry point from rollupOptions or html files and there are no explicit optimizeDeps.include patterns. Skipping dependency pre-bundling."));
			return;
		}
		if (scanContext.cancelled) return;
		debug$15?.(`Crawling dependencies using entries: ${entries.map((entry) => `\n  ${import_picocolors$27.default.dim(entry)}`).join("")}`);
		const deps = {};
		const missing = {};
		let context;
		try {
			esbuildContext = prepareEsbuildScanner(environment, entries, deps, missing);
			context = await esbuildContext;
			if (scanContext.cancelled) return;
			try {
				await context.rebuild();
				return {
					deps: orderedDependencies(deps),
					missing
				};
			} catch (e$1) {
				if (e$1.errors && e$1.message.includes("The build was canceled")) return;
				const prependMessage = import_picocolors$27.default.red(`\
  Failed to scan for dependencies from entries:
  ${entries.join("\n")}

  `);
				if (e$1.errors) e$1.message = prependMessage + (await formatMessages(e$1.errors, {
					kind: "error",
					color: true
				})).join("\n");
				else e$1.message = prependMessage + e$1.message;
				throw e$1;
			} finally {
				if (debug$15) debug$15(`Scan completed in ${(performance$1.now() - start).toFixed(2)}ms: ${Object.keys(orderedDependencies(deps)).sort().map((id) => `\n  ${import_picocolors$27.default.cyan(id)} -> ${import_picocolors$27.default.dim(deps[id])}`).join("") || import_picocolors$27.default.dim("no dependencies found")}`);
			}
		} finally {
			context?.dispose().catch((e$1) => {
				environment.logger.error("Failed to dispose esbuild context", { error: e$1 });
			});
		}
	}
	return {
		cancel,
		result: scan().then((res) => res ?? {
			deps: {},
			missing: {}
		})
	};
}
async function computeEntries(environment) {
	let entries = [];
	const explicitEntryPatterns = environment.config.optimizeDeps.entries;
	const buildInput = environment.config.build.rollupOptions.input;
	if (explicitEntryPatterns) entries = await globEntries(explicitEntryPatterns, environment);
	else if (buildInput) {
		const resolvePath = async (p) => {
			const id = (await environment.pluginContainer.resolveId(p, path.join(process.cwd(), "*"), {
				isEntry: true,
				scan: true
			}))?.id;
			if (id === void 0) throw new Error(`failed to resolve rollupOptions.input value: ${JSON.stringify(p)}.`);
			return id;
		};
		if (typeof buildInput === "string") entries = [await resolvePath(buildInput)];
		else if (Array.isArray(buildInput)) entries = await Promise.all(buildInput.map(resolvePath));
		else if (isObject(buildInput)) entries = await Promise.all(Object.values(buildInput).map(resolvePath));
		else throw new Error("invalid rollupOptions.input value.");
	} else entries = await globEntries("**/*.html", environment);
	entries = entries.filter((entry) => isScannable(entry, environment.config.optimizeDeps.extensions) && fs.existsSync(entry));
	return entries;
}
async function prepareEsbuildScanner(environment, entries, deps, missing) {
	const plugin = esbuildScanPlugin(environment, deps, missing, entries);
	const { plugins: plugins$1 = [],...esbuildOptions } = environment.config.optimizeDeps.esbuildOptions ?? {};
	let tsconfigRaw = esbuildOptions.tsconfigRaw;
	if (!tsconfigRaw && !esbuildOptions.tsconfig) {
		const { tsconfig } = await loadTsconfigJsonForFile(path.join(environment.config.root, "_dummy.js"));
		if (tsconfig.compilerOptions?.experimentalDecorators || tsconfig.compilerOptions?.jsx || tsconfig.compilerOptions?.jsxFactory || tsconfig.compilerOptions?.jsxFragmentFactory || tsconfig.compilerOptions?.jsxImportSource) tsconfigRaw = { compilerOptions: {
			experimentalDecorators: tsconfig.compilerOptions?.experimentalDecorators,
			jsx: esbuildOptions.jsx ? void 0 : tsconfig.compilerOptions?.jsx,
			jsxFactory: esbuildOptions.jsxFactory ? void 0 : tsconfig.compilerOptions?.jsxFactory,
			jsxFragmentFactory: esbuildOptions.jsxFragment ? void 0 : tsconfig.compilerOptions?.jsxFragmentFactory,
			jsxImportSource: esbuildOptions.jsxImportSource ? void 0 : tsconfig.compilerOptions?.jsxImportSource
		} };
	}
	return await esbuild.context({
		absWorkingDir: process.cwd(),
		write: false,
		stdin: {
			contents: entries.map((e$1) => `import ${JSON.stringify(e$1)}`).join("\n"),
			loader: "js"
		},
		bundle: true,
		format: "esm",
		logLevel: "silent",
		plugins: [...plugins$1, plugin],
		jsxDev: !environment.config.isProduction,
		...esbuildOptions,
		tsconfigRaw
	});
}
function orderedDependencies(deps) {
	const depsList = Object.entries(deps);
	depsList.sort((a, b) => a[0].localeCompare(b[0]));
	return Object.fromEntries(depsList);
}
async function globEntries(patterns, environment) {
	const nodeModulesPatterns = [];
	const regularPatterns = [];
	for (const pattern of arraify(patterns)) if (pattern.includes("node_modules")) nodeModulesPatterns.push(pattern);
	else regularPatterns.push(pattern);
	const sharedOptions = {
		absolute: true,
		cwd: environment.config.root,
		ignore: [`**/${environment.config.build.outDir}/**`, ...environment.config.optimizeDeps.entries ? [] : [`**/__tests__/**`, `**/coverage/**`]]
	};
	return (await Promise.all([glob(nodeModulesPatterns, sharedOptions), glob(regularPatterns, {
		...sharedOptions,
		ignore: [...sharedOptions.ignore, "**/node_modules/**"]
	})])).flat();
}
const scriptRE = /(<script(?:\s+[a-z_:][-\w:]*(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^"'<>=\s]+))?)*\s*>)(.*?)<\/script>/gis;
const commentRE$1 = /<!--.*?-->/gs;
const srcRE = /\bsrc\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
const typeRE = /\btype\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
const langRE = /\blang\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
const svelteScriptModuleRE = /\bcontext\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
const svelteModuleRE = /\smodule\b/i;
function esbuildScanPlugin(environment, depImports, missing, entries) {
	const seen$1 = /* @__PURE__ */ new Map();
	async function resolveId(id, importer) {
		return environment.pluginContainer.resolveId(id, importer && normalizePath(importer), { scan: true });
	}
	const resolve$4 = async (id, importer) => {
		const key = id + (importer && path.dirname(importer));
		if (seen$1.has(key)) return seen$1.get(key);
		const res = (await resolveId(id, importer))?.id;
		seen$1.set(key, res);
		return res;
	};
	const optimizeDepsOptions = environment.config.optimizeDeps;
	const include = optimizeDepsOptions.include;
	const exclude = [
		...optimizeDepsOptions.exclude ?? [],
		"@vite/client",
		"@vite/env"
	];
	const isUnlessEntry = (path$13) => !entries.includes(path$13);
	const externalUnlessEntry = ({ path: path$13 }) => ({
		path: path$13,
		external: isUnlessEntry(path$13)
	});
	const doTransformGlobImport = async (contents, id, loader$1) => {
		let transpiledContents;
		if (loader$1 !== "js") transpiledContents = (await transform(contents, { loader: loader$1 })).code;
		else transpiledContents = contents;
		return (await transformGlobImport(transpiledContents, id, environment.config.root, resolve$4))?.s.toString() || transpiledContents;
	};
	return {
		name: "vite:dep-scan",
		setup(build$3) {
			const scripts = {};
			build$3.onResolve({ filter: externalRE }, ({ path: path$13 }) => ({
				path: path$13,
				external: true
			}));
			build$3.onResolve({ filter: dataUrlRE }, ({ path: path$13 }) => ({
				path: path$13,
				external: true
			}));
			build$3.onResolve({ filter: virtualModuleRE }, ({ path: path$13 }) => {
				return {
					path: path$13.replace(virtualModulePrefix, ""),
					namespace: "script"
				};
			});
			build$3.onLoad({
				filter: /.*/,
				namespace: "script"
			}, ({ path: path$13 }) => {
				return scripts[path$13];
			});
			build$3.onResolve({ filter: htmlTypesRE }, async ({ path: path$13, importer }) => {
				const resolved = await resolve$4(path$13, importer);
				if (!resolved) return;
				if (isInNodeModules(resolved) && isOptimizable(resolved, optimizeDepsOptions)) return;
				return {
					path: resolved,
					namespace: "html"
				};
			});
			const htmlTypeOnLoadCallback = async ({ path: p }) => {
				let raw = await fsp.readFile(p, "utf-8");
				raw = raw.replace(commentRE$1, "<!---->");
				const isHtml = p.endsWith(".html");
				let js = "";
				let scriptId = 0;
				const matches$2 = raw.matchAll(scriptRE);
				for (const [, openTag, content] of matches$2) {
					const typeMatch = typeRE.exec(openTag);
					const type = typeMatch && (typeMatch[1] || typeMatch[2] || typeMatch[3]);
					const langMatch = langRE.exec(openTag);
					const lang = langMatch && (langMatch[1] || langMatch[2] || langMatch[3]);
					if (isHtml && type !== "module") continue;
					if (type && !(type.includes("javascript") || type.includes("ecmascript") || type === "module")) continue;
					let loader$1 = "js";
					if (lang === "ts" || lang === "tsx" || lang === "jsx") loader$1 = lang;
					else if (p.endsWith(".astro")) loader$1 = "ts";
					const srcMatch = srcRE.exec(openTag);
					if (srcMatch) {
						const src = srcMatch[1] || srcMatch[2] || srcMatch[3];
						js += `import ${JSON.stringify(src)}\n`;
					} else if (content.trim()) {
						const contents = content + (loader$1.startsWith("ts") ? extractImportPaths(content) : "");
						const key = `${p}?id=${scriptId++}`;
						if (contents.includes("import.meta.glob")) scripts[key] = {
							loader: "js",
							contents: await doTransformGlobImport(contents, p, loader$1),
							resolveDir: normalizePath(path.dirname(p)),
							pluginData: { htmlType: { loader: loader$1 } }
						};
						else scripts[key] = {
							loader: loader$1,
							contents,
							resolveDir: normalizePath(path.dirname(p)),
							pluginData: { htmlType: { loader: loader$1 } }
						};
						const virtualModulePath = JSON.stringify(virtualModulePrefix + key);
						let addedImport = false;
						if (p.endsWith(".svelte")) {
							let isModule = svelteModuleRE.test(openTag);
							if (!isModule) {
								const contextMatch = svelteScriptModuleRE.exec(openTag);
								isModule = (contextMatch && (contextMatch[1] || contextMatch[2] || contextMatch[3])) === "module";
							}
							if (!isModule) {
								addedImport = true;
								js += `import ${virtualModulePath}\n`;
							}
						}
						if (!addedImport) js += `export * from ${virtualModulePath}\n`;
					}
				}
				if (!p.endsWith(".vue") || !js.includes("export default")) js += "\nexport default {}";
				return {
					loader: "js",
					contents: js
				};
			};
			build$3.onLoad({
				filter: htmlTypesRE,
				namespace: "html"
			}, htmlTypeOnLoadCallback);
			build$3.onLoad({
				filter: htmlTypesRE,
				namespace: "file"
			}, htmlTypeOnLoadCallback);
			build$3.onResolve({ filter: /^[\w@][^:]/ }, async ({ path: id, importer }) => {
				if (moduleListContains(exclude, id)) return externalUnlessEntry({ path: id });
				if (depImports[id]) return externalUnlessEntry({ path: id });
				const resolved = await resolve$4(id, importer);
				if (resolved) {
					if (shouldExternalizeDep(resolved, id)) return externalUnlessEntry({ path: id });
					if (isInNodeModules(resolved) || include?.includes(id)) {
						if (isOptimizable(resolved, optimizeDepsOptions)) depImports[id] = resolved;
						return externalUnlessEntry({ path: id });
					} else if (isScannable(resolved, optimizeDepsOptions.extensions)) {
						const namespace = htmlTypesRE.test(resolved) ? "html" : void 0;
						return {
							path: path.resolve(resolved),
							namespace
						};
					} else return externalUnlessEntry({ path: id });
				} else missing[id] = normalizePath(importer);
			});
			const setupExternalize = (filter$1, doExternalize) => {
				build$3.onResolve({ filter: filter$1 }, ({ path: path$13 }) => {
					return {
						path: path$13,
						external: doExternalize(path$13)
					};
				});
			};
			setupExternalize(CSS_LANGS_RE, isUnlessEntry);
			setupExternalize(/\.(json|json5|wasm)$/, isUnlessEntry);
			setupExternalize(/* @__PURE__ */ new RegExp(`\\.(${KNOWN_ASSET_TYPES.join("|")})$`), isUnlessEntry);
			setupExternalize(SPECIAL_QUERY_RE, () => true);
			build$3.onResolve({ filter: /.*/ }, async ({ path: id, importer }) => {
				const resolved = await resolve$4(id, importer);
				if (resolved) {
					if (shouldExternalizeDep(resolved, id) || !isScannable(resolved, optimizeDepsOptions.extensions)) return externalUnlessEntry({ path: id });
					const namespace = htmlTypesRE.test(resolved) ? "html" : void 0;
					return {
						path: path.resolve(cleanUrl(resolved)),
						namespace
					};
				} else return externalUnlessEntry({ path: id });
			});
			build$3.onLoad({ filter: JS_TYPES_RE }, async ({ path: id }) => {
				let ext = path.extname(id).slice(1);
				if (ext === "mjs") ext = "js";
				const esbuildConfig = environment.config.esbuild;
				let contents = await fsp.readFile(id, "utf-8");
				if (ext.endsWith("x") && esbuildConfig && esbuildConfig.jsxInject) contents = esbuildConfig.jsxInject + `\n` + contents;
				const loader$1 = optimizeDepsOptions.esbuildOptions?.loader?.[`.${ext}`] ?? ext;
				if (contents.includes("import.meta.glob")) return {
					loader: "js",
					contents: await doTransformGlobImport(contents, id, loader$1)
				};
				return {
					loader: loader$1,
					contents
				};
			});
			build$3.onLoad({
				filter: /.*/,
				namespace: "file"
			}, () => {
				return {
					loader: "js",
					contents: "export default {}"
				};
			});
		}
	};
}
/**
* when using TS + (Vue + `<script setup>`) or Svelte, imports may seem
* unused to esbuild and dropped in the build output, which prevents
* esbuild from crawling further.
* the solution is to add `import 'x'` for every source to force
* esbuild to keep crawling due to potential side effects.
*/
function extractImportPaths(code) {
	code = code.replace(multilineCommentsRE, "/* */").replace(singlelineCommentsRE, "");
	let js = "";
	let m$2;
	importsRE.lastIndex = 0;
	while ((m$2 = importsRE.exec(code)) != null) js += `\nimport ${m$2[1]}`;
	return js;
}
function shouldExternalizeDep(resolvedId, rawId) {
	if (!path.isAbsolute(resolvedId)) return true;
	if (resolvedId === rawId || resolvedId.includes("\0")) return true;
	return false;
}
function isScannable(id, extensions$1) {
	return JS_TYPES_RE.test(id) || htmlTypesRE.test(id) || extensions$1?.includes(path.extname(id)) || false;
}

//#endregion
//#region src/node/optimizer/resolve.ts
function createOptimizeDepsIncludeResolver(environment) {
	const topLevelConfig = environment.getTopLevelConfig();
	const resolve$4 = createBackCompatIdResolver(topLevelConfig, {
		asSrc: false,
		scan: true,
		packageCache: /* @__PURE__ */ new Map()
	});
	return async (id) => {
		const lastArrowIndex = id.lastIndexOf(">");
		if (lastArrowIndex === -1) return await resolve$4(environment, id, void 0);
		const nestedRoot = id.substring(0, lastArrowIndex).trim();
		const nestedPath = id.substring(lastArrowIndex + 1).trim();
		const basedir = nestedResolveBasedir(nestedRoot, topLevelConfig.root, topLevelConfig.resolve.preserveSymlinks);
		return await resolve$4(environment, nestedPath, path.resolve(basedir, "package.json"));
	};
}
/**
* Expand the glob syntax in `optimizeDeps.include` to proper import paths
*/
function expandGlobIds(id, config$2) {
	const pkgName = getNpmPackageName(id);
	if (!pkgName) return [];
	const pkgData = resolvePackageData(pkgName, config$2.root, config$2.resolve.preserveSymlinks, config$2.packageCache);
	if (!pkgData) return [];
	const pattern = "." + id.slice(pkgName.length);
	const exports$1 = pkgData.data.exports;
	if (exports$1) {
		if (typeof exports$1 === "string" || Array.isArray(exports$1)) return [pkgName];
		const possibleExportPaths = [];
		for (const key in exports$1) if (key[0] === ".") if (key.includes("*")) {
			const exportsValue = getFirstExportStringValue(exports$1[key]);
			if (!exportsValue) continue;
			const exportValuePattern = exportsValue.replace(/\*/g, "**/*");
			const exportsValueGlobRe = new RegExp(exportsValue.split("*").map(escapeRegex).join("(.*)"));
			possibleExportPaths.push(...globSync(exportValuePattern, {
				cwd: pkgData.dir,
				expandDirectories: false,
				ignore: ["node_modules"]
			}).map((filePath) => {
				if (exportsValue.startsWith("./")) filePath = "./" + filePath;
				const matched$1 = exportsValueGlobRe.exec(slash(filePath));
				if (matched$1) {
					let allGlobSame = matched$1.length === 2;
					if (!allGlobSame) {
						allGlobSame = true;
						for (let i$1 = 2; i$1 < matched$1.length; i$1++) if (matched$1[i$1] !== matched$1[i$1 - 1]) {
							allGlobSame = false;
							break;
						}
					}
					if (allGlobSame) return key.replace("*", matched$1[1]).slice(2);
				}
				return "";
			}).filter(Boolean));
		} else possibleExportPaths.push(key.slice(2));
		const isMatch$1 = picomatch(pattern);
		const matched = possibleExportPaths.filter((p) => isMatch$1(p)).map((match) => path.posix.join(pkgName, match));
		matched.unshift(pkgName);
		return matched;
	} else {
		const matched = globSync(pattern, {
			cwd: pkgData.dir,
			expandDirectories: false,
			ignore: ["node_modules"]
		}).map((match) => path.posix.join(pkgName, slash(match)));
		matched.unshift(pkgName);
		return matched;
	}
}
function getFirstExportStringValue(obj) {
	if (typeof obj === "string") return obj;
	else if (Array.isArray(obj)) return obj[0];
	else for (const key in obj) return getFirstExportStringValue(obj[key]);
}
/**
* Continuously resolve the basedir of packages separated by '>'
*/
function nestedResolveBasedir(id, basedir, preserveSymlinks = false) {
	const pkgs = id.split(">").map((pkg) => pkg.trim());
	for (const pkg of pkgs) basedir = resolvePackageData(pkg, basedir, preserveSymlinks)?.dir || basedir;
	return basedir;
}

//#endregion
//#region src/node/optimizer/index.ts
var import_picocolors$26 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const debug$14 = createDebugger("vite:deps");
const jsExtensionRE = /\.js$/i;
const jsMapExtensionRE = /\.js\.map$/i;
function isDepOptimizationDisabled(optimizeDeps$1) {
	return optimizeDeps$1.disabled === true || optimizeDeps$1.disabled === "dev" || !!optimizeDeps$1.noDiscovery && !optimizeDeps$1.include?.length;
}
/**
* Scan and optimize dependencies within a project.
* Used by Vite CLI when running `vite optimize`.
*
* @deprecated the optimization process runs automatically and does not need to be called
*/
async function optimizeDeps(config$2, force = config$2.optimizeDeps.force, asCommand = false) {
	const log$4 = asCommand ? config$2.logger.info : debug$14;
	config$2.logger.warn(import_picocolors$26.default.yellow("manually calling optimizeDeps is deprecated. This is done automatically and does not need to be called manually."));
	const environment = new ScanEnvironment("client", config$2);
	await environment.init();
	const cachedMetadata = await loadCachedDepOptimizationMetadata(environment, force, asCommand);
	if (cachedMetadata) return cachedMetadata;
	const deps = await discoverProjectDependencies(environment).result;
	await addManuallyIncludedOptimizeDeps(environment, deps);
	const depsString = depsLogString(Object.keys(deps));
	log$4?.(import_picocolors$26.default.green(`Optimizing dependencies:\n  ${depsString}`));
	const result = await runOptimizeDeps(environment, toDiscoveredDependencies(environment, deps)).result;
	await result.commit();
	return result.metadata;
}
async function optimizeExplicitEnvironmentDeps(environment) {
	const cachedMetadata = await loadCachedDepOptimizationMetadata(environment, environment.config.optimizeDeps.force ?? false, false);
	if (cachedMetadata) return cachedMetadata;
	const deps = {};
	await addManuallyIncludedOptimizeDeps(environment, deps);
	const result = await runOptimizeDeps(environment, toDiscoveredDependencies(environment, deps)).result;
	await result.commit();
	return result.metadata;
}
function initDepsOptimizerMetadata(environment, timestamp) {
	const { lockfileHash, configHash, hash: hash$1 } = getDepHash(environment);
	return {
		hash: hash$1,
		lockfileHash,
		configHash,
		browserHash: getOptimizedBrowserHash(hash$1, {}, timestamp),
		optimized: {},
		chunks: {},
		discovered: {},
		depInfoList: []
	};
}
function addOptimizedDepInfo(metadata, type, depInfo) {
	metadata[type][depInfo.id] = depInfo;
	metadata.depInfoList.push(depInfo);
	return depInfo;
}
let firstLoadCachedDepOptimizationMetadata = true;
/**
* Creates the initial dep optimization metadata, loading it from the deps cache
* if it exists and pre-bundling isn't forced
*/
async function loadCachedDepOptimizationMetadata(environment, force = environment.config.optimizeDeps.force ?? false, asCommand = false) {
	const log$4 = asCommand ? environment.logger.info : debug$14;
	if (firstLoadCachedDepOptimizationMetadata) {
		firstLoadCachedDepOptimizationMetadata = false;
		setTimeout(() => cleanupDepsCacheStaleDirs(environment.getTopLevelConfig()), 0);
	}
	const depsCacheDir = getDepsCacheDir(environment);
	if (!force) {
		let cachedMetadata;
		try {
			const cachedMetadataPath = path.join(depsCacheDir, METADATA_FILENAME);
			cachedMetadata = parseDepsOptimizerMetadata(await fsp.readFile(cachedMetadataPath, "utf-8"), depsCacheDir);
		} catch {}
		if (cachedMetadata) if (cachedMetadata.lockfileHash !== getLockfileHash(environment)) environment.logger.info("Re-optimizing dependencies because lockfile has changed", { timestamp: true });
		else if (cachedMetadata.configHash !== getConfigHash(environment)) environment.logger.info("Re-optimizing dependencies because vite config has changed", { timestamp: true });
		else {
			log$4?.(`(${environment.name}) Hash is consistent. Skipping. Use --force to override.`);
			return cachedMetadata;
		}
	} else environment.logger.info("Forced re-optimization of dependencies", { timestamp: true });
	debug$14?.(`(${environment.name}) ${import_picocolors$26.default.green(`removing old cache dir ${depsCacheDir}`)}`);
	await fsp.rm(depsCacheDir, {
		recursive: true,
		force: true
	});
}
/**
* Initial optimizeDeps at server start. Perform a fast scan using esbuild to
* find deps to pre-bundle and include user hard-coded dependencies
*/
function discoverProjectDependencies(environment) {
	const { cancel, result } = scanImports(environment);
	return {
		cancel,
		result: result.then(({ deps, missing }) => {
			const missingIds = Object.keys(missing);
			if (missingIds.length) throw new Error(`The following dependencies are imported but could not be resolved:\n\n  ${missingIds.map((id) => `${import_picocolors$26.default.cyan(id)} ${import_picocolors$26.default.white(import_picocolors$26.default.dim(`(imported by ${missing[id]})`))}`).join(`\n  `)}\n\nAre they installed?`);
			return deps;
		})
	};
}
function toDiscoveredDependencies(environment, deps, timestamp) {
	const browserHash = getOptimizedBrowserHash(getDepHash(environment).hash, deps, timestamp);
	const discovered = {};
	for (const id in deps) {
		const src = deps[id];
		discovered[id] = {
			id,
			file: getOptimizedDepPath(environment, id),
			src,
			browserHash,
			exportsData: extractExportsData(environment, src)
		};
	}
	return discovered;
}
function depsLogString(qualifiedIds) {
	return import_picocolors$26.default.yellow(qualifiedIds.join(`, `));
}
/**
* Internally, Vite uses this function to prepare a optimizeDeps run. When Vite starts, we can get
* the metadata and start the server without waiting for the optimizeDeps processing to be completed
*/
function runOptimizeDeps(environment, depsInfo) {
	const optimizerContext = { cancelled: false };
	const depsCacheDir = getDepsCacheDir(environment);
	const processingCacheDir = getProcessingDepsCacheDir(environment);
	fs.mkdirSync(processingCacheDir, { recursive: true });
	debug$14?.(import_picocolors$26.default.green(`creating package.json in ${processingCacheDir}`));
	fs.writeFileSync(path.resolve(processingCacheDir, "package.json"), `{\n  "type": "module"\n}\n`);
	const metadata = initDepsOptimizerMetadata(environment);
	metadata.browserHash = getOptimizedBrowserHash(metadata.hash, depsFromOptimizedDepInfo(depsInfo));
	const qualifiedIds = Object.keys(depsInfo);
	let cleaned = false;
	let committed = false;
	const cleanUp = () => {
		if (!cleaned && !committed) {
			cleaned = true;
			debug$14?.(import_picocolors$26.default.green(`removing cache dir ${processingCacheDir}`));
			try {
				fs.rmSync(processingCacheDir, {
					recursive: true,
					force: true
				});
			} catch {}
		}
	};
	const successfulResult = {
		metadata,
		cancel: cleanUp,
		commit: async () => {
			if (cleaned) throw new Error("Can not commit a Deps Optimization run as it was cancelled");
			committed = true;
			const dataPath = path.join(processingCacheDir, METADATA_FILENAME);
			debug$14?.(import_picocolors$26.default.green(`creating ${METADATA_FILENAME} in ${processingCacheDir}`));
			fs.writeFileSync(dataPath, stringifyDepsOptimizerMetadata(metadata, depsCacheDir));
			const temporaryPath = depsCacheDir + getTempSuffix();
			const depsCacheDirPresent = fs.existsSync(depsCacheDir);
			if (isWindows) {
				if (depsCacheDirPresent) {
					debug$14?.(import_picocolors$26.default.green(`renaming ${depsCacheDir} to ${temporaryPath}`));
					await safeRename(depsCacheDir, temporaryPath);
				}
				debug$14?.(import_picocolors$26.default.green(`renaming ${processingCacheDir} to ${depsCacheDir}`));
				await safeRename(processingCacheDir, depsCacheDir);
			} else {
				if (depsCacheDirPresent) {
					debug$14?.(import_picocolors$26.default.green(`renaming ${depsCacheDir} to ${temporaryPath}`));
					fs.renameSync(depsCacheDir, temporaryPath);
				}
				debug$14?.(import_picocolors$26.default.green(`renaming ${processingCacheDir} to ${depsCacheDir}`));
				fs.renameSync(processingCacheDir, depsCacheDir);
			}
			if (depsCacheDirPresent) {
				debug$14?.(import_picocolors$26.default.green(`removing cache temp dir ${temporaryPath}`));
				fsp.rm(temporaryPath, {
					recursive: true,
					force: true
				});
			}
		}
	};
	if (!qualifiedIds.length) return {
		cancel: async () => cleanUp(),
		result: Promise.resolve(successfulResult)
	};
	const cancelledResult = {
		metadata,
		commit: async () => cleanUp(),
		cancel: cleanUp
	};
	const start = performance$1.now();
	const preparedRun = prepareEsbuildOptimizerRun(environment, depsInfo, processingCacheDir, optimizerContext);
	const runResult = preparedRun.then(({ context, idToExports }) => {
		function disposeContext() {
			return context?.dispose().catch((e$1) => {
				environment.logger.error("Failed to dispose esbuild context", { error: e$1 });
			});
		}
		if (!context || optimizerContext.cancelled) {
			disposeContext();
			return cancelledResult;
		}
		return context.rebuild().then((result) => {
			const meta = result.metafile;
			const processingCacheDirOutputPath = path.relative(process.cwd(), processingCacheDir);
			for (const id in depsInfo) {
				const output = esbuildOutputFromId(meta.outputs, id, processingCacheDir);
				const { exportsData,...info } = depsInfo[id];
				addOptimizedDepInfo(metadata, "optimized", {
					...info,
					fileHash: getHash(metadata.hash + depsInfo[id].file + JSON.stringify(output.imports)),
					browserHash: metadata.browserHash,
					needsInterop: needsInterop(environment, id, idToExports[id], output)
				});
			}
			for (const o$1 of Object.keys(meta.outputs)) if (!jsMapExtensionRE.test(o$1)) {
				const id = path.relative(processingCacheDirOutputPath, o$1).replace(jsExtensionRE, "");
				const file = getOptimizedDepPath(environment, id);
				if (!findOptimizedDepInfoInRecord(metadata.optimized, (depInfo) => depInfo.file === file)) addOptimizedDepInfo(metadata, "chunks", {
					id,
					file,
					needsInterop: false,
					browserHash: metadata.browserHash
				});
			} else if (meta.outputs[o$1].bytes === 93) {
				const jsMapPath = path.resolve(o$1);
				const jsPath = jsMapPath.slice(0, -4);
				if (fs.existsSync(jsPath) && fs.existsSync(jsMapPath)) {
					if (JSON.parse(fs.readFileSync(jsMapPath, "utf-8")).sources.length === 0) {
						const js = fs.readFileSync(jsPath, "utf-8");
						fs.writeFileSync(jsPath, js.slice(0, js.lastIndexOf("//# sourceMappingURL=")));
					}
				}
			}
			debug$14?.(`Dependencies bundled in ${(performance$1.now() - start).toFixed(2)}ms`);
			return successfulResult;
		}).catch(async (e$1) => {
			if (e$1.errors && e$1.message.includes("The build was canceled")) return cancelledResult;
			const prependMessage = import_picocolors$26.default.red("Error during dependency optimization:\n\n");
			if (e$1.errors) e$1.message = prependMessage + (await formatMessages(e$1.errors, {
				kind: "error",
				color: true
			})).join("\n");
			else e$1.message = prependMessage + e$1.message;
			throw e$1;
		}).finally(() => {
			return disposeContext();
		});
	});
	runResult.catch(() => {
		cleanUp();
	});
	return {
		async cancel() {
			optimizerContext.cancelled = true;
			const { context } = await preparedRun;
			await context?.cancel();
			cleanUp();
		},
		result: runResult
	};
}
async function prepareEsbuildOptimizerRun(environment, depsInfo, processingCacheDir, optimizerContext) {
	const flatIdDeps = {};
	const idToExports = {};
	const { optimizeDeps: optimizeDeps$1 } = environment.config;
	const { plugins: pluginsFromConfig = [],...esbuildOptions } = optimizeDeps$1.esbuildOptions ?? {};
	await Promise.all(Object.keys(depsInfo).map(async (id) => {
		const src = depsInfo[id].src;
		const exportsData = await (depsInfo[id].exportsData ?? extractExportsData(environment, src));
		if (exportsData.jsxLoader && !esbuildOptions.loader?.[".js"]) esbuildOptions.loader = {
			".js": "jsx",
			...esbuildOptions.loader
		};
		const flatId = flattenId(id);
		flatIdDeps[flatId] = src;
		idToExports[id] = exportsData;
	}));
	if (optimizerContext.cancelled) return {
		context: void 0,
		idToExports
	};
	const define$1 = { "process.env.NODE_ENV": environment.config.keepProcessEnv ? "process.env.NODE_ENV" : JSON.stringify(process.env.NODE_ENV || environment.config.mode) };
	const platform$2 = optimizeDeps$1.esbuildOptions?.platform ?? (environment.config.consumer === "client" || environment.config.ssr.target === "webworker" ? "browser" : "node");
	const external = [...optimizeDeps$1.exclude ?? []];
	const plugins$1 = [...pluginsFromConfig];
	if (external.length) plugins$1.push(esbuildCjsExternalPlugin(external, platform$2));
	plugins$1.push(esbuildDepPlugin(environment, flatIdDeps, external));
	return {
		context: await esbuild.context({
			absWorkingDir: process.cwd(),
			entryPoints: Object.keys(flatIdDeps),
			bundle: true,
			platform: platform$2,
			define: define$1,
			format: "esm",
			banner: platform$2 === "node" ? { js: `import { createRequire } from 'module';const require = createRequire(import.meta.url);` } : void 0,
			target: ESBUILD_BASELINE_WIDELY_AVAILABLE_TARGET,
			external,
			logLevel: "error",
			splitting: true,
			sourcemap: true,
			outdir: processingCacheDir,
			ignoreAnnotations: true,
			metafile: true,
			plugins: plugins$1,
			charset: "utf8",
			...esbuildOptions,
			supported: {
				...defaultEsbuildSupported,
				...esbuildOptions.supported
			}
		}),
		idToExports
	};
}
async function addManuallyIncludedOptimizeDeps(environment, deps) {
	const { logger } = environment;
	const { optimizeDeps: optimizeDeps$1 } = environment.config;
	const optimizeDepsInclude = optimizeDeps$1.include ?? [];
	if (optimizeDepsInclude.length) {
		const unableToOptimize = (id, msg) => {
			if (optimizeDepsInclude.includes(id)) logger.warn(`${msg}: ${import_picocolors$26.default.cyan(id)}, present in ${environment.name} 'optimizeDeps.include'`);
		};
		const includes = [...optimizeDepsInclude];
		for (let i$1 = 0; i$1 < includes.length; i$1++) {
			const id = includes[i$1];
			if (isDynamicPattern(id)) {
				const globIds = expandGlobIds(id, environment.getTopLevelConfig());
				includes.splice(i$1, 1, ...globIds);
				i$1 += globIds.length - 1;
			}
		}
		const resolve$4 = createOptimizeDepsIncludeResolver(environment);
		for (const id of includes) {
			const normalizedId = normalizeId(id);
			if (!deps[normalizedId]) {
				const entry = await resolve$4(id);
				if (entry) if (isOptimizable(entry, optimizeDeps$1)) deps[normalizedId] = entry;
				else unableToOptimize(id, "Cannot optimize dependency");
				else unableToOptimize(id, "Failed to resolve dependency");
			}
		}
	}
}
function depsFromOptimizedDepInfo(depsInfo) {
	const obj = {};
	for (const key in depsInfo) obj[key] = depsInfo[key].src;
	return obj;
}
function getOptimizedDepPath(environment, id) {
	return normalizePath(path.resolve(getDepsCacheDir(environment), flattenId(id) + ".js"));
}
function getDepsCacheSuffix(environment) {
	return environment.name === "client" ? "" : `_${environment.name}`;
}
function getDepsCacheDir(environment) {
	return getDepsCacheDirPrefix(environment) + getDepsCacheSuffix(environment);
}
function getProcessingDepsCacheDir(environment) {
	return getDepsCacheDirPrefix(environment) + getDepsCacheSuffix(environment) + getTempSuffix();
}
function getTempSuffix() {
	return "_temp_" + getHash(`${process.pid}:${Date.now().toString()}:${Math.random().toString(16).slice(2)}`);
}
function getDepsCacheDirPrefix(environment) {
	return normalizePath(path.resolve(environment.config.cacheDir, "deps"));
}
function createIsOptimizedDepFile(environment) {
	const depsCacheDirPrefix = getDepsCacheDirPrefix(environment);
	return (id) => id.startsWith(depsCacheDirPrefix);
}
function createIsOptimizedDepUrl(environment) {
	const { root } = environment.config;
	const depsCacheDir = getDepsCacheDirPrefix(environment);
	const depsCacheDirRelative = normalizePath(path.relative(root, depsCacheDir));
	const depsCacheDirPrefix = depsCacheDirRelative.startsWith("../") ? `/@fs/${removeLeadingSlash(normalizePath(depsCacheDir))}` : `/${depsCacheDirRelative}`;
	return function isOptimizedDepUrl(url$3) {
		return url$3.startsWith(depsCacheDirPrefix);
	};
}
function parseDepsOptimizerMetadata(jsonMetadata, depsCacheDir) {
	const { hash: hash$1, lockfileHash, configHash, browserHash, optimized, chunks } = JSON.parse(jsonMetadata, (key, value$1) => {
		if (key === "file" || key === "src") return normalizePath(path.resolve(depsCacheDir, value$1));
		return value$1;
	});
	if (!chunks || Object.values(optimized).some((depInfo) => !depInfo.fileHash)) return;
	const metadata = {
		hash: hash$1,
		lockfileHash,
		configHash,
		browserHash,
		optimized: {},
		discovered: {},
		chunks: {},
		depInfoList: []
	};
	for (const id of Object.keys(optimized)) addOptimizedDepInfo(metadata, "optimized", {
		...optimized[id],
		id,
		browserHash
	});
	for (const id of Object.keys(chunks)) addOptimizedDepInfo(metadata, "chunks", {
		...chunks[id],
		id,
		browserHash,
		needsInterop: false
	});
	return metadata;
}
/**
* Stringify metadata for deps cache. Remove processing promises
* and individual dep info browserHash. Once the cache is reload
* the next time the server start we need to use the global
* browserHash to allow long term caching
*/
function stringifyDepsOptimizerMetadata(metadata, depsCacheDir) {
	const { hash: hash$1, configHash, lockfileHash, browserHash, optimized, chunks } = metadata;
	return JSON.stringify({
		hash: hash$1,
		configHash,
		lockfileHash,
		browserHash,
		optimized: Object.fromEntries(Object.values(optimized).map(({ id, src, file, fileHash, needsInterop: needsInterop$1 }) => [id, {
			src,
			file,
			fileHash,
			needsInterop: needsInterop$1
		}])),
		chunks: Object.fromEntries(Object.values(chunks).map(({ id, file }) => [id, { file }]))
	}, (key, value$1) => {
		if (key === "file" || key === "src") return normalizePath(path.relative(depsCacheDir, value$1));
		return value$1;
	}, 2);
}
function esbuildOutputFromId(outputs, id, cacheDirOutputPath) {
	const cwd = process.cwd();
	const flatId = flattenId(id) + ".js";
	const normalizedOutputPath = normalizePath(path.relative(cwd, path.join(cacheDirOutputPath, flatId)));
	const output = outputs[normalizedOutputPath];
	if (output) return output;
	for (const [key, value$1] of Object.entries(outputs)) if (normalizePath(path.relative(cwd, key)) === normalizedOutputPath) return value$1;
}
async function extractExportsData(environment, filePath) {
	await init;
	const { optimizeDeps: optimizeDeps$1 } = environment.config;
	const esbuildOptions = optimizeDeps$1.esbuildOptions ?? {};
	if (optimizeDeps$1.extensions?.some((ext) => filePath.endsWith(ext))) {
		const [, exports$2, , hasModuleSyntax$1] = parse((await build({
			...esbuildOptions,
			entryPoints: [filePath],
			write: false,
			format: "esm"
		})).outputFiles[0].text);
		return {
			hasModuleSyntax: hasModuleSyntax$1,
			exports: exports$2.map((e$1) => e$1.n)
		};
	}
	let parseResult;
	let usedJsxLoader = false;
	const entryContent = await fsp.readFile(filePath, "utf-8");
	try {
		parseResult = parse(entryContent);
	} catch {
		const loader$1 = esbuildOptions.loader?.[path.extname(filePath)] || "jsx";
		debug$14?.(`Unable to parse: ${filePath}.\n Trying again with a ${loader$1} transform.`);
		parseResult = parse((await transformWithEsbuild(entryContent, filePath, { loader: loader$1 }, void 0, environment.config)).code);
		usedJsxLoader = true;
	}
	const [, exports$1, , hasModuleSyntax] = parseResult;
	return {
		hasModuleSyntax,
		exports: exports$1.map((e$1) => e$1.n),
		jsxLoader: usedJsxLoader
	};
}
function needsInterop(environment, id, exportsData, output) {
	if (environment.config.optimizeDeps.needsInterop?.includes(id)) return true;
	const { hasModuleSyntax, exports: exports$1 } = exportsData;
	if (!hasModuleSyntax) return true;
	if (output) {
		const generatedExports = output.exports;
		if (isSingleDefaultExport(generatedExports) && !isSingleDefaultExport(exports$1)) return true;
	}
	return false;
}
function isSingleDefaultExport(exports$1) {
	return exports$1.length === 1 && exports$1[0] === "default";
}
const lockfileFormats = [
	{
		path: "node_modules/.package-lock.json",
		checkPatchesDir: "patches",
		manager: "npm"
	},
	{
		path: "node_modules/.yarn-state.yml",
		checkPatchesDir: false,
		manager: "yarn"
	},
	{
		path: ".pnp.cjs",
		checkPatchesDir: ".yarn/patches",
		manager: "yarn"
	},
	{
		path: ".pnp.js",
		checkPatchesDir: ".yarn/patches",
		manager: "yarn"
	},
	{
		path: "node_modules/.yarn-integrity",
		checkPatchesDir: "patches",
		manager: "yarn"
	},
	{
		path: "node_modules/.pnpm/lock.yaml",
		checkPatchesDir: false,
		manager: "pnpm"
	},
	{
		path: "bun.lock",
		checkPatchesDir: "patches",
		manager: "bun"
	},
	{
		path: "bun.lockb",
		checkPatchesDir: "patches",
		manager: "bun"
	}
].sort((_, { manager }) => {
	return process.env.npm_config_user_agent?.startsWith(manager) ? 1 : -1;
});
const lockfilePaths = lockfileFormats.map((l) => l.path);
function getConfigHash(environment) {
	const { config: config$2 } = environment;
	const { optimizeDeps: optimizeDeps$1 } = config$2;
	return getHash(JSON.stringify({
		define: !config$2.keepProcessEnv ? process.env.NODE_ENV || config$2.mode : null,
		root: config$2.root,
		resolve: config$2.resolve,
		assetsInclude: config$2.assetsInclude,
		plugins: config$2.plugins.map((p) => p.name),
		optimizeDeps: {
			include: optimizeDeps$1.include ? unique(optimizeDeps$1.include).sort() : void 0,
			exclude: optimizeDeps$1.exclude ? unique(optimizeDeps$1.exclude).sort() : void 0,
			esbuildOptions: {
				...optimizeDeps$1.esbuildOptions,
				plugins: optimizeDeps$1.esbuildOptions?.plugins?.map((p) => p.name)
			}
		}
	}, (_, value$1) => {
		if (typeof value$1 === "function" || value$1 instanceof RegExp) return value$1.toString();
		return value$1;
	}));
}
function getLockfileHash(environment) {
	const lockfilePath = lookupFile(environment.config.root, lockfilePaths);
	let content = lockfilePath ? fs.readFileSync(lockfilePath, "utf-8") : "";
	if (lockfilePath) {
		const normalizedLockfilePath = lockfilePath.replaceAll("\\", "/");
		const lockfileFormat = lockfileFormats.find((f$1) => normalizedLockfilePath.endsWith(f$1.path));
		if (lockfileFormat.checkPatchesDir) {
			const baseDir = lockfilePath.slice(0, -lockfileFormat.path.length);
			const stat$4 = tryStatSync(path.join(baseDir, lockfileFormat.checkPatchesDir));
			if (stat$4?.isDirectory()) content += stat$4.mtimeMs.toString();
		}
	}
	return getHash(content);
}
function getDepHash(environment) {
	const lockfileHash = getLockfileHash(environment);
	const configHash = getConfigHash(environment);
	return {
		hash: getHash(lockfileHash + configHash),
		lockfileHash,
		configHash
	};
}
function getOptimizedBrowserHash(hash$1, deps, timestamp = "") {
	return getHash(hash$1 + JSON.stringify(deps) + timestamp);
}
function optimizedDepInfoFromId(metadata, id) {
	return metadata.optimized[id] || metadata.discovered[id] || metadata.chunks[id];
}
function optimizedDepInfoFromFile(metadata, file) {
	return metadata.depInfoList.find((depInfo) => depInfo.file === file);
}
function findOptimizedDepInfoInRecord(dependenciesInfo, callbackFn) {
	for (const o$1 of Object.keys(dependenciesInfo)) {
		const info = dependenciesInfo[o$1];
		if (callbackFn(info, o$1)) return info;
	}
}
async function optimizedDepNeedsInterop(environment, metadata, file) {
	const depInfo = optimizedDepInfoFromFile(metadata, file);
	if (depInfo?.src && depInfo.needsInterop === void 0) {
		depInfo.exportsData ??= extractExportsData(environment, depInfo.src);
		depInfo.needsInterop = needsInterop(environment, depInfo.id, await depInfo.exportsData);
	}
	return depInfo?.needsInterop;
}
const MAX_TEMP_DIR_AGE_MS = 1440 * 60 * 1e3;
async function cleanupDepsCacheStaleDirs(config$2) {
	try {
		const cacheDir = path.resolve(config$2.cacheDir);
		if (fs.existsSync(cacheDir)) {
			const dirents = await fsp.readdir(cacheDir, { withFileTypes: true });
			for (const dirent of dirents) if (dirent.isDirectory() && dirent.name.includes("_temp_")) {
				const tempDirPath = path.resolve(config$2.cacheDir, dirent.name);
				const stats = await fsp.stat(tempDirPath).catch(() => null);
				if (stats?.mtime && Date.now() - stats.mtime.getTime() > MAX_TEMP_DIR_AGE_MS) {
					debug$14?.(`removing stale cache temp dir ${tempDirPath}`);
					await fsp.rm(tempDirPath, {
						recursive: true,
						force: true
					});
				}
			}
		}
	} catch (err$2) {
		config$2.logger.error(err$2);
	}
}
const GRACEFUL_RENAME_TIMEOUT = 5e3;
const safeRename = promisify(function gracefulRename(from, to, cb) {
	const start = Date.now();
	let backoff = 0;
	fs.rename(from, to, function CB(er) {
		if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < GRACEFUL_RENAME_TIMEOUT) {
			setTimeout(function() {
				fs.stat(to, function(stater, _st) {
					if (stater && stater.code === "ENOENT") fs.rename(from, to, CB);
					else CB(er);
				});
			}, backoff);
			if (backoff < 100) backoff += 10;
			return;
		}
		cb(er);
	});
});

//#endregion
//#region src/node/external.ts
const debug$13 = createDebugger("vite:external");
const isExternalCache = /* @__PURE__ */ new WeakMap();
function shouldExternalize(environment, id, importer) {
	let isExternal$1 = isExternalCache.get(environment);
	if (!isExternal$1) {
		isExternal$1 = createIsExternal(environment);
		isExternalCache.set(environment, isExternal$1);
	}
	return isExternal$1(id, importer);
}
function createIsConfiguredAsExternal(environment) {
	const { config: config$2 } = environment;
	const { root, resolve: resolve$4 } = config$2;
	const { external, noExternal } = resolve$4;
	const noExternalFilter = typeof noExternal !== "boolean" && !(Array.isArray(noExternal) && noExternal.length === 0) && createFilter(void 0, noExternal, { resolve: false });
	const targetConditions = resolve$4.externalConditions;
	const resolveOptions = {
		...resolve$4,
		root,
		isProduction: false,
		isBuild: true,
		conditions: targetConditions
	};
	const isExternalizable = (id, importer, configuredAsExternal) => {
		if (!bareImportRE.test(id) || id.includes("\0")) return false;
		try {
			const resolved = tryNodeResolve(id, config$2.command === "build" ? void 0 : importer, resolveOptions, void 0, false);
			if (!resolved) return false;
			if (!configuredAsExternal && !isInNodeModules(resolved.id)) return false;
			return canExternalizeFile(resolved.id);
		} catch {
			debug$13?.(`Failed to node resolve "${id}". Skipping externalizing it by default.`);
			return false;
		}
	};
	return (id, importer) => {
		if (external !== true && external.includes(id)) return true;
		const pkgName = getNpmPackageName(id);
		if (!pkgName) return isExternalizable(id, importer, false);
		if (external !== true && external.includes(pkgName)) return isExternalizable(id, importer, true);
		if (typeof noExternal === "boolean") return !noExternal;
		if (noExternalFilter && !noExternalFilter(pkgName)) return false;
		return isExternalizable(id, importer, external === true);
	};
}
function createIsExternal(environment) {
	const processedIds = /* @__PURE__ */ new Map();
	const isConfiguredAsExternal = createIsConfiguredAsExternal(environment);
	return (id, importer) => {
		if (processedIds.has(id)) return processedIds.get(id);
		let isExternal$1 = false;
		if (id[0] !== "." && !path.isAbsolute(id)) isExternal$1 = isBuiltin(environment.config.resolve.builtins, id) || isConfiguredAsExternal(id, importer);
		processedIds.set(id, isExternal$1);
		return isExternal$1;
	};
}
function canExternalizeFile(filePath) {
	const ext = path.extname(filePath);
	return !ext || ext === ".js" || ext === ".mjs" || ext === ".cjs";
}

//#endregion
//#region src/node/plugins/resolve.ts
var import_picocolors$25 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const normalizedClientEntry$1 = normalizePath(CLIENT_ENTRY);
const normalizedEnvEntry$1 = normalizePath(ENV_ENTRY);
const ERR_RESOLVE_PACKAGE_ENTRY_FAIL = "ERR_RESOLVE_PACKAGE_ENTRY_FAIL";
const browserExternalId = "__vite-browser-external";
const optionalPeerDepId = "__vite-optional-peer-dep";
const subpathImportsPrefix = "#";
const relativePrefixRE = /^\.\.?(?:[/\\]|$)/;
const startsWithWordCharRE = /^\w/;
const debug$12 = createDebugger("vite:resolve-details", { onlyWhenFocused: true });
function resolvePlugin(resolveOptions) {
	const { root, isProduction, asSrc, preferRelative = false } = resolveOptions;
	const rootInRoot = tryStatSync(path.join(root, root))?.isDirectory() ?? false;
	return {
		name: "vite:resolve",
		resolveId: {
			filter: { id: { exclude: /^(?:\0|\/?virtual:)/ } },
			async handler(id, importer, resolveOpts) {
				const depsOptimizer = resolveOptions.optimizeDeps && this.environment.mode === "dev" ? this.environment.depsOptimizer : void 0;
				if (id.startsWith(browserExternalId)) return id;
				const isRequire$1 = resolveOpts.custom?.["node-resolve"]?.isRequire ?? false;
				const currentEnvironmentOptions = this.environment.config;
				const options$1 = {
					isRequire: isRequire$1,
					...currentEnvironmentOptions.resolve,
					...resolveOptions,
					scan: resolveOpts.scan ?? resolveOptions.scan
				};
				const resolvedImports = resolveSubpathImports(id, importer, options$1);
				if (resolvedImports) {
					id = resolvedImports;
					if (resolveOpts.custom?.["vite:import-glob"]?.isSubImportsPattern) return normalizePath(path.join(root, id));
				}
				let res;
				if (asSrc && depsOptimizer?.isOptimizedDepUrl(id)) return id.startsWith(FS_PREFIX) ? fsPathFromId(id) : normalizePath(path.resolve(root, id.slice(1)));
				if (asSrc && id.startsWith(FS_PREFIX)) {
					res = fsPathFromId(id);
					debug$12?.(`[@fs] ${import_picocolors$25.default.cyan(id)} -> ${import_picocolors$25.default.dim(res)}`);
					return ensureVersionQuery(res, id, options$1, depsOptimizer);
				}
				if (asSrc && id[0] === "/" && (rootInRoot || !id.startsWith(withTrailingSlash(root)))) {
					if (res = tryFsResolve(path.resolve(root, id.slice(1)), options$1)) {
						debug$12?.(`[url] ${import_picocolors$25.default.cyan(id)} -> ${import_picocolors$25.default.dim(res)}`);
						return ensureVersionQuery(res, id, options$1, depsOptimizer);
					}
				}
				if (relativePrefixRE.test(id) || (preferRelative || resolveOpts.isEntry || importer?.endsWith(".html")) && startsWithWordCharRE.test(id)) {
					const basedir = importer ? path.dirname(importer) : process.cwd();
					const fsPath = path.resolve(basedir, id);
					const normalizedFsPath = normalizePath(fsPath);
					if (depsOptimizer?.isOptimizedDepFile(normalizedFsPath)) {
						if (!options$1.isBuild && !DEP_VERSION_RE.test(normalizedFsPath)) {
							const browserHash = optimizedDepInfoFromFile(depsOptimizer.metadata, normalizedFsPath)?.browserHash;
							if (browserHash) return injectQuery(normalizedFsPath, `v=${browserHash}`);
						}
						return normalizedFsPath;
					}
					if (options$1.mainFields.includes("browser") && (res = tryResolveBrowserMapping(fsPath, importer, options$1, true))) return res;
					if (res = tryFsResolve(fsPath, options$1)) {
						res = ensureVersionQuery(res, id, options$1, depsOptimizer);
						debug$12?.(`[relative] ${import_picocolors$25.default.cyan(id)} -> ${import_picocolors$25.default.dim(res)}`);
						if (!options$1.idOnly && !options$1.scan && options$1.isBuild) {
							const resPkg = findNearestPackageData(path.dirname(res), options$1.packageCache);
							if (resPkg) return {
								id: res,
								moduleSideEffects: resPkg.hasSideEffects(res)
							};
						}
						return res;
					}
				}
				if (id.startsWith("file://")) {
					const { file, postfix } = splitFileAndPostfix(id);
					id = fileURLToPath(file) + postfix;
				}
				if (isWindows && id[0] === "/") {
					const basedir = importer ? path.dirname(importer) : process.cwd();
					if (res = tryFsResolve(path.resolve(basedir, id), options$1)) {
						debug$12?.(`[drive-relative] ${import_picocolors$25.default.cyan(id)} -> ${import_picocolors$25.default.dim(res)}`);
						return ensureVersionQuery(res, id, options$1, depsOptimizer);
					}
				}
				if (isNonDriveRelativeAbsolutePath(id) && (res = tryFsResolve(id, options$1))) {
					debug$12?.(`[fs] ${import_picocolors$25.default.cyan(id)} -> ${import_picocolors$25.default.dim(res)}`);
					return ensureVersionQuery(res, id, options$1, depsOptimizer);
				}
				if (isExternalUrl(id)) return options$1.idOnly ? id : {
					id,
					external: true
				};
				if (isDataUrl(id)) return null;
				if (bareImportRE.test(id)) {
					const external = options$1.externalize && options$1.isBuild && currentEnvironmentOptions.consumer === "server" && shouldExternalize(this.environment, id, importer);
					if (!external && asSrc && depsOptimizer && !options$1.scan && (res = await tryOptimizedResolve(depsOptimizer, id, importer, options$1.preserveSymlinks, options$1.packageCache))) return res;
					if (options$1.mainFields.includes("browser") && (res = tryResolveBrowserMapping(id, importer, options$1, false, external))) return res;
					if (res = tryNodeResolve(id, importer, options$1, depsOptimizer, external)) return res;
					if (currentEnvironmentOptions.consumer === "server" && isBuiltin(options$1.builtins, id)) return options$1.idOnly ? id : {
						id,
						external: true,
						moduleSideEffects: false
					};
					else if (currentEnvironmentOptions.consumer === "server" && isNodeLikeBuiltin(id)) {
						if (!(options$1.external === true || options$1.external.includes(id))) {
							let message = `Automatically externalized node built-in module "${id}"`;
							if (importer) message += ` imported from "${path.relative(process.cwd(), importer)}"`;
							message += `. Consider adding it to environments.${this.environment.name}.external if it is intended.`;
							this.warn(message);
						}
						return options$1.idOnly ? id : {
							id,
							external: true,
							moduleSideEffects: false
						};
					} else if (currentEnvironmentOptions.consumer === "client" && isNodeLikeBuiltin(id)) {
						if (options$1.noExternal === true && (options$1.external === true || !options$1.external.includes(id))) {
							let message = `Cannot bundle built-in module "${id}"`;
							if (importer) message += ` imported from "${path.relative(process.cwd(), importer)}"`;
							message += `. Consider disabling environments.${this.environment.name}.noExternal or remove the built-in dependency.`;
							this.error(message);
						}
						if (!asSrc) debug$12?.(`externalized node built-in "${id}" to empty module. (imported by: ${import_picocolors$25.default.white(import_picocolors$25.default.dim(importer))})`);
						else if (isProduction) this.warn(`Module "${id}" has been externalized for browser compatibility, imported by "${importer}". See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
						return isProduction ? browserExternalId : `${browserExternalId}:${id}`;
					}
				}
				debug$12?.(`[fallthrough] ${import_picocolors$25.default.dim(id)}`);
			}
		},
		load: {
			filter: { id: [prefixRegex(browserExternalId), prefixRegex(optionalPeerDepId)] },
			handler(id) {
				if (id.startsWith(browserExternalId)) if (isProduction) return `export default {}`;
				else {
					id = id.slice(24);
					return `\
  export default new Proxy({}, {
    get(_, key) {
      throw new Error(\`Module "${id}" has been externalized for browser compatibility. Cannot access "${id}.\${key}" in client code.  See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.\`)
    }
  })`;
				}
				if (id.startsWith(optionalPeerDepId)) {
					const [, peerDep, parentDep, isRequire$1] = id.split(":");
					if (isRequire$1 === "true" && isProduction) return "export default {}";
					return `export default {};throw new Error(\`Could not resolve "${peerDep}" imported by "${parentDep}".${isProduction ? "" : " Is it installed?"}\`)`;
				}
			}
		}
	};
}
function resolveSubpathImports(id, importer, options$1) {
	if (!importer || !id.startsWith(subpathImportsPrefix)) return;
	const basedir = path.dirname(importer);
	const pkgData = findNearestPackageData(basedir, options$1.packageCache);
	if (!pkgData) return;
	let { file: idWithoutPostfix, postfix } = splitFileAndPostfix(id.slice(1));
	idWithoutPostfix = "#" + idWithoutPostfix;
	let importsPath = resolveExportsOrImports(pkgData.data, idWithoutPostfix, options$1, "imports");
	if (importsPath?.[0] === ".") {
		importsPath = path.relative(basedir, path.join(pkgData.dir, importsPath));
		if (importsPath[0] !== ".") importsPath = `./${importsPath}`;
	}
	return importsPath + postfix;
}
function ensureVersionQuery(resolved, id, options$1, depsOptimizer) {
	if (!options$1.isBuild && !options$1.scan && depsOptimizer && !(resolved === normalizedClientEntry$1 || resolved === normalizedEnvEntry$1)) {
		if ((isInNodeModules(id) || isInNodeModules(resolved)) && !DEP_VERSION_RE.test(resolved)) {
			const versionHash = depsOptimizer.metadata.browserHash;
			if (versionHash && isOptimizable(resolved, depsOptimizer.options)) resolved = injectQuery(resolved, `v=${versionHash}`);
		}
	}
	return resolved;
}
function tryFsResolve(fsPath, options$1, tryIndex = true, skipPackageJson = false) {
	const hashIndex = fsPath.indexOf("#");
	if (hashIndex >= 0 && isInNodeModules(fsPath)) {
		const queryIndex = fsPath.indexOf("?");
		if (queryIndex < 0 || queryIndex > hashIndex) {
			const file$1 = queryIndex > hashIndex ? fsPath.slice(0, queryIndex) : fsPath;
			const res$1 = tryCleanFsResolve(file$1, options$1, tryIndex, skipPackageJson);
			if (res$1) return res$1 + fsPath.slice(file$1.length);
		}
	}
	const { file, postfix } = splitFileAndPostfix(fsPath);
	const res = tryCleanFsResolve(file, options$1, tryIndex, skipPackageJson);
	if (res) return res + postfix;
}
const knownTsOutputRE = /\.(?:js|mjs|cjs|jsx)$/;
const isPossibleTsOutput = (url$3) => knownTsOutputRE.test(url$3);
function tryCleanFsResolve(file, options$1, tryIndex = true, skipPackageJson = false) {
	const { tryPrefix, extensions: extensions$1, preserveSymlinks } = options$1;
	const fileResult = tryResolveRealFileOrType(file, options$1.preserveSymlinks);
	if (fileResult?.path) return fileResult.path;
	let res;
	const possibleJsToTs = isPossibleTsOutput(file);
	if (possibleJsToTs || options$1.extensions.length || tryPrefix) {
		const dirPath = path.dirname(file);
		if (isDirectory(dirPath)) {
			if (possibleJsToTs) {
				const fileExt = path.extname(file);
				const fileName = file.slice(0, -fileExt.length);
				if (res = tryResolveRealFile(fileName + fileExt.replace("js", "ts"), preserveSymlinks)) return res;
				if (fileExt === ".js" && (res = tryResolveRealFile(fileName + ".tsx", preserveSymlinks))) return res;
			}
			if (res = tryResolveRealFileWithExtensions(file, extensions$1, preserveSymlinks)) return res;
			if (tryPrefix) {
				const prefixed = `${dirPath}/${options$1.tryPrefix}${path.basename(file)}`;
				if (res = tryResolveRealFile(prefixed, preserveSymlinks)) return res;
				if (res = tryResolveRealFileWithExtensions(prefixed, extensions$1, preserveSymlinks)) return res;
			}
		}
	}
	if (tryIndex && fileResult?.type === "directory") {
		const dirPath = file;
		if (!skipPackageJson) {
			let pkgPath = `${dirPath}/package.json`;
			try {
				if (fs.existsSync(pkgPath)) {
					if (!options$1.preserveSymlinks) pkgPath = safeRealpathSync(pkgPath);
					return resolvePackageEntry(dirPath, loadPackageData(pkgPath), options$1);
				}
			} catch (e$1) {
				if (e$1.code !== ERR_RESOLVE_PACKAGE_ENTRY_FAIL && e$1.code !== "ENOENT") throw e$1;
			}
		}
		if (res = tryResolveRealFileWithExtensions(`${dirPath}/index`, extensions$1, preserveSymlinks)) return res;
		if (tryPrefix) {
			if (res = tryResolveRealFileWithExtensions(`${dirPath}/${options$1.tryPrefix}index`, extensions$1, preserveSymlinks)) return res;
		}
	}
}
function tryNodeResolve(id, importer, options$1, depsOptimizer, externalize) {
	const { root, dedupe, isBuild, preserveSymlinks, packageCache } = options$1;
	const deepMatch = deepImportRE.exec(id);
	const pkgId = deepMatch ? deepMatch[1] || deepMatch[2] : cleanUrl(id);
	let basedir;
	if (dedupe.includes(pkgId)) basedir = root;
	else if (importer && path.isAbsolute(importer) && (importer.endsWith("*") || fs.existsSync(cleanUrl(importer)))) basedir = path.dirname(importer);
	else basedir = root;
	const isModuleBuiltin = (id$1) => isBuiltin(options$1.builtins, id$1);
	let selfPkg = null;
	if (!isModuleBuiltin(id) && !id.includes("\0") && bareImportRE.test(id)) {
		const selfPackageData = findNearestPackageData(basedir, packageCache);
		selfPkg = selfPackageData?.data.exports && selfPackageData.data.name === pkgId ? selfPackageData : null;
	}
	const pkg = selfPkg || resolvePackageData(pkgId, basedir, preserveSymlinks, packageCache);
	if (!pkg) {
		if (basedir !== root && !isModuleBuiltin(id) && !id.includes("\0") && bareImportRE.test(id)) {
			const mainPkg = findNearestMainPackageData(basedir, packageCache)?.data;
			if (mainPkg) {
				const pkgName = getNpmPackageName(id);
				if (pkgName != null && mainPkg.peerDependencies?.[pkgName] && mainPkg.peerDependenciesMeta?.[pkgName]?.optional) return { id: `${optionalPeerDepId}:${id}:${mainPkg.name}:${!!options$1.isRequire}` };
			}
		}
		return;
	}
	let resolved = (deepMatch ? resolveDeepImport : resolvePackageEntry)(deepMatch ? "." + id.slice(pkgId.length) : id, pkg, options$1, externalize);
	if (!resolved) return;
	const processResult$1 = (resolved$1) => {
		if (!externalize) return resolved$1;
		if (!canExternalizeFile(resolved$1.id)) return resolved$1;
		let resolvedId = id;
		if (deepMatch && !pkg.data.exports && path.extname(id) !== path.extname(resolved$1.id)) {
			const index = resolved$1.id.indexOf(id);
			if (index > -1) {
				resolvedId = resolved$1.id.slice(index);
				debug$12?.(`[processResult] ${import_picocolors$25.default.cyan(id)} -> ${import_picocolors$25.default.dim(resolvedId)}`);
			}
		}
		return {
			...resolved$1,
			id: resolvedId,
			external: true
		};
	};
	if (!options$1.idOnly && (!options$1.scan && isBuild || externalize)) return processResult$1({
		id: resolved,
		moduleSideEffects: pkg.hasSideEffects(resolved)
	});
	if (!isInNodeModules(resolved) || !depsOptimizer || options$1.scan) return { id: resolved };
	const isJsType = isOptimizable(resolved, depsOptimizer.options);
	const exclude = depsOptimizer.options.exclude;
	if (depsOptimizer.options.noDiscovery || !isJsType || importer && isInNodeModules(importer) || exclude?.includes(pkgId) || exclude?.includes(id) || SPECIAL_QUERY_RE.test(resolved)) {
		const versionHash = depsOptimizer.metadata.browserHash;
		if (versionHash && isJsType) resolved = injectQuery(resolved, `v=${versionHash}`);
	} else {
		const optimizedInfo = depsOptimizer.registerMissingImport(id, resolved);
		resolved = depsOptimizer.getOptimizedDepId(optimizedInfo);
	}
	return { id: resolved };
}
async function tryOptimizedResolve(depsOptimizer, id, importer, preserveSymlinks, packageCache) {
	await depsOptimizer.scanProcessing;
	const metadata = depsOptimizer.metadata;
	const depInfo = optimizedDepInfoFromId(metadata, id);
	if (depInfo) return depsOptimizer.getOptimizedDepId(depInfo);
	if (!importer) return;
	let idPkgDir;
	const nestedIdMatch = `> ${id}`;
	for (const optimizedData of metadata.depInfoList) {
		if (!optimizedData.src) continue;
		if (!optimizedData.id.endsWith(nestedIdMatch)) continue;
		if (idPkgDir == null) {
			const pkgName = getNpmPackageName(id);
			if (!pkgName) break;
			idPkgDir = resolvePackageData(pkgName, importer, preserveSymlinks, packageCache)?.dir;
			if (idPkgDir == null) break;
			idPkgDir = normalizePath(idPkgDir);
		}
		if (optimizedData.src.startsWith(withTrailingSlash(idPkgDir))) return depsOptimizer.getOptimizedDepId(optimizedData);
	}
}
function resolvePackageEntry(id, { dir, data, setResolvedCache, getResolvedCache }, options$1, externalize) {
	const { file: idWithoutPostfix, postfix } = splitFileAndPostfix(id);
	const cached = getResolvedCache(".", options$1);
	if (cached) return cached + postfix;
	try {
		let entryPoint;
		if (data.exports) entryPoint = resolveExportsOrImports(data, ".", options$1, "exports", externalize);
		if (!entryPoint) {
			for (const field of options$1.mainFields) if (field === "browser") {
				entryPoint = tryResolveBrowserEntry(dir, data, options$1);
				if (entryPoint) break;
			} else if (typeof data[field] === "string") {
				entryPoint = data[field];
				break;
			}
		}
		entryPoint ||= data.main;
		const entryPoints = entryPoint ? [entryPoint] : [
			"index.js",
			"index.json",
			"index.node"
		];
		for (let entry of entryPoints) {
			let skipPackageJson = false;
			if (options$1.mainFields[0] === "sass" && !options$1.extensions.includes(path.extname(entry))) {
				entry = "";
				skipPackageJson = true;
			} else {
				const { browser: browserField } = data;
				if (options$1.mainFields.includes("browser") && isObject(browserField)) entry = mapWithBrowserField(entry, browserField) || entry;
			}
			const resolvedEntryPoint = tryFsResolve(path.join(dir, entry), options$1, true, skipPackageJson);
			if (resolvedEntryPoint) {
				debug$12?.(`[package entry] ${import_picocolors$25.default.cyan(idWithoutPostfix)} -> ${import_picocolors$25.default.dim(resolvedEntryPoint)}${postfix !== "" ? ` (postfix: ${postfix})` : ""}`);
				setResolvedCache(".", resolvedEntryPoint, options$1);
				return resolvedEntryPoint + postfix;
			}
		}
	} catch (e$1) {
		packageEntryFailure(id, e$1.message);
	}
	packageEntryFailure(id);
}
function packageEntryFailure(id, details) {
	const err$2 = /* @__PURE__ */ new Error(`Failed to resolve entry for package "${id}". The package may have incorrect main/module/exports specified in its package.json` + (details ? ": " + details : "."));
	err$2.code = ERR_RESOLVE_PACKAGE_ENTRY_FAIL;
	throw err$2;
}
function resolveExportsOrImports(pkg, key, options$1, type, externalize) {
	const conditions = (externalize ? options$1.externalConditions : options$1.conditions).map((condition) => {
		if (condition === DEV_PROD_CONDITION) return options$1.isProduction ? "production" : "development";
		return condition;
	});
	if (options$1.isRequire) conditions.push("require");
	else conditions.push("import");
	const result = (type === "imports" ? f : o)(pkg, key, {
		conditions,
		unsafe: true
	});
	return result ? result[0] : void 0;
}
function resolveDeepImport(id, { setResolvedCache, getResolvedCache, dir, data }, options$1, externalize) {
	const cache$1 = getResolvedCache(id, options$1);
	if (cache$1) return cache$1;
	let relativeId = id;
	const { exports: exportsField, browser: browserField } = data;
	if (exportsField) {
		if (isObject(exportsField) && !Array.isArray(exportsField)) {
			const { file, postfix } = splitFileAndPostfix(relativeId);
			const exportsId = resolveExportsOrImports(data, file, options$1, "exports", externalize);
			if (exportsId !== void 0) relativeId = exportsId + postfix;
			else relativeId = void 0;
		} else relativeId = void 0;
		if (!relativeId) throw new Error(`Package subpath '${relativeId}' is not defined by "exports" in ${path.join(dir, "package.json")}.`);
	} else if (options$1.mainFields.includes("browser") && isObject(browserField)) {
		const { file, postfix } = splitFileAndPostfix(relativeId);
		const mapped = mapWithBrowserField(file, browserField);
		if (mapped) relativeId = mapped + postfix;
		else if (mapped === false) {
			setResolvedCache(id, browserExternalId, options$1);
			return browserExternalId;
		}
	}
	if (relativeId) {
		const resolved = tryFsResolve(path.join(dir, relativeId), options$1, !exportsField);
		if (resolved) {
			debug$12?.(`[node/deep-import] ${import_picocolors$25.default.cyan(id)} -> ${import_picocolors$25.default.dim(resolved)}`);
			setResolvedCache(id, resolved, options$1);
			return resolved;
		}
	}
}
function tryResolveBrowserMapping(id, importer, options$1, isFilePath, externalize) {
	let res;
	const pkg = importer && findNearestPackageData(path.dirname(importer), options$1.packageCache);
	if (pkg && isObject(pkg.data.browser)) {
		const browserMappedPath = mapWithBrowserField(isFilePath ? "./" + slash(path.relative(pkg.dir, id)) : id, pkg.data.browser);
		if (browserMappedPath) {
			if (res = bareImportRE.test(browserMappedPath) ? tryNodeResolve(browserMappedPath, importer, options$1, void 0, void 0)?.id : tryFsResolve(path.join(pkg.dir, browserMappedPath), options$1)) {
				debug$12?.(`[browser mapped] ${import_picocolors$25.default.cyan(id)} -> ${import_picocolors$25.default.dim(res)}`);
				let result = { id: res };
				if (options$1.idOnly) return result;
				if (!options$1.scan && options$1.isBuild) {
					const resPkg = findNearestPackageData(path.dirname(res), options$1.packageCache);
					if (resPkg) result = {
						id: res,
						moduleSideEffects: resPkg.hasSideEffects(res)
					};
				}
				return externalize ? {
					...result,
					external: true
				} : result;
			}
		} else if (browserMappedPath === false) return browserExternalId;
	}
}
function tryResolveBrowserEntry(dir, data, options$1) {
	const browserEntry = typeof data.browser === "string" ? data.browser : isObject(data.browser) && data.browser["."];
	if (browserEntry) if (!options$1.isRequire && options$1.mainFields.includes("module") && typeof data.module === "string" && data.module !== browserEntry) {
		const resolvedBrowserEntry = tryFsResolve(path.join(dir, browserEntry), options$1);
		if (resolvedBrowserEntry) if (hasESMSyntax(fs.readFileSync(resolvedBrowserEntry, "utf-8"))) return browserEntry;
		else return data.module;
	} else return browserEntry;
}
/**
* given a relative path in pkg dir,
* return a relative path in pkg dir,
* mapped with the "map" object
*
* - Returning `undefined` means there is no browser mapping for this id
* - Returning `false` means this id is explicitly externalized for browser
*/
function mapWithBrowserField(relativePathInPkgDir, map$1) {
	const normalizedPath = path.posix.normalize(relativePathInPkgDir);
	for (const key in map$1) {
		const normalizedKey = path.posix.normalize(key);
		if (normalizedPath === normalizedKey || equalWithoutSuffix(normalizedPath, normalizedKey, ".js") || equalWithoutSuffix(normalizedPath, normalizedKey, "/index.js")) return map$1[key];
	}
}
function equalWithoutSuffix(path$13, key, suffix) {
	return key.endsWith(suffix) && key.slice(0, -suffix.length) === path$13;
}
function tryResolveRealFile(file, preserveSymlinks) {
	if (tryStatSync(file)?.isFile()) return getRealPath(file, preserveSymlinks);
}
function tryResolveRealFileWithExtensions(filePath, extensions$1, preserveSymlinks) {
	for (const ext of extensions$1) {
		const res = tryResolveRealFile(filePath + ext, preserveSymlinks);
		if (res) return res;
	}
}
function tryResolveRealFileOrType(file, preserveSymlinks) {
	const fileStat = tryStatSync(file);
	if (fileStat?.isFile()) return {
		path: getRealPath(file, preserveSymlinks),
		type: "file"
	};
	if (fileStat?.isDirectory()) return { type: "directory" };
}
function getRealPath(resolved, preserveSymlinks) {
	if (!preserveSymlinks) resolved = safeRealpathSync(resolved);
	return normalizePath(resolved);
}
function isDirectory(path$13) {
	return tryStatSync(path$13)?.isDirectory() ?? false;
}

//#endregion
//#region src/node/plugins/optimizedDeps.ts
var import_picocolors$24 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const debug$11 = createDebugger("vite:optimize-deps");
function optimizedDepsPlugin() {
	return {
		name: "vite:optimized-deps",
		applyToEnvironment(environment) {
			return !isDepOptimizationDisabled(environment.config.optimizeDeps);
		},
		resolveId(id) {
			if (this.environment.depsOptimizer?.isOptimizedDepFile(id)) return id;
		},
		async load(id) {
			const depsOptimizer = this.environment.depsOptimizer;
			if (depsOptimizer?.isOptimizedDepFile(id)) {
				const metadata = depsOptimizer.metadata;
				const file = cleanUrl(id);
				const versionMatch = DEP_VERSION_RE.exec(id);
				const browserHash = versionMatch ? versionMatch[1].split("=")[1] : void 0;
				const info = optimizedDepInfoFromFile(metadata, file);
				if (info) {
					if (browserHash && info.browserHash !== browserHash) throwOutdatedRequest(id);
					try {
						await info.processing;
					} catch {
						throwProcessingError(id);
					}
					const newMetadata = depsOptimizer.metadata;
					if (metadata !== newMetadata) {
						const currentInfo = optimizedDepInfoFromFile(newMetadata, file);
						if (info.browserHash !== currentInfo?.browserHash) throwOutdatedRequest(id);
					}
				}
				debug$11?.(`load ${import_picocolors$24.default.cyan(file)}`);
				try {
					return await fsp.readFile(file, "utf-8");
				} catch {
					if (browserHash) throwOutdatedRequest(id);
					throwFileNotFoundInOptimizedDep(id);
				}
			}
		}
	};
}
function throwProcessingError(id) {
	const err$2 = /* @__PURE__ */ new Error(`Something unexpected happened while optimizing "${id}". The current page should have reloaded by now`);
	err$2.code = ERR_OPTIMIZE_DEPS_PROCESSING_ERROR;
	throw err$2;
}
function throwOutdatedRequest(id) {
	const err$2 = /* @__PURE__ */ new Error(`There is a new version of the pre-bundle for "${id}", a page reload is going to ask for it.`);
	err$2.code = ERR_OUTDATED_OPTIMIZED_DEP;
	throw err$2;
}
function throwFileNotFoundInOptimizedDep(id) {
	const err$2 = /* @__PURE__ */ new Error(`The file does not exist at "${id}" which is in the optimize deps directory. The dependency might be incompatible with the dep optimizer. Try adding it to \`optimizeDeps.exclude\`.`);
	err$2.code = ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR;
	throw err$2;
}

//#endregion
//#region ../../node_modules/.pnpm/dotenv@17.2.3/node_modules/dotenv/package.json
var require_package = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/dotenv@17.2.3/node_modules/dotenv/package.json": ((exports, module) => {
	module.exports = {
		"name": "dotenv",
		"version": "17.2.3",
		"description": "Loads environment variables from .env file",
		"main": "lib/main.js",
		"types": "lib/main.d.ts",
		"exports": {
			".": {
				"types": "./lib/main.d.ts",
				"require": "./lib/main.js",
				"default": "./lib/main.js"
			},
			"./config": "./config.js",
			"./config.js": "./config.js",
			"./lib/env-options": "./lib/env-options.js",
			"./lib/env-options.js": "./lib/env-options.js",
			"./lib/cli-options": "./lib/cli-options.js",
			"./lib/cli-options.js": "./lib/cli-options.js",
			"./package.json": "./package.json"
		},
		"scripts": {
			"dts-check": "tsc --project tests/types/tsconfig.json",
			"lint": "standard",
			"pretest": "npm run lint && npm run dts-check",
			"test": "tap run tests/**/*.js --allow-empty-coverage --disable-coverage --timeout=60000",
			"test:coverage": "tap run tests/**/*.js --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov",
			"prerelease": "npm test",
			"release": "standard-version"
		},
		"repository": {
			"type": "git",
			"url": "git://github.com/motdotla/dotenv.git"
		},
		"homepage": "https://github.com/motdotla/dotenv#readme",
		"funding": "https://dotenvx.com",
		"keywords": [
			"dotenv",
			"env",
			".env",
			"environment",
			"variables",
			"config",
			"settings"
		],
		"readmeFilename": "README.md",
		"license": "BSD-2-Clause",
		"devDependencies": {
			"@types/node": "^18.11.3",
			"decache": "^4.6.2",
			"sinon": "^14.0.1",
			"standard": "^17.0.0",
			"standard-version": "^9.5.0",
			"tap": "^19.2.0",
			"typescript": "^4.8.4"
		},
		"engines": { "node": ">=12" },
		"browser": { "fs": false }
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/dotenv@17.2.3/node_modules/dotenv/lib/main.js
var require_main$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/dotenv@17.2.3/node_modules/dotenv/lib/main.js": ((exports, module) => {
	const fs$10 = __require("fs");
	const path$10 = __require("path");
	const os$3 = __require("os");
	const crypto$2 = __require("crypto");
	const version = require_package().version;
	const TIPS = [
		"🔐 encrypt with Dotenvx: https://dotenvx.com",
		"🔐 prevent committing .env to code: https://dotenvx.com/precommit",
		"🔐 prevent building .env in docker: https://dotenvx.com/prebuild",
		"📡 add observability to secrets: https://dotenvx.com/ops",
		"👥 sync secrets across teammates & machines: https://dotenvx.com/ops",
		"🗂️ backup and recover secrets: https://dotenvx.com/ops",
		"✅ audit secrets and track compliance: https://dotenvx.com/ops",
		"🔄 add secrets lifecycle management: https://dotenvx.com/ops",
		"🔑 add access controls to secrets: https://dotenvx.com/ops",
		"🛠️  run anywhere with `dotenvx run -- yourcommand`",
		"⚙️  specify custom .env file path with { path: '/custom/path/.env' }",
		"⚙️  enable debug logging with { debug: true }",
		"⚙️  override existing env vars with { override: true }",
		"⚙️  suppress all logs with { quiet: true }",
		"⚙️  write to custom object with { processEnv: myObject }",
		"⚙️  load multiple .env files with { path: ['.env.local', '.env'] }"
	];
	function _getRandomTip() {
		return TIPS[Math.floor(Math.random() * TIPS.length)];
	}
	function parseBoolean(value$1) {
		if (typeof value$1 === "string") return ![
			"false",
			"0",
			"no",
			"off",
			""
		].includes(value$1.toLowerCase());
		return Boolean(value$1);
	}
	function supportsAnsi() {
		return process.stdout.isTTY;
	}
	function dim(text) {
		return supportsAnsi() ? `\x1b[2m${text}\x1b[0m` : text;
	}
	const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm;
	function parse$13(src) {
		const obj = {};
		let lines = src.toString();
		lines = lines.replace(/\r\n?/gm, "\n");
		let match;
		while ((match = LINE.exec(lines)) != null) {
			const key = match[1];
			let value$1 = match[2] || "";
			value$1 = value$1.trim();
			const maybeQuote = value$1[0];
			value$1 = value$1.replace(/^(['"`])([\s\S]*)\1$/gm, "$2");
			if (maybeQuote === "\"") {
				value$1 = value$1.replace(/\\n/g, "\n");
				value$1 = value$1.replace(/\\r/g, "\r");
			}
			obj[key] = value$1;
		}
		return obj;
	}
	function _parseVault(options$1) {
		options$1 = options$1 || {};
		const vaultPath = _vaultPath(options$1);
		options$1.path = vaultPath;
		const result = DotenvModule.configDotenv(options$1);
		if (!result.parsed) {
			const err$2 = /* @__PURE__ */ new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
			err$2.code = "MISSING_DATA";
			throw err$2;
		}
		const keys = _dotenvKey(options$1).split(",");
		const length = keys.length;
		let decrypted;
		for (let i$1 = 0; i$1 < length; i$1++) try {
			const attrs = _instructions(result, keys[i$1].trim());
			decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
			break;
		} catch (error$1) {
			if (i$1 + 1 >= length) throw error$1;
		}
		return DotenvModule.parse(decrypted);
	}
	function _warn(message) {
		console.error(`[dotenv@${version}][WARN] ${message}`);
	}
	function _debug(message) {
		console.log(`[dotenv@${version}][DEBUG] ${message}`);
	}
	function _log(message) {
		console.log(`[dotenv@${version}] ${message}`);
	}
	function _dotenvKey(options$1) {
		if (options$1 && options$1.DOTENV_KEY && options$1.DOTENV_KEY.length > 0) return options$1.DOTENV_KEY;
		if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) return process.env.DOTENV_KEY;
		return "";
	}
	function _instructions(result, dotenvKey) {
		let uri;
		try {
			uri = new URL(dotenvKey);
		} catch (error$1) {
			if (error$1.code === "ERR_INVALID_URL") {
				const err$2 = /* @__PURE__ */ new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
				err$2.code = "INVALID_DOTENV_KEY";
				throw err$2;
			}
			throw error$1;
		}
		const key = uri.password;
		if (!key) {
			const err$2 = /* @__PURE__ */ new Error("INVALID_DOTENV_KEY: Missing key part");
			err$2.code = "INVALID_DOTENV_KEY";
			throw err$2;
		}
		const environment = uri.searchParams.get("environment");
		if (!environment) {
			const err$2 = /* @__PURE__ */ new Error("INVALID_DOTENV_KEY: Missing environment part");
			err$2.code = "INVALID_DOTENV_KEY";
			throw err$2;
		}
		const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
		const ciphertext = result.parsed[environmentKey];
		if (!ciphertext) {
			const err$2 = /* @__PURE__ */ new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
			err$2.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
			throw err$2;
		}
		return {
			ciphertext,
			key
		};
	}
	function _vaultPath(options$1) {
		let possibleVaultPath = null;
		if (options$1 && options$1.path && options$1.path.length > 0) if (Array.isArray(options$1.path)) {
			for (const filepath of options$1.path) if (fs$10.existsSync(filepath)) possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
		} else possibleVaultPath = options$1.path.endsWith(".vault") ? options$1.path : `${options$1.path}.vault`;
		else possibleVaultPath = path$10.resolve(process.cwd(), ".env.vault");
		if (fs$10.existsSync(possibleVaultPath)) return possibleVaultPath;
		return null;
	}
	function _resolveHome(envPath) {
		return envPath[0] === "~" ? path$10.join(os$3.homedir(), envPath.slice(1)) : envPath;
	}
	function _configVault(options$1) {
		const debug$19 = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || options$1 && options$1.debug);
		const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || options$1 && options$1.quiet);
		if (debug$19 || !quiet) _log("Loading env from encrypted .env.vault");
		const parsed = DotenvModule._parseVault(options$1);
		let processEnv = process.env;
		if (options$1 && options$1.processEnv != null) processEnv = options$1.processEnv;
		DotenvModule.populate(processEnv, parsed, options$1);
		return { parsed };
	}
	function configDotenv(options$1) {
		const dotenvPath = path$10.resolve(process.cwd(), ".env");
		let encoding = "utf8";
		let processEnv = process.env;
		if (options$1 && options$1.processEnv != null) processEnv = options$1.processEnv;
		let debug$19 = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || options$1 && options$1.debug);
		let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || options$1 && options$1.quiet);
		if (options$1 && options$1.encoding) encoding = options$1.encoding;
		else if (debug$19) _debug("No encoding is specified. UTF-8 is used by default");
		let optionPaths = [dotenvPath];
		if (options$1 && options$1.path) if (!Array.isArray(options$1.path)) optionPaths = [_resolveHome(options$1.path)];
		else {
			optionPaths = [];
			for (const filepath of options$1.path) optionPaths.push(_resolveHome(filepath));
		}
		let lastError;
		const parsedAll = {};
		for (const path$13 of optionPaths) try {
			const parsed = DotenvModule.parse(fs$10.readFileSync(path$13, { encoding }));
			DotenvModule.populate(parsedAll, parsed, options$1);
		} catch (e$1) {
			if (debug$19) _debug(`Failed to load ${path$13} ${e$1.message}`);
			lastError = e$1;
		}
		const populated = DotenvModule.populate(processEnv, parsedAll, options$1);
		debug$19 = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug$19);
		quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet);
		if (debug$19 || !quiet) {
			const keysCount = Object.keys(populated).length;
			const shortPaths = [];
			for (const filePath of optionPaths) try {
				const relative$3 = path$10.relative(process.cwd(), filePath);
				shortPaths.push(relative$3);
			} catch (e$1) {
				if (debug$19) _debug(`Failed to load ${filePath} ${e$1.message}`);
				lastError = e$1;
			}
			_log(`injecting env (${keysCount}) from ${shortPaths.join(",")} ${dim(`-- tip: ${_getRandomTip()}`)}`);
		}
		if (lastError) return {
			parsed: parsedAll,
			error: lastError
		};
		else return { parsed: parsedAll };
	}
	function config(options$1) {
		if (_dotenvKey(options$1).length === 0) return DotenvModule.configDotenv(options$1);
		const vaultPath = _vaultPath(options$1);
		if (!vaultPath) {
			_warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
			return DotenvModule.configDotenv(options$1);
		}
		return DotenvModule._configVault(options$1);
	}
	function decrypt(encrypted, keyStr) {
		const key = Buffer.from(keyStr.slice(-64), "hex");
		let ciphertext = Buffer.from(encrypted, "base64");
		const nonce = ciphertext.subarray(0, 12);
		const authTag = ciphertext.subarray(-16);
		ciphertext = ciphertext.subarray(12, -16);
		try {
			const aesgcm = crypto$2.createDecipheriv("aes-256-gcm", key, nonce);
			aesgcm.setAuthTag(authTag);
			return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
		} catch (error$1) {
			const isRange = error$1 instanceof RangeError;
			const invalidKeyLength = error$1.message === "Invalid key length";
			const decryptionFailed = error$1.message === "Unsupported state or unable to authenticate data";
			if (isRange || invalidKeyLength) {
				const err$2 = /* @__PURE__ */ new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
				err$2.code = "INVALID_DOTENV_KEY";
				throw err$2;
			} else if (decryptionFailed) {
				const err$2 = /* @__PURE__ */ new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
				err$2.code = "DECRYPTION_FAILED";
				throw err$2;
			} else throw error$1;
		}
	}
	function populate(processEnv, parsed, options$1 = {}) {
		const debug$19 = Boolean(options$1 && options$1.debug);
		const override = Boolean(options$1 && options$1.override);
		const populated = {};
		if (typeof parsed !== "object") {
			const err$2 = /* @__PURE__ */ new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
			err$2.code = "OBJECT_REQUIRED";
			throw err$2;
		}
		for (const key of Object.keys(parsed)) if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
			if (override === true) {
				processEnv[key] = parsed[key];
				populated[key] = parsed[key];
			}
			if (debug$19) if (override === true) _debug(`"${key}" is already defined and WAS overwritten`);
			else _debug(`"${key}" is already defined and was NOT overwritten`);
		} else {
			processEnv[key] = parsed[key];
			populated[key] = parsed[key];
		}
		return populated;
	}
	const DotenvModule = {
		configDotenv,
		_configVault,
		_parseVault,
		config,
		decrypt,
		parse: parse$13,
		populate
	};
	module.exports.configDotenv = DotenvModule.configDotenv;
	module.exports._configVault = DotenvModule._configVault;
	module.exports._parseVault = DotenvModule._parseVault;
	module.exports.config = DotenvModule.config;
	module.exports.decrypt = DotenvModule.decrypt;
	module.exports.parse = DotenvModule.parse;
	module.exports.populate = DotenvModule.populate;
	module.exports = DotenvModule;
}) });

//#endregion
//#region ../../node_modules/.pnpm/dotenv-expand@12.0.3_patch_hash=49330a663821151418e003e822a82a6a61d2f0f8a6e3cab00c1c94815a112889/node_modules/dotenv-expand/lib/main.js
var require_main = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/dotenv-expand@12.0.3_patch_hash=49330a663821151418e003e822a82a6a61d2f0f8a6e3cab00c1c94815a112889/node_modules/dotenv-expand/lib/main.js": ((exports, module) => {
	function _resolveEscapeSequences(value$1) {
		return value$1.replace(/\\\$/g, "$");
	}
	function expandValue(value$1, processEnv, runningParsed) {
		const env$1 = {
			...runningParsed,
			...processEnv
		};
		const regex = /(?<!\\)\${([^{}]+)}|(?<!\\)\$([A-Za-z_][A-Za-z0-9_]*)/g;
		let result = value$1;
		let match;
		const seen$1 = /* @__PURE__ */ new Set();
		while ((match = regex.exec(result)) !== null) {
			seen$1.add(result);
			const [template, bracedExpression, unbracedExpression] = match;
			const expression = bracedExpression || unbracedExpression;
			const opMatch = expression.match(/(:\+|\+|:-|-)/);
			const splitter = opMatch ? opMatch[0] : null;
			const r$1 = expression.split(splitter);
			let defaultValue;
			let value$2;
			const key = r$1.shift();
			if ([":+", "+"].includes(splitter)) {
				defaultValue = env$1[key] ? r$1.join(splitter) : "";
				value$2 = null;
			} else {
				defaultValue = r$1.join(splitter);
				value$2 = env$1[key];
			}
			if (value$2) if (seen$1.has(value$2)) result = result.replace(template, defaultValue);
			else result = result.replace(template, value$2);
			else result = result.replace(template, defaultValue);
			if (result === runningParsed[key]) break;
			regex.lastIndex = 0;
		}
		return result;
	}
	function expand$3(options$1) {
		let processEnv = process.env;
		if (options$1 && options$1.processEnv != null) processEnv = options$1.processEnv;
		for (const key in options$1.parsed) {
			let value$1 = options$1.parsed[key];
			if (processEnv[key] && processEnv[key] !== value$1) value$1 = processEnv[key];
			else value$1 = expandValue(value$1, processEnv, options$1.parsed);
			options$1.parsed[key] = _resolveEscapeSequences(value$1);
		}
		for (const processKey in options$1.parsed) processEnv[processKey] = options$1.parsed[processKey];
		return options$1;
	}
	module.exports.expand = expand$3;
}) });

//#endregion
//#region src/node/env.ts
var import_main = /* @__PURE__ */ __toESM(require_main$1(), 1);
var import_main$1 = /* @__PURE__ */ __toESM(require_main(), 1);
const debug$10 = createDebugger("vite:env");
function getEnvFilesForMode(mode, envDir) {
	if (envDir !== false) return [
		`.env`,
		`.env.local`,
		`.env.${mode}`,
		`.env.${mode}.local`
	].map((file) => normalizePath(path.join(envDir, file)));
	return [];
}
function loadEnv(mode, envDir, prefixes = "VITE_") {
	const start = performance.now();
	const getTime = () => `${(performance.now() - start).toFixed(2)}ms`;
	if (mode === "local") throw new Error("\"local\" cannot be used as a mode name because it conflicts with the .local postfix for .env files.");
	prefixes = arraify(prefixes);
	const env$1 = {};
	const envFiles = getEnvFilesForMode(mode, envDir);
	debug$10?.(`loading env files: %O`, envFiles);
	const parsed = Object.fromEntries(envFiles.flatMap((filePath) => {
		if (!tryStatSync(filePath)?.isFile()) return [];
		return Object.entries((0, import_main.parse)(fs.readFileSync(filePath)));
	}));
	debug$10?.(`env files loaded in ${getTime()}`);
	if (parsed.NODE_ENV && process.env.VITE_USER_NODE_ENV === void 0) process.env.VITE_USER_NODE_ENV = parsed.NODE_ENV;
	if (parsed.BROWSER && process.env.BROWSER === void 0) process.env.BROWSER = parsed.BROWSER;
	if (parsed.BROWSER_ARGS && process.env.BROWSER_ARGS === void 0) process.env.BROWSER_ARGS = parsed.BROWSER_ARGS;
	(0, import_main$1.expand)({
		parsed,
		processEnv: { ...process.env }
	});
	for (const [key, value$1] of Object.entries(parsed)) if (prefixes.some((prefix) => key.startsWith(prefix))) env$1[key] = value$1;
	for (const key in process.env) if (prefixes.some((prefix) => key.startsWith(prefix))) env$1[key] = process.env[key];
	debug$10?.(`using resolved env: %O`, env$1);
	return env$1;
}
function resolveEnvPrefix({ envPrefix = "VITE_" }) {
	envPrefix = arraify(envPrefix);
	if (envPrefix.includes("")) throw new Error(`envPrefix option contains value '', which could lead unexpected exposure of sensitive information.`);
	return envPrefix;
}

//#endregion
//#region src/node/deprecations.ts
var import_picocolors$23 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const docsURL = "https://vite.dev";
const deprecationCode = {
	removePluginHookSsrArgument: "changes/this-environment-in-hooks",
	removePluginHookHandleHotUpdate: "changes/hotupdate-hook",
	removeServerModuleGraph: "changes/per-environment-apis",
	removeServerReloadModule: "changes/per-environment-apis",
	removeServerPluginContainer: "changes/per-environment-apis",
	removeServerHot: "changes/per-environment-apis",
	removeServerTransformRequest: "changes/per-environment-apis",
	removeServerWarmupRequest: "changes/per-environment-apis",
	removeSsrLoadModule: "changes/ssr-using-modulerunner"
};
const deprecationMessages = {
	removePluginHookSsrArgument: "Plugin hook `options.ssr` is replaced with `this.environment.config.consumer === 'server'`.",
	removePluginHookHandleHotUpdate: "Plugin hook `handleHotUpdate()` is replaced with `hotUpdate()`.",
	removeServerModuleGraph: "The `server.moduleGraph` is replaced with `this.environment.moduleGraph`.",
	removeServerReloadModule: "The `server.reloadModule` is replaced with `environment.reloadModule`.",
	removeServerPluginContainer: "The `server.pluginContainer` is replaced with `this.environment.pluginContainer`.",
	removeServerHot: "The `server.hot` is replaced with `this.environment.hot`.",
	removeServerTransformRequest: "The `server.transformRequest` is replaced with `this.environment.transformRequest`.",
	removeServerWarmupRequest: "The `server.warmupRequest` is replaced with `this.environment.warmupRequest`.",
	removeSsrLoadModule: "The `server.ssrLoadModule` is replaced with Environment Runner."
};
let _ignoreDeprecationWarnings = false;
function isFutureDeprecationEnabled(config$2, type) {
	return !!config$2.future?.[type];
}
/**
* Warn about future deprecations.
*/
function warnFutureDeprecation(config$2, type, extraMessage, stacktrace = true) {
	if (_ignoreDeprecationWarnings || !config$2.future || config$2.future[type] !== "warn") return;
	let msg = `[vite future] ${deprecationMessages[type]}`;
	if (extraMessage) msg += ` ${extraMessage}`;
	msg = import_picocolors$23.default.yellow(msg);
	const docs = `${docsURL}/changes/${deprecationCode[type].toLowerCase()}`;
	msg += import_picocolors$23.default.gray(`\n  ${stacktrace ? "├" : "└"}─── `) + import_picocolors$23.default.underline(docs) + "\n";
	if (stacktrace) {
		const stack = (/* @__PURE__ */ new Error()).stack;
		if (stack) {
			let stacks = stack.split("\n").slice(3).filter((i$1) => !i$1.includes("/node_modules/vite/dist/"));
			if (stacks.length === 0) stacks.push("No stack trace found.");
			stacks = stacks.map((i$1, idx) => `  ${idx === stacks.length - 1 ? "└" : "│"} ${i$1.trim()}`);
			msg += import_picocolors$23.default.dim(stacks.join("\n")) + "\n";
		}
	}
	config$2.logger.warnOnce(msg);
}
function ignoreDeprecationWarnings(fn) {
	const before = _ignoreDeprecationWarnings;
	_ignoreDeprecationWarnings = true;
	const ret = fn();
	_ignoreDeprecationWarnings = before;
	return ret;
}

//#endregion
//#region src/node/server/middlewares/error.ts
var import_picocolors$22 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
function prepareError(err$2) {
	return {
		message: stripVTControlCharacters(err$2.message),
		stack: stripVTControlCharacters(cleanStack(err$2.stack || "")),
		id: err$2.id,
		frame: stripVTControlCharacters(err$2.frame || ""),
		plugin: err$2.plugin,
		pluginCode: err$2.pluginCode?.toString(),
		loc: err$2.loc
	};
}
function buildErrorMessage(err$2, args = [], includeStack = true) {
	if (err$2.plugin) args.push(`  Plugin: ${import_picocolors$22.default.magenta(err$2.plugin)}`);
	const loc = err$2.loc ? `:${err$2.loc.line}:${err$2.loc.column}` : "";
	if (err$2.id) args.push(`  File: ${import_picocolors$22.default.cyan(err$2.id)}${loc}`);
	if (err$2.frame) args.push(import_picocolors$22.default.yellow(pad$1(err$2.frame)));
	if (includeStack && err$2.stack) args.push(pad$1(cleanStack(err$2.stack)));
	return args.join("\n");
}
function cleanStack(stack) {
	return stack.split(/\n/).filter((l) => /^\s*at/.test(l)).join("\n");
}
function logError(server, err$2) {
	const msg = buildErrorMessage(err$2, [import_picocolors$22.default.red(`Internal server error: ${err$2.message}`)]);
	server.config.logger.error(msg, {
		clear: true,
		timestamp: true,
		error: err$2
	});
	server.environments.client.hot.send({
		type: "error",
		err: prepareError(err$2)
	});
}
function errorMiddleware(server, allowNext = false) {
	return function viteErrorMiddleware(err$2, _req, res, next) {
		logError(server, err$2);
		if (allowNext) next();
		else {
			res.statusCode = 500;
			res.end(`
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <title>Error</title>
            <script type="module">
              const error = ${JSON.stringify(prepareError(err$2)).replace(/</g, "\\u003c")}
              try {
                const { ErrorOverlay } = await import(${JSON.stringify(path.posix.join(server.config.base, CLIENT_PUBLIC_PATH))})
                document.body.appendChild(new ErrorOverlay(error))
              } catch {
                const h = (tag, text) => {
                  const el = document.createElement(tag)
                  el.textContent = text
                  return el
                }
                document.body.appendChild(h('h1', 'Internal Server Error'))
                document.body.appendChild(h('h2', error.message))
                document.body.appendChild(h('pre', error.stack))
                document.body.appendChild(h('p', '(Error overlay failed to load)'))
              }
            <\/script>
          </head>
          <body>
          </body>
        </html>
      `);
		}
	};
}

//#endregion
//#region ../../node_modules/.pnpm/ms@2.0.0/node_modules/ms/index.js
var require_ms = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ms@2.0.0/node_modules/ms/index.js": ((exports, module) => {
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options$1) {
		options$1 = options$1 || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse$11(val);
		else if (type === "number" && isNaN(val) === false) return options$1.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse$11(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n$2 = parseFloat(match[1]);
		switch ((match[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n$2 * y;
			case "days":
			case "day":
			case "d": return n$2 * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n$2 * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n$2 * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n$2 * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n$2;
			default: return;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms) {
		if (ms >= d) return Math.round(ms / d) + "d";
		if (ms >= h) return Math.round(ms / h) + "h";
		if (ms >= m) return Math.round(ms / m) + "m";
		if (ms >= s) return Math.round(ms / s) + "s";
		return ms + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms) {
		return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms, n$2, name) {
		if (ms < n$2) return;
		if (ms < n$2 * 1.5) return Math.floor(ms / n$2) + " " + name;
		return Math.ceil(ms / n$2) + " " + name + "s";
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/debug.js
var require_debug$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/debug.js": ((exports, module) => {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = require_ms();
	/**
	* The currently active debug mode names, and names to skip.
	*/
	exports.names = [];
	exports.skips = [];
	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	exports.formatters = {};
	/**
	* Previous log timestamp.
	*/
	var prevTime;
	/**
	* Select a color.
	* @param {String} namespace
	* @return {Number}
	* @api private
	*/
	function selectColor(namespace) {
		var hash$1 = 0, i$1;
		for (i$1 in namespace) {
			hash$1 = (hash$1 << 5) - hash$1 + namespace.charCodeAt(i$1);
			hash$1 |= 0;
		}
		return exports.colors[Math.abs(hash$1) % exports.colors.length];
	}
	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		function debug$19() {
			if (!debug$19.enabled) return;
			var self$1 = debug$19;
			var curr = +/* @__PURE__ */ new Date();
			self$1.diff = curr - (prevTime || curr);
			self$1.prev = prevTime;
			self$1.curr = curr;
			prevTime = curr;
			var args = new Array(arguments.length);
			for (var i$1 = 0; i$1 < args.length; i$1++) args[i$1] = arguments[i$1];
			args[0] = exports.coerce(args[0]);
			if ("string" !== typeof args[0]) args.unshift("%O");
			var index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format$3) {
				if (match === "%%") return match;
				index++;
				var formatter = exports.formatters[format$3];
				if ("function" === typeof formatter) {
					var val = args[index];
					match = formatter.call(self$1, val);
					args.splice(index, 1);
					index--;
				}
				return match;
			});
			exports.formatArgs.call(self$1, args);
			(debug$19.log || exports.log || console.log.bind(console)).apply(self$1, args);
		}
		debug$19.namespace = namespace;
		debug$19.enabled = exports.enabled(namespace);
		debug$19.useColors = exports.useColors();
		debug$19.color = selectColor(namespace);
		if ("function" === typeof exports.init) exports.init(debug$19);
		return debug$19;
	}
	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		exports.save(namespaces);
		exports.names = [];
		exports.skips = [];
		var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
		var len = split.length;
		for (var i$1 = 0; i$1 < len; i$1++) {
			if (!split[i$1]) continue;
			namespaces = split[i$1].replace(/\*/g, ".*?");
			if (namespaces[0] === "-") exports.skips.push(/* @__PURE__ */ new RegExp("^" + namespaces.substr(1) + "$"));
			else exports.names.push(/* @__PURE__ */ new RegExp("^" + namespaces + "$"));
		}
	}
	/**
	* Disable debug output.
	*
	* @api public
	*/
	function disable() {
		exports.enable("");
	}
	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		var i$1, len;
		for (i$1 = 0, len = exports.skips.length; i$1 < len; i$1++) if (exports.skips[i$1].test(name)) return false;
		for (i$1 = 0, len = exports.names.length; i$1 < len; i$1++) if (exports.names[i$1].test(name)) return true;
		return false;
	}
	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) return val.stack || val.message;
		return val;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/node.js
var require_node = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/node.js": ((exports, module) => {
	/**
	* Module dependencies.
	*/
	var tty = __require("tty");
	var util$1 = __require("util");
	/**
	* This is the Node.js implementation of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = require_debug$1();
	exports.init = init$1;
	exports.log = log$2;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	/**
	* Colors.
	*/
	exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	/**
	* Build up the default `inspectOpts` object from the environment variables.
	*
	*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	*/
	exports.inspectOpts = Object.keys(process.env).filter(function(key) {
		return /^debug_/i.test(key);
	}).reduce(function(obj, key) {
		var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
			return k.toUpperCase();
		});
		var val = process.env[key];
		if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		else if (val === "null") val = null;
		else val = Number(val);
		obj[prop] = val;
		return obj;
	}, {});
	/**
	* The file descriptor to write the `debug()` calls to.
	* Set the `DEBUG_FD` env variable to override with another value. i.e.:
	*
	*   $ DEBUG_FD=3 node script.js 3>debug.log
	*/
	var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
	if (1 !== fd && 2 !== fd) util$1.deprecate(function() {}, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
	var stream$2 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
	/**
	* Is stdout a TTY? Colored output is enabled when `true`.
	*/
	function useColors() {
		return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
	}
	/**
	* Map %o to `util.inspect()`, all on a single line.
	*/
	exports.formatters.o = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$1.inspect(v, this.inspectOpts).split("\n").map(function(str) {
			return str.trim();
		}).join(" ");
	};
	/**
	* Map %o to `util.inspect()`, allowing multiple lines if needed.
	*/
	exports.formatters.O = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$1.inspect(v, this.inspectOpts);
	};
	/**
	* Adds ANSI color escape codes if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		var name = this.namespace;
		if (this.useColors) {
			var c = this.color;
			var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
			args[0] = prefix + args[0].split("\n").join("\n" + prefix);
			args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
	}
	/**
	* Invokes `util.format()` with the specified arguments and writes to `stream`.
	*/
	function log$2() {
		return stream$2.write(util$1.format.apply(util$1, arguments) + "\n");
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		if (null == namespaces) delete process.env.DEBUG;
		else process.env.DEBUG = namespaces;
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		return process.env.DEBUG;
	}
	/**
	* Copied from `node/src/node.js`.
	*
	* XXX: It's lame that node doesn't expose this API out-of-the-box. It also
	* relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
	*/
	function createWritableStdioStream(fd$1) {
		var stream$3;
		switch (process.binding("tty_wrap").guessHandleType(fd$1)) {
			case "TTY":
				stream$3 = new tty.WriteStream(fd$1);
				stream$3._type = "tty";
				if (stream$3._handle && stream$3._handle.unref) stream$3._handle.unref();
				break;
			case "FILE":
				stream$3 = new (__require("fs")).SyncWriteStream(fd$1, { autoClose: false });
				stream$3._type = "fs";
				break;
			case "PIPE":
			case "TCP":
				stream$3 = new (__require("net")).Socket({
					fd: fd$1,
					readable: false,
					writable: true
				});
				stream$3.readable = false;
				stream$3.read = null;
				stream$3._type = "pipe";
				if (stream$3._handle && stream$3._handle.unref) stream$3._handle.unref();
				break;
			default: throw new Error("Implement me. Unknown stream file type!");
		}
		stream$3.fd = fd$1;
		stream$3._isStdio = true;
		return stream$3;
	}
	/**
	* Init logic for `debug` instances.
	*
	* Create a new `inspectOpts` object in case `useColors` is set
	* differently for a particular `debug` instance.
	*/
	function init$1(debug$19) {
		debug$19.inspectOpts = {};
		var keys = Object.keys(exports.inspectOpts);
		for (var i$1 = 0; i$1 < keys.length; i$1++) debug$19.inspectOpts[keys[i$1]] = exports.inspectOpts[keys[i$1]];
	}
	/**
	* Enable namespaces listed in `process.env.DEBUG` initially.
	*/
	exports.enable(load());
}) });

//#endregion
//#region ../../node_modules/.pnpm/encodeurl@1.0.2/node_modules/encodeurl/index.js
var require_encodeurl = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/encodeurl@1.0.2/node_modules/encodeurl/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = encodeUrl$1;
	/**
	* RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
	* and including invalid escape sequences.
	* @private
	*/
	var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
	/**
	* RegExp to match unmatched surrogate pair.
	* @private
	*/
	var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
	/**
	* String to replace unmatched surrogate pair with.
	* @private
	*/
	var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1�$2";
	/**
	* Encode a URL to a percent-encoded form, excluding already-encoded sequences.
	*
	* This function will take an already-encoded URL and encode all the non-URL
	* code points. This function will not encode the "%" character unless it is
	* not part of a valid sequence (`%20` will be left as-is, but `%foo` will
	* be encoded as `%25foo`).
	*
	* This encode is meant to be "safe" and does not throw errors. It will try as
	* hard as it can to properly encode the given URL, including replacing any raw,
	* unpaired surrogate pairs with the Unicode replacement character prior to
	* encoding.
	*
	* @param {string} url
	* @return {string}
	* @public
	*/
	function encodeUrl$1(url$3) {
		return String(url$3).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js
var require_escape_html = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js": ((exports, module) => {
	/**
	* Module variables.
	* @private
	*/
	var matchHtmlRegExp = /["'&<>]/;
	/**
	* Module exports.
	* @public
	*/
	module.exports = escapeHtml$3;
	/**
	* Escape special characters in the given string of html.
	*
	* @param  {string} string The string to escape for inserting into HTML
	* @return {string}
	* @public
	*/
	function escapeHtml$3(string) {
		var str = "" + string;
		var match = matchHtmlRegExp.exec(str);
		if (!match) return str;
		var escape$2;
		var html = "";
		var index = 0;
		var lastIndex = 0;
		for (index = match.index; index < str.length; index++) {
			switch (str.charCodeAt(index)) {
				case 34:
					escape$2 = "&quot;";
					break;
				case 38:
					escape$2 = "&amp;";
					break;
				case 39:
					escape$2 = "&#39;";
					break;
				case 60:
					escape$2 = "&lt;";
					break;
				case 62:
					escape$2 = "&gt;";
					break;
				default: continue;
			}
			if (lastIndex !== index) html += str.substring(lastIndex, index);
			lastIndex = index + 1;
			html += escape$2;
		}
		return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/ee-first@1.1.1/node_modules/ee-first/index.js
var require_ee_first = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ee-first@1.1.1/node_modules/ee-first/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = first$1;
	/**
	* Get the first event in a set of event emitters and event pairs.
	*
	* @param {array} stuff
	* @param {function} done
	* @public
	*/
	function first$1(stuff, done) {
		if (!Array.isArray(stuff)) throw new TypeError("arg must be an array of [ee, events...] arrays");
		var cleanups = [];
		for (var i$1 = 0; i$1 < stuff.length; i$1++) {
			var arr = stuff[i$1];
			if (!Array.isArray(arr) || arr.length < 2) throw new TypeError("each array member must be [ee, events...]");
			var ee = arr[0];
			for (var j = 1; j < arr.length; j++) {
				var event = arr[j];
				var fn = listener(event, callback);
				ee.on(event, fn);
				cleanups.push({
					ee,
					event,
					fn
				});
			}
		}
		function callback() {
			cleanup();
			done.apply(null, arguments);
		}
		function cleanup() {
			var x;
			for (var i$2 = 0; i$2 < cleanups.length; i$2++) {
				x = cleanups[i$2];
				x.ee.removeListener(x.event, x.fn);
			}
		}
		function thunk(fn$1) {
			done = fn$1;
		}
		thunk.cancel = cleanup;
		return thunk;
	}
	/**
	* Create the event listener.
	* @private
	*/
	function listener(event, done) {
		return function onevent(arg1) {
			var args = new Array(arguments.length);
			var ee = this;
			var err$2 = event === "error" ? arg1 : null;
			for (var i$1 = 0; i$1 < args.length; i$1++) args[i$1] = arguments[i$1];
			done(err$2, ee, event, args);
		};
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/on-finished@2.3.0/node_modules/on-finished/index.js
var require_on_finished = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/on-finished@2.3.0/node_modules/on-finished/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = onFinished$1;
	module.exports.isFinished = isFinished$1;
	/**
	* Module dependencies.
	* @private
	*/
	var first = require_ee_first();
	/**
	* Variables.
	* @private
	*/
	/* istanbul ignore next */
	var defer$2 = typeof setImmediate === "function" ? setImmediate : function(fn) {
		process.nextTick(fn.bind.apply(fn, arguments));
	};
	/**
	* Invoke callback when the response has finished, useful for
	* cleaning up resources afterwards.
	*
	* @param {object} msg
	* @param {function} listener
	* @return {object}
	* @public
	*/
	function onFinished$1(msg, listener$1) {
		if (isFinished$1(msg) !== false) {
			defer$2(listener$1, null, msg);
			return msg;
		}
		attachListener(msg, listener$1);
		return msg;
	}
	/**
	* Determine if message is already finished.
	*
	* @param {object} msg
	* @return {boolean}
	* @public
	*/
	function isFinished$1(msg) {
		var socket = msg.socket;
		if (typeof msg.finished === "boolean") return Boolean(msg.finished || socket && !socket.writable);
		if (typeof msg.complete === "boolean") return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
	}
	/**
	* Attach a finished listener to the message.
	*
	* @param {object} msg
	* @param {function} callback
	* @private
	*/
	function attachFinishedListener(msg, callback) {
		var eeMsg;
		var eeSocket;
		var finished = false;
		function onFinish(error$1) {
			eeMsg.cancel();
			eeSocket.cancel();
			finished = true;
			callback(error$1);
		}
		eeMsg = eeSocket = first([[
			msg,
			"end",
			"finish"
		]], onFinish);
		function onSocket(socket) {
			msg.removeListener("socket", onSocket);
			if (finished) return;
			if (eeMsg !== eeSocket) return;
			eeSocket = first([[
				socket,
				"error",
				"close"
			]], onFinish);
		}
		if (msg.socket) {
			onSocket(msg.socket);
			return;
		}
		msg.on("socket", onSocket);
		if (msg.socket === void 0) patchAssignSocket(msg, onSocket);
	}
	/**
	* Attach the listener to the message.
	*
	* @param {object} msg
	* @return {function}
	* @private
	*/
	function attachListener(msg, listener$1) {
		var attached = msg.__onFinished;
		if (!attached || !attached.queue) {
			attached = msg.__onFinished = createListener(msg);
			attachFinishedListener(msg, attached);
		}
		attached.queue.push(listener$1);
	}
	/**
	* Create listener on message.
	*
	* @param {object} msg
	* @return {function}
	* @private
	*/
	function createListener(msg) {
		function listener$1(err$2) {
			if (msg.__onFinished === listener$1) msg.__onFinished = null;
			if (!listener$1.queue) return;
			var queue = listener$1.queue;
			listener$1.queue = null;
			for (var i$1 = 0; i$1 < queue.length; i$1++) queue[i$1](err$2, msg);
		}
		listener$1.queue = [];
		return listener$1;
	}
	/**
	* Patch ServerResponse.prototype.assignSocket for node.js 0.8.
	*
	* @param {ServerResponse} res
	* @param {function} callback
	* @private
	*/
	function patchAssignSocket(res, callback) {
		var assignSocket = res.assignSocket;
		if (typeof assignSocket !== "function") return;
		res.assignSocket = function _assignSocket(socket) {
			assignSocket.call(this, socket);
			callback(socket);
		};
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js
var require_parseurl = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var url$1 = __require("url");
	var parse$10 = url$1.parse;
	var Url = url$1.Url;
	/**
	* Module exports.
	* @public
	*/
	module.exports = parseurl;
	module.exports.original = originalurl;
	/**
	* Parse the `req` url with memoization.
	*
	* @param {ServerRequest} req
	* @return {Object}
	* @public
	*/
	function parseurl(req$4) {
		var url$3 = req$4.url;
		if (url$3 === void 0) return;
		var parsed = req$4._parsedUrl;
		if (fresh(url$3, parsed)) return parsed;
		parsed = fastparse(url$3);
		parsed._raw = url$3;
		return req$4._parsedUrl = parsed;
	}
	/**
	* Parse the `req` original url with fallback and memoization.
	*
	* @param {ServerRequest} req
	* @return {Object}
	* @public
	*/
	function originalurl(req$4) {
		var url$3 = req$4.originalUrl;
		if (typeof url$3 !== "string") return parseurl(req$4);
		var parsed = req$4._parsedOriginalUrl;
		if (fresh(url$3, parsed)) return parsed;
		parsed = fastparse(url$3);
		parsed._raw = url$3;
		return req$4._parsedOriginalUrl = parsed;
	}
	/**
	* Parse the `str` url with fast-path short-cut.
	*
	* @param {string} str
	* @return {Object}
	* @private
	*/
	function fastparse(str) {
		if (typeof str !== "string" || str.charCodeAt(0) !== 47) return parse$10(str);
		var pathname = str;
		var query = null;
		var search = null;
		for (var i$1 = 1; i$1 < str.length; i$1++) switch (str.charCodeAt(i$1)) {
			case 63:
				if (search === null) {
					pathname = str.substring(0, i$1);
					query = str.substring(i$1 + 1);
					search = str.substring(i$1);
				}
				break;
			case 9:
			case 10:
			case 12:
			case 13:
			case 32:
			case 35:
			case 160:
			case 65279: return parse$10(str);
		}
		var url$3 = Url !== void 0 ? new Url() : {};
		url$3.path = str;
		url$3.href = str;
		url$3.pathname = pathname;
		if (search !== null) {
			url$3.query = query;
			url$3.search = search;
		}
		return url$3;
	}
	/**
	* Determine if parsed is still fresh for url.
	*
	* @param {string} url
	* @param {object} parsedUrl
	* @return {boolean}
	* @private
	*/
	function fresh(url$3, parsedUrl) {
		return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url$3;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/statuses@1.5.0/node_modules/statuses/codes.json
var require_codes = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/statuses@1.5.0/node_modules/statuses/codes.json": ((exports, module) => {
	module.exports = {
		"100": "Continue",
		"101": "Switching Protocols",
		"102": "Processing",
		"103": "Early Hints",
		"200": "OK",
		"201": "Created",
		"202": "Accepted",
		"203": "Non-Authoritative Information",
		"204": "No Content",
		"205": "Reset Content",
		"206": "Partial Content",
		"207": "Multi-Status",
		"208": "Already Reported",
		"226": "IM Used",
		"300": "Multiple Choices",
		"301": "Moved Permanently",
		"302": "Found",
		"303": "See Other",
		"304": "Not Modified",
		"305": "Use Proxy",
		"306": "(Unused)",
		"307": "Temporary Redirect",
		"308": "Permanent Redirect",
		"400": "Bad Request",
		"401": "Unauthorized",
		"402": "Payment Required",
		"403": "Forbidden",
		"404": "Not Found",
		"405": "Method Not Allowed",
		"406": "Not Acceptable",
		"407": "Proxy Authentication Required",
		"408": "Request Timeout",
		"409": "Conflict",
		"410": "Gone",
		"411": "Length Required",
		"412": "Precondition Failed",
		"413": "Payload Too Large",
		"414": "URI Too Long",
		"415": "Unsupported Media Type",
		"416": "Range Not Satisfiable",
		"417": "Expectation Failed",
		"418": "I'm a teapot",
		"421": "Misdirected Request",
		"422": "Unprocessable Entity",
		"423": "Locked",
		"424": "Failed Dependency",
		"425": "Unordered Collection",
		"426": "Upgrade Required",
		"428": "Precondition Required",
		"429": "Too Many Requests",
		"431": "Request Header Fields Too Large",
		"451": "Unavailable For Legal Reasons",
		"500": "Internal Server Error",
		"501": "Not Implemented",
		"502": "Bad Gateway",
		"503": "Service Unavailable",
		"504": "Gateway Timeout",
		"505": "HTTP Version Not Supported",
		"506": "Variant Also Negotiates",
		"507": "Insufficient Storage",
		"508": "Loop Detected",
		"509": "Bandwidth Limit Exceeded",
		"510": "Not Extended",
		"511": "Network Authentication Required"
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/statuses@1.5.0/node_modules/statuses/index.js
var require_statuses = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/statuses@1.5.0/node_modules/statuses/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var codes = require_codes();
	/**
	* Module exports.
	* @public
	*/
	module.exports = status;
	status.STATUS_CODES = codes;
	status.codes = populateStatusesMap(status, codes);
	status.redirect = {
		300: true,
		301: true,
		302: true,
		303: true,
		305: true,
		307: true,
		308: true
	};
	status.empty = {
		204: true,
		205: true,
		304: true
	};
	status.retry = {
		502: true,
		503: true,
		504: true
	};
	/**
	* Populate the statuses map for given codes.
	* @private
	*/
	function populateStatusesMap(statuses$1, codes$2) {
		var arr = [];
		Object.keys(codes$2).forEach(function forEachCode(code) {
			var message = codes$2[code];
			var status$1 = Number(code);
			statuses$1[status$1] = message;
			statuses$1[message] = status$1;
			statuses$1[message.toLowerCase()] = status$1;
			arr.push(status$1);
		});
		return arr;
	}
	/**
	* Get the status code.
	*
	* Given a number, this will throw if it is not a known status
	* code, otherwise the code will be returned. Given a string,
	* the string will be parsed for a number and return the code
	* if valid, otherwise will lookup the code assuming this is
	* the status message.
	*
	* @param {string|number} code
	* @returns {number}
	* @public
	*/
	function status(code) {
		if (typeof code === "number") {
			if (!status[code]) throw new Error("invalid status code: " + code);
			return code;
		}
		if (typeof code !== "string") throw new TypeError("code must be a number or string");
		var n$2 = parseInt(code, 10);
		if (!isNaN(n$2)) {
			if (!status[n$2]) throw new Error("invalid status code: " + n$2);
			return n$2;
		}
		n$2 = status[code.toLowerCase()];
		if (!n$2) throw new Error("invalid status message: \"" + code + "\"");
		return n$2;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js
var require_unpipe = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = unpipe$1;
	/**
	* Determine if there are Node.js pipe-like data listeners.
	* @private
	*/
	function hasPipeDataListeners(stream$3) {
		var listeners = stream$3.listeners("data");
		for (var i$1 = 0; i$1 < listeners.length; i$1++) if (listeners[i$1].name === "ondata") return true;
		return false;
	}
	/**
	* Unpipe a stream from all destinations.
	*
	* @param {object} stream
	* @public
	*/
	function unpipe$1(stream$3) {
		if (!stream$3) throw new TypeError("argument stream is required");
		if (typeof stream$3.unpipe === "function") {
			stream$3.unpipe();
			return;
		}
		if (!hasPipeDataListeners(stream$3)) return;
		var listener$1;
		var listeners = stream$3.listeners("close");
		for (var i$1 = 0; i$1 < listeners.length; i$1++) {
			listener$1 = listeners[i$1];
			if (listener$1.name !== "cleanup" && listener$1.name !== "onclose") continue;
			listener$1.call(stream$3);
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/finalhandler@1.1.2/node_modules/finalhandler/index.js
var require_finalhandler = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/finalhandler@1.1.2/node_modules/finalhandler/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var debug$9 = require_node()("finalhandler");
	var encodeUrl = require_encodeurl();
	var escapeHtml$2 = require_escape_html();
	var onFinished = require_on_finished();
	var parseUrl$2 = require_parseurl();
	var statuses = require_statuses();
	var unpipe = require_unpipe();
	/**
	* Module variables.
	* @private
	*/
	var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
	var NEWLINE_REGEXP = /\n/g;
	/* istanbul ignore next */
	var defer$1 = typeof setImmediate === "function" ? setImmediate : function(fn) {
		process.nextTick(fn.bind.apply(fn, arguments));
	};
	var isFinished = onFinished.isFinished;
	/**
	* Create a minimal HTML document.
	*
	* @param {string} message
	* @private
	*/
	function createHtmlDocument(message) {
		return "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Error</title>\n</head>\n<body>\n<pre>" + escapeHtml$2(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;") + "</pre>\n</body>\n</html>\n";
	}
	/**
	* Module exports.
	* @public
	*/
	module.exports = finalhandler$1;
	/**
	* Create a function to handle the final response.
	*
	* @param {Request} req
	* @param {Response} res
	* @param {Object} [options]
	* @return {Function}
	* @public
	*/
	function finalhandler$1(req$4, res, options$1) {
		var opts = options$1 || {};
		var env$1 = opts.env || process.env.NODE_ENV || "development";
		var onerror = opts.onerror;
		return function(err$2) {
			var headers;
			var msg;
			var status$1;
			if (!err$2 && headersSent(res)) {
				debug$9("cannot 404 after headers sent");
				return;
			}
			if (err$2) {
				status$1 = getErrorStatusCode(err$2);
				if (status$1 === void 0) status$1 = getResponseStatusCode(res);
				else headers = getErrorHeaders(err$2);
				msg = getErrorMessage(err$2, status$1, env$1);
			} else {
				status$1 = 404;
				msg = "Cannot " + req$4.method + " " + encodeUrl(getResourceName(req$4));
			}
			debug$9("default %s", status$1);
			if (err$2 && onerror) defer$1(onerror, err$2, req$4, res);
			if (headersSent(res)) {
				debug$9("cannot %d after headers sent", status$1);
				req$4.socket.destroy();
				return;
			}
			send$2(req$4, res, status$1, headers, msg);
		};
	}
	/**
	* Get headers from Error object.
	*
	* @param {Error} err
	* @return {object}
	* @private
	*/
	function getErrorHeaders(err$2) {
		if (!err$2.headers || typeof err$2.headers !== "object") return;
		var headers = Object.create(null);
		var keys = Object.keys(err$2.headers);
		for (var i$1 = 0; i$1 < keys.length; i$1++) {
			var key = keys[i$1];
			headers[key] = err$2.headers[key];
		}
		return headers;
	}
	/**
	* Get message from Error object, fallback to status message.
	*
	* @param {Error} err
	* @param {number} status
	* @param {string} env
	* @return {string}
	* @private
	*/
	function getErrorMessage(err$2, status$1, env$1) {
		var msg;
		if (env$1 !== "production") {
			msg = err$2.stack;
			if (!msg && typeof err$2.toString === "function") msg = err$2.toString();
		}
		return msg || statuses[status$1];
	}
	/**
	* Get status code from Error object.
	*
	* @param {Error} err
	* @return {number}
	* @private
	*/
	function getErrorStatusCode(err$2) {
		if (typeof err$2.status === "number" && err$2.status >= 400 && err$2.status < 600) return err$2.status;
		if (typeof err$2.statusCode === "number" && err$2.statusCode >= 400 && err$2.statusCode < 600) return err$2.statusCode;
	}
	/**
	* Get resource name for the request.
	*
	* This is typically just the original pathname of the request
	* but will fallback to "resource" is that cannot be determined.
	*
	* @param {IncomingMessage} req
	* @return {string}
	* @private
	*/
	function getResourceName(req$4) {
		try {
			return parseUrl$2.original(req$4).pathname;
		} catch (e$1) {
			return "resource";
		}
	}
	/**
	* Get status code from response.
	*
	* @param {OutgoingMessage} res
	* @return {number}
	* @private
	*/
	function getResponseStatusCode(res) {
		var status$1 = res.statusCode;
		if (typeof status$1 !== "number" || status$1 < 400 || status$1 > 599) status$1 = 500;
		return status$1;
	}
	/**
	* Determine if the response headers have been sent.
	*
	* @param {object} res
	* @returns {boolean}
	* @private
	*/
	function headersSent(res) {
		return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
	}
	/**
	* Send response.
	*
	* @param {IncomingMessage} req
	* @param {OutgoingMessage} res
	* @param {number} status
	* @param {object} headers
	* @param {string} message
	* @private
	*/
	function send$2(req$4, res, status$1, headers, message) {
		function write() {
			var body = createHtmlDocument(message);
			res.statusCode = status$1;
			res.statusMessage = statuses[status$1];
			setHeaders(res, headers);
			res.setHeader("Content-Security-Policy", "default-src 'none'");
			res.setHeader("X-Content-Type-Options", "nosniff");
			res.setHeader("Content-Type", "text/html; charset=utf-8");
			res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
			if (req$4.method === "HEAD") {
				res.end();
				return;
			}
			res.end(body, "utf8");
		}
		if (isFinished(req$4)) {
			write();
			return;
		}
		unpipe(req$4);
		onFinished(req$4, write);
		req$4.resume();
	}
	/**
	* Set response headers from an object.
	*
	* @param {OutgoingMessage} res
	* @param {object} headers
	* @private
	*/
	function setHeaders(res, headers) {
		if (!headers) return;
		var keys = Object.keys(headers);
		for (var i$1 = 0; i$1 < keys.length; i$1++) {
			var key = keys[i$1];
			res.setHeader(key, headers[key]);
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/utils-merge@1.0.1/node_modules/utils-merge/index.js
var require_utils_merge = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/utils-merge@1.0.1/node_modules/utils-merge/index.js": ((exports, module) => {
	/**
	* Merge object b with object a.
	*
	*     var a = { foo: 'bar' }
	*       , b = { bar: 'baz' };
	*
	*     merge(a, b);
	*     // => { foo: 'bar', bar: 'baz' }
	*
	* @param {Object} a
	* @param {Object} b
	* @return {Object}
	* @api public
	*/
	exports = module.exports = function(a, b) {
		if (a && b) for (var key in b) a[key] = b[key];
		return a;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/connect@3.7.0/node_modules/connect/index.js
var require_connect = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/connect@3.7.0/node_modules/connect/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var debug$8 = require_node()("connect:dispatcher");
	var EventEmitter$4 = __require("events").EventEmitter;
	var finalhandler = require_finalhandler();
	var http$6 = __require("http");
	var merge = require_utils_merge();
	var parseUrl$1 = require_parseurl();
	/**
	* Module exports.
	* @public
	*/
	module.exports = createServer$3;
	/**
	* Module variables.
	* @private
	*/
	var env = process.env.NODE_ENV || "development";
	var proto = {};
	/* istanbul ignore next */
	var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
		process.nextTick(fn.bind.apply(fn, arguments));
	};
	/**
	* Create a new connect server.
	*
	* @return {function}
	* @public
	*/
	function createServer$3() {
		function app(req$4, res, next) {
			app.handle(req$4, res, next);
		}
		merge(app, proto);
		merge(app, EventEmitter$4.prototype);
		app.route = "/";
		app.stack = [];
		return app;
	}
	/**
	* Utilize the given middleware `handle` to the given `route`,
	* defaulting to _/_. This "route" is the mount-point for the
	* middleware, when given a value other than _/_ the middleware
	* is only effective when that segment is present in the request's
	* pathname.
	*
	* For example if we were to mount a function at _/admin_, it would
	* be invoked on _/admin_, and _/admin/settings_, however it would
	* not be invoked for _/_, or _/posts_.
	*
	* @param {String|Function|Server} route, callback or server
	* @param {Function|Server} callback or server
	* @return {Server} for chaining
	* @public
	*/
	proto.use = function use(route, fn) {
		var handle = fn;
		var path$13 = route;
		if (typeof route !== "string") {
			handle = route;
			path$13 = "/";
		}
		if (typeof handle.handle === "function") {
			var server = handle;
			server.route = path$13;
			handle = function(req$4, res, next) {
				server.handle(req$4, res, next);
			};
		}
		if (handle instanceof http$6.Server) handle = handle.listeners("request")[0];
		if (path$13[path$13.length - 1] === "/") path$13 = path$13.slice(0, -1);
		debug$8("use %s %s", path$13 || "/", handle.name || "anonymous");
		this.stack.push({
			route: path$13,
			handle
		});
		return this;
	};
	/**
	* Handle server requests, punting them down
	* the middleware stack.
	*
	* @private
	*/
	proto.handle = function handle(req$4, res, out) {
		var index = 0;
		var protohost = getProtohost(req$4.url) || "";
		var removed = "";
		var slashAdded = false;
		var stack = this.stack;
		var done = out || finalhandler(req$4, res, {
			env,
			onerror: logerror
		});
		req$4.originalUrl = req$4.originalUrl || req$4.url;
		function next(err$2) {
			if (slashAdded) {
				req$4.url = req$4.url.substr(1);
				slashAdded = false;
			}
			if (removed.length !== 0) {
				req$4.url = protohost + removed + req$4.url.substr(protohost.length);
				removed = "";
			}
			var layer = stack[index++];
			if (!layer) {
				defer(done, err$2);
				return;
			}
			var path$13 = parseUrl$1(req$4).pathname || "/";
			var route = layer.route;
			if (path$13.toLowerCase().substr(0, route.length) !== route.toLowerCase()) return next(err$2);
			var c = path$13.length > route.length && path$13[route.length];
			if (c && c !== "/" && c !== ".") return next(err$2);
			if (route.length !== 0 && route !== "/") {
				removed = route;
				req$4.url = protohost + req$4.url.substr(protohost.length + removed.length);
				if (!protohost && req$4.url[0] !== "/") {
					req$4.url = "/" + req$4.url;
					slashAdded = true;
				}
			}
			call(layer.handle, route, err$2, req$4, res, next);
		}
		next();
	};
	/**
	* Listen for connections.
	*
	* This method takes the same arguments
	* as node's `http.Server#listen()`.
	*
	* HTTP and HTTPS:
	*
	* If you run your application both as HTTP
	* and HTTPS you may wrap them individually,
	* since your Connect "server" is really just
	* a JavaScript `Function`.
	*
	*      var connect = require('connect')
	*        , http = require('http')
	*        , https = require('https');
	*
	*      var app = connect();
	*
	*      http.createServer(app).listen(80);
	*      https.createServer(options, app).listen(443);
	*
	* @return {http.Server}
	* @api public
	*/
	proto.listen = function listen() {
		var server = http$6.createServer(this);
		return server.listen.apply(server, arguments);
	};
	/**
	* Invoke a route handle.
	* @private
	*/
	function call(handle, route, err$2, req$4, res, next) {
		var arity = handle.length;
		var error$1 = err$2;
		var hasError = Boolean(err$2);
		debug$8("%s %s : %s", handle.name || "<anonymous>", route, req$4.originalUrl);
		try {
			if (hasError && arity === 4) {
				handle(err$2, req$4, res, next);
				return;
			} else if (!hasError && arity < 4) {
				handle(req$4, res, next);
				return;
			}
		} catch (e$1) {
			error$1 = e$1;
		}
		next(error$1);
	}
	/**
	* Log error using console.error.
	*
	* @param {Error} err
	* @private
	*/
	function logerror(err$2) {
		if (env !== "test") console.error(err$2.stack || err$2.toString());
	}
	/**
	* Get get protocol + host for a URL.
	*
	* @param {string} url
	* @private
	*/
	function getProtohost(url$3) {
		if (url$3.length === 0 || url$3[0] === "/") return;
		var fqdnIndex = url$3.indexOf("://");
		return fqdnIndex !== -1 && url$3.lastIndexOf("?", fqdnIndex) === -1 ? url$3.substr(0, url$3.indexOf("/", 3 + fqdnIndex)) : void 0;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js
var require_object_assign = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js": ((exports, module) => {
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	function toObject(val) {
		if (val === null || val === void 0) throw new TypeError("Object.assign cannot be called with null or undefined");
		return Object(val);
	}
	function shouldUseNative() {
		try {
			if (!Object.assign) return false;
			var test1 = /* @__PURE__ */ new String("abc");
			test1[5] = "de";
			if (Object.getOwnPropertyNames(test1)[0] === "5") return false;
			var test2 = {};
			for (var i$1 = 0; i$1 < 10; i$1++) test2["_" + String.fromCharCode(i$1)] = i$1;
			if (Object.getOwnPropertyNames(test2).map(function(n$2) {
				return test2[n$2];
			}).join("") !== "0123456789") return false;
			var test3 = {};
			"abcdefghijklmnopqrst".split("").forEach(function(letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") return false;
			return true;
		} catch (err$2) {
			return false;
		}
	}
	module.exports = shouldUseNative() ? Object.assign : function(target, source) {
		var from;
		var to = toObject(target);
		var symbols;
		for (var s$2 = 1; s$2 < arguments.length; s$2++) {
			from = Object(arguments[s$2]);
			for (var key in from) if (hasOwnProperty.call(from, key)) to[key] = from[key];
			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i$1 = 0; i$1 < symbols.length; i$1++) if (propIsEnumerable.call(from, symbols[i$1])) to[symbols[i$1]] = from[symbols[i$1]];
			}
		}
		return to;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/vary@1.1.2/node_modules/vary/index.js
var require_vary = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/vary@1.1.2/node_modules/vary/index.js": ((exports, module) => {
	/**
	* Module exports.
	*/
	module.exports = vary;
	module.exports.append = append$1;
	/**
	* RegExp to match field-name in RFC 7230 sec 3.2
	*
	* field-name    = token
	* token         = 1*tchar
	* tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	*               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	*               / DIGIT / ALPHA
	*               ; any VCHAR, except delimiters
	*/
	var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
	/**
	* Append a field to a vary header.
	*
	* @param {String} header
	* @param {String|Array} field
	* @return {String}
	* @public
	*/
	function append$1(header, field) {
		if (typeof header !== "string") throw new TypeError("header argument is required");
		if (!field) throw new TypeError("field argument is required");
		var fields = !Array.isArray(field) ? parse$9(String(field)) : field;
		for (var j = 0; j < fields.length; j++) if (!FIELD_NAME_REGEXP.test(fields[j])) throw new TypeError("field argument contains an invalid header name");
		if (header === "*") return header;
		var val = header;
		var vals = parse$9(header.toLowerCase());
		if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) return "*";
		for (var i$1 = 0; i$1 < fields.length; i$1++) {
			var fld = fields[i$1].toLowerCase();
			if (vals.indexOf(fld) === -1) {
				vals.push(fld);
				val = val ? val + ", " + fields[i$1] : fields[i$1];
			}
		}
		return val;
	}
	/**
	* Parse a vary header into an array.
	*
	* @param {String} header
	* @return {Array}
	* @private
	*/
	function parse$9(header) {
		var end = 0;
		var list = [];
		var start = 0;
		for (var i$1 = 0, len = header.length; i$1 < len; i$1++) switch (header.charCodeAt(i$1)) {
			case 32:
				if (start === end) start = end = i$1 + 1;
				break;
			case 44:
				list.push(header.substring(start, end));
				start = end = i$1 + 1;
				break;
			default:
				end = i$1 + 1;
				break;
		}
		list.push(header.substring(start, end));
		return list;
	}
	/**
	* Mark that a request is varied on a header field.
	*
	* @param {Object} res
	* @param {String|Array} field
	* @public
	*/
	function vary(res, field) {
		if (!res || !res.getHeader || !res.setHeader) throw new TypeError("res argument is required");
		var val = res.getHeader("Vary") || "";
		if (val = append$1(Array.isArray(val) ? val.join(", ") : String(val), field)) res.setHeader("Vary", val);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/cors@2.8.5/node_modules/cors/lib/index.js
var require_lib$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/cors@2.8.5/node_modules/cors/lib/index.js": ((exports, module) => {
	(function() {
		var assign = require_object_assign();
		var vary$1 = require_vary();
		var defaults = {
			origin: "*",
			methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
			preflightContinue: false,
			optionsSuccessStatus: 204
		};
		function isString$1(s$2) {
			return typeof s$2 === "string" || s$2 instanceof String;
		}
		function isOriginAllowed(origin, allowedOrigin) {
			if (Array.isArray(allowedOrigin)) {
				for (var i$1 = 0; i$1 < allowedOrigin.length; ++i$1) if (isOriginAllowed(origin, allowedOrigin[i$1])) return true;
				return false;
			} else if (isString$1(allowedOrigin)) return origin === allowedOrigin;
			else if (allowedOrigin instanceof RegExp) return allowedOrigin.test(origin);
			else return !!allowedOrigin;
		}
		function configureOrigin(options$1, req$4) {
			var requestOrigin = req$4.headers.origin, headers = [], isAllowed;
			if (!options$1.origin || options$1.origin === "*") headers.push([{
				key: "Access-Control-Allow-Origin",
				value: "*"
			}]);
			else if (isString$1(options$1.origin)) {
				headers.push([{
					key: "Access-Control-Allow-Origin",
					value: options$1.origin
				}]);
				headers.push([{
					key: "Vary",
					value: "Origin"
				}]);
			} else {
				isAllowed = isOriginAllowed(requestOrigin, options$1.origin);
				headers.push([{
					key: "Access-Control-Allow-Origin",
					value: isAllowed ? requestOrigin : false
				}]);
				headers.push([{
					key: "Vary",
					value: "Origin"
				}]);
			}
			return headers;
		}
		function configureMethods(options$1) {
			var methods = options$1.methods;
			if (methods.join) methods = options$1.methods.join(",");
			return {
				key: "Access-Control-Allow-Methods",
				value: methods
			};
		}
		function configureCredentials(options$1) {
			if (options$1.credentials === true) return {
				key: "Access-Control-Allow-Credentials",
				value: "true"
			};
			return null;
		}
		function configureAllowedHeaders(options$1, req$4) {
			var allowedHeaders = options$1.allowedHeaders || options$1.headers;
			var headers = [];
			if (!allowedHeaders) {
				allowedHeaders = req$4.headers["access-control-request-headers"];
				headers.push([{
					key: "Vary",
					value: "Access-Control-Request-Headers"
				}]);
			} else if (allowedHeaders.join) allowedHeaders = allowedHeaders.join(",");
			if (allowedHeaders && allowedHeaders.length) headers.push([{
				key: "Access-Control-Allow-Headers",
				value: allowedHeaders
			}]);
			return headers;
		}
		function configureExposedHeaders(options$1) {
			var headers = options$1.exposedHeaders;
			if (!headers) return null;
			else if (headers.join) headers = headers.join(",");
			if (headers && headers.length) return {
				key: "Access-Control-Expose-Headers",
				value: headers
			};
			return null;
		}
		function configureMaxAge(options$1) {
			var maxAge = (typeof options$1.maxAge === "number" || options$1.maxAge) && options$1.maxAge.toString();
			if (maxAge && maxAge.length) return {
				key: "Access-Control-Max-Age",
				value: maxAge
			};
			return null;
		}
		function applyHeaders(headers, res) {
			for (var i$1 = 0, n$2 = headers.length; i$1 < n$2; i$1++) {
				var header = headers[i$1];
				if (header) {
					if (Array.isArray(header)) applyHeaders(header, res);
					else if (header.key === "Vary" && header.value) vary$1(res, header.value);
					else if (header.value) res.setHeader(header.key, header.value);
				}
			}
		}
		function cors(options$1, req$4, res, next) {
			var headers = [];
			if ((req$4.method && req$4.method.toUpperCase && req$4.method.toUpperCase()) === "OPTIONS") {
				headers.push(configureOrigin(options$1, req$4));
				headers.push(configureCredentials(options$1, req$4));
				headers.push(configureMethods(options$1, req$4));
				headers.push(configureAllowedHeaders(options$1, req$4));
				headers.push(configureMaxAge(options$1, req$4));
				headers.push(configureExposedHeaders(options$1, req$4));
				applyHeaders(headers, res);
				if (options$1.preflightContinue) next();
				else {
					res.statusCode = options$1.optionsSuccessStatus;
					res.setHeader("Content-Length", "0");
					res.end();
				}
			} else {
				headers.push(configureOrigin(options$1, req$4));
				headers.push(configureCredentials(options$1, req$4));
				headers.push(configureExposedHeaders(options$1, req$4));
				applyHeaders(headers, res);
				next();
			}
		}
		function middlewareWrapper(o$1) {
			var optionsCallback = null;
			if (typeof o$1 === "function") optionsCallback = o$1;
			else optionsCallback = function(req$4, cb) {
				cb(null, o$1);
			};
			return function corsMiddleware$2(req$4, res, next) {
				optionsCallback(req$4, function(err$2, options$1) {
					if (err$2) next(err$2);
					else {
						var corsOptions = assign({}, defaults, options$1);
						var originCallback = null;
						if (corsOptions.origin && typeof corsOptions.origin === "function") originCallback = corsOptions.origin;
						else if (corsOptions.origin) originCallback = function(origin, cb) {
							cb(null, corsOptions.origin);
						};
						if (originCallback) originCallback(req$4.headers.origin, function(err2, origin) {
							if (err2 || !origin) next(err2);
							else {
								corsOptions.origin = origin;
								cors(corsOptions, req$4, res, next);
							}
						});
						else next();
					}
				});
			};
		}
		module.exports = middlewareWrapper;
	})();
}) });

//#endregion
//#region ../../node_modules/.pnpm/readdirp@3.6.0/node_modules/readdirp/index.js
var require_readdirp = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/readdirp@3.6.0/node_modules/readdirp/index.js": ((exports, module) => {
	const fs$9 = __require("fs");
	const { Readable: Readable$1 } = __require("stream");
	const sysPath$3 = __require("path");
	const { promisify: promisify$4 } = __require("util");
	const picomatch$2 = __require("picomatch");
	const readdir$1 = promisify$4(fs$9.readdir);
	const stat$3 = promisify$4(fs$9.stat);
	const lstat$2 = promisify$4(fs$9.lstat);
	const realpath$1 = promisify$4(fs$9.realpath);
	/**
	* @typedef {Object} EntryInfo
	* @property {String} path
	* @property {String} fullPath
	* @property {fs.Stats=} stats
	* @property {fs.Dirent=} dirent
	* @property {String} basename
	*/
	const BANG$2 = "!";
	const RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
	const NORMAL_FLOW_ERRORS = new Set([
		"ENOENT",
		"EPERM",
		"EACCES",
		"ELOOP",
		RECURSIVE_ERROR_CODE
	]);
	const FILE_TYPE = "files";
	const DIR_TYPE = "directories";
	const FILE_DIR_TYPE = "files_directories";
	const EVERYTHING_TYPE = "all";
	const ALL_TYPES = [
		FILE_TYPE,
		DIR_TYPE,
		FILE_DIR_TYPE,
		EVERYTHING_TYPE
	];
	const isNormalFlowError = (error$1) => NORMAL_FLOW_ERRORS.has(error$1.code);
	const [maj, min] = process.versions.node.split(".").slice(0, 2).map((n$2) => Number.parseInt(n$2, 10));
	const wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
	const normalizeFilter$1 = (filter$1) => {
		if (filter$1 === void 0) return;
		if (typeof filter$1 === "function") return filter$1;
		if (typeof filter$1 === "string") {
			const glob$1 = picomatch$2(filter$1.trim());
			return (entry) => glob$1(entry.basename);
		}
		if (Array.isArray(filter$1)) {
			const positive = [];
			const negative = [];
			for (const item of filter$1) {
				const trimmed = item.trim();
				if (trimmed.charAt(0) === BANG$2) negative.push(picomatch$2(trimmed.slice(1)));
				else positive.push(picomatch$2(trimmed));
			}
			if (negative.length > 0) {
				if (positive.length > 0) return (entry) => positive.some((f$1) => f$1(entry.basename)) && !negative.some((f$1) => f$1(entry.basename));
				return (entry) => !negative.some((f$1) => f$1(entry.basename));
			}
			return (entry) => positive.some((f$1) => f$1(entry.basename));
		}
	};
	var ReaddirpStream = class ReaddirpStream extends Readable$1 {
		static get defaultOptions() {
			return {
				root: ".",
				fileFilter: (path$13) => true,
				directoryFilter: (path$13) => true,
				type: FILE_TYPE,
				lstat: false,
				depth: 2147483648,
				alwaysStat: false
			};
		}
		constructor(options$1 = {}) {
			super({
				objectMode: true,
				autoDestroy: true,
				highWaterMark: options$1.highWaterMark || 4096
			});
			const opts = {
				...ReaddirpStream.defaultOptions,
				...options$1
			};
			const { root, type } = opts;
			this._fileFilter = normalizeFilter$1(opts.fileFilter);
			this._directoryFilter = normalizeFilter$1(opts.directoryFilter);
			const statMethod = opts.lstat ? lstat$2 : stat$3;
			if (wantBigintFsStats) this._stat = (path$13) => statMethod(path$13, { bigint: true });
			else this._stat = statMethod;
			this._maxDepth = opts.depth;
			this._wantsDir = [
				DIR_TYPE,
				FILE_DIR_TYPE,
				EVERYTHING_TYPE
			].includes(type);
			this._wantsFile = [
				FILE_TYPE,
				FILE_DIR_TYPE,
				EVERYTHING_TYPE
			].includes(type);
			this._wantsEverything = type === EVERYTHING_TYPE;
			this._root = sysPath$3.resolve(root);
			this._isDirent = "Dirent" in fs$9 && !opts.alwaysStat;
			this._statsProp = this._isDirent ? "dirent" : "stats";
			this._rdOptions = {
				encoding: "utf8",
				withFileTypes: this._isDirent
			};
			this.parents = [this._exploreDir(root, 1)];
			this.reading = false;
			this.parent = void 0;
		}
		async _read(batch) {
			if (this.reading) return;
			this.reading = true;
			try {
				while (!this.destroyed && batch > 0) {
					const { path: path$13, depth, files = [] } = this.parent || {};
					if (files.length > 0) {
						const slice = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path$13));
						for (const entry of await Promise.all(slice)) {
							if (this.destroyed) return;
							const entryType = await this._getEntryType(entry);
							if (entryType === "directory" && this._directoryFilter(entry)) {
								if (depth <= this._maxDepth) this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
								if (this._wantsDir) {
									this.push(entry);
									batch--;
								}
							} else if ((entryType === "file" || this._includeAsFile(entry)) && this._fileFilter(entry)) {
								if (this._wantsFile) {
									this.push(entry);
									batch--;
								}
							}
						}
					} else {
						const parent = this.parents.pop();
						if (!parent) {
							this.push(null);
							break;
						}
						this.parent = await parent;
						if (this.destroyed) return;
					}
				}
			} catch (error$1) {
				this.destroy(error$1);
			} finally {
				this.reading = false;
			}
		}
		async _exploreDir(path$13, depth) {
			let files;
			try {
				files = await readdir$1(path$13, this._rdOptions);
			} catch (error$1) {
				this._onError(error$1);
			}
			return {
				files,
				depth,
				path: path$13
			};
		}
		async _formatEntry(dirent, path$13) {
			let entry;
			try {
				const basename$3 = this._isDirent ? dirent.name : dirent;
				const fullPath = sysPath$3.resolve(sysPath$3.join(path$13, basename$3));
				entry = {
					path: sysPath$3.relative(this._root, fullPath),
					fullPath,
					basename: basename$3
				};
				entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
			} catch (err$2) {
				this._onError(err$2);
			}
			return entry;
		}
		_onError(err$2) {
			if (isNormalFlowError(err$2) && !this.destroyed) this.emit("warn", err$2);
			else this.destroy(err$2);
		}
		async _getEntryType(entry) {
			const stats = entry && entry[this._statsProp];
			if (!stats) return;
			if (stats.isFile()) return "file";
			if (stats.isDirectory()) return "directory";
			if (stats && stats.isSymbolicLink()) {
				const full = entry.fullPath;
				try {
					const entryRealPath = await realpath$1(full);
					const entryRealPathStats = await lstat$2(entryRealPath);
					if (entryRealPathStats.isFile()) return "file";
					if (entryRealPathStats.isDirectory()) {
						const len = entryRealPath.length;
						if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {
							const recursiveError = /* @__PURE__ */ new Error(`Circular symlink detected: "${full}" points to "${entryRealPath}"`);
							recursiveError.code = RECURSIVE_ERROR_CODE;
							return this._onError(recursiveError);
						}
						return "directory";
					}
				} catch (error$1) {
					this._onError(error$1);
				}
			}
		}
		_includeAsFile(entry) {
			const stats = entry && entry[this._statsProp];
			return stats && this._wantsEverything && !stats.isDirectory();
		}
	};
	/**
	* @typedef {Object} ReaddirpArguments
	* @property {Function=} fileFilter
	* @property {Function=} directoryFilter
	* @property {String=} type
	* @property {Number=} depth
	* @property {String=} root
	* @property {Boolean=} lstat
	* @property {Boolean=} bigint
	*/
	/**
	* Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
	* @param {String} root Root directory
	* @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth
	*/
	const readdirp$1 = (root, options$1 = {}) => {
		let type = options$1.entryType || options$1.type;
		if (type === "both") type = FILE_DIR_TYPE;
		if (type) options$1.type = type;
		if (!root) throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
		else if (typeof root !== "string") throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
		else if (type && !ALL_TYPES.includes(type)) throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
		options$1.root = root;
		return new ReaddirpStream(options$1);
	};
	const readdirpPromise = (root, options$1 = {}) => {
		return new Promise((resolve$4, reject) => {
			const files = [];
			readdirp$1(root, options$1).on("data", (entry) => files.push(entry)).on("end", () => resolve$4(files)).on("error", (error$1) => reject(error$1));
		});
	};
	readdirp$1.promise = readdirpPromise;
	readdirp$1.ReaddirpStream = ReaddirpStream;
	readdirp$1.default = readdirp$1;
	module.exports = readdirp$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js
var require_normalize_path = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js": ((exports, module) => {
	/*!
	* normalize-path <https://github.com/jonschlinkert/normalize-path>
	*
	* Copyright (c) 2014-2018, Jon Schlinkert.
	* Released under the MIT License.
	*/
	module.exports = function(path$13, stripTrailing) {
		if (typeof path$13 !== "string") throw new TypeError("expected path to be a string");
		if (path$13 === "\\" || path$13 === "/") return "/";
		var len = path$13.length;
		if (len <= 1) return path$13;
		var prefix = "";
		if (len > 4 && path$13[3] === "\\") {
			var ch = path$13[2];
			if ((ch === "?" || ch === ".") && path$13.slice(0, 2) === "\\\\") {
				path$13 = path$13.slice(2);
				prefix = "//";
			}
		}
		var segs = path$13.split(/[/\\]+/);
		if (stripTrailing !== false && segs[segs.length - 1] === "") segs.pop();
		return prefix + segs.join("/");
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/anymatch@3.1.3/node_modules/anymatch/index.js
var require_anymatch = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/anymatch@3.1.3/node_modules/anymatch/index.js": ((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const picomatch$1 = __require("picomatch");
	const normalizePath$2 = require_normalize_path();
	/**
	* @typedef {(testString: string) => boolean} AnymatchFn
	* @typedef {string|RegExp|AnymatchFn} AnymatchPattern
	* @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher
	*/
	const BANG$1 = "!";
	const DEFAULT_OPTIONS = { returnIndex: false };
	const arrify$1 = (item) => Array.isArray(item) ? item : [item];
	/**
	* @param {AnymatchPattern} matcher
	* @param {object} options
	* @returns {AnymatchFn}
	*/
	const createPattern = (matcher, options$1) => {
		if (typeof matcher === "function") return matcher;
		if (typeof matcher === "string") {
			const glob$1 = picomatch$1(matcher, options$1);
			return (string) => matcher === string || glob$1(string);
		}
		if (matcher instanceof RegExp) return (string) => matcher.test(string);
		return (string) => false;
	};
	/**
	* @param {Array<Function>} patterns
	* @param {Array<Function>} negPatterns
	* @param {String|Array} args
	* @param {Boolean} returnIndex
	* @returns {boolean|number}
	*/
	const matchPatterns = (patterns, negPatterns, args, returnIndex) => {
		const isList = Array.isArray(args);
		const _path = isList ? args[0] : args;
		if (!isList && typeof _path !== "string") throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
		const path$13 = normalizePath$2(_path, false);
		for (let index = 0; index < negPatterns.length; index++) {
			const nglob = negPatterns[index];
			if (nglob(path$13)) return returnIndex ? -1 : false;
		}
		const applied = isList && [path$13].concat(args.slice(1));
		for (let index = 0; index < patterns.length; index++) {
			const pattern = patterns[index];
			if (isList ? pattern(...applied) : pattern(path$13)) return returnIndex ? index : true;
		}
		return returnIndex ? -1 : false;
	};
	/**
	* @param {AnymatchMatcher} matchers
	* @param {Array|string} testString
	* @param {object} options
	* @returns {boolean|number|Function}
	*/
	const anymatch$1 = (matchers, testString, options$1 = DEFAULT_OPTIONS) => {
		if (matchers == null) throw new TypeError("anymatch: specify first argument");
		const opts = typeof options$1 === "boolean" ? { returnIndex: options$1 } : options$1;
		const returnIndex = opts.returnIndex || false;
		const mtchers = arrify$1(matchers);
		const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG$1).map((item) => item.slice(1)).map((item) => picomatch$1(item, opts));
		const patterns = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG$1).map((matcher) => createPattern(matcher, opts));
		if (testString == null) return (testString$1, ri = false) => {
			return matchPatterns(patterns, negatedGlobs, testString$1, typeof ri === "boolean" ? ri : false);
		};
		return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
	};
	anymatch$1.default = anymatch$1;
	module.exports = anymatch$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js
var require_is_extglob = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js": ((exports, module) => {
	/*!
	* is-extglob <https://github.com/jonschlinkert/is-extglob>
	*
	* Copyright (c) 2014-2016, Jon Schlinkert.
	* Licensed under the MIT License.
	*/
	module.exports = function isExtglob$1(str) {
		if (typeof str !== "string" || str === "") return false;
		var match;
		while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
			if (match[2]) return true;
			str = str.slice(match.index + match[0].length);
		}
		return false;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js
var require_is_glob = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js": ((exports, module) => {
	/*!
	* is-glob <https://github.com/jonschlinkert/is-glob>
	*
	* Copyright (c) 2014-2017, Jon Schlinkert.
	* Released under the MIT License.
	*/
	var isExtglob = require_is_extglob();
	var chars = {
		"{": "}",
		"(": ")",
		"[": "]"
	};
	var strictCheck = function(str) {
		if (str[0] === "!") return true;
		var index = 0;
		var pipeIndex = -2;
		var closeSquareIndex = -2;
		var closeCurlyIndex = -2;
		var closeParenIndex = -2;
		var backSlashIndex = -2;
		while (index < str.length) {
			if (str[index] === "*") return true;
			if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) return true;
			if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
				if (closeSquareIndex < index) closeSquareIndex = str.indexOf("]", index);
				if (closeSquareIndex > index) {
					if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) return true;
					backSlashIndex = str.indexOf("\\", index);
					if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) return true;
				}
			}
			if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
				closeCurlyIndex = str.indexOf("}", index);
				if (closeCurlyIndex > index) {
					backSlashIndex = str.indexOf("\\", index);
					if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) return true;
				}
			}
			if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
				closeParenIndex = str.indexOf(")", index);
				if (closeParenIndex > index) {
					backSlashIndex = str.indexOf("\\", index);
					if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) return true;
				}
			}
			if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
				if (pipeIndex < index) pipeIndex = str.indexOf("|", index);
				if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
					closeParenIndex = str.indexOf(")", pipeIndex);
					if (closeParenIndex > pipeIndex) {
						backSlashIndex = str.indexOf("\\", pipeIndex);
						if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) return true;
					}
				}
			}
			if (str[index] === "\\") {
				var open$2 = str[index + 1];
				index += 2;
				var close$1 = chars[open$2];
				if (close$1) {
					var n$2 = str.indexOf(close$1, index);
					if (n$2 !== -1) index = n$2 + 1;
				}
				if (str[index] === "!") return true;
			} else index++;
		}
		return false;
	};
	var relaxedCheck = function(str) {
		if (str[0] === "!") return true;
		var index = 0;
		while (index < str.length) {
			if (/[*?{}()[\]]/.test(str[index])) return true;
			if (str[index] === "\\") {
				var open$2 = str[index + 1];
				index += 2;
				var close$1 = chars[open$2];
				if (close$1) {
					var n$2 = str.indexOf(close$1, index);
					if (n$2 !== -1) index = n$2 + 1;
				}
				if (str[index] === "!") return true;
			} else index++;
		}
		return false;
	};
	module.exports = function isGlob$2(str, options$1) {
		if (typeof str !== "string" || str === "") return false;
		if (isExtglob(str)) return true;
		var check = strictCheck;
		if (options$1 && options$1.strict === false) check = relaxedCheck;
		return check(str);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js
var require_glob_parent = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js": ((exports, module) => {
	var isGlob$1 = require_is_glob();
	var pathPosixDirname = __require("path").posix.dirname;
	var isWin32 = __require("os").platform() === "win32";
	var slash$1 = "/";
	var backslash = /\\/g;
	var enclosure = /[\{\[].*[\}\]]$/;
	var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
	var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
	/**
	* @param {string} str
	* @param {Object} opts
	* @param {boolean} [opts.flipBackslashes=true]
	* @returns {string}
	*/
	module.exports = function globParent$1(str, opts) {
		if (Object.assign({ flipBackslashes: true }, opts).flipBackslashes && isWin32 && str.indexOf(slash$1) < 0) str = str.replace(backslash, slash$1);
		if (enclosure.test(str)) str += slash$1;
		str += "a";
		do
			str = pathPosixDirname(str);
		while (isGlob$1(str) || globby.test(str));
		return str.replace(escaped, "$1");
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/utils.js
var require_utils = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/utils.js": ((exports) => {
	exports.isInteger = (num) => {
		if (typeof num === "number") return Number.isInteger(num);
		if (typeof num === "string" && num.trim() !== "") return Number.isInteger(Number(num));
		return false;
	};
	/**
	* Find a node of the given type
	*/
	exports.find = (node, type) => node.nodes.find((node$1) => node$1.type === type);
	/**
	* Find a node of the given type
	*/
	exports.exceedsLimit = (min$1, max, step = 1, limit) => {
		if (limit === false) return false;
		if (!exports.isInteger(min$1) || !exports.isInteger(max)) return false;
		return (Number(max) - Number(min$1)) / Number(step) >= limit;
	};
	/**
	* Escape the given node with '\\' before node.value
	*/
	exports.escapeNode = (block, n$2 = 0, type) => {
		const node = block.nodes[n$2];
		if (!node) return;
		if (type && node.type === type || node.type === "open" || node.type === "close") {
			if (node.escaped !== true) {
				node.value = "\\" + node.value;
				node.escaped = true;
			}
		}
	};
	/**
	* Returns true if the given brace node should be enclosed in literal braces
	*/
	exports.encloseBrace = (node) => {
		if (node.type !== "brace") return false;
		if (node.commas >> 0 + node.ranges >> 0 === 0) {
			node.invalid = true;
			return true;
		}
		return false;
	};
	/**
	* Returns true if a brace node is invalid.
	*/
	exports.isInvalidBrace = (block) => {
		if (block.type !== "brace") return false;
		if (block.invalid === true || block.dollar) return true;
		if (block.commas >> 0 + block.ranges >> 0 === 0) {
			block.invalid = true;
			return true;
		}
		if (block.open !== true || block.close !== true) {
			block.invalid = true;
			return true;
		}
		return false;
	};
	/**
	* Returns true if a node is an open or close node
	*/
	exports.isOpenOrClose = (node) => {
		if (node.type === "open" || node.type === "close") return true;
		return node.open === true || node.close === true;
	};
	/**
	* Reduce an array of text nodes.
	*/
	exports.reduce = (nodes) => nodes.reduce((acc, node) => {
		if (node.type === "text") acc.push(node.value);
		if (node.type === "range") node.type = "text";
		return acc;
	}, []);
	/**
	* Flatten an array
	*/
	exports.flatten = (...args) => {
		const result = [];
		const flat = (arr) => {
			for (let i$1 = 0; i$1 < arr.length; i$1++) {
				const ele = arr[i$1];
				if (Array.isArray(ele)) {
					flat(ele);
					continue;
				}
				if (ele !== void 0) result.push(ele);
			}
			return result;
		};
		flat(args);
		return result;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/stringify.js
var require_stringify = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/stringify.js": ((exports, module) => {
	const utils$2 = require_utils();
	module.exports = (ast, options$1 = {}) => {
		const stringify$5 = (node, parent = {}) => {
			const invalidBlock = options$1.escapeInvalid && utils$2.isInvalidBrace(parent);
			const invalidNode = node.invalid === true && options$1.escapeInvalid === true;
			let output = "";
			if (node.value) {
				if ((invalidBlock || invalidNode) && utils$2.isOpenOrClose(node)) return "\\" + node.value;
				return node.value;
			}
			if (node.value) return node.value;
			if (node.nodes) for (const child of node.nodes) output += stringify$5(child);
			return output;
		};
		return stringify$5(ast);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js
var require_is_number = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js": ((exports, module) => {
	module.exports = function(num) {
		if (typeof num === "number") return num - num === 0;
		if (typeof num === "string" && num.trim() !== "") return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
		return false;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js
var require_to_regex_range = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js": ((exports, module) => {
	const isNumber$1 = require_is_number();
	const toRegexRange$1 = (min$1, max, options$1) => {
		if (isNumber$1(min$1) === false) throw new TypeError("toRegexRange: expected the first argument to be a number");
		if (max === void 0 || min$1 === max) return String(min$1);
		if (isNumber$1(max) === false) throw new TypeError("toRegexRange: expected the second argument to be a number.");
		let opts = {
			relaxZeros: true,
			...options$1
		};
		if (typeof opts.strictZeros === "boolean") opts.relaxZeros = opts.strictZeros === false;
		let relax = String(opts.relaxZeros);
		let shorthand = String(opts.shorthand);
		let capture = String(opts.capture);
		let wrap$1 = String(opts.wrap);
		let cacheKey = min$1 + ":" + max + "=" + relax + shorthand + capture + wrap$1;
		if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) return toRegexRange$1.cache[cacheKey].result;
		let a = Math.min(min$1, max);
		let b = Math.max(min$1, max);
		if (Math.abs(a - b) === 1) {
			let result = min$1 + "|" + max;
			if (opts.capture) return `(${result})`;
			if (opts.wrap === false) return result;
			return `(?:${result})`;
		}
		let isPadded = hasPadding(min$1) || hasPadding(max);
		let state = {
			min: min$1,
			max,
			a,
			b
		};
		let positives = [];
		let negatives = [];
		if (isPadded) {
			state.isPadded = isPadded;
			state.maxLen = String(state.max).length;
		}
		if (a < 0) {
			negatives = splitToPatterns(b < 0 ? Math.abs(b) : 1, Math.abs(a), state, opts);
			a = state.a = 0;
		}
		if (b >= 0) positives = splitToPatterns(a, b, state, opts);
		state.negatives = negatives;
		state.positives = positives;
		state.result = collatePatterns(negatives, positives, opts);
		if (opts.capture === true) state.result = `(${state.result})`;
		else if (opts.wrap !== false && positives.length + negatives.length > 1) state.result = `(?:${state.result})`;
		toRegexRange$1.cache[cacheKey] = state;
		return state.result;
	};
	function collatePatterns(neg, pos, options$1) {
		let onlyNegative = filterPatterns(neg, pos, "-", false, options$1) || [];
		let onlyPositive = filterPatterns(pos, neg, "", false, options$1) || [];
		let intersected = filterPatterns(neg, pos, "-?", true, options$1) || [];
		return onlyNegative.concat(intersected).concat(onlyPositive).join("|");
	}
	function splitToRanges(min$1, max) {
		let nines = 1;
		let zeros$1 = 1;
		let stop = countNines(min$1, nines);
		let stops = new Set([max]);
		while (min$1 <= stop && stop <= max) {
			stops.add(stop);
			nines += 1;
			stop = countNines(min$1, nines);
		}
		stop = countZeros(max + 1, zeros$1) - 1;
		while (min$1 < stop && stop <= max) {
			stops.add(stop);
			zeros$1 += 1;
			stop = countZeros(max + 1, zeros$1) - 1;
		}
		stops = [...stops];
		stops.sort(compare);
		return stops;
	}
	/**
	* Convert a range to a regex pattern
	* @param {Number} `start`
	* @param {Number} `stop`
	* @return {String}
	*/
	function rangeToPattern(start, stop, options$1) {
		if (start === stop) return {
			pattern: start,
			count: [],
			digits: 0
		};
		let zipped = zip(start, stop);
		let digits = zipped.length;
		let pattern = "";
		let count = 0;
		for (let i$1 = 0; i$1 < digits; i$1++) {
			let [startDigit, stopDigit] = zipped[i$1];
			if (startDigit === stopDigit) pattern += startDigit;
			else if (startDigit !== "0" || stopDigit !== "9") pattern += toCharacterClass(startDigit, stopDigit, options$1);
			else count++;
		}
		if (count) pattern += options$1.shorthand === true ? "\\d" : "[0-9]";
		return {
			pattern,
			count: [count],
			digits
		};
	}
	function splitToPatterns(min$1, max, tok, options$1) {
		let ranges = splitToRanges(min$1, max);
		let tokens = [];
		let start = min$1;
		let prev;
		for (let i$1 = 0; i$1 < ranges.length; i$1++) {
			let max$1 = ranges[i$1];
			let obj = rangeToPattern(String(start), String(max$1), options$1);
			let zeros$1 = "";
			if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
				if (prev.count.length > 1) prev.count.pop();
				prev.count.push(obj.count[0]);
				prev.string = prev.pattern + toQuantifier(prev.count);
				start = max$1 + 1;
				continue;
			}
			if (tok.isPadded) zeros$1 = padZeros(max$1, tok, options$1);
			obj.string = zeros$1 + obj.pattern + toQuantifier(obj.count);
			tokens.push(obj);
			start = max$1 + 1;
			prev = obj;
		}
		return tokens;
	}
	function filterPatterns(arr, comparison, prefix, intersection, options$1) {
		let result = [];
		for (let ele of arr) {
			let { string } = ele;
			if (!intersection && !contains(comparison, "string", string)) result.push(prefix + string);
			if (intersection && contains(comparison, "string", string)) result.push(prefix + string);
		}
		return result;
	}
	/**
	* Zip strings
	*/
	function zip(a, b) {
		let arr = [];
		for (let i$1 = 0; i$1 < a.length; i$1++) arr.push([a[i$1], b[i$1]]);
		return arr;
	}
	function compare(a, b) {
		return a > b ? 1 : b > a ? -1 : 0;
	}
	function contains(arr, key, val) {
		return arr.some((ele) => ele[key] === val);
	}
	function countNines(min$1, len) {
		return Number(String(min$1).slice(0, -len) + "9".repeat(len));
	}
	function countZeros(integer, zeros$1) {
		return integer - integer % Math.pow(10, zeros$1);
	}
	function toQuantifier(digits) {
		let [start = 0, stop = ""] = digits;
		if (stop || start > 1) return `{${start + (stop ? "," + stop : "")}}`;
		return "";
	}
	function toCharacterClass(a, b, options$1) {
		return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
	}
	function hasPadding(str) {
		return /^-?(0+)\d/.test(str);
	}
	function padZeros(value$1, tok, options$1) {
		if (!tok.isPadded) return value$1;
		let diff = Math.abs(tok.maxLen - String(value$1).length);
		let relax = options$1.relaxZeros !== false;
		switch (diff) {
			case 0: return "";
			case 1: return relax ? "0?" : "0";
			case 2: return relax ? "0{0,2}" : "00";
			default: return relax ? `0{0,${diff}}` : `0{${diff}}`;
		}
	}
	/**
	* Cache
	*/
	toRegexRange$1.cache = {};
	toRegexRange$1.clearCache = () => toRegexRange$1.cache = {};
	/**
	* Expose `toRegexRange`
	*/
	module.exports = toRegexRange$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/fill-range@7.1.1/node_modules/fill-range/index.js
var require_fill_range = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fill-range@7.1.1/node_modules/fill-range/index.js": ((exports, module) => {
	const util = __require("util");
	const toRegexRange = require_to_regex_range();
	const isObject$1 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
	const transform$1 = (toNumber) => {
		return (value$1) => toNumber === true ? Number(value$1) : String(value$1);
	};
	const isValidValue = (value$1) => {
		return typeof value$1 === "number" || typeof value$1 === "string" && value$1 !== "";
	};
	const isNumber = (num) => Number.isInteger(+num);
	const zeros = (input) => {
		let value$1 = `${input}`;
		let index = -1;
		if (value$1[0] === "-") value$1 = value$1.slice(1);
		if (value$1 === "0") return false;
		while (value$1[++index] === "0");
		return index > 0;
	};
	const stringify$3 = (start, end, options$1) => {
		if (typeof start === "string" || typeof end === "string") return true;
		return options$1.stringify === true;
	};
	const pad = (input, maxLength, toNumber) => {
		if (maxLength > 0) {
			let dash = input[0] === "-" ? "-" : "";
			if (dash) input = input.slice(1);
			input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
		}
		if (toNumber === false) return String(input);
		return input;
	};
	const toMaxLen = (input, maxLength) => {
		let negative = input[0] === "-" ? "-" : "";
		if (negative) {
			input = input.slice(1);
			maxLength--;
		}
		while (input.length < maxLength) input = "0" + input;
		return negative ? "-" + input : input;
	};
	const toSequence = (parts, options$1, maxLen) => {
		parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
		parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
		let prefix = options$1.capture ? "" : "?:";
		let positives = "";
		let negatives = "";
		let result;
		if (parts.positives.length) positives = parts.positives.map((v) => toMaxLen(String(v), maxLen)).join("|");
		if (parts.negatives.length) negatives = `-(${prefix}${parts.negatives.map((v) => toMaxLen(String(v), maxLen)).join("|")})`;
		if (positives && negatives) result = `${positives}|${negatives}`;
		else result = positives || negatives;
		if (options$1.wrap) return `(${prefix}${result})`;
		return result;
	};
	const toRange = (a, b, isNumbers, options$1) => {
		if (isNumbers) return toRegexRange(a, b, {
			wrap: false,
			...options$1
		});
		let start = String.fromCharCode(a);
		if (a === b) return start;
		return `[${start}-${String.fromCharCode(b)}]`;
	};
	const toRegex = (start, end, options$1) => {
		if (Array.isArray(start)) return options$1.wrap === true ? `(${options$1.capture ? "" : "?:"}${start.join("|")})` : start.join("|");
		return toRegexRange(start, end, options$1);
	};
	const rangeError = (...args) => {
		return /* @__PURE__ */ new RangeError("Invalid range arguments: " + util.inspect(...args));
	};
	const invalidRange = (start, end, options$1) => {
		if (options$1.strictRanges === true) throw rangeError([start, end]);
		return [];
	};
	const invalidStep = (step, options$1) => {
		if (options$1.strictRanges === true) throw new TypeError(`Expected step "${step}" to be a number`);
		return [];
	};
	const fillNumbers = (start, end, step = 1, options$1 = {}) => {
		let a = Number(start);
		let b = Number(end);
		if (!Number.isInteger(a) || !Number.isInteger(b)) {
			if (options$1.strictRanges === true) throw rangeError([start, end]);
			return [];
		}
		if (a === 0) a = 0;
		if (b === 0) b = 0;
		let descending = a > b;
		let startString = String(start);
		let endString = String(end);
		let stepString = String(step);
		step = Math.max(Math.abs(step), 1);
		let padded = zeros(startString) || zeros(endString) || zeros(stepString);
		let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
		let toNumber = padded === false && stringify$3(start, end, options$1) === false;
		let format$3 = options$1.transform || transform$1(toNumber);
		if (options$1.toRegex && step === 1) return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options$1);
		let parts = {
			negatives: [],
			positives: []
		};
		let push$1 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
		let range$1 = [];
		let index = 0;
		while (descending ? a >= b : a <= b) {
			if (options$1.toRegex === true && step > 1) push$1(a);
			else range$1.push(pad(format$3(a, index), maxLen, toNumber));
			a = descending ? a - step : a + step;
			index++;
		}
		if (options$1.toRegex === true) return step > 1 ? toSequence(parts, options$1, maxLen) : toRegex(range$1, null, {
			wrap: false,
			...options$1
		});
		return range$1;
	};
	const fillLetters = (start, end, step = 1, options$1 = {}) => {
		if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) return invalidRange(start, end, options$1);
		let format$3 = options$1.transform || ((val) => String.fromCharCode(val));
		let a = `${start}`.charCodeAt(0);
		let b = `${end}`.charCodeAt(0);
		let descending = a > b;
		let min$1 = Math.min(a, b);
		let max = Math.max(a, b);
		if (options$1.toRegex && step === 1) return toRange(min$1, max, false, options$1);
		let range$1 = [];
		let index = 0;
		while (descending ? a >= b : a <= b) {
			range$1.push(format$3(a, index));
			a = descending ? a - step : a + step;
			index++;
		}
		if (options$1.toRegex === true) return toRegex(range$1, null, {
			wrap: false,
			options: options$1
		});
		return range$1;
	};
	const fill$2 = (start, end, step, options$1 = {}) => {
		if (end == null && isValidValue(start)) return [start];
		if (!isValidValue(start) || !isValidValue(end)) return invalidRange(start, end, options$1);
		if (typeof step === "function") return fill$2(start, end, 1, { transform: step });
		if (isObject$1(step)) return fill$2(start, end, 0, step);
		let opts = { ...options$1 };
		if (opts.capture === true) opts.wrap = true;
		step = step || opts.step || 1;
		if (!isNumber(step)) {
			if (step != null && !isObject$1(step)) return invalidStep(step, opts);
			return fill$2(start, end, 1, step);
		}
		if (isNumber(start) && isNumber(end)) return fillNumbers(start, end, step, opts);
		return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
	};
	module.exports = fill$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/compile.js
var require_compile = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/compile.js": ((exports, module) => {
	const fill$1 = require_fill_range();
	const utils$1 = require_utils();
	const compile$1 = (ast, options$1 = {}) => {
		const walk$3 = (node, parent = {}) => {
			const invalid = utils$1.isInvalidBrace(parent) === true || (node.invalid === true && options$1.escapeInvalid === true) === true;
			const prefix = options$1.escapeInvalid === true ? "\\" : "";
			let output = "";
			if (node.isOpen === true) return prefix + node.value;
			if (node.isClose === true) {
				console.log("node.isClose", prefix, node.value);
				return prefix + node.value;
			}
			if (node.type === "open") return invalid ? prefix + node.value : "(";
			if (node.type === "close") return invalid ? prefix + node.value : ")";
			if (node.type === "comma") return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
			if (node.value) return node.value;
			if (node.nodes && node.ranges > 0) {
				const args = utils$1.reduce(node.nodes);
				const range$1 = fill$1(...args, {
					...options$1,
					wrap: false,
					toRegex: true,
					strictZeros: true
				});
				if (range$1.length !== 0) return args.length > 1 && range$1.length > 1 ? `(${range$1})` : range$1;
			}
			if (node.nodes) for (const child of node.nodes) output += walk$3(child, node);
			return output;
		};
		return walk$3(ast);
	};
	module.exports = compile$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/expand.js
var require_expand = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/expand.js": ((exports, module) => {
	const fill = require_fill_range();
	const stringify$2 = require_stringify();
	const utils = require_utils();
	const append = (queue = "", stash = "", enclose = false) => {
		const result = [];
		queue = [].concat(queue);
		stash = [].concat(stash);
		if (!stash.length) return queue;
		if (!queue.length) return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
		for (const item of queue) if (Array.isArray(item)) for (const value$1 of item) result.push(append(value$1, stash, enclose));
		else for (let ele of stash) {
			if (enclose === true && typeof ele === "string") ele = `{${ele}}`;
			result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
		}
		return utils.flatten(result);
	};
	const expand$1 = (ast, options$1 = {}) => {
		const rangeLimit = options$1.rangeLimit === void 0 ? 1e3 : options$1.rangeLimit;
		const walk$3 = (node, parent = {}) => {
			node.queue = [];
			let p = parent;
			let q = parent.queue;
			while (p.type !== "brace" && p.type !== "root" && p.parent) {
				p = p.parent;
				q = p.queue;
			}
			if (node.invalid || node.dollar) {
				q.push(append(q.pop(), stringify$2(node, options$1)));
				return;
			}
			if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
				q.push(append(q.pop(), ["{}"]));
				return;
			}
			if (node.nodes && node.ranges > 0) {
				const args = utils.reduce(node.nodes);
				if (utils.exceedsLimit(...args, options$1.step, rangeLimit)) throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
				let range$1 = fill(...args, options$1);
				if (range$1.length === 0) range$1 = stringify$2(node, options$1);
				q.push(append(q.pop(), range$1));
				node.nodes = [];
				return;
			}
			const enclose = utils.encloseBrace(node);
			let queue = node.queue;
			let block = node;
			while (block.type !== "brace" && block.type !== "root" && block.parent) {
				block = block.parent;
				queue = block.queue;
			}
			for (let i$1 = 0; i$1 < node.nodes.length; i$1++) {
				const child = node.nodes[i$1];
				if (child.type === "comma" && node.type === "brace") {
					if (i$1 === 1) queue.push("");
					queue.push("");
					continue;
				}
				if (child.type === "close") {
					q.push(append(q.pop(), queue, enclose));
					continue;
				}
				if (child.value && child.type !== "open") {
					queue.push(append(queue.pop(), child.value));
					continue;
				}
				if (child.nodes) walk$3(child, node);
			}
			return queue;
		};
		return utils.flatten(walk$3(ast));
	};
	module.exports = expand$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/constants.js
var require_constants$2 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/constants.js": ((exports, module) => {
	module.exports = {
		MAX_LENGTH: 1e4,
		CHAR_0: "0",
		CHAR_9: "9",
		CHAR_UPPERCASE_A: "A",
		CHAR_LOWERCASE_A: "a",
		CHAR_UPPERCASE_Z: "Z",
		CHAR_LOWERCASE_Z: "z",
		CHAR_LEFT_PARENTHESES: "(",
		CHAR_RIGHT_PARENTHESES: ")",
		CHAR_ASTERISK: "*",
		CHAR_AMPERSAND: "&",
		CHAR_AT: "@",
		CHAR_BACKSLASH: "\\",
		CHAR_BACKTICK: "`",
		CHAR_CARRIAGE_RETURN: "\r",
		CHAR_CIRCUMFLEX_ACCENT: "^",
		CHAR_COLON: ":",
		CHAR_COMMA: ",",
		CHAR_DOLLAR: "$",
		CHAR_DOT: ".",
		CHAR_DOUBLE_QUOTE: "\"",
		CHAR_EQUAL: "=",
		CHAR_EXCLAMATION_MARK: "!",
		CHAR_FORM_FEED: "\f",
		CHAR_FORWARD_SLASH: "/",
		CHAR_HASH: "#",
		CHAR_HYPHEN_MINUS: "-",
		CHAR_LEFT_ANGLE_BRACKET: "<",
		CHAR_LEFT_CURLY_BRACE: "{",
		CHAR_LEFT_SQUARE_BRACKET: "[",
		CHAR_LINE_FEED: "\n",
		CHAR_NO_BREAK_SPACE: "\xA0",
		CHAR_PERCENT: "%",
		CHAR_PLUS: "+",
		CHAR_QUESTION_MARK: "?",
		CHAR_RIGHT_ANGLE_BRACKET: ">",
		CHAR_RIGHT_CURLY_BRACE: "}",
		CHAR_RIGHT_SQUARE_BRACKET: "]",
		CHAR_SEMICOLON: ";",
		CHAR_SINGLE_QUOTE: "'",
		CHAR_SPACE: " ",
		CHAR_TAB: "	",
		CHAR_UNDERSCORE: "_",
		CHAR_VERTICAL_LINE: "|",
		CHAR_ZERO_WIDTH_NOBREAK_SPACE: "﻿"
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/parse.js
var require_parse$2 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/parse.js": ((exports, module) => {
	const stringify$1 = require_stringify();
	/**
	* Constants
	*/
	const { MAX_LENGTH, CHAR_BACKSLASH, CHAR_BACKTICK, CHAR_COMMA, CHAR_DOT, CHAR_LEFT_PARENTHESES, CHAR_RIGHT_PARENTHESES, CHAR_LEFT_CURLY_BRACE, CHAR_RIGHT_CURLY_BRACE, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_DOUBLE_QUOTE, CHAR_SINGLE_QUOTE, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE } = require_constants$2();
	/**
	* parse
	*/
	const parse$8 = (input, options$1 = {}) => {
		if (typeof input !== "string") throw new TypeError("Expected a string");
		const opts = options$1 || {};
		const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
		if (input.length > max) throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
		const ast = {
			type: "root",
			input,
			nodes: []
		};
		const stack = [ast];
		let block = ast;
		let prev = ast;
		let brackets = 0;
		const length = input.length;
		let index = 0;
		let depth = 0;
		let value$1;
		/**
		* Helpers
		*/
		const advance = () => input[index++];
		const push$1 = (node) => {
			if (node.type === "text" && prev.type === "dot") prev.type = "text";
			if (prev && prev.type === "text" && node.type === "text") {
				prev.value += node.value;
				return;
			}
			block.nodes.push(node);
			node.parent = block;
			node.prev = prev;
			prev = node;
			return node;
		};
		push$1({ type: "bos" });
		while (index < length) {
			block = stack[stack.length - 1];
			value$1 = advance();
			/**
			* Invalid chars
			*/
			if (value$1 === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value$1 === CHAR_NO_BREAK_SPACE) continue;
			/**
			* Escaped chars
			*/
			if (value$1 === CHAR_BACKSLASH) {
				push$1({
					type: "text",
					value: (options$1.keepEscaping ? value$1 : "") + advance()
				});
				continue;
			}
			/**
			* Right square bracket (literal): ']'
			*/
			if (value$1 === CHAR_RIGHT_SQUARE_BRACKET) {
				push$1({
					type: "text",
					value: "\\" + value$1
				});
				continue;
			}
			/**
			* Left square bracket: '['
			*/
			if (value$1 === CHAR_LEFT_SQUARE_BRACKET) {
				brackets++;
				let next;
				while (index < length && (next = advance())) {
					value$1 += next;
					if (next === CHAR_LEFT_SQUARE_BRACKET) {
						brackets++;
						continue;
					}
					if (next === CHAR_BACKSLASH) {
						value$1 += advance();
						continue;
					}
					if (next === CHAR_RIGHT_SQUARE_BRACKET) {
						brackets--;
						if (brackets === 0) break;
					}
				}
				push$1({
					type: "text",
					value: value$1
				});
				continue;
			}
			/**
			* Parentheses
			*/
			if (value$1 === CHAR_LEFT_PARENTHESES) {
				block = push$1({
					type: "paren",
					nodes: []
				});
				stack.push(block);
				push$1({
					type: "text",
					value: value$1
				});
				continue;
			}
			if (value$1 === CHAR_RIGHT_PARENTHESES) {
				if (block.type !== "paren") {
					push$1({
						type: "text",
						value: value$1
					});
					continue;
				}
				block = stack.pop();
				push$1({
					type: "text",
					value: value$1
				});
				block = stack[stack.length - 1];
				continue;
			}
			/**
			* Quotes: '|"|`
			*/
			if (value$1 === CHAR_DOUBLE_QUOTE || value$1 === CHAR_SINGLE_QUOTE || value$1 === CHAR_BACKTICK) {
				const open$2 = value$1;
				let next;
				if (options$1.keepQuotes !== true) value$1 = "";
				while (index < length && (next = advance())) {
					if (next === CHAR_BACKSLASH) {
						value$1 += next + advance();
						continue;
					}
					if (next === open$2) {
						if (options$1.keepQuotes === true) value$1 += next;
						break;
					}
					value$1 += next;
				}
				push$1({
					type: "text",
					value: value$1
				});
				continue;
			}
			/**
			* Left curly brace: '{'
			*/
			if (value$1 === CHAR_LEFT_CURLY_BRACE) {
				depth++;
				block = push$1({
					type: "brace",
					open: true,
					close: false,
					dollar: prev.value && prev.value.slice(-1) === "$" || block.dollar === true,
					depth,
					commas: 0,
					ranges: 0,
					nodes: []
				});
				stack.push(block);
				push$1({
					type: "open",
					value: value$1
				});
				continue;
			}
			/**
			* Right curly brace: '}'
			*/
			if (value$1 === CHAR_RIGHT_CURLY_BRACE) {
				if (block.type !== "brace") {
					push$1({
						type: "text",
						value: value$1
					});
					continue;
				}
				const type = "close";
				block = stack.pop();
				block.close = true;
				push$1({
					type,
					value: value$1
				});
				depth--;
				block = stack[stack.length - 1];
				continue;
			}
			/**
			* Comma: ','
			*/
			if (value$1 === CHAR_COMMA && depth > 0) {
				if (block.ranges > 0) {
					block.ranges = 0;
					block.nodes = [block.nodes.shift(), {
						type: "text",
						value: stringify$1(block)
					}];
				}
				push$1({
					type: "comma",
					value: value$1
				});
				block.commas++;
				continue;
			}
			/**
			* Dot: '.'
			*/
			if (value$1 === CHAR_DOT && depth > 0 && block.commas === 0) {
				const siblings = block.nodes;
				if (depth === 0 || siblings.length === 0) {
					push$1({
						type: "text",
						value: value$1
					});
					continue;
				}
				if (prev.type === "dot") {
					block.range = [];
					prev.value += value$1;
					prev.type = "range";
					if (block.nodes.length !== 3 && block.nodes.length !== 5) {
						block.invalid = true;
						block.ranges = 0;
						prev.type = "text";
						continue;
					}
					block.ranges++;
					block.args = [];
					continue;
				}
				if (prev.type === "range") {
					siblings.pop();
					const before = siblings[siblings.length - 1];
					before.value += prev.value + value$1;
					prev = before;
					block.ranges--;
					continue;
				}
				push$1({
					type: "dot",
					value: value$1
				});
				continue;
			}
			/**
			* Text
			*/
			push$1({
				type: "text",
				value: value$1
			});
		}
		do {
			block = stack.pop();
			if (block.type !== "root") {
				block.nodes.forEach((node) => {
					if (!node.nodes) {
						if (node.type === "open") node.isOpen = true;
						if (node.type === "close") node.isClose = true;
						if (!node.nodes) node.type = "text";
						node.invalid = true;
					}
				});
				const parent = stack[stack.length - 1];
				const index$1 = parent.nodes.indexOf(block);
				parent.nodes.splice(index$1, 1, ...block.nodes);
			}
		} while (stack.length > 0);
		push$1({ type: "eos" });
		return ast;
	};
	module.exports = parse$8;
}) });

//#endregion
//#region ../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/index.js
var require_braces = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/index.js": ((exports, module) => {
	const stringify = require_stringify();
	const compile = require_compile();
	const expand = require_expand();
	const parse$7 = require_parse$2();
	/**
	* Expand the given pattern or create a regex-compatible string.
	*
	* ```js
	* const braces = require('braces');
	* console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
	* console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
	* ```
	* @param {String} `str`
	* @param {Object} `options`
	* @return {String}
	* @api public
	*/
	const braces$1 = (input, options$1 = {}) => {
		let output = [];
		if (Array.isArray(input)) for (const pattern of input) {
			const result = braces$1.create(pattern, options$1);
			if (Array.isArray(result)) output.push(...result);
			else output.push(result);
		}
		else output = [].concat(braces$1.create(input, options$1));
		if (options$1 && options$1.expand === true && options$1.nodupes === true) output = [...new Set(output)];
		return output;
	};
	/**
	* Parse the given `str` with the given `options`.
	*
	* ```js
	* // braces.parse(pattern, [, options]);
	* const ast = braces.parse('a/{b,c}/d');
	* console.log(ast);
	* ```
	* @param {String} pattern Brace pattern to parse
	* @param {Object} options
	* @return {Object} Returns an AST
	* @api public
	*/
	braces$1.parse = (input, options$1 = {}) => parse$7(input, options$1);
	/**
	* Creates a braces string from an AST, or an AST node.
	*
	* ```js
	* const braces = require('braces');
	* let ast = braces.parse('foo/{a,b}/bar');
	* console.log(stringify(ast.nodes[2])); //=> '{a,b}'
	* ```
	* @param {String} `input` Brace pattern or AST.
	* @param {Object} `options`
	* @return {Array} Returns an array of expanded values.
	* @api public
	*/
	braces$1.stringify = (input, options$1 = {}) => {
		if (typeof input === "string") return stringify(braces$1.parse(input, options$1), options$1);
		return stringify(input, options$1);
	};
	/**
	* Compiles a brace pattern into a regex-compatible, optimized string.
	* This method is called by the main [braces](#braces) function by default.
	*
	* ```js
	* const braces = require('braces');
	* console.log(braces.compile('a/{b,c}/d'));
	* //=> ['a/(b|c)/d']
	* ```
	* @param {String} `input` Brace pattern or AST.
	* @param {Object} `options`
	* @return {Array} Returns an array of expanded values.
	* @api public
	*/
	braces$1.compile = (input, options$1 = {}) => {
		if (typeof input === "string") input = braces$1.parse(input, options$1);
		return compile(input, options$1);
	};
	/**
	* Expands a brace pattern into an array. This method is called by the
	* main [braces](#braces) function when `options.expand` is true. Before
	* using this method it's recommended that you read the [performance notes](#performance))
	* and advantages of using [.compile](#compile) instead.
	*
	* ```js
	* const braces = require('braces');
	* console.log(braces.expand('a/{b,c}/d'));
	* //=> ['a/b/d', 'a/c/d'];
	* ```
	* @param {String} `pattern` Brace pattern
	* @param {Object} `options`
	* @return {Array} Returns an array of expanded values.
	* @api public
	*/
	braces$1.expand = (input, options$1 = {}) => {
		if (typeof input === "string") input = braces$1.parse(input, options$1);
		let result = expand(input, options$1);
		if (options$1.noempty === true) result = result.filter(Boolean);
		if (options$1.nodupes === true) result = [...new Set(result)];
		return result;
	};
	/**
	* Processes a brace pattern and returns either an expanded array
	* (if `options.expand` is true), a highly optimized regex-compatible string.
	* This method is called by the main [braces](#braces) function.
	*
	* ```js
	* const braces = require('braces');
	* console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
	* //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
	* ```
	* @param {String} `pattern` Brace pattern
	* @param {Object} `options`
	* @return {Array} Returns an array of expanded values.
	* @api public
	*/
	braces$1.create = (input, options$1 = {}) => {
		if (input === "" || input.length < 3) return [input];
		return options$1.expand !== true ? braces$1.compile(input, options$1) : braces$1.expand(input, options$1);
	};
	/**
	* Expose "braces"
	*/
	module.exports = braces$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/binary-extensions@2.3.0/node_modules/binary-extensions/binary-extensions.json
var require_binary_extensions$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/binary-extensions@2.3.0/node_modules/binary-extensions/binary-extensions.json": ((exports, module) => {
	module.exports = [
		"3dm",
		"3ds",
		"3g2",
		"3gp",
		"7z",
		"a",
		"aac",
		"adp",
		"afdesign",
		"afphoto",
		"afpub",
		"ai",
		"aif",
		"aiff",
		"alz",
		"ape",
		"apk",
		"appimage",
		"ar",
		"arj",
		"asf",
		"au",
		"avi",
		"bak",
		"baml",
		"bh",
		"bin",
		"bk",
		"bmp",
		"btif",
		"bz2",
		"bzip2",
		"cab",
		"caf",
		"cgm",
		"class",
		"cmx",
		"cpio",
		"cr2",
		"cur",
		"dat",
		"dcm",
		"deb",
		"dex",
		"djvu",
		"dll",
		"dmg",
		"dng",
		"doc",
		"docm",
		"docx",
		"dot",
		"dotm",
		"dra",
		"DS_Store",
		"dsk",
		"dts",
		"dtshd",
		"dvb",
		"dwg",
		"dxf",
		"ecelp4800",
		"ecelp7470",
		"ecelp9600",
		"egg",
		"eol",
		"eot",
		"epub",
		"exe",
		"f4v",
		"fbs",
		"fh",
		"fla",
		"flac",
		"flatpak",
		"fli",
		"flv",
		"fpx",
		"fst",
		"fvt",
		"g3",
		"gh",
		"gif",
		"graffle",
		"gz",
		"gzip",
		"h261",
		"h263",
		"h264",
		"icns",
		"ico",
		"ief",
		"img",
		"ipa",
		"iso",
		"jar",
		"jpeg",
		"jpg",
		"jpgv",
		"jpm",
		"jxr",
		"key",
		"ktx",
		"lha",
		"lib",
		"lvp",
		"lz",
		"lzh",
		"lzma",
		"lzo",
		"m3u",
		"m4a",
		"m4v",
		"mar",
		"mdi",
		"mht",
		"mid",
		"midi",
		"mj2",
		"mka",
		"mkv",
		"mmr",
		"mng",
		"mobi",
		"mov",
		"movie",
		"mp3",
		"mp4",
		"mp4a",
		"mpeg",
		"mpg",
		"mpga",
		"mxu",
		"nef",
		"npx",
		"numbers",
		"nupkg",
		"o",
		"odp",
		"ods",
		"odt",
		"oga",
		"ogg",
		"ogv",
		"otf",
		"ott",
		"pages",
		"pbm",
		"pcx",
		"pdb",
		"pdf",
		"pea",
		"pgm",
		"pic",
		"png",
		"pnm",
		"pot",
		"potm",
		"potx",
		"ppa",
		"ppam",
		"ppm",
		"pps",
		"ppsm",
		"ppsx",
		"ppt",
		"pptm",
		"pptx",
		"psd",
		"pya",
		"pyc",
		"pyo",
		"pyv",
		"qt",
		"rar",
		"ras",
		"raw",
		"resources",
		"rgb",
		"rip",
		"rlc",
		"rmf",
		"rmvb",
		"rpm",
		"rtf",
		"rz",
		"s3m",
		"s7z",
		"scpt",
		"sgi",
		"shar",
		"snap",
		"sil",
		"sketch",
		"slk",
		"smv",
		"snk",
		"so",
		"stl",
		"suo",
		"sub",
		"swf",
		"tar",
		"tbz",
		"tbz2",
		"tga",
		"tgz",
		"thmx",
		"tif",
		"tiff",
		"tlz",
		"ttc",
		"ttf",
		"txz",
		"udf",
		"uvh",
		"uvi",
		"uvm",
		"uvp",
		"uvs",
		"uvu",
		"viv",
		"vob",
		"war",
		"wav",
		"wax",
		"wbmp",
		"wdp",
		"weba",
		"webm",
		"webp",
		"whl",
		"wim",
		"wm",
		"wma",
		"wmv",
		"wmx",
		"woff",
		"woff2",
		"wrm",
		"wvx",
		"xbm",
		"xif",
		"xla",
		"xlam",
		"xls",
		"xlsb",
		"xlsm",
		"xlsx",
		"xlt",
		"xltm",
		"xltx",
		"xm",
		"xmind",
		"xpi",
		"xpm",
		"xwd",
		"xz",
		"z",
		"zip",
		"zipx"
	];
}) });

//#endregion
//#region ../../node_modules/.pnpm/binary-extensions@2.3.0/node_modules/binary-extensions/index.js
var require_binary_extensions = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/binary-extensions@2.3.0/node_modules/binary-extensions/index.js": ((exports, module) => {
	module.exports = require_binary_extensions$1();
}) });

//#endregion
//#region ../../node_modules/.pnpm/is-binary-path@2.1.0/node_modules/is-binary-path/index.js
var require_is_binary_path = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/is-binary-path@2.1.0/node_modules/is-binary-path/index.js": ((exports, module) => {
	const path$9 = __require("path");
	const binaryExtensions = require_binary_extensions();
	const extensions = new Set(binaryExtensions);
	module.exports = (filePath) => extensions.has(path$9.extname(filePath).slice(1).toLowerCase());
}) });

//#endregion
//#region ../../node_modules/.pnpm/chokidar@3.6.0_patch_hash=8a4f9e2b397e6034b91a0508faae3cecb97f222313faa129d7cb0eb71e9d0e84/node_modules/chokidar/lib/constants.js
var require_constants$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/chokidar@3.6.0_patch_hash=8a4f9e2b397e6034b91a0508faae3cecb97f222313faa129d7cb0eb71e9d0e84/node_modules/chokidar/lib/constants.js": ((exports) => {
	const { sep: sep$2 } = __require("path");
	const { platform: platform$1 } = process;
	const os$2 = __require("os");
	exports.EV_ALL = "all";
	exports.EV_READY = "ready";
	exports.EV_ADD = "add";
	exports.EV_CHANGE = "change";
	exports.EV_ADD_DIR = "addDir";
	exports.EV_UNLINK = "unlink";
	exports.EV_UNLINK_DIR = "unlinkDir";
	exports.EV_RAW = "raw";
	exports.EV_ERROR = "error";
	exports.STR_DATA = "data";
	exports.STR_END = "end";
	exports.STR_CLOSE = "close";
	exports.FSEVENT_CREATED = "created";
	exports.FSEVENT_MODIFIED = "modified";
	exports.FSEVENT_DELETED = "deleted";
	exports.FSEVENT_MOVED = "moved";
	exports.FSEVENT_CLONED = "cloned";
	exports.FSEVENT_UNKNOWN = "unknown";
	exports.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;
	exports.FSEVENT_TYPE_FILE = "file";
	exports.FSEVENT_TYPE_DIRECTORY = "directory";
	exports.FSEVENT_TYPE_SYMLINK = "symlink";
	exports.KEY_LISTENERS = "listeners";
	exports.KEY_ERR = "errHandlers";
	exports.KEY_RAW = "rawEmitters";
	exports.HANDLER_KEYS = [
		exports.KEY_LISTENERS,
		exports.KEY_ERR,
		exports.KEY_RAW
	];
	exports.DOT_SLASH = `.${sep$2}`;
	exports.BACK_SLASH_RE = /\\/g;
	exports.DOUBLE_SLASH_RE = /\/\//;
	exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
	exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
	exports.REPLACER_RE = /^\.[/\\]/;
	exports.SLASH = "/";
	exports.SLASH_SLASH = "//";
	exports.BRACE_START = "{";
	exports.BANG = "!";
	exports.ONE_DOT = ".";
	exports.TWO_DOTS = "..";
	exports.STAR = "*";
	exports.GLOBSTAR = "**";
	exports.ROOT_GLOBSTAR = "/**/*";
	exports.SLASH_GLOBSTAR = "/**";
	exports.DIR_SUFFIX = "Dir";
	exports.ANYMATCH_OPTS = { dot: true };
	exports.STRING_TYPE = "string";
	exports.FUNCTION_TYPE = "function";
	exports.EMPTY_STR = "";
	exports.EMPTY_FN = () => {};
	exports.IDENTITY_FN = (val) => val;
	exports.isWindows = platform$1 === "win32";
	exports.isMacos = platform$1 === "darwin";
	exports.isLinux = platform$1 === "linux";
	exports.isIBMi = os$2.type() === "OS400";
}) });

//#endregion
//#region ../../node_modules/.pnpm/chokidar@3.6.0_patch_hash=8a4f9e2b397e6034b91a0508faae3cecb97f222313faa129d7cb0eb71e9d0e84/node_modules/chokidar/lib/nodefs-handler.js
var require_nodefs_handler = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/chokidar@3.6.0_patch_hash=8a4f9e2b397e6034b91a0508faae3cecb97f222313faa129d7cb0eb71e9d0e84/node_modules/chokidar/lib/nodefs-handler.js": ((exports, module) => {
	const fs$8 = __require("fs");
	const sysPath$2 = __require("path");
	const { promisify: promisify$3 } = __require("util");
	const isBinaryPath = require_is_binary_path();
	const { isWindows: isWindows$3, isLinux, EMPTY_FN: EMPTY_FN$2, EMPTY_STR: EMPTY_STR$1, KEY_LISTENERS, KEY_ERR, KEY_RAW, HANDLER_KEYS, EV_CHANGE: EV_CHANGE$2, EV_ADD: EV_ADD$2, EV_ADD_DIR: EV_ADD_DIR$2, EV_ERROR: EV_ERROR$2, STR_DATA: STR_DATA$1, STR_END: STR_END$2, BRACE_START: BRACE_START$1, STAR } = require_constants$1();
	const THROTTLE_MODE_WATCH = "watch";
	const open$1 = promisify$3(fs$8.open);
	const stat$2 = promisify$3(fs$8.stat);
	const lstat$1 = promisify$3(fs$8.lstat);
	const close = promisify$3(fs$8.close);
	const fsrealpath = promisify$3(fs$8.realpath);
	const statMethods$1 = {
		lstat: lstat$1,
		stat: stat$2
	};
	const foreach = (val, fn) => {
		if (val instanceof Set) val.forEach(fn);
		else fn(val);
	};
	const addAndConvert = (main, prop, item) => {
		let container = main[prop];
		if (!(container instanceof Set)) main[prop] = container = new Set([container]);
		container.add(item);
	};
	const clearItem = (cont) => (key) => {
		const set = cont[key];
		if (set instanceof Set) set.clear();
		else delete cont[key];
	};
	const delFromSet = (main, prop, item) => {
		const container = main[prop];
		if (container instanceof Set) container.delete(item);
		else if (container === item) delete main[prop];
	};
	const isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
	/**
	* @typedef {String} Path
	*/
	/**
	* @typedef {Object} FsWatchContainer
	* @property {Set} listeners
	* @property {Set} errHandlers
	* @property {Set} rawEmitters
	* @property {fs.FSWatcher=} watcher
	* @property {Boolean=} watcherUnusable
	*/
	/**
	* @type {Map<String,FsWatchContainer>}
	*/
	const FsWatchInstances = /* @__PURE__ */ new Map();
	/**
	* Instantiates the fs_watch interface
	* @param {String} path to be watched
	* @param {Object} options to be passed to fs_watch
	* @param {Function} listener main event handler
	* @param {Function} errHandler emits info about errors
	* @param {Function} emitRaw emits raw event data
	* @returns {fs.FSWatcher} new fsevents instance
	*/
	function createFsWatchInstance(path$13, options$1, listener$1, errHandler, emitRaw) {
		const handleEvent = (rawEvent, evPath) => {
			listener$1(path$13);
			emitRaw(rawEvent, evPath, { watchedPath: path$13 });
			if (evPath && path$13 !== evPath) fsWatchBroadcast(sysPath$2.resolve(path$13, evPath), KEY_LISTENERS, sysPath$2.join(path$13, evPath));
		};
		try {
			return fs$8.watch(path$13, options$1, handleEvent);
		} catch (error$1) {
			errHandler(error$1);
		}
	}
	/**
	* Helper for passing fs_watch event data to a collection of listeners
	* @param {Path} fullPath absolute path bound to fs_watch instance
	* @param {String} type listener type
	* @param {*=} val1 arguments to be passed to listeners
	* @param {*=} val2
	* @param {*=} val3
	*/
	const fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
		const cont = FsWatchInstances.get(fullPath);
		if (!cont) return;
		foreach(cont[type], (listener$1) => {
			listener$1(val1, val2, val3);
		});
	};
	/**
	* Instantiates the fs_watch interface or binds listeners
	* to an existing one covering the same file system entry
	* @param {String} path
	* @param {String} fullPath absolute path
	* @param {Object} options to be passed to fs_watch
	* @param {Object} handlers container for event listener functions
	*/
	const setFsWatchListener = (path$13, fullPath, options$1, handlers) => {
		const { listener: listener$1, errHandler, rawEmitter } = handlers;
		let cont = FsWatchInstances.get(fullPath);
		/** @type {fs.FSWatcher=} */
		let watcher;
		if (!options$1.persistent) {
			watcher = createFsWatchInstance(path$13, options$1, listener$1, errHandler, rawEmitter);
			return watcher.close.bind(watcher);
		}
		if (cont) {
			addAndConvert(cont, KEY_LISTENERS, listener$1);
			addAndConvert(cont, KEY_ERR, errHandler);
			addAndConvert(cont, KEY_RAW, rawEmitter);
		} else {
			watcher = createFsWatchInstance(path$13, options$1, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
			if (!watcher) return;
			watcher.on(EV_ERROR$2, async (error$1) => {
				const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
				cont.watcherUnusable = true;
				if (isWindows$3 && error$1.code === "EPERM") try {
					await close(await open$1(path$13, "r"));
					broadcastErr(error$1);
				} catch (err$2) {}
				else broadcastErr(error$1);
			});
			cont = {
				listeners: listener$1,
				errHandlers: errHandler,
				rawEmitters: rawEmitter,
				watcher
			};
			FsWatchInstances.set(fullPath, cont);
		}
		return () => {
			delFromSet(cont, KEY_LISTENERS, listener$1);
			delFromSet(cont, KEY_ERR, errHandler);
			delFromSet(cont, KEY_RAW, rawEmitter);
			if (isEmptySet(cont.listeners)) {
				cont.watcher.close();
				FsWatchInstances.delete(fullPath);
				HANDLER_KEYS.forEach(clearItem(cont));
				cont.watcher = void 0;
				Object.freeze(cont);
			}
		};
	};
	const FsWatchFileInstances = /* @__PURE__ */ new Map();
	/**
	* Instantiates the fs_watchFile interface or binds listeners
	* to an existing one covering the same file system entry
	* @param {String} path to be watched
	* @param {String} fullPath absolute path
	* @param {Object} options options to be passed to fs_watchFile
	* @param {Object} handlers container for event listener functions
	* @returns {Function} closer
	*/
	const setFsWatchFileListener = (path$13, fullPath, options$1, handlers) => {
		const { listener: listener$1, rawEmitter } = handlers;
		let cont = FsWatchFileInstances.get(fullPath);
		const copts = cont && cont.options;
		if (copts && (copts.persistent < options$1.persistent || copts.interval > options$1.interval)) {
			fs$8.unwatchFile(fullPath);
			cont = void 0;
		}
		if (cont) {
			addAndConvert(cont, KEY_LISTENERS, listener$1);
			addAndConvert(cont, KEY_RAW, rawEmitter);
		} else {
			cont = {
				listeners: listener$1,
				rawEmitters: rawEmitter,
				options: options$1,
				watcher: fs$8.watchFile(fullPath, options$1, (curr, prev) => {
					foreach(cont.rawEmitters, (rawEmitter$1) => {
						rawEmitter$1(EV_CHANGE$2, fullPath, {
							curr,
							prev
						});
					});
					const currmtime = curr.mtimeMs;
					if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) foreach(cont.listeners, (listener$2) => listener$2(path$13, curr));
				})
			};
			FsWatchFileInstances.set(fullPath, cont);
		}
		return () => {
			delFromSet(cont, KEY_LISTENERS, listener$1);
			delFromSet(cont, KEY_RAW, rawEmitter);
			if (isEmptySet(cont.listeners)) {
				FsWatchFileInstances.delete(fullPath);
				fs$8.unwatchFile(fullPath);
				cont.options = cont.watcher = void 0;
				Object.freeze(cont);
			}
		};
	};
	/**
	* @mixin
	*/
	var NodeFsHandler$1 = class {
		/**
		* @param {import("../index").FSWatcher} fsW
		*/
		constructor(fsW) {
			this.fsw = fsW;
			this._boundHandleError = (error$1) => fsW._handleError(error$1);
		}
		/**
		* Watch file for changes with fs_watchFile or fs_watch.
		* @param {String} path to file or dir
		* @param {Function} listener on fs change
		* @returns {Function} closer for the watcher instance
		*/
		_watchWithNodeFs(path$13, listener$1) {
			const opts = this.fsw.options;
			const directory = sysPath$2.dirname(path$13);
			const basename$3 = sysPath$2.basename(path$13);
			this.fsw._getWatchedDir(directory).add(basename$3);
			const absolutePath = sysPath$2.resolve(path$13);
			const options$1 = { persistent: opts.persistent };
			if (!listener$1) listener$1 = EMPTY_FN$2;
			let closer;
			if (opts.usePolling) {
				options$1.interval = opts.enableBinaryInterval && isBinaryPath(basename$3) ? opts.binaryInterval : opts.interval;
				closer = setFsWatchFileListener(path$13, absolutePath, options$1, {
					listener: listener$1,
					rawEmitter: this.fsw._emitRaw
				});
			} else closer = setFsWatchListener(path$13, absolutePath, options$1, {
				listener: listener$1,
				errHandler: this._boundHandleError,
				rawEmitter: this.fsw._emitRaw
			});
			return closer;
		}
		/**
		* Watch a file and emit add event if warranted.
		* @param {Path} file Path
		* @param {fs.Stats} stats result of fs_stat
		* @param {Boolean} initialAdd was the file added at watch instantiation?
		* @returns {Function} closer for the watcher instance
		*/
		_handleFile(file, stats, initialAdd) {
			if (this.fsw.closed) return;
			const dirname$3 = sysPath$2.dirname(file);
			const basename$3 = sysPath$2.basename(file);
			const parent = this.fsw._getWatchedDir(dirname$3);
			let prevStats = stats;
			if (parent.has(basename$3)) return;
			const listener$1 = async (path$13, newStats) => {
				if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;
				if (!newStats || newStats.mtimeMs === 0) try {
					const newStats$1 = await stat$2(file);
					if (this.fsw.closed) return;
					const at = newStats$1.atimeMs;
					const mt = newStats$1.mtimeMs;
					if (!at || at <= mt || mt !== prevStats.mtimeMs) this.fsw._emit(EV_CHANGE$2, file, newStats$1);
					if (isLinux && prevStats.ino !== newStats$1.ino) {
						this.fsw._closeFile(path$13);
						prevStats = newStats$1;
						this.fsw._addPathCloser(path$13, this._watchWithNodeFs(file, listener$1));
					} else prevStats = newStats$1;
				} catch (error$1) {
					this.fsw._remove(dirname$3, basename$3);
				}
				else if (parent.has(basename$3)) {
					const at = newStats.atimeMs;
					const mt = newStats.mtimeMs;
					if (!at || at <= mt || mt !== prevStats.mtimeMs) this.fsw._emit(EV_CHANGE$2, file, newStats);
					prevStats = newStats;
				}
			};
			const closer = this._watchWithNodeFs(file, listener$1);
			if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
				if (!this.fsw._throttle(EV_ADD$2, file, 0)) return;
				this.fsw._emit(EV_ADD$2, file, stats);
			}
			return closer;
		}
		/**
		* Handle symlinks encountered while reading a dir.
		* @param {Object} entry returned by readdirp
		* @param {String} directory path of dir being read
		* @param {String} path of this item
		* @param {String} item basename of this item
		* @returns {Promise<Boolean>} true if no more processing is needed for this entry.
		*/
		async _handleSymlink(entry, directory, path$13, item) {
			if (this.fsw.closed) return;
			const full = entry.fullPath;
			const dir = this.fsw._getWatchedDir(directory);
			if (!this.fsw.options.followSymlinks) {
				this.fsw._incrReadyCount();
				let linkPath;
				try {
					linkPath = await fsrealpath(path$13);
				} catch (e$1) {
					this.fsw._emitReady();
					return true;
				}
				if (this.fsw.closed) return;
				if (dir.has(item)) {
					if (this.fsw._symlinkPaths.get(full) !== linkPath) {
						this.fsw._symlinkPaths.set(full, linkPath);
						this.fsw._emit(EV_CHANGE$2, path$13, entry.stats);
					}
				} else {
					dir.add(item);
					this.fsw._symlinkPaths.set(full, linkPath);
					this.fsw._emit(EV_ADD$2, path$13, entry.stats);
				}
				this.fsw._emitReady();
				return true;
			}
			if (this.fsw._symlinkPaths.has(full)) return true;
			this.fsw._symlinkPaths.set(full, true);
		}
		_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
			directory = sysPath$2.join(directory, EMPTY_STR$1);
			if (!wh.hasGlob) {
				throttler = this.fsw._throttle("readdir", directory, 1e3);
				if (!throttler) return;
			}
			const previous = this.fsw._getWatchedDir(wh.path);
			const current = /* @__PURE__ */ new Set();
			let stream$3 = this.fsw._readdirp(directory, {
				fileFilter: (entry) => wh.filterPath(entry),
				directoryFilter: (entry) => wh.filterDir(entry),
				depth: 0
			}).on(STR_DATA$1, async (entry) => {
				if (this.fsw.closed) {
					stream$3 = void 0;
					return;
				}
				const item = entry.path;
				let path$13 = sysPath$2.join(directory, item);
				current.add(item);
				if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path$13, item)) return;
				if (this.fsw.closed) {
					stream$3 = void 0;
					return;
				}
				if (item === target || !target && !previous.has(item)) {
					this.fsw._incrReadyCount();
					path$13 = sysPath$2.join(dir, sysPath$2.relative(dir, path$13));
					this._addToNodeFs(path$13, initialAdd, wh, depth + 1);
				}
			}).on(EV_ERROR$2, this._boundHandleError);
			return new Promise((resolve$4) => stream$3.once(STR_END$2, () => {
				if (this.fsw.closed) {
					stream$3 = void 0;
					return;
				}
				const wasThrottled = throttler ? throttler.clear() : false;
				resolve$4();
				previous.getChildren().filter((item) => {
					return item !== directory && !current.has(item) && (!wh.hasGlob || wh.filterPath({ fullPath: sysPath$2.resolve(directory, item) }));
				}).forEach((item) => {
					this.fsw._remove(directory, item);
				});
				stream$3 = void 0;
				if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);
			}));
		}
		/**
		* Read directory to add / remove files from `@watched` list and re-read it on change.
		* @param {String} dir fs path
		* @param {fs.Stats} stats
		* @param {Boolean} initialAdd
		* @param {Number} depth relative to user-supplied path
		* @param {String} target child path targeted for watch
		* @param {Object} wh Common watch helpers for this path
		* @param {String} realpath
		* @returns {Promise<Function>} closer for the watcher instance.
		*/
		async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath$2) {
			const parentDir$1 = this.fsw._getWatchedDir(sysPath$2.dirname(dir));
			const tracked = parentDir$1.has(sysPath$2.basename(dir));
			if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
				if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR$2, dir, stats);
			}
			parentDir$1.add(sysPath$2.basename(dir));
			this.fsw._getWatchedDir(dir);
			let throttler;
			let closer;
			const oDepth = this.fsw.options.depth;
			if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath$2)) {
				if (!target) {
					await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
					if (this.fsw.closed) return;
				}
				closer = this._watchWithNodeFs(dir, (dirPath, stats$1) => {
					if (stats$1 && stats$1.mtimeMs === 0) return;
					this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
				});
			}
			return closer;
		}
		/**
		* Handle added file, directory, or glob pattern.
		* Delegates call to _handleFile / _handleDir after checks.
		* @param {String} path to file or ir
		* @param {Boolean} initialAdd was the file added at watch instantiation?
		* @param {Object} priorWh depth relative to user-supplied path
		* @param {Number} depth Child path actually targeted for watch
		* @param {String=} target Child path actually targeted for watch
		* @returns {Promise}
		*/
		async _addToNodeFs(path$13, initialAdd, priorWh, depth, target) {
			const ready = this.fsw._emitReady;
			if (this.fsw._isIgnored(path$13) || this.fsw.closed) {
				ready();
				return false;
			}
			const wh = this.fsw._getWatchHelpers(path$13, depth);
			if (!wh.hasGlob && priorWh) {
				wh.hasGlob = priorWh.hasGlob;
				wh.globFilter = priorWh.globFilter;
				wh.filterPath = (entry) => priorWh.filterPath(entry);
				wh.filterDir = (entry) => priorWh.filterDir(entry);
			}
			try {
				const stats = await statMethods$1[wh.statMethod](wh.watchPath);
				if (this.fsw.closed) return;
				if (this.fsw._isIgnored(wh.watchPath, stats)) {
					ready();
					return false;
				}
				const follow = this.fsw.options.followSymlinks && !path$13.includes(STAR) && !path$13.includes(BRACE_START$1);
				let closer;
				if (stats.isDirectory()) {
					const absPath = sysPath$2.resolve(path$13);
					const targetPath = follow ? await fsrealpath(path$13) : path$13;
					if (this.fsw.closed) return;
					closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
					if (this.fsw.closed) return;
					if (absPath !== targetPath && targetPath !== void 0) this.fsw._symlinkPaths.set(absPath, targetPath);
				} else if (stats.isSymbolicLink()) {
					const targetPath = follow ? await fsrealpath(path$13) : path$13;
					if (this.fsw.closed) return;
					const parent = sysPath$2.dirname(wh.watchPath);
					this.fsw._getWatchedDir(parent).add(wh.watchPath);
					this.fsw._emit(EV_ADD$2, wh.watchPath, stats);
					closer = await this._handleDir(parent, stats, initialAdd, depth, path$13, wh, targetPath);
					if (this.fsw.closed) return;
					if (targetPath !== void 0) this.fsw._symlinkPaths.set(sysPath$2.resolve(path$13), targetPath);
				} else closer = this._handleFile(wh.watchPath, stats, initialAdd);
				ready();
				this.fsw._addPathCloser(path$13, closer);
				return false;
			} catch (error$1) {
				if (this.fsw._handleError(error$1)) {
					ready();
					return path$13;
				}
			}
		}
	};
	module.exports = NodeFsHandler$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/chokidar@3.6.0_patch_hash=8a4f9e2b397e6034b91a0508faae3cecb97f222313faa129d7cb0eb71e9d0e84/node_modules/chokidar/lib/fsevents-handler.js
var require_fsevents_handler = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/chokidar@3.6.0_patch_hash=8a4f9e2b397e6034b91a0508faae3cecb97f222313faa129d7cb0eb71e9d0e84/node_modules/chokidar/lib/fsevents-handler.js": ((exports, module) => {
	const fs$7 = __require("fs");
	const sysPath$1 = __require("path");
	const { promisify: promisify$2 } = __require("util");
	let fsevents;
	try {
		fsevents = __require("fsevents");
	} catch (error$1) {
		if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error$1);
	}
	if (fsevents) {
		const mtch = process.version.match(/v(\d+)\.(\d+)/);
		if (mtch && mtch[1] && mtch[2]) {
			if (Number.parseInt(mtch[1], 10) === 8 && Number.parseInt(mtch[2], 10) < 16) fsevents = void 0;
		}
	}
	const { EV_ADD: EV_ADD$1, EV_CHANGE: EV_CHANGE$1, EV_ADD_DIR: EV_ADD_DIR$1, EV_UNLINK: EV_UNLINK$1, EV_ERROR: EV_ERROR$1, STR_DATA, STR_END: STR_END$1, FSEVENT_CREATED, FSEVENT_MODIFIED, FSEVENT_DELETED, FSEVENT_MOVED, FSEVENT_UNKNOWN, FSEVENT_FLAG_MUST_SCAN_SUBDIRS, FSEVENT_TYPE_FILE, FSEVENT_TYPE_DIRECTORY, FSEVENT_TYPE_SYMLINK, ROOT_GLOBSTAR, DIR_SUFFIX, DOT_SLASH, FUNCTION_TYPE: FUNCTION_TYPE$1, EMPTY_FN: EMPTY_FN$1, IDENTITY_FN } = require_constants$1();
	const Depth = (value$1) => isNaN(value$1) ? {} : { depth: value$1 };
	const stat$1 = promisify$2(fs$7.stat);
	const lstat = promisify$2(fs$7.lstat);
	const realpath = promisify$2(fs$7.realpath);
	const statMethods = {
		stat: stat$1,
		lstat
	};
	/**
	* @typedef {String} Path
	*/
	/**
	* @typedef {Object} FsEventsWatchContainer
	* @property {Set<Function>} listeners
	* @property {Function} rawEmitter
	* @property {{stop: Function}} watcher
	*/
	/**
	* Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)
	* @type {Map<Path,FsEventsWatchContainer>}
	*/
	const FSEventsWatchers = /* @__PURE__ */ new Map();
	const consolidateThreshhold = 10;
	const wrongEventFlags = new Set([
		69888,
		70400,
		71424,
		72704,
		73472,
		131328,
		131840,
		262912
	]);
	/**
	* Instantiates the fsevents interface
	* @param {Path} path path to be watched
	* @param {Function} callback called when fsevents is bound and ready
	* @returns {{stop: Function}} new fsevents instance
	*/
	const createFSEventsInstance = (path$13, callback) => {
		return { stop: fsevents.watch(path$13, callback) };
	};
	/**
	* Instantiates the fsevents interface or binds listeners to an existing one covering
	* the same file tree.
	* @param {Path} path           - to be watched
	* @param {Path} realPath       - real path for symlinks
	* @param {Function} listener   - called when fsevents emits events
	* @param {Function} rawEmitter - passes data to listeners of the 'raw' event
	* @returns {Function} closer
	*/
	function setFSEventsListener(path$13, realPath, listener$1, rawEmitter) {
		let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;
		const parentPath = sysPath$1.dirname(watchPath);
		let cont = FSEventsWatchers.get(watchPath);
		if (couldConsolidate(parentPath)) watchPath = parentPath;
		const resolvedPath = sysPath$1.resolve(path$13);
		const hasSymlink = resolvedPath !== realPath;
		const filteredListener = (fullPath, flags, info) => {
			if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
			if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath$1.sep)) listener$1(fullPath, flags, info);
		};
		let watchedParent = false;
		for (const watchedPath of FSEventsWatchers.keys()) if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {
			watchPath = watchedPath;
			cont = FSEventsWatchers.get(watchPath);
			watchedParent = true;
			break;
		}
		if (cont || watchedParent) cont.listeners.add(filteredListener);
		else {
			cont = {
				listeners: new Set([filteredListener]),
				rawEmitter,
				watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
					if (!cont.listeners.size) return;
					if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS) return;
					const info = fsevents.getInfo(fullPath, flags);
					cont.listeners.forEach((list) => {
						list(fullPath, flags, info);
					});
					cont.rawEmitter(info.event, fullPath, info);
				})
			};
			FSEventsWatchers.set(watchPath, cont);
		}
		return () => {
			const lst = cont.listeners;
			lst.delete(filteredListener);
			if (!lst.size) {
				FSEventsWatchers.delete(watchPath);
				if (cont.watcher) return cont.watcher.stop().then(() => {
					cont.rawEmitter = cont.watcher = void 0;
					Object.freeze(cont);
				});
			}
		};
	}
	const couldConsolidate = (path$13) => {
		let count = 0;
		for (const watchPath of FSEventsWatchers.keys()) if (watchPath.indexOf(path$13) === 0) {
			count++;
			if (count >= consolidateThreshhold) return true;
		}
		return false;
	};
	const canUse = () => fsevents && FSEventsWatchers.size < 128;
	const calcDepth = (path$13, root) => {
		let i$1 = 0;
		while (!path$13.indexOf(root) && (path$13 = sysPath$1.dirname(path$13)) !== root) i$1++;
		return i$1;
	};
	const sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
	/**
	* @mixin
	*/
	var FsEventsHandler$1 = class {
		/**
		* @param {import('../index').FSWatcher} fsw
		*/
		constructor(fsw) {
			this.fsw = fsw;
		}
		checkIgnored(path$13, stats) {
			const ipaths = this.fsw._ignoredPaths;
			if (this.fsw._isIgnored(path$13, stats)) {
				ipaths.add(path$13);
				if (stats && stats.isDirectory()) ipaths.add(path$13 + ROOT_GLOBSTAR);
				return true;
			}
			ipaths.delete(path$13);
			ipaths.delete(path$13 + ROOT_GLOBSTAR);
		}
		addOrChange(path$13, fullPath, realPath, parent, watchedDir, item, info, opts) {
			const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;
			this.handleEvent(event, path$13, fullPath, realPath, parent, watchedDir, item, info, opts);
		}
		async checkExists(path$13, fullPath, realPath, parent, watchedDir, item, info, opts) {
			try {
				const stats = await stat$1(path$13);
				if (this.fsw.closed) return;
				if (sameTypes(info, stats)) this.addOrChange(path$13, fullPath, realPath, parent, watchedDir, item, info, opts);
				else this.handleEvent(EV_UNLINK$1, path$13, fullPath, realPath, parent, watchedDir, item, info, opts);
			} catch (error$1) {
				if (error$1.code === "EACCES") this.addOrChange(path$13, fullPath, realPath, parent, watchedDir, item, info, opts);
				else this.handleEvent(EV_UNLINK$1, path$13, fullPath, realPath, parent, watchedDir, item, info, opts);
			}
		}
		handleEvent(event, path$13, fullPath, realPath, parent, watchedDir, item, info, opts) {
			if (this.fsw.closed || this.checkIgnored(path$13)) return;
			if (event === EV_UNLINK$1) {
				const isDirectory$2 = info.type === FSEVENT_TYPE_DIRECTORY;
				if (isDirectory$2 || watchedDir.has(item)) this.fsw._remove(parent, item, isDirectory$2);
			} else {
				if (event === EV_ADD$1) {
					if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path$13);
					if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
						const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
						return this._addToFsEvents(path$13, false, true, curDepth);
					}
					this.fsw._getWatchedDir(parent).add(item);
				}
				/**
				* @type {'add'|'addDir'|'unlink'|'unlinkDir'}
				*/
				const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
				this.fsw._emit(eventName, path$13);
				if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path$13, false, true);
			}
		}
		/**
		* Handle symlinks encountered during directory scan
		* @param {String} watchPath  - file/dir path to be watched with fsevents
		* @param {String} realPath   - real path (in case of symlinks)
		* @param {Function} transform  - path transformer
		* @param {Function} globFilter - path filter in case a glob pattern was provided
		* @returns {Function} closer for the watcher instance
		*/
		_watchWithFsEvents(watchPath, realPath, transform$2, globFilter) {
			if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;
			const opts = this.fsw.options;
			const watchCallback = async (fullPath, flags, info) => {
				if (this.fsw.closed || this.fsw._isIgnored(fullPath)) return;
				if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth) return;
				const path$13 = transform$2(sysPath$1.join(watchPath, sysPath$1.relative(watchPath, fullPath)));
				if (globFilter && !globFilter(path$13)) return;
				const parent = sysPath$1.dirname(path$13);
				const item = sysPath$1.basename(path$13);
				const watchedDir = this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path$13 : parent);
				if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) if (typeof opts.ignored === FUNCTION_TYPE$1) {
					let stats;
					try {
						stats = await stat$1(path$13);
					} catch (error$1) {}
					if (this.fsw.closed) return;
					if (this.checkIgnored(path$13, stats)) return;
					if (sameTypes(info, stats)) this.addOrChange(path$13, fullPath, realPath, parent, watchedDir, item, info, opts);
					else this.handleEvent(EV_UNLINK$1, path$13, fullPath, realPath, parent, watchedDir, item, info, opts);
				} else this.checkExists(path$13, fullPath, realPath, parent, watchedDir, item, info, opts);
				else switch (info.event) {
					case FSEVENT_CREATED:
					case FSEVENT_MODIFIED: return this.addOrChange(path$13, fullPath, realPath, parent, watchedDir, item, info, opts);
					case FSEVENT_DELETED:
					case FSEVENT_MOVED: return this.checkExists(path$13, fullPath, realPath, parent, watchedDir, item, info, opts);
				}
			};
			const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);
			this.fsw._emitReady();
			return closer;
		}
		/**
		* Handle symlinks encountered during directory scan
		* @param {String} linkPath path to symlink
		* @param {String} fullPath absolute path to the symlink
		* @param {Function} transform pre-existing path transformer
		* @param {Number} curDepth level of subdirectories traversed to where symlink is
		* @returns {Promise<void>}
		*/
		async _handleFsEventsSymlink(linkPath, fullPath, transform$2, curDepth) {
			if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;
			this.fsw._symlinkPaths.set(fullPath, true);
			this.fsw._incrReadyCount();
			try {
				const linkTarget = await realpath(linkPath);
				if (this.fsw.closed) return;
				if (this.fsw._isIgnored(linkTarget)) return this.fsw._emitReady();
				this.fsw._incrReadyCount();
				this._addToFsEvents(linkTarget || linkPath, (path$13) => {
					let aliasedPath = linkPath;
					if (linkTarget && linkTarget !== DOT_SLASH) aliasedPath = path$13.replace(linkTarget, linkPath);
					else if (path$13 !== DOT_SLASH) aliasedPath = sysPath$1.join(linkPath, path$13);
					return transform$2(aliasedPath);
				}, false, curDepth);
			} catch (error$1) {
				if (this.fsw._handleError(error$1)) return this.fsw._emitReady();
			}
		}
		/**
		*
		* @param {Path} newPath
		* @param {fs.Stats} stats
		*/
		emitAdd(newPath, stats, processPath, opts, forceAdd) {
			const pp = processPath(newPath);
			const isDir = stats.isDirectory();
			const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp));
			const base = sysPath$1.basename(pp);
			if (isDir) this.fsw._getWatchedDir(pp);
			if (dirObj.has(base)) return;
			dirObj.add(base);
			if (!opts.ignoreInitial || forceAdd === true) this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);
		}
		initWatch(realPath, path$13, wh, processPath) {
			if (this.fsw.closed) return;
			const closer = this._watchWithFsEvents(wh.watchPath, sysPath$1.resolve(realPath || wh.watchPath), processPath, wh.globFilter);
			this.fsw._addPathCloser(path$13, closer);
		}
		/**
		* Handle added path with fsevents
		* @param {String} path file/dir path or glob pattern
		* @param {Function|Boolean=} transform converts working path to what the user expects
		* @param {Boolean=} forceAdd ensure add is emitted
		* @param {Number=} priorDepth Level of subdirectories already traversed.
		* @returns {Promise<void>}
		*/
		async _addToFsEvents(path$13, transform$2, forceAdd, priorDepth) {
			if (this.fsw.closed) return;
			const opts = this.fsw.options;
			const processPath = typeof transform$2 === FUNCTION_TYPE$1 ? transform$2 : IDENTITY_FN;
			const wh = this.fsw._getWatchHelpers(path$13);
			try {
				const stats = await statMethods[wh.statMethod](wh.watchPath);
				if (this.fsw.closed) return;
				if (this.fsw._isIgnored(wh.watchPath, stats)) throw null;
				if (stats.isDirectory()) {
					if (!wh.globFilter) this.emitAdd(processPath(path$13), stats, processPath, opts, forceAdd);
					if (priorDepth && priorDepth > opts.depth) return;
					this.fsw._readdirp(wh.watchPath, {
						fileFilter: (entry) => wh.filterPath(entry),
						directoryFilter: (entry) => wh.filterDir(entry),
						...Depth(opts.depth - (priorDepth || 0))
					}).on(STR_DATA, (entry) => {
						if (this.fsw.closed) return;
						if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;
						const joinedPath = sysPath$1.join(wh.watchPath, entry.path);
						const { fullPath } = entry;
						if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
							const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;
							this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
						} else this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
					}).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {
						this.fsw._emitReady();
					});
				} else {
					this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
					this.fsw._emitReady();
				}
			} catch (error$1) {
				if (!error$1 || this.fsw._handleError(error$1)) {
					this.fsw._emitReady();
					this.fsw._emitReady();
				}
			}
			if (opts.persistent && forceAdd !== true) if (typeof transform$2 === FUNCTION_TYPE$1) this.initWatch(void 0, path$13, wh, processPath);
			else {
				let realPath;
				try {
					realPath = await realpath(wh.watchPath);
				} catch (e$1) {}
				this.initWatch(realPath, path$13, wh, processPath);
			}
		}
	};
	module.exports = FsEventsHandler$1;
	module.exports.canUse = canUse;
}) });

//#endregion
//#region ../../node_modules/.pnpm/chokidar@3.6.0_patch_hash=8a4f9e2b397e6034b91a0508faae3cecb97f222313faa129d7cb0eb71e9d0e84/node_modules/chokidar/index.js
var require_chokidar = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/chokidar@3.6.0_patch_hash=8a4f9e2b397e6034b91a0508faae3cecb97f222313faa129d7cb0eb71e9d0e84/node_modules/chokidar/index.js": ((exports) => {
	const { EventEmitter: EventEmitter$3 } = __require("events");
	const fs$6 = __require("fs");
	const sysPath = __require("path");
	const { promisify: promisify$1 } = __require("util");
	const readdirp = require_readdirp();
	const anymatch = require_anymatch().default;
	const globParent = require_glob_parent();
	const isGlob = require_is_glob();
	const braces = require_braces();
	const normalizePath$1 = require_normalize_path();
	const NodeFsHandler = require_nodefs_handler();
	const FsEventsHandler = require_fsevents_handler();
	const { EV_ALL, EV_READY, EV_ADD, EV_CHANGE, EV_UNLINK, EV_ADD_DIR, EV_UNLINK_DIR, EV_RAW, EV_ERROR, STR_CLOSE, STR_END, BACK_SLASH_RE, DOUBLE_SLASH_RE, SLASH_OR_BACK_SLASH_RE, DOT_RE, REPLACER_RE, SLASH, SLASH_SLASH, BRACE_START, BANG, ONE_DOT, TWO_DOTS, GLOBSTAR, SLASH_GLOBSTAR, ANYMATCH_OPTS, STRING_TYPE, FUNCTION_TYPE, EMPTY_STR, EMPTY_FN, isWindows: isWindows$2, isMacos, isIBMi } = require_constants$1();
	const stat = promisify$1(fs$6.stat);
	const readdir = promisify$1(fs$6.readdir);
	/**
	* @typedef {String} Path
	* @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName
	* @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType
	*/
	/**
	*
	* @typedef {Object} WatchHelpers
	* @property {Boolean} followSymlinks
	* @property {'stat'|'lstat'} statMethod
	* @property {Path} path
	* @property {Path} watchPath
	* @property {Function} entryPath
	* @property {Boolean} hasGlob
	* @property {Object} globFilter
	* @property {Function} filterPath
	* @property {Function} filterDir
	*/
	const arrify = (value$1 = []) => Array.isArray(value$1) ? value$1 : [value$1];
	const flatten = (list, result = []) => {
		list.forEach((item) => {
			if (Array.isArray(item)) flatten(item, result);
			else result.push(item);
		});
		return result;
	};
	const unifyPaths = (paths_) => {
		/**
		* @type {Array<String>}
		*/
		const paths = flatten(arrify(paths_));
		if (!paths.every((p) => typeof p === STRING_TYPE)) throw new TypeError(`Non-string provided as watch path: ${paths}`);
		return paths.map(normalizePathToUnix);
	};
	const toUnix = (string) => {
		let str = string.replace(BACK_SLASH_RE, SLASH);
		let prepend = false;
		if (str.startsWith(SLASH_SLASH)) prepend = true;
		while (str.match(DOUBLE_SLASH_RE)) str = str.replace(DOUBLE_SLASH_RE, SLASH);
		if (prepend) str = SLASH + str;
		return str;
	};
	const normalizePathToUnix = (path$13) => toUnix(sysPath.normalize(toUnix(path$13)));
	const normalizeIgnored = (cwd = EMPTY_STR) => (path$13) => {
		if (typeof path$13 !== STRING_TYPE) return path$13;
		return normalizePathToUnix(sysPath.isAbsolute(path$13) ? path$13 : sysPath.join(cwd, path$13));
	};
	const getAbsolutePath = (path$13, cwd) => {
		if (sysPath.isAbsolute(path$13)) return path$13;
		if (path$13.startsWith(BANG)) return BANG + sysPath.join(cwd, path$13.slice(1));
		return sysPath.join(cwd, path$13);
	};
	const undef = (opts, key) => opts[key] === void 0;
	/**
	* Directory entry.
	* @property {Path} path
	* @property {Set<Path>} items
	*/
	var DirEntry = class {
		/**
		* @param {Path} dir
		* @param {Function} removeWatcher
		*/
		constructor(dir, removeWatcher) {
			this.path = dir;
			this._removeWatcher = removeWatcher;
			/** @type {Set<Path>} */
			this.items = /* @__PURE__ */ new Set();
		}
		add(item) {
			const { items } = this;
			if (!items) return;
			if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);
		}
		async remove(item) {
			const { items } = this;
			if (!items) return;
			items.delete(item);
			if (items.size > 0) return;
			const dir = this.path;
			try {
				await readdir(dir);
			} catch (err$2) {
				if (this._removeWatcher) this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
			}
		}
		has(item) {
			const { items } = this;
			if (!items) return;
			return items.has(item);
		}
		/**
		* @returns {Array<String>}
		*/
		getChildren() {
			const { items } = this;
			if (!items) return;
			return [...items.values()];
		}
		dispose() {
			this.items.clear();
			delete this.path;
			delete this._removeWatcher;
			delete this.items;
			Object.freeze(this);
		}
	};
	const STAT_METHOD_F = "stat";
	const STAT_METHOD_L = "lstat";
	var WatchHelper = class {
		constructor(path$13, watchPath, follow, fsw) {
			this.fsw = fsw;
			this.path = path$13 = path$13.replace(REPLACER_RE, EMPTY_STR);
			this.watchPath = watchPath;
			this.fullWatchPath = sysPath.resolve(watchPath);
			this.hasGlob = watchPath !== path$13;
			/** @type {object|boolean} */
			if (path$13 === EMPTY_STR) this.hasGlob = false;
			this.globSymlink = this.hasGlob && follow ? void 0 : false;
			this.globFilter = this.hasGlob ? anymatch(path$13, void 0, ANYMATCH_OPTS) : false;
			this.dirParts = this.getDirParts(path$13);
			this.dirParts.forEach((parts) => {
				if (parts.length > 1) parts.pop();
			});
			this.followSymlinks = follow;
			this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
		}
		checkGlobSymlink(entry) {
			if (this.globSymlink === void 0) this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {
				realPath: entry.fullParentDir,
				linkPath: this.fullWatchPath
			};
			if (this.globSymlink) return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
			return entry.fullPath;
		}
		entryPath(entry) {
			return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));
		}
		filterPath(entry) {
			const { stats } = entry;
			if (stats && stats.isSymbolicLink()) return this.filterDir(entry);
			const resolvedPath = this.entryPath(entry);
			return (this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true) && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
		}
		getDirParts(path$13) {
			if (!this.hasGlob) return [];
			const parts = [];
			(path$13.includes(BRACE_START) ? braces.expand(path$13) : [path$13]).forEach((path$14) => {
				parts.push(sysPath.relative(this.watchPath, path$14).split(SLASH_OR_BACK_SLASH_RE));
			});
			return parts;
		}
		filterDir(entry) {
			if (this.hasGlob) {
				const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
				let globstar = false;
				this.unmatchedGlob = !this.dirParts.some((parts) => {
					return parts.every((part, i$1) => {
						if (part === GLOBSTAR) globstar = true;
						return globstar || !entryParts[0][i$1] || anymatch(part, entryParts[0][i$1], ANYMATCH_OPTS);
					});
				});
			}
			return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
		}
	};
	/**
	* Watches files & directories for changes. Emitted events:
	* `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
	*
	*     new FSWatcher()
	*       .add(directories)
	*       .on('add', path => log('File', path, 'was added'))
	*/
	var FSWatcher = class extends EventEmitter$3 {
		constructor(_opts) {
			super();
			const opts = {};
			if (_opts) Object.assign(opts, _opts);
			/** @type {Map<String, DirEntry>} */
			this._watched = /* @__PURE__ */ new Map();
			/** @type {Map<String, Array>} */
			this._closers = /* @__PURE__ */ new Map();
			/** @type {Set<String>} */
			this._ignoredPaths = /* @__PURE__ */ new Set();
			/** @type {Map<ThrottleType, Map>} */
			this._throttled = /* @__PURE__ */ new Map();
			/** @type {Map<Path, String|Boolean>} */
			this._symlinkPaths = /* @__PURE__ */ new Map();
			this._streams = /* @__PURE__ */ new Set();
			this.closed = false;
			if (undef(opts, "persistent")) opts.persistent = true;
			if (undef(opts, "ignoreInitial")) opts.ignoreInitial = false;
			if (undef(opts, "ignorePermissionErrors")) opts.ignorePermissionErrors = false;
			if (undef(opts, "interval")) opts.interval = 100;
			if (undef(opts, "binaryInterval")) opts.binaryInterval = 300;
			if (undef(opts, "disableGlobbing")) opts.disableGlobbing = false;
			opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
			if (undef(opts, "useFsEvents")) opts.useFsEvents = !opts.usePolling;
			if (!FsEventsHandler.canUse()) opts.useFsEvents = false;
			if (undef(opts, "usePolling") && !opts.useFsEvents) opts.usePolling = isMacos;
			if (isIBMi) opts.usePolling = true;
			const envPoll = process.env.CHOKIDAR_USEPOLLING;
			if (envPoll !== void 0) {
				const envLower = envPoll.toLowerCase();
				if (envLower === "false" || envLower === "0") opts.usePolling = false;
				else if (envLower === "true" || envLower === "1") opts.usePolling = true;
				else opts.usePolling = !!envLower;
			}
			const envInterval = process.env.CHOKIDAR_INTERVAL;
			if (envInterval) opts.interval = Number.parseInt(envInterval, 10);
			if (undef(opts, "atomic")) opts.atomic = !opts.usePolling && !opts.useFsEvents;
			if (opts.atomic) this._pendingUnlinks = /* @__PURE__ */ new Map();
			if (undef(opts, "followSymlinks")) opts.followSymlinks = true;
			if (undef(opts, "awaitWriteFinish")) opts.awaitWriteFinish = false;
			if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
			const awf = opts.awaitWriteFinish;
			if (awf) {
				if (!awf.stabilityThreshold) awf.stabilityThreshold = 2e3;
				if (!awf.pollInterval) awf.pollInterval = 100;
				this._pendingWrites = /* @__PURE__ */ new Map();
			}
			if (opts.ignored) opts.ignored = arrify(opts.ignored);
			let readyCalls = 0;
			this._emitReady = () => {
				readyCalls++;
				if (readyCalls >= this._readyCount) {
					this._emitReady = EMPTY_FN;
					this._readyEmitted = true;
					process.nextTick(() => this.emit(EV_READY));
				}
			};
			this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
			this._readyEmitted = false;
			this.options = opts;
			if (opts.useFsEvents) this._fsEventsHandler = new FsEventsHandler(this);
			else this._nodeFsHandler = new NodeFsHandler(this);
			Object.freeze(opts);
		}
		/**
		* Adds paths to be watched on an existing FSWatcher instance
		* @param {Path|Array<Path>} paths_
		* @param {String=} _origAdd private; for handling non-existent paths to be watched
		* @param {Boolean=} _internal private; indicates a non-user add
		* @returns {FSWatcher} for chaining
		*/
		add(paths_, _origAdd, _internal) {
			const { cwd, disableGlobbing } = this.options;
			this.closed = false;
			let paths = unifyPaths(paths_);
			if (cwd) paths = paths.map((path$13) => {
				const absPath = getAbsolutePath(path$13, cwd);
				if (disableGlobbing || !isGlob(path$13)) return absPath;
				return normalizePath$1(absPath);
			});
			paths = paths.filter((path$13) => {
				if (path$13.startsWith(BANG)) {
					this._ignoredPaths.add(path$13.slice(1));
					return false;
				}
				this._ignoredPaths.delete(path$13);
				this._ignoredPaths.delete(path$13 + SLASH_GLOBSTAR);
				this._userIgnored = void 0;
				return true;
			});
			if (this.options.useFsEvents && this._fsEventsHandler) {
				if (!this._readyCount) this._readyCount = paths.length;
				if (this.options.persistent) this._readyCount += paths.length;
				paths.forEach((path$13) => this._fsEventsHandler._addToFsEvents(path$13));
			} else {
				if (!this._readyCount) this._readyCount = 0;
				this._readyCount += paths.length;
				Promise.all(paths.map(async (path$13) => {
					const res = await this._nodeFsHandler._addToNodeFs(path$13, !_internal, 0, 0, _origAdd);
					if (res) this._emitReady();
					return res;
				})).then((results) => {
					if (this.closed) return;
					results.filter((item) => item).forEach((item) => {
						this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
					});
				});
			}
			return this;
		}
		/**
		* Close watchers or start ignoring events from specified paths.
		* @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
		* @returns {FSWatcher} for chaining
		*/
		unwatch(paths_) {
			if (this.closed) return this;
			const paths = unifyPaths(paths_);
			const { cwd } = this.options;
			paths.forEach((path$13) => {
				if (!sysPath.isAbsolute(path$13) && !this._closers.has(path$13)) {
					if (cwd) path$13 = sysPath.join(cwd, path$13);
					path$13 = sysPath.resolve(path$13);
				}
				this._closePath(path$13);
				this._ignoredPaths.add(path$13);
				if (this._watched.has(path$13)) this._ignoredPaths.add(path$13 + SLASH_GLOBSTAR);
				this._userIgnored = void 0;
			});
			return this;
		}
		/**
		* Close watchers and remove all listeners from watched paths.
		* @returns {Promise<void>}.
		*/
		close() {
			if (this.closed) return this._closePromise;
			this.closed = true;
			this.removeAllListeners();
			const closers = [];
			this._closers.forEach((closerList) => closerList.forEach((closer) => {
				const promise = closer();
				if (promise instanceof Promise) closers.push(promise);
			}));
			this._streams.forEach((stream$3) => stream$3.destroy());
			this._userIgnored = void 0;
			this._readyCount = 0;
			this._readyEmitted = false;
			this._watched.forEach((dirent) => dirent.dispose());
			[
				"closers",
				"watched",
				"streams",
				"symlinkPaths",
				"throttled"
			].forEach((key) => {
				this[`_${key}`].clear();
			});
			this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
			return this._closePromise;
		}
		/**
		* Expose list of watched paths
		* @returns {Object} for chaining
		*/
		getWatched() {
			const watchList = {};
			this._watched.forEach((entry, dir) => {
				const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
				watchList[key || ONE_DOT] = entry.getChildren().sort();
			});
			return watchList;
		}
		emitWithAll(event, args) {
			this.emit(...args);
			if (event !== EV_ERROR) this.emit(EV_ALL, ...args);
		}
		/**
		* Normalize and emit events.
		* Calling _emit DOES NOT MEAN emit() would be called!
		* @param {EventName} event Type of event
		* @param {Path} path File or directory path
		* @param {*=} val1 arguments to be passed with event
		* @param {*=} val2
		* @param {*=} val3
		* @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
		*/
		async _emit(event, path$13, val1, val2, val3) {
			if (this.closed) return;
			const opts = this.options;
			if (isWindows$2) path$13 = sysPath.normalize(path$13);
			if (opts.cwd) path$13 = sysPath.relative(opts.cwd, path$13);
			/** @type Array<any> */
			const args = [event, path$13];
			if (val3 !== void 0) args.push(val1, val2, val3);
			else if (val2 !== void 0) args.push(val1, val2);
			else if (val1 !== void 0) args.push(val1);
			const awf = opts.awaitWriteFinish;
			let pw;
			if (awf && (pw = this._pendingWrites.get(path$13))) {
				pw.lastChange = /* @__PURE__ */ new Date();
				return this;
			}
			if (opts.atomic) {
				if (event === EV_UNLINK) {
					this._pendingUnlinks.set(path$13, args);
					setTimeout(() => {
						this._pendingUnlinks.forEach((entry, path$14) => {
							this.emit(...entry);
							this.emit(EV_ALL, ...entry);
							this._pendingUnlinks.delete(path$14);
						});
					}, typeof opts.atomic === "number" ? opts.atomic : 100);
					return this;
				}
				if (event === EV_ADD && this._pendingUnlinks.has(path$13)) {
					event = args[0] = EV_CHANGE;
					this._pendingUnlinks.delete(path$13);
				}
			}
			if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
				const awfEmit = (err$2, stats) => {
					if (err$2) {
						event = args[0] = EV_ERROR;
						args[1] = err$2;
						this.emitWithAll(event, args);
					} else if (stats) {
						if (args.length > 2) args[2] = stats;
						else args.push(stats);
						this.emitWithAll(event, args);
					}
				};
				this._awaitWriteFinish(path$13, awf.stabilityThreshold, event, awfEmit);
				return this;
			}
			if (event === EV_CHANGE) {
				if (!this._throttle(EV_CHANGE, path$13, 50)) return this;
			}
			if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
				const fullPath = opts.cwd ? sysPath.join(opts.cwd, path$13) : path$13;
				let stats;
				try {
					stats = await stat(fullPath);
				} catch (err$2) {}
				if (!stats || this.closed) return;
				args.push(stats);
			}
			this.emitWithAll(event, args);
			return this;
		}
		/**
		* Common handler for errors
		* @param {Error} error
		* @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
		*/
		_handleError(error$1) {
			const code = error$1 && error$1.code;
			if (error$1 && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) this.emit(EV_ERROR, error$1);
			return error$1 || this.closed;
		}
		/**
		* Helper utility for throttling
		* @param {ThrottleType} actionType type being throttled
		* @param {Path} path being acted upon
		* @param {Number} timeout duration of time to suppress duplicate actions
		* @returns {Object|false} tracking object or false if action should be suppressed
		*/
		_throttle(actionType, path$13, timeout$1) {
			if (!this._throttled.has(actionType)) this._throttled.set(actionType, /* @__PURE__ */ new Map());
			/** @type {Map<Path, Object>} */
			const action = this._throttled.get(actionType);
			/** @type {Object} */
			const actionPath = action.get(path$13);
			if (actionPath) {
				actionPath.count++;
				return false;
			}
			let timeoutObject;
			const clear = () => {
				const item = action.get(path$13);
				const count = item ? item.count : 0;
				action.delete(path$13);
				clearTimeout(timeoutObject);
				if (item) clearTimeout(item.timeoutObject);
				return count;
			};
			timeoutObject = setTimeout(clear, timeout$1);
			const thr = {
				timeoutObject,
				clear,
				count: 0
			};
			action.set(path$13, thr);
			return thr;
		}
		_incrReadyCount() {
			return this._readyCount++;
		}
		/**
		* Awaits write operation to finish.
		* Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
		* @param {Path} path being acted upon
		* @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
		* @param {EventName} event
		* @param {Function} awfEmit Callback to be called when ready for event to be emitted.
		*/
		_awaitWriteFinish(path$13, threshold, event, awfEmit) {
			let timeoutHandler;
			let fullPath = path$13;
			if (this.options.cwd && !sysPath.isAbsolute(path$13)) fullPath = sysPath.join(this.options.cwd, path$13);
			const now = /* @__PURE__ */ new Date();
			const awaitWriteFinish = (prevStat) => {
				fs$6.stat(fullPath, (err$2, curStat) => {
					if (err$2 || !this._pendingWrites.has(path$13)) {
						if (err$2 && err$2.code !== "ENOENT") awfEmit(err$2);
						return;
					}
					const now$1 = Number(/* @__PURE__ */ new Date());
					if (prevStat && curStat.size !== prevStat.size) this._pendingWrites.get(path$13).lastChange = now$1;
					if (now$1 - this._pendingWrites.get(path$13).lastChange >= threshold) {
						this._pendingWrites.delete(path$13);
						awfEmit(void 0, curStat);
					} else timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval, curStat);
				});
			};
			if (!this._pendingWrites.has(path$13)) {
				this._pendingWrites.set(path$13, {
					lastChange: now,
					cancelWait: () => {
						this._pendingWrites.delete(path$13);
						clearTimeout(timeoutHandler);
						return event;
					}
				});
				timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);
			}
		}
		_getGlobIgnored() {
			return [...this._ignoredPaths.values()];
		}
		/**
		* Determines whether user has asked to ignore this path.
		* @param {Path} path filepath or dir
		* @param {fs.Stats=} stats result of fs.stat
		* @returns {Boolean}
		*/
		_isIgnored(path$13, stats) {
			if (this.options.atomic && DOT_RE.test(path$13)) return true;
			if (!this._userIgnored) {
				const { cwd } = this.options;
				const ign = this.options.ignored;
				const ignored = ign && ign.map(normalizeIgnored(cwd));
				const paths = arrify(ignored).filter((path$14) => typeof path$14 === STRING_TYPE && !isGlob(path$14)).map((path$14) => path$14 + SLASH_GLOBSTAR);
				this._userIgnored = anymatch(this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths), void 0, ANYMATCH_OPTS);
			}
			return this._userIgnored([path$13, stats]);
		}
		_isntIgnored(path$13, stat$4) {
			return !this._isIgnored(path$13, stat$4);
		}
		/**
		* Provides a set of common helpers and properties relating to symlink and glob handling.
		* @param {Path} path file, directory, or glob pattern being watched
		* @param {Number=} depth at any depth > 0, this isn't a glob
		* @returns {WatchHelper} object containing helpers for this path
		*/
		_getWatchHelpers(path$13, depth) {
			const watchPath = depth || this.options.disableGlobbing || !isGlob(path$13) ? path$13 : globParent(path$13);
			const follow = this.options.followSymlinks;
			return new WatchHelper(path$13, watchPath, follow, this);
		}
		/**
		* Provides directory tracking objects
		* @param {String} directory path of the directory
		* @returns {DirEntry} the directory's tracking object
		*/
		_getWatchedDir(directory) {
			if (!this._boundRemove) this._boundRemove = this._remove.bind(this);
			const dir = sysPath.resolve(directory);
			if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
			return this._watched.get(dir);
		}
		/**
		* Check for read permissions.
		* Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
		* @param {fs.Stats} stats - object, result of fs_stat
		* @returns {Boolean} indicates whether the file can be read
		*/
		_hasReadPermissions(stats) {
			if (this.options.ignorePermissionErrors) return true;
			const st = (stats && Number.parseInt(stats.mode, 10)) & 511;
			const it = Number.parseInt(st.toString(8)[0], 10);
			return Boolean(4 & it);
		}
		/**
		* Handles emitting unlink events for
		* files and directories, and via recursion, for
		* files and directories within directories that are unlinked
		* @param {String} directory within which the following item is located
		* @param {String} item      base path of item/directory
		* @returns {void}
		*/
		_remove(directory, item, isDirectory$2) {
			const path$13 = sysPath.join(directory, item);
			const fullPath = sysPath.resolve(path$13);
			isDirectory$2 = isDirectory$2 != null ? isDirectory$2 : this._watched.has(path$13) || this._watched.has(fullPath);
			if (!this._throttle("remove", path$13, 100)) return;
			if (!isDirectory$2 && !this.options.useFsEvents && this._watched.size === 1) this.add(directory, item, true);
			this._getWatchedDir(path$13).getChildren().forEach((nested) => this._remove(path$13, nested));
			const parent = this._getWatchedDir(directory);
			const wasTracked = parent.has(item);
			parent.remove(item);
			if (this._symlinkPaths.has(fullPath)) this._symlinkPaths.delete(fullPath);
			let relPath = path$13;
			if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path$13);
			if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
				if (this._pendingWrites.get(relPath).cancelWait() === EV_ADD) return;
			}
			this._watched.delete(path$13);
			this._watched.delete(fullPath);
			const eventName = isDirectory$2 ? EV_UNLINK_DIR : EV_UNLINK;
			if (wasTracked && !this._isIgnored(path$13)) this._emit(eventName, path$13);
			if (!this.options.useFsEvents) this._closePath(path$13);
		}
		/**
		* Closes all watchers for a path
		* @param {Path} path
		*/
		_closePath(path$13) {
			this._closeFile(path$13);
			const dir = sysPath.dirname(path$13);
			this._getWatchedDir(dir).remove(sysPath.basename(path$13));
		}
		/**
		* Closes only file-specific watchers
		* @param {Path} path
		*/
		_closeFile(path$13) {
			const closers = this._closers.get(path$13);
			if (!closers) return;
			closers.forEach((closer) => closer());
			this._closers.delete(path$13);
		}
		/**
		*
		* @param {Path} path
		* @param {Function} closer
		*/
		_addPathCloser(path$13, closer) {
			if (!closer) return;
			let list = this._closers.get(path$13);
			if (!list) {
				list = [];
				this._closers.set(path$13, list);
			}
			list.push(closer);
		}
		_readdirp(root, opts) {
			if (this.closed) return;
			let stream$3 = readdirp(root, {
				type: EV_ALL,
				alwaysStat: true,
				lstat: true,
				...opts
			});
			this._streams.add(stream$3);
			stream$3.once(STR_CLOSE, () => {
				stream$3 = void 0;
			});
			stream$3.once(STR_END, () => {
				if (stream$3) {
					this._streams.delete(stream$3);
					stream$3 = void 0;
				}
			});
			return stream$3;
		}
	};
	/**
	* Instantiates watcher with paths to be tracked.
	* @param {String|Array<String>} paths file/directory paths and/or globs
	* @param {Object=} options chokidar opts
	* @returns an instance of FSWatcher for chaining.
	*/
	const watch = (paths, options$1) => {
		const watcher = new FSWatcher(options$1);
		watcher.add(paths);
		return watcher;
	};
	exports.watch = watch;
}) });

//#endregion
//#region ../../node_modules/.pnpm/shell-quote@1.8.3/node_modules/shell-quote/quote.js
var require_quote = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/shell-quote@1.8.3/node_modules/shell-quote/quote.js": ((exports, module) => {
	module.exports = function quote(xs) {
		return xs.map(function(s$2) {
			if (s$2 === "") return "''";
			if (s$2 && typeof s$2 === "object") return s$2.op.replace(/(.)/g, "\\$1");
			if (/["\s\\]/.test(s$2) && !/'/.test(s$2)) return "'" + s$2.replace(/(['])/g, "\\$1") + "'";
			if (/["'\s]/.test(s$2)) return "\"" + s$2.replace(/(["\\$`!])/g, "\\$1") + "\"";
			return String(s$2).replace(/([A-Za-z]:)?([#!"$&'()*,:;<=>?@[\\\]^`{|}])/g, "$1\\$2");
		}).join(" ");
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/shell-quote@1.8.3/node_modules/shell-quote/parse.js
var require_parse$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/shell-quote@1.8.3/node_modules/shell-quote/parse.js": ((exports, module) => {
	var CONTROL = "(?:" + [
		"\\|\\|",
		"\\&\\&",
		";;",
		"\\|\\&",
		"\\<\\(",
		"\\<\\<\\<",
		">>",
		">\\&",
		"<\\&",
		"[&;()|<>]"
	].join("|") + ")";
	var controlRE = /* @__PURE__ */ new RegExp("^" + CONTROL + "$");
	var META = "|&;()<> \\t";
	var SINGLE_QUOTE = "\"((\\\\\"|[^\"])*?)\"";
	var DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
	var hash = /^#$/;
	var SQ = "'";
	var DQ = "\"";
	var DS = "$";
	var TOKEN = "";
	var mult = 4294967296;
	for (var i = 0; i < 4; i++) TOKEN += (mult * Math.random()).toString(16);
	var startsWithToken = /* @__PURE__ */ new RegExp("^" + TOKEN);
	function matchAll(s$2, r$1) {
		var origIndex = r$1.lastIndex;
		var matches$2 = [];
		var matchObj;
		while (matchObj = r$1.exec(s$2)) {
			matches$2.push(matchObj);
			if (r$1.lastIndex === matchObj.index) r$1.lastIndex += 1;
		}
		r$1.lastIndex = origIndex;
		return matches$2;
	}
	function getVar(env$1, pre, key) {
		var r$1 = typeof env$1 === "function" ? env$1(key) : env$1[key];
		if (typeof r$1 === "undefined" && key != "") r$1 = "";
		else if (typeof r$1 === "undefined") r$1 = "$";
		if (typeof r$1 === "object") return pre + TOKEN + JSON.stringify(r$1) + TOKEN;
		return pre + r$1;
	}
	function parseInternal(string, env$1, opts) {
		if (!opts) opts = {};
		var BS = opts.escape || "\\";
		var BAREWORD = "(\\" + BS + "['\"" + META + "]|[^\\s'\"" + META + "])+";
		var matches$2 = matchAll(string, new RegExp(["(" + CONTROL + ")", "(" + BAREWORD + "|" + SINGLE_QUOTE + "|" + DOUBLE_QUOTE + ")+"].join("|"), "g"));
		if (matches$2.length === 0) return [];
		if (!env$1) env$1 = {};
		var commented = false;
		return matches$2.map(function(match) {
			var s$2 = match[0];
			if (!s$2 || commented) return;
			if (controlRE.test(s$2)) return { op: s$2 };
			var quote = false;
			var esc = false;
			var out = "";
			var isGlob$2 = false;
			var i$1;
			function parseEnvVar() {
				i$1 += 1;
				var varend;
				var varname;
				var char = s$2.charAt(i$1);
				if (char === "{") {
					i$1 += 1;
					if (s$2.charAt(i$1) === "}") throw new Error("Bad substitution: " + s$2.slice(i$1 - 2, i$1 + 1));
					varend = s$2.indexOf("}", i$1);
					if (varend < 0) throw new Error("Bad substitution: " + s$2.slice(i$1));
					varname = s$2.slice(i$1, varend);
					i$1 = varend;
				} else if (/[*@#?$!_-]/.test(char)) {
					varname = char;
					i$1 += 1;
				} else {
					var slicedFromI = s$2.slice(i$1);
					varend = slicedFromI.match(/[^\w\d_]/);
					if (!varend) {
						varname = slicedFromI;
						i$1 = s$2.length;
					} else {
						varname = slicedFromI.slice(0, varend.index);
						i$1 += varend.index - 1;
					}
				}
				return getVar(env$1, "", varname);
			}
			for (i$1 = 0; i$1 < s$2.length; i$1++) {
				var c = s$2.charAt(i$1);
				isGlob$2 = isGlob$2 || !quote && (c === "*" || c === "?");
				if (esc) {
					out += c;
					esc = false;
				} else if (quote) if (c === quote) quote = false;
				else if (quote == SQ) out += c;
				else if (c === BS) {
					i$1 += 1;
					c = s$2.charAt(i$1);
					if (c === DQ || c === BS || c === DS) out += c;
					else out += BS + c;
				} else if (c === DS) out += parseEnvVar();
				else out += c;
				else if (c === DQ || c === SQ) quote = c;
				else if (controlRE.test(c)) return { op: s$2 };
				else if (hash.test(c)) {
					commented = true;
					var commentObj = { comment: string.slice(match.index + i$1 + 1) };
					if (out.length) return [out, commentObj];
					return [commentObj];
				} else if (c === BS) esc = true;
				else if (c === DS) out += parseEnvVar();
				else out += c;
			}
			if (isGlob$2) return {
				op: "glob",
				pattern: out
			};
			return out;
		}).reduce(function(prev, arg) {
			return typeof arg === "undefined" ? prev : prev.concat(arg);
		}, []);
	}
	module.exports = function parse$17(s$2, env$1, opts) {
		var mapped = parseInternal(s$2, env$1, opts);
		if (typeof env$1 !== "function") return mapped;
		return mapped.reduce(function(acc, s$3) {
			if (typeof s$3 === "object") return acc.concat(s$3);
			var xs = s$3.split(RegExp("(" + TOKEN + ".*?" + TOKEN + ")", "g"));
			if (xs.length === 1) return acc.concat(xs[0]);
			return acc.concat(xs.filter(Boolean).map(function(x) {
				if (startsWithToken.test(x)) return JSON.parse(x.split(TOKEN)[1]);
				return x;
			}));
		}, []);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/shell-quote@1.8.3/node_modules/shell-quote/index.js
var require_shell_quote = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/shell-quote@1.8.3/node_modules/shell-quote/index.js": ((exports) => {
	exports.quote = require_quote();
	exports.parse = require_parse$1();
}) });

//#endregion
//#region ../../node_modules/.pnpm/launch-editor@2.11.1/node_modules/launch-editor/editor-info/macos.js
var require_macos = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/launch-editor@2.11.1/node_modules/launch-editor/editor-info/macos.js": ((exports, module) => {
	module.exports = {
		"/Applications/Atom.app/Contents/MacOS/Atom": "atom",
		"/Applications/Atom Beta.app/Contents/MacOS/Atom Beta": "/Applications/Atom Beta.app/Contents/MacOS/Atom Beta",
		"/Applications/Brackets.app/Contents/MacOS/Brackets": "brackets",
		"/Applications/Sublime Text.app/Contents/MacOS/Sublime Text": "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl",
		"/Applications/Sublime Text.app/Contents/MacOS/sublime_text": "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl",
		"/Applications/Sublime Text 2.app/Contents/MacOS/Sublime Text 2": "/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl",
		"/Applications/Sublime Text Dev.app/Contents/MacOS/Sublime Text": "/Applications/Sublime Text Dev.app/Contents/SharedSupport/bin/subl",
		"/Applications/Visual Studio Code.app/Contents/MacOS/Electron": "code",
		"/Applications/Visual Studio Code - Insiders.app/Contents/MacOS/Electron": "code-insiders",
		"/Applications/VSCodium.app/Contents/MacOS/Electron": "codium",
		"/Applications/Cursor.app/Contents/MacOS/Cursor": "cursor",
		"/Applications/Trae.app/Contents/MacOS/Electron": "trae",
		"/Applications/AppCode.app/Contents/MacOS/appcode": "/Applications/AppCode.app/Contents/MacOS/appcode",
		"/Applications/CLion.app/Contents/MacOS/clion": "/Applications/CLion.app/Contents/MacOS/clion",
		"/Applications/IntelliJ IDEA.app/Contents/MacOS/idea": "/Applications/IntelliJ IDEA.app/Contents/MacOS/idea",
		"/Applications/IntelliJ IDEA Ultimate.app/Contents/MacOS/idea": "/Applications/IntelliJ IDEA Ultimate.app/Contents/MacOS/idea",
		"/Applications/IntelliJ IDEA Community Edition.app/Contents/MacOS/idea": "/Applications/IntelliJ IDEA Community Edition.app/Contents/MacOS/idea",
		"/Applications/PhpStorm.app/Contents/MacOS/phpstorm": "/Applications/PhpStorm.app/Contents/MacOS/phpstorm",
		"/Applications/PyCharm.app/Contents/MacOS/pycharm": "/Applications/PyCharm.app/Contents/MacOS/pycharm",
		"/Applications/PyCharm CE.app/Contents/MacOS/pycharm": "/Applications/PyCharm CE.app/Contents/MacOS/pycharm",
		"/Applications/RubyMine.app/Contents/MacOS/rubymine": "/Applications/RubyMine.app/Contents/MacOS/rubymine",
		"/Applications/WebStorm.app/Contents/MacOS/webstorm": "/Applications/WebStorm.app/Contents/MacOS/webstorm",
		"/Applications/MacVim.app/Contents/MacOS/MacVim": "mvim",
		"/Applications/GoLand.app/Contents/MacOS/goland": "/Applications/GoLand.app/Contents/MacOS/goland",
		"/Applications/Rider.app/Contents/MacOS/rider": "/Applications/Rider.app/Contents/MacOS/rider",
		"/Applications/Zed.app/Contents/MacOS/zed": "zed"
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/launch-editor@2.11.1/node_modules/launch-editor/editor-info/linux.js
var require_linux = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/launch-editor@2.11.1/node_modules/launch-editor/editor-info/linux.js": ((exports, module) => {
	module.exports = {
		atom: "atom",
		Brackets: "brackets",
		"code-insiders": "code-insiders",
		code: "code",
		vscodium: "vscodium",
		codium: "codium",
		trae: "trae",
		emacs: "emacs",
		gvim: "gvim",
		idea: "idea",
		"idea.sh": "idea",
		phpstorm: "phpstorm",
		"phpstorm.sh": "phpstorm",
		pycharm: "pycharm",
		"pycharm.sh": "pycharm",
		rubymine: "rubymine",
		"rubymine.sh": "rubymine",
		sublime_text: "subl",
		vim: "vim",
		webstorm: "webstorm",
		"webstorm.sh": "webstorm",
		goland: "goland",
		"goland.sh": "goland",
		rider: "rider",
		"rider.sh": "rider",
		zed: "zed"
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/launch-editor@2.11.1/node_modules/launch-editor/editor-info/windows.js
var require_windows$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/launch-editor@2.11.1/node_modules/launch-editor/editor-info/windows.js": ((exports, module) => {
	module.exports = [
		"Brackets.exe",
		"Code.exe",
		"Code - Insiders.exe",
		"VSCodium.exe",
		"Cursor.exe",
		"atom.exe",
		"sublime_text.exe",
		"notepad++.exe",
		"clion.exe",
		"clion64.exe",
		"idea.exe",
		"idea64.exe",
		"phpstorm.exe",
		"phpstorm64.exe",
		"pycharm.exe",
		"pycharm64.exe",
		"rubymine.exe",
		"rubymine64.exe",
		"webstorm.exe",
		"webstorm64.exe",
		"goland.exe",
		"goland64.exe",
		"rider.exe",
		"rider64.exe",
		"trae.exe"
	];
}) });

//#endregion
//#region ../../node_modules/.pnpm/launch-editor@2.11.1/node_modules/launch-editor/guess.js
var require_guess = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/launch-editor@2.11.1/node_modules/launch-editor/guess.js": ((exports, module) => {
	const path$8 = __require("path");
	const shellQuote = require_shell_quote();
	const childProcess$2 = __require("child_process");
	const COMMON_EDITORS_MACOS = require_macos();
	const COMMON_EDITORS_LINUX = require_linux();
	const COMMON_EDITORS_WIN = require_windows$1();
	module.exports = function guessEditor$1(specifiedEditor) {
		if (specifiedEditor) return shellQuote.parse(specifiedEditor);
		if (process.env.LAUNCH_EDITOR) return [process.env.LAUNCH_EDITOR];
		if (process.versions.webcontainer) return [process.env.EDITOR || "code"];
		try {
			if (process.platform === "darwin") {
				const output = childProcess$2.execSync("ps x -o comm=", { stdio: [
					"pipe",
					"pipe",
					"ignore"
				] }).toString();
				const processNames = Object.keys(COMMON_EDITORS_MACOS);
				const processList = output.split("\n");
				for (let i$1 = 0; i$1 < processNames.length; i$1++) {
					const processName = processNames[i$1];
					if (processList.includes(processName)) return [COMMON_EDITORS_MACOS[processName]];
					const processNameWithoutApplications = processName.replace("/Applications", "");
					if (output.indexOf(processNameWithoutApplications) !== -1) {
						if (processName !== COMMON_EDITORS_MACOS[processName]) return [COMMON_EDITORS_MACOS[processName]];
						const runningProcess = processList.find((procName) => procName.endsWith(processNameWithoutApplications));
						if (runningProcess !== void 0) return [runningProcess];
					}
				}
			} else if (process.platform === "win32") {
				const runningProcesses = childProcess$2.execSync("powershell -NoProfile -Command \"[Console]::OutputEncoding=[Text.Encoding]::UTF8;Get-CimInstance -Query \\\"select executablepath from win32_process where executablepath is not null\\\" | % { $_.ExecutablePath }\"", { stdio: [
					"pipe",
					"pipe",
					"ignore"
				] }).toString().split("\r\n");
				for (let i$1 = 0; i$1 < runningProcesses.length; i$1++) {
					const fullProcessPath = runningProcesses[i$1].trim();
					const shortProcessName = path$8.basename(fullProcessPath);
					if (COMMON_EDITORS_WIN.indexOf(shortProcessName) !== -1) return [fullProcessPath];
				}
			} else if (process.platform === "linux") {
				const output = childProcess$2.execSync("ps x --no-heading -o comm --sort=comm", { stdio: [
					"pipe",
					"pipe",
					"ignore"
				] }).toString();
				const processNames = Object.keys(COMMON_EDITORS_LINUX);
				for (let i$1 = 0; i$1 < processNames.length; i$1++) {
					const processName = processNames[i$1];
					if (output.indexOf(processName) !== -1) return [COMMON_EDITORS_LINUX[processName]];
				}
			}
		} catch (ignoreError) {}
		if (process.env.VISUAL) return [process.env.VISUAL];
		else if (process.env.EDITOR) return [process.env.EDITOR];
		return [null];
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/launch-editor@2.11.1/node_modules/launch-editor/get-args.js
var require_get_args = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/launch-editor@2.11.1/node_modules/launch-editor/get-args.js": ((exports, module) => {
	const path$7 = __require("path");
	module.exports = function getArgumentsForPosition$1(editor, fileName, lineNumber, columnNumber = 1) {
		switch (path$7.basename(editor).replace(/\.(exe|cmd|bat)$/i, "")) {
			case "atom":
			case "Atom":
			case "Atom Beta":
			case "subl":
			case "sublime":
			case "sublime_text":
			case "wstorm":
			case "charm":
			case "zed": return [`${fileName}:${lineNumber}:${columnNumber}`];
			case "notepad++": return [
				"-n" + lineNumber,
				"-c" + columnNumber,
				fileName
			];
			case "vim":
			case "mvim": return [`+call cursor(${lineNumber}, ${columnNumber})`, fileName];
			case "joe":
			case "gvim": return [`+${lineNumber}`, fileName];
			case "emacs":
			case "emacsclient": return [`+${lineNumber}:${columnNumber}`, fileName];
			case "rmate":
			case "mate":
			case "mine": return [
				"--line",
				lineNumber,
				fileName
			];
			case "code":
			case "Code":
			case "code-insiders":
			case "Code - Insiders":
			case "codium":
			case "trae":
			case "cursor":
			case "vscodium":
			case "VSCodium": return [
				"-r",
				"-g",
				`${fileName}:${lineNumber}:${columnNumber}`
			];
			case "appcode":
			case "clion":
			case "clion64":
			case "idea":
			case "idea64":
			case "phpstorm":
			case "phpstorm64":
			case "pycharm":
			case "pycharm64":
			case "rubymine":
			case "rubymine64":
			case "webstorm":
			case "webstorm64":
			case "goland":
			case "goland64":
			case "rider":
			case "rider64": return [
				"--line",
				lineNumber,
				"--column",
				columnNumber,
				fileName
			];
		}
		if (process.env.LAUNCH_EDITOR) return [
			fileName,
			lineNumber,
			columnNumber
		];
		return [fileName];
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/launch-editor@2.11.1/node_modules/launch-editor/index.js
var require_launch_editor = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/launch-editor@2.11.1/node_modules/launch-editor/index.js": ((exports, module) => {
	/**
	* Copyright (c) 2015-present, Facebook, Inc.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file at
	* https://github.com/facebookincubator/create-react-app/blob/master/LICENSE
	*
	* Modified by Yuxi Evan You
	*/
	const fs$5 = __require("fs");
	const os$1 = __require("os");
	const path$6 = __require("path");
	const colors$22 = require_picocolors();
	const childProcess$1 = __require("child_process");
	const guessEditor = require_guess();
	const getArgumentsForPosition = require_get_args();
	function wrapErrorCallback(cb) {
		return (fileName, errorMessage) => {
			console.log();
			console.log(colors$22.red("Could not open " + path$6.basename(fileName) + " in the editor."));
			if (errorMessage) {
				if (errorMessage[errorMessage.length - 1] !== ".") errorMessage += ".";
				console.log(colors$22.red("The editor process exited with an error: " + errorMessage));
			}
			console.log();
			if (cb) cb(fileName, errorMessage);
		};
	}
	function isTerminalEditor(editor) {
		switch (editor) {
			case "vim":
			case "emacs":
			case "nano": return true;
		}
		return false;
	}
	const positionRE = /:(\d+)(:(\d+))?$/;
	function parseFile(file) {
		if (file.startsWith("file://")) file = __require("url").fileURLToPath(file);
		const fileName = file.replace(positionRE, "");
		const match = file.match(positionRE);
		return {
			fileName,
			lineNumber: match && match[1],
			columnNumber: match && match[3]
		};
	}
	let _childProcess = null;
	function launchEditor(file, specifiedEditor, onErrorCallback) {
		const parsed = parseFile(file);
		let { fileName } = parsed;
		const { lineNumber, columnNumber } = parsed;
		if (!fs$5.existsSync(fileName)) return;
		if (typeof specifiedEditor === "function") {
			onErrorCallback = specifiedEditor;
			specifiedEditor = void 0;
		}
		onErrorCallback = wrapErrorCallback(onErrorCallback);
		const [editor, ...args] = guessEditor(specifiedEditor);
		if (!editor) {
			onErrorCallback(fileName, null);
			return;
		}
		if (process.platform === "linux" && fileName.startsWith("/mnt/") && /Microsoft/i.test(os$1.release())) fileName = path$6.relative("", fileName);
		if (lineNumber) {
			const extraArgs = getArgumentsForPosition(editor, fileName, lineNumber, columnNumber);
			args.push.apply(args, extraArgs);
		} else args.push(fileName);
		if (_childProcess && isTerminalEditor(editor)) _childProcess.kill("SIGKILL");
		if (process.platform === "win32") {
			function escapeCmdArgs(cmdArgs) {
				return cmdArgs.replace(/([&|<>,;=^])/g, "^$1");
			}
			function doubleQuoteIfNeeded(str) {
				if (str.includes("^")) return `^"${str}^"`;
				else if (str.includes(" ")) return `"${str}"`;
				return str;
			}
			const launchCommand = [editor, ...args.map(escapeCmdArgs)].map(doubleQuoteIfNeeded).join(" ");
			_childProcess = childProcess$1.exec(launchCommand, {
				stdio: "inherit",
				shell: true
			});
		} else _childProcess = childProcess$1.spawn(editor, args, { stdio: "inherit" });
		_childProcess.on("exit", function(errorCode) {
			_childProcess = null;
			if (errorCode) onErrorCallback(fileName, "(code " + errorCode + ")");
		});
		_childProcess.on("error", function(error$1) {
			let { code, message } = error$1;
			if ("ENOENT" === code) message = `${message} ('${editor}' command does not exist in 'PATH')`;
			onErrorCallback(fileName, message);
		});
	}
	module.exports = launchEditor;
}) });

//#endregion
//#region ../../node_modules/.pnpm/launch-editor-middleware@2.11.1/node_modules/launch-editor-middleware/index.js
var require_launch_editor_middleware = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/launch-editor-middleware@2.11.1/node_modules/launch-editor-middleware/index.js": ((exports, module) => {
	const path$5 = __require("path");
	const launch = require_launch_editor();
	module.exports = (specifiedEditor, srcRoot, onErrorCallback) => {
		if (typeof specifiedEditor === "function") {
			onErrorCallback = specifiedEditor;
			specifiedEditor = void 0;
		}
		if (typeof srcRoot === "function") {
			onErrorCallback = srcRoot;
			srcRoot = void 0;
		}
		srcRoot = srcRoot || process.cwd();
		return function launchEditorMiddleware$1(req$4, res) {
			let url$3;
			try {
				const fullUrl = req$4.url.startsWith("http") ? req$4.url : `http://localhost${req$4.url}`;
				url$3 = new URL(fullUrl);
			} catch (_err) {
				res.statusCode = 500;
				res.end(`launch-editor-middleware: invalid URL.`);
				return;
			}
			const file = url$3.searchParams.get("file");
			if (!file) {
				res.statusCode = 500;
				res.end(`launch-editor-middleware: required query param "file" is missing.`);
			} else {
				launch(file.startsWith("file://") ? file : path$5.resolve(srcRoot, file), specifiedEditor, onErrorCallback);
				res.end();
			}
		};
	};
}) });

//#endregion
//#region src/node/http.ts
var import_picocolors$21 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
async function resolveHttpServer({ proxy }, app, httpsOptions) {
	if (!httpsOptions) {
		const { createServer: createServer$4 } = await import("node:http");
		return createServer$4(app);
	}
	if (proxy) {
		const { createServer: createServer$4 } = await import("node:https");
		return createServer$4(httpsOptions, app);
	} else {
		const { createSecureServer } = await import("node:http2");
		return createSecureServer({
			maxSessionMemory: 1e3,
			...httpsOptions,
			allowHTTP1: true
		}, app);
	}
}
async function resolveHttpsConfig(https$4) {
	if (!https$4) return void 0;
	const [ca, cert, key, pfx] = await Promise.all([
		readFileIfExists(https$4.ca),
		readFileIfExists(https$4.cert),
		readFileIfExists(https$4.key),
		readFileIfExists(https$4.pfx)
	]);
	return {
		...https$4,
		ca,
		cert,
		key,
		pfx
	};
}
async function readFileIfExists(value$1) {
	if (typeof value$1 === "string") return fsp.readFile(path.resolve(value$1)).catch(() => value$1);
	return value$1;
}
async function httpServerStart(httpServer, serverOptions) {
	let { port, strictPort, host, logger } = serverOptions;
	return new Promise((resolve$4, reject) => {
		const onError$1 = (e$1) => {
			if (e$1.code === "EADDRINUSE") if (strictPort) {
				httpServer.removeListener("error", onError$1);
				reject(/* @__PURE__ */ new Error(`Port ${port} is already in use`));
			} else {
				logger.info(`Port ${port} is in use, trying another one...`);
				httpServer.listen(++port, host);
			}
			else {
				httpServer.removeListener("error", onError$1);
				reject(e$1);
			}
		};
		httpServer.on("error", onError$1);
		httpServer.listen(port, host, () => {
			httpServer.removeListener("error", onError$1);
			resolve$4(port);
		});
	});
}
function setClientErrorHandler(server, logger) {
	server.on("clientError", (err$2, socket) => {
		let msg = "400 Bad Request";
		if (err$2.code === "HPE_HEADER_OVERFLOW") {
			msg = "431 Request Header Fields Too Large";
			logger.warn(import_picocolors$21.default.yellow("Server responded with status code 431. See https://vite.dev/guide/troubleshooting.html#_431-request-header-fields-too-large."));
		}
		if (err$2.code === "ECONNRESET" || !socket.writable) return;
		socket.end(`HTTP/1.1 ${msg}\r\n\r\n`);
	});
}

//#endregion
//#region src/node/ssr/ssrStacktrace.ts
let offset;
function calculateOffsetOnce() {
	if (offset !== void 0) return;
	try {
		new Function("throw new Error(1)")();
	} catch (e$1) {
		const match = /:(\d+):\d+\)$/.exec(e$1.stack.split("\n")[1]);
		offset = match ? +match[1] - 1 : 0;
	}
}
function ssrRewriteStacktrace(stack, moduleGraph) {
	calculateOffsetOnce();
	return stack.split("\n").map((line) => {
		return line.replace(/^ {4}at (?:(\S.*?)\s\()?(.+?):(\d+)(?::(\d+))?\)?/, (input, varName, id, line$1, column) => {
			if (!id) return input;
			const rawSourceMap = moduleGraph.getModuleById(id)?.transformResult?.map;
			if (!rawSourceMap) return input;
			const pos = originalPositionFor(new TraceMap(rawSourceMap), {
				line: Number(line$1) - offset,
				column: Number(column) - 1
			});
			if (!pos.source) return input;
			const trimmedVarName = varName?.trim();
			const source = `${path.resolve(path.dirname(id), pos.source)}:${pos.line}:${pos.column + 1}`;
			if (!trimmedVarName || trimmedVarName === "eval") return `    at ${source}`;
			else return `    at ${trimmedVarName} (${source})`;
		});
	}).join("\n");
}
function rebindErrorStacktrace(e$1, stacktrace) {
	const { configurable, writable } = Object.getOwnPropertyDescriptor(e$1, "stack");
	if (configurable) Object.defineProperty(e$1, "stack", {
		value: stacktrace,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else if (writable) e$1.stack = stacktrace;
}
const rewroteStacktraces = /* @__PURE__ */ new WeakSet();
function ssrFixStacktrace(e$1, moduleGraph) {
	if (!e$1.stack) return;
	if (rewroteStacktraces.has(e$1)) return;
	rebindErrorStacktrace(e$1, ssrRewriteStacktrace(e$1.stack, moduleGraph));
	rewroteStacktraces.add(e$1);
}

//#endregion
//#region src/node/ssr/runtime/serverModuleRunner.ts
function createHMROptions(environment, options$1) {
	if (environment.config.server.hmr === false || options$1.hmr === false) return false;
	if (!("api" in environment.hot)) return false;
	return { logger: options$1.hmr?.logger };
}
const prepareStackTrace = { retrieveFile(id) {
	if (existsSync(id)) return readFileSync(id, "utf-8");
} };
function resolveSourceMapOptions(options$1) {
	if (options$1.sourcemapInterceptor != null) {
		if (options$1.sourcemapInterceptor === "prepareStackTrace") return prepareStackTrace;
		if (typeof options$1.sourcemapInterceptor === "object") return {
			...prepareStackTrace,
			...options$1.sourcemapInterceptor
		};
		return options$1.sourcemapInterceptor;
	}
	if (typeof process !== "undefined" && "setSourceMapsEnabled" in process) return "node";
	return prepareStackTrace;
}
const createServerModuleRunnerTransport = (options$1) => {
	const hmrClient = { send: (payload) => {
		if (payload.type !== "custom") throw new Error("Cannot send non-custom events from the client to the server.");
		options$1.channel.send(payload);
	} };
	let handler;
	return {
		connect({ onMessage }) {
			options$1.channel.api.outsideEmitter.on("send", onMessage);
			onMessage({ type: "connected" });
			handler = onMessage;
		},
		disconnect() {
			if (handler) options$1.channel.api.outsideEmitter.off("send", handler);
		},
		send(payload) {
			if (payload.type !== "custom") throw new Error("Cannot send non-custom events from the server to the client.");
			options$1.channel.api.innerEmitter.emit(payload.event, payload.data, hmrClient);
		}
	};
};
/**
* Create an instance of the Vite SSR runtime that support HMR.
* @experimental
*/
function createServerModuleRunner(environment, options$1 = {}) {
	const hmr = createHMROptions(environment, options$1);
	return new ModuleRunner({
		...options$1,
		transport: createServerModuleRunnerTransport({ channel: environment.hot }),
		hmr,
		createImportMeta: createNodeImportMeta,
		sourcemapInterceptor: resolveSourceMapOptions(options$1)
	}, options$1.evaluator);
}

//#endregion
//#region src/node/ssr/ssrModuleLoader.ts
var import_picocolors$20 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
async function ssrLoadModule(url$3, server, fixStacktrace) {
	const environment = server.environments.ssr;
	server._ssrCompatModuleRunner ||= new SSRCompatModuleRunner(environment);
	url$3 = unwrapId(url$3);
	return instantiateModule(url$3, server._ssrCompatModuleRunner, environment, fixStacktrace);
}
async function instantiateModule(url$3, runner, environment, fixStacktrace) {
	const mod = await environment.moduleGraph.ensureEntryFromUrl(url$3);
	if (mod.ssrError) throw mod.ssrError;
	try {
		return await runner.import(url$3);
	} catch (e$1) {
		if (e$1.stack && fixStacktrace) ssrFixStacktrace(e$1, environment.moduleGraph);
		environment.logger.error(buildErrorMessage(e$1, [import_picocolors$20.default.red(`Error when evaluating SSR module ${url$3}: ${e$1.message}`)]), {
			timestamp: true,
			clear: environment.config.clearScreen,
			error: e$1
		});
		throw e$1;
	}
}
var SSRCompatModuleRunner = class extends ModuleRunner {
	constructor(environment) {
		super({
			transport: createServerModuleRunnerTransport({ channel: environment.hot }),
			createImportMeta: createNodeImportMeta,
			sourcemapInterceptor: false,
			hmr: false
		}, new ESModulesEvaluator());
		this.environment = environment;
	}
	async directRequest(url$3, mod, callstack) {
		const id = mod.meta && "id" in mod.meta && mod.meta.id;
		if (!id) return super.directRequest(url$3, mod, callstack);
		const viteMod = this.environment.moduleGraph.getModuleById(id);
		if (!viteMod) return super.directRequest(id, mod, callstack);
		try {
			const exports$1 = await super.directRequest(id, mod, callstack);
			viteMod.ssrModule = exports$1;
			return exports$1;
		} catch (err$2) {
			viteMod.ssrError = err$2;
			throw err$2;
		}
	}
};

//#endregion
//#region ../../node_modules/.pnpm/periscopic@4.0.2/node_modules/periscopic/src/index.js
/**
* @param {import('estree').Node} param
* @returns {string[]}
*/
function extract_names(param) {
	return extract_identifiers(param).map((node) => node.name);
}
/**
* @param {import('estree').Node} param
* @param {import('estree').Identifier[]} nodes
* @returns {import('estree').Identifier[]}
*/
function extract_identifiers(param, nodes = []) {
	switch (param.type) {
		case "Identifier":
			nodes.push(param);
			break;
		case "MemberExpression":
			let object = param;
			while (object.type === "MemberExpression") object = object.object;
			nodes.push(object);
			break;
		case "ObjectPattern":
			for (const prop of param.properties) if (prop.type === "RestElement") extract_identifiers(prop.argument, nodes);
			else extract_identifiers(prop.value, nodes);
			break;
		case "ArrayPattern":
			for (const element of param.elements) if (element) extract_identifiers(element, nodes);
			break;
		case "RestElement":
			extract_identifiers(param.argument, nodes);
			break;
		case "AssignmentPattern":
			extract_identifiers(param.left, nodes);
			break;
	}
	return nodes;
}

//#endregion
//#region ../../node_modules/.pnpm/estree-walker@3.0.3/node_modules/estree-walker/src/walker.js
/**
* @typedef { import('estree').Node} Node
* @typedef {{
*   skip: () => void;
*   remove: () => void;
*   replace: (node: Node) => void;
* }} WalkerContext
*/
var WalkerBase = class {
	constructor() {
		/** @type {boolean} */
		this.should_skip = false;
		/** @type {boolean} */
		this.should_remove = false;
		/** @type {Node | null} */
		this.replacement = null;
		/** @type {WalkerContext} */
		this.context = {
			skip: () => this.should_skip = true,
			remove: () => this.should_remove = true,
			replace: (node) => this.replacement = node
		};
	}
	/**
	* @template {Node} Parent
	* @param {Parent | null | undefined} parent
	* @param {keyof Parent | null | undefined} prop
	* @param {number | null | undefined} index
	* @param {Node} node
	*/
	replace(parent, prop, index, node) {
		if (parent && prop) if (index != null)
 /** @type {Array<Node>} */ parent[prop][index] = node;
		else
 /** @type {Node} */ parent[prop] = node;
	}
	/**
	* @template {Node} Parent
	* @param {Parent | null | undefined} parent
	* @param {keyof Parent | null | undefined} prop
	* @param {number | null | undefined} index
	*/
	remove(parent, prop, index) {
		if (parent && prop) if (index !== null && index !== void 0)
 /** @type {Array<Node>} */ parent[prop].splice(index, 1);
		else delete parent[prop];
	}
};

//#endregion
//#region ../../node_modules/.pnpm/estree-walker@3.0.3/node_modules/estree-walker/src/sync.js
/**
* @typedef { import('estree').Node} Node
* @typedef { import('./walker.js').WalkerContext} WalkerContext
* @typedef {(
*    this: WalkerContext,
*    node: Node,
*    parent: Node | null,
*    key: string | number | symbol | null | undefined,
*    index: number | null | undefined
* ) => void} SyncHandler
*/
var SyncWalker = class extends WalkerBase {
	/**
	*
	* @param {SyncHandler} [enter]
	* @param {SyncHandler} [leave]
	*/
	constructor(enter, leave) {
		super();
		/** @type {boolean} */
		this.should_skip = false;
		/** @type {boolean} */
		this.should_remove = false;
		/** @type {Node | null} */
		this.replacement = null;
		/** @type {WalkerContext} */
		this.context = {
			skip: () => this.should_skip = true,
			remove: () => this.should_remove = true,
			replace: (node) => this.replacement = node
		};
		/** @type {SyncHandler | undefined} */
		this.enter = enter;
		/** @type {SyncHandler | undefined} */
		this.leave = leave;
	}
	/**
	* @template {Node} Parent
	* @param {Node} node
	* @param {Parent | null} parent
	* @param {keyof Parent} [prop]
	* @param {number | null} [index]
	* @returns {Node | null}
	*/
	visit(node, parent, prop, index) {
		if (node) {
			if (this.enter) {
				const _should_skip = this.should_skip;
				const _should_remove = this.should_remove;
				const _replacement = this.replacement;
				this.should_skip = false;
				this.should_remove = false;
				this.replacement = null;
				this.enter.call(this.context, node, parent, prop, index);
				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}
				if (this.should_remove) this.remove(parent, prop, index);
				const skipped = this.should_skip;
				const removed = this.should_remove;
				this.should_skip = _should_skip;
				this.should_remove = _should_remove;
				this.replacement = _replacement;
				if (skipped) return node;
				if (removed) return null;
			}
			/** @type {keyof Node} */
			let key;
			for (key in node) {
				/** @type {unknown} */
				const value$1 = node[key];
				if (value$1 && typeof value$1 === "object") {
					if (Array.isArray(value$1)) {
						const nodes = value$1;
						for (let i$1 = 0; i$1 < nodes.length; i$1 += 1) {
							const item = nodes[i$1];
							if (isNode(item)) {
								if (!this.visit(item, node, key, i$1)) i$1--;
							}
						}
					} else if (isNode(value$1)) this.visit(value$1, node, key, null);
				}
			}
			if (this.leave) {
				const _replacement = this.replacement;
				const _should_remove = this.should_remove;
				this.replacement = null;
				this.should_remove = false;
				this.leave.call(this.context, node, parent, prop, index);
				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}
				if (this.should_remove) this.remove(parent, prop, index);
				const removed = this.should_remove;
				this.replacement = _replacement;
				this.should_remove = _should_remove;
				if (removed) return null;
			}
		}
		return node;
	}
};
/**
* Ducktype a node.
*
* @param {unknown} value
* @returns {value is Node}
*/
function isNode(value$1) {
	return value$1 !== null && typeof value$1 === "object" && "type" in value$1 && typeof value$1.type === "string";
}

//#endregion
//#region ../../node_modules/.pnpm/estree-walker@3.0.3/node_modules/estree-walker/src/index.js
/**
* @typedef {import('estree').Node} Node
* @typedef {import('./sync.js').SyncHandler} SyncHandler
* @typedef {import('./async.js').AsyncHandler} AsyncHandler
*/
/**
* @param {Node} ast
* @param {{
*   enter?: SyncHandler
*   leave?: SyncHandler
* }} walker
* @returns {Node | null}
*/
function walk(ast, { enter, leave }) {
	return new SyncWalker(enter, leave).visit(ast, null);
}

//#endregion
//#region src/node/ssr/ssrTransform.ts
const ssrModuleExportsKey = `__vite_ssr_exports__`;
const ssrImportKey = `__vite_ssr_import__`;
const ssrDynamicImportKey = `__vite_ssr_dynamic_import__`;
const ssrExportAllKey = `__vite_ssr_exportAll__`;
const ssrExportNameKey = `__vite_ssr_exportName__`;
const ssrImportMetaKey = `__vite_ssr_import_meta__`;
const hashbangRE = /^#!.*\n/;
async function ssrTransform(code, inMap, url$3, originalCode, options$1) {
	if (options$1?.json?.stringify && isJSONRequest(url$3)) return ssrTransformJSON(code, inMap);
	return ssrTransformScript(code, inMap, url$3, originalCode);
}
async function ssrTransformJSON(code, inMap) {
	return {
		code: code.replace("export default", `${ssrModuleExportsKey}.default =`),
		map: inMap,
		deps: [],
		dynamicDeps: [],
		ssr: true
	};
}
async function ssrTransformScript(code, inMap, url$3, originalCode) {
	const s$2 = new MagicString(code);
	let ast;
	try {
		ast = await parseAstAsync(code);
	} catch (err$2) {
		if (err$2.code === "PARSE_ERROR") {
			err$2.message = `Parse failure: ${err$2.message}\n`;
			err$2.id = url$3;
			if (typeof err$2.pos === "number") {
				err$2.loc = numberToPos(code, err$2.pos);
				err$2.loc.file = url$3;
				err$2.frame = generateCodeFrame(code, err$2.pos);
				err$2.message += `At file: ${url$3}:${err$2.loc.line}:${err$2.loc.column}`;
			} else err$2.message += `At file: ${url$3}`;
		}
		throw err$2;
	}
	let uid = 0;
	const deps = /* @__PURE__ */ new Set();
	const dynamicDeps = /* @__PURE__ */ new Set();
	const idToImportMap = /* @__PURE__ */ new Map();
	const declaredConst = /* @__PURE__ */ new Set();
	const fileStartIndex = hashbangRE.exec(code)?.[0].length ?? 0;
	let hoistIndex = fileStartIndex;
	function defineImport(index, importNode, metadata) {
		const source = importNode.source.value;
		deps.add(source);
		const metadataArg = (metadata?.importedNames?.length ?? 0) > 0 ? `, ${JSON.stringify(metadata)}` : "";
		const importId = `__vite_ssr_import_${uid++}__`;
		const transformedImport = `const ${importId} = await ${ssrImportKey}(${JSON.stringify(source)}${metadataArg});\n`;
		s$2.update(importNode.start, importNode.end, transformedImport);
		if (importNode.start === index) hoistIndex = importNode.end;
		else s$2.move(importNode.start, importNode.end, index);
		return importId;
	}
	function defineExport(name, local = name) {
		s$2.appendLeft(fileStartIndex, `${ssrExportNameKey}(${JSON.stringify(name)}, () => { try { return ${local} } catch {} });\n`);
	}
	const imports = [];
	const exports$1 = [];
	const reExportImportIdMap = /* @__PURE__ */ new Map();
	for (const node of ast.body) if (node.type === "ImportDeclaration") imports.push(node);
	else if (node.type === "ExportDefaultDeclaration") exports$1.push(node);
	else if (node.type === "ExportNamedDeclaration" || node.type === "ExportAllDeclaration") {
		imports.push(node);
		exports$1.push(node);
	}
	for (const node of imports) {
		if (node.type === "ExportNamedDeclaration") {
			if (node.source) {
				const importId$1 = defineImport(hoistIndex, node, { importedNames: node.specifiers.map((s$3) => getIdentifierNameOrLiteralValue$1(s$3.local)) });
				reExportImportIdMap.set(node, importId$1);
			}
			continue;
		}
		if (node.type === "ExportAllDeclaration") {
			if (node.source) {
				const importId$1 = defineImport(hoistIndex, node);
				reExportImportIdMap.set(node, importId$1);
			}
			continue;
		}
		const importId = defineImport(hoistIndex, node, { importedNames: node.specifiers.map((s$3) => {
			if (s$3.type === "ImportSpecifier") return getIdentifierNameOrLiteralValue$1(s$3.imported);
			else if (s$3.type === "ImportDefaultSpecifier") return "default";
		}).filter(isDefined) });
		for (const spec of node.specifiers) if (spec.type === "ImportSpecifier") if (spec.imported.type === "Identifier") idToImportMap.set(spec.local.name, `${importId}.${spec.imported.name}`);
		else idToImportMap.set(spec.local.name, `${importId}[${JSON.stringify(spec.imported.value)}]`);
		else if (spec.type === "ImportDefaultSpecifier") idToImportMap.set(spec.local.name, `${importId}.default`);
		else idToImportMap.set(spec.local.name, importId);
	}
	for (const node of exports$1) {
		if (node.type === "ExportNamedDeclaration") if (node.declaration) {
			if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") defineExport(node.declaration.id.name);
			else for (const declaration of node.declaration.declarations) {
				const names = extract_names(declaration.id);
				for (const name of names) defineExport(name);
			}
			s$2.remove(node.start, node.declaration.start);
		} else if (node.source) {
			const importId = reExportImportIdMap.get(node);
			for (const spec of node.specifiers) {
				const exportedAs = getIdentifierNameOrLiteralValue$1(spec.exported);
				if (spec.local.type === "Identifier") defineExport(exportedAs, `${importId}.${spec.local.name}`);
				else defineExport(exportedAs, `${importId}[${JSON.stringify(spec.local.value)}]`);
			}
		} else {
			s$2.remove(node.start, node.end);
			for (const spec of node.specifiers) {
				const local = spec.local.name;
				const binding = idToImportMap.get(local);
				defineExport(getIdentifierNameOrLiteralValue$1(spec.exported), binding || local);
			}
		}
		if (node.type === "ExportDefaultDeclaration") if ("id" in node.declaration && node.declaration.id && !["FunctionExpression", "ClassExpression"].includes(node.declaration.type)) {
			const { name } = node.declaration.id;
			s$2.remove(node.start, node.start + 15);
			defineExport("default", name);
		} else {
			const name = `__vite_ssr_export_default__`;
			s$2.update(node.start, node.start + 14, `const ${name} =`);
			defineExport("default", name);
		}
		if (node.type === "ExportAllDeclaration") {
			const importId = reExportImportIdMap.get(node);
			if (node.exported) defineExport(getIdentifierNameOrLiteralValue$1(node.exported), `${importId}`);
			else s$2.appendLeft(node.end, `${ssrExportAllKey}(${importId});\n`);
		}
	}
	walk$1(ast, {
		onStatements(statements) {
			for (let i$1 = 0; i$1 < statements.length - 1; i$1++) {
				const stmt = statements[i$1];
				if (code[stmt.end - 1] !== ";" && stmt.type !== "FunctionDeclaration" && stmt.type !== "ClassDeclaration" && stmt.type !== "BlockStatement" && stmt.type !== "ImportDeclaration") s$2.appendLeft(stmt.end, ";");
			}
		},
		onIdentifier(id, parent, parentStack) {
			const grandparent = parentStack[1];
			const binding = idToImportMap.get(id.name);
			if (!binding) return;
			if (isStaticProperty(parent) && parent.shorthand) {
				if (!isNodeInPattern(parent) || isInDestructuringAssignment(parent, parentStack)) s$2.appendLeft(id.end, `: ${binding}`);
			} else if (parent.type === "PropertyDefinition" && grandparent?.type === "ClassBody" || parent.type === "ClassDeclaration" && id === parent.superClass) {
				if (!declaredConst.has(id.name)) {
					declaredConst.add(id.name);
					const topNode = parentStack[parentStack.length - 2];
					s$2.prependRight(topNode.start, `const ${id.name} = ${binding};\n`);
				}
			} else if (parent.type === "CallExpression") {
				s$2.update(id.start, id.end, binding);
				s$2.prependRight(id.start, `(0,`);
				s$2.appendLeft(id.end, `)`);
			} else if (!(parent.type === "ClassExpression" && id === parent.id)) s$2.update(id.start, id.end, binding);
		},
		onImportMeta(node) {
			s$2.update(node.start, node.end, ssrImportMetaKey);
		},
		onDynamicImport(node) {
			s$2.update(node.start, node.start + 6, ssrDynamicImportKey);
			if (node.type === "ImportExpression" && node.source.type === "Literal") dynamicDeps.add(node.source.value);
		}
	});
	let map$1;
	if (inMap?.mappings === "") map$1 = inMap;
	else {
		map$1 = s$2.generateMap({ hires: "boundary" });
		map$1.sources = [path.basename(url$3)];
		map$1.sourcesContent = [originalCode];
		if (inMap && inMap.mappings && "sources" in inMap && inMap.sources.length > 0) map$1 = combineSourcemaps(url$3, [map$1, inMap]);
	}
	return {
		code: s$2.toString(),
		map: map$1,
		ssr: true,
		deps: [...deps],
		dynamicDeps: [...dynamicDeps]
	};
}
function getIdentifierNameOrLiteralValue$1(node) {
	return node.type === "Identifier" ? node.name : node.value;
}
const isNodeInPatternWeakSet = /* @__PURE__ */ new WeakSet();
const setIsNodeInPattern = (node) => isNodeInPatternWeakSet.add(node);
const isNodeInPattern = (node) => isNodeInPatternWeakSet.has(node);
/**
* Same logic from \@vue/compiler-core & \@vue/compiler-sfc
* Except this is using acorn AST
*/
function walk$1(root, { onIdentifier, onImportMeta, onDynamicImport, onStatements }) {
	const parentStack = [];
	const varKindStack = [];
	const scopeMap = /* @__PURE__ */ new WeakMap();
	const identifiers = [];
	const setScope = (node, name) => {
		let scopeIds = scopeMap.get(node);
		if (scopeIds && scopeIds.has(name)) return;
		if (!scopeIds) {
			scopeIds = /* @__PURE__ */ new Set();
			scopeMap.set(node, scopeIds);
		}
		scopeIds.add(name);
	};
	function isInScope(name, parents) {
		return parents.some((node) => scopeMap.get(node)?.has(name));
	}
	function handlePattern(p, parentScope) {
		if (p.type === "Identifier") setScope(parentScope, p.name);
		else if (p.type === "RestElement") handlePattern(p.argument, parentScope);
		else if (p.type === "ObjectPattern") p.properties.forEach((property) => {
			if (property.type === "RestElement") setScope(parentScope, property.argument.name);
			else handlePattern(property.value, parentScope);
		});
		else if (p.type === "ArrayPattern") p.elements.forEach((element) => {
			if (element) handlePattern(element, parentScope);
		});
		else if (p.type === "AssignmentPattern") handlePattern(p.left, parentScope);
		else setScope(parentScope, p.name);
	}
	walk(root, {
		enter(node, parent) {
			if (node.type === "ImportDeclaration") return this.skip();
			if (node.type === "Program" || node.type === "BlockStatement" || node.type === "StaticBlock") onStatements(node.body);
			else if (node.type === "SwitchCase") onStatements(node.consequent);
			if (parent && !(parent.type === "IfStatement" && node === parent.alternate)) parentStack.unshift(parent);
			if (node.type === "VariableDeclaration") varKindStack.unshift(node.kind);
			if (node.type === "MetaProperty" && node.meta.name === "import") onImportMeta(node);
			else if (node.type === "ImportExpression") onDynamicImport(node);
			if (node.type === "Identifier") {
				if (!isInScope(node.name, parentStack) && isRefIdentifier(node, parent, parentStack)) identifiers.push([node, parentStack.slice(0)]);
			} else if (isFunction$1(node)) {
				if (node.type === "FunctionDeclaration") {
					const parentScope = findParentScope(parentStack);
					if (parentScope) setScope(parentScope, node.id.name);
				}
				if (node.type === "FunctionExpression" && node.id) setScope(node, node.id.name);
				node.params.forEach((p) => {
					if (p.type === "ObjectPattern" || p.type === "ArrayPattern") {
						handlePattern(p, node);
						return;
					}
					walk(p.type === "AssignmentPattern" ? p.left : p, { enter(child, parent$1) {
						if (parent$1?.type === "AssignmentPattern" && parent$1.right === child) return this.skip();
						if (child.type !== "Identifier") return;
						if (isStaticPropertyKey(child, parent$1)) return;
						if (parent$1?.type === "TemplateLiteral" && parent$1.expressions.includes(child) || parent$1?.type === "CallExpression" && parent$1.callee === child) return;
						setScope(node, child.name);
					} });
				});
			} else if (node.type === "ClassDeclaration") {
				const parentScope = findParentScope(parentStack);
				if (parentScope) setScope(parentScope, node.id.name);
			} else if (node.type === "ClassExpression" && node.id) setScope(node, node.id.name);
			else if (node.type === "Property" && parent.type === "ObjectPattern") setIsNodeInPattern(node);
			else if (node.type === "VariableDeclarator") {
				const parentFunction = findParentScope(parentStack, varKindStack[0] === "var");
				if (parentFunction) handlePattern(node.id, parentFunction);
			} else if (node.type === "CatchClause" && node.param) handlePattern(node.param, node);
		},
		leave(node, parent) {
			if (parent && !(parent.type === "IfStatement" && node === parent.alternate)) parentStack.shift();
			if (node.type === "VariableDeclaration") varKindStack.shift();
		}
	});
	identifiers.forEach(([node, stack]) => {
		if (!isInScope(node.name, stack)) onIdentifier(node, stack[0], stack);
	});
}
function isRefIdentifier(id, parent, parentStack) {
	if (parent.type === "CatchClause" || (parent.type === "VariableDeclarator" || parent.type === "ClassDeclaration") && parent.id === id) return false;
	if (isFunction$1(parent)) {
		if (parent.id === id) return false;
		if (parent.params.includes(id)) return false;
	}
	if (parent.type === "MethodDefinition" && !parent.computed) return false;
	if (isStaticPropertyKey(id, parent)) return false;
	if (isNodeInPattern(parent) && parent.value === id) return false;
	if (parent.type === "ArrayPattern" && !isInDestructuringAssignment(parent, parentStack)) return false;
	if (parent.type === "MemberExpression" && parent.property === id && !parent.computed) return false;
	if (parent.type === "ExportSpecifier" || parent.type === "ExportAllDeclaration") return false;
	if (id.name === "arguments") return false;
	return true;
}
const isStaticProperty = (node) => node.type === "Property" && !node.computed;
const isStaticPropertyKey = (node, parent) => parent && isStaticProperty(parent) && parent.key === node;
const functionNodeTypeRE = /Function(?:Expression|Declaration)$|Method$/;
function isFunction$1(node) {
	return functionNodeTypeRE.test(node.type);
}
const blockNodeTypeRE = /^BlockStatement$|^For(?:In|Of)?Statement$/;
function isBlock(node) {
	return blockNodeTypeRE.test(node.type);
}
function findParentScope(parentStack, isVar = false) {
	return parentStack.find(isVar ? isFunction$1 : isBlock);
}
function isInDestructuringAssignment(parent, parentStack) {
	if (parent.type === "Property" || parent.type === "ArrayPattern") return parentStack.some((i$1) => i$1.type === "AssignmentExpression");
	return false;
}

//#endregion
//#region ../../node_modules/.pnpm/is-docker@3.0.0/node_modules/is-docker/index.js
let isDockerCached;
function hasDockerEnv() {
	try {
		fs.statSync("/.dockerenv");
		return true;
	} catch {
		return false;
	}
}
function hasDockerCGroup() {
	try {
		return fs.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
	} catch {
		return false;
	}
}
function isDocker() {
	if (isDockerCached === void 0) isDockerCached = hasDockerEnv() || hasDockerCGroup();
	return isDockerCached;
}

//#endregion
//#region ../../node_modules/.pnpm/is-inside-container@1.0.0/node_modules/is-inside-container/index.js
let cachedResult;
const hasContainerEnv = () => {
	try {
		fs.statSync("/run/.containerenv");
		return true;
	} catch {
		return false;
	}
};
function isInsideContainer() {
	if (cachedResult === void 0) cachedResult = hasContainerEnv() || isDocker();
	return cachedResult;
}

//#endregion
//#region ../../node_modules/.pnpm/is-wsl@3.1.0/node_modules/is-wsl/index.js
const isWsl = () => {
	if (process$1.platform !== "linux") return false;
	if (os.release().toLowerCase().includes("microsoft")) {
		if (isInsideContainer()) return false;
		return true;
	}
	try {
		return fs.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isInsideContainer() : false;
	} catch {
		return false;
	}
};
var is_wsl_default = process$1.env.__IS_WSL_TEST__ ? isWsl : isWsl();

//#endregion
//#region ../../node_modules/.pnpm/wsl-utils@0.1.0/node_modules/wsl-utils/index.js
const wslDrivesMountPoint = (() => {
	const defaultMountPoint = "/mnt/";
	let mountPoint;
	return async function() {
		if (mountPoint) return mountPoint;
		const configFilePath = "/etc/wsl.conf";
		let isConfigFileExists = false;
		try {
			await fsp.access(configFilePath, constants.F_OK);
			isConfigFileExists = true;
		} catch {}
		if (!isConfigFileExists) return defaultMountPoint;
		const configContent = await fsp.readFile(configFilePath, { encoding: "utf8" });
		const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
		if (!configMountPoint) return defaultMountPoint;
		mountPoint = configMountPoint.groups.mountPoint.trim();
		mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
		return mountPoint;
	};
})();
const powerShellPathFromWsl = async () => {
	return `${await wslDrivesMountPoint()}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`;
};
const powerShellPath = async () => {
	if (is_wsl_default) return powerShellPathFromWsl();
	return `${process$1.env.SYSTEMROOT || process$1.env.windir || String.raw`C:\Windows`}\\System32\\WindowsPowerShell\\v1.0\\powershell.exe`;
};

//#endregion
//#region ../../node_modules/.pnpm/define-lazy-prop@3.0.0/node_modules/define-lazy-prop/index.js
function defineLazyProperty(object, propertyName, valueGetter) {
	const define$1 = (value$1) => Object.defineProperty(object, propertyName, {
		value: value$1,
		enumerable: true,
		writable: true
	});
	Object.defineProperty(object, propertyName, {
		configurable: true,
		enumerable: true,
		get() {
			const result = valueGetter();
			define$1(result);
			return result;
		},
		set(value$1) {
			define$1(value$1);
		}
	});
	return object;
}

//#endregion
//#region ../../node_modules/.pnpm/default-browser-id@5.0.0/node_modules/default-browser-id/index.js
const execFileAsync$3 = promisify(execFile);
async function defaultBrowserId() {
	if (process$1.platform !== "darwin") throw new Error("macOS only");
	const { stdout } = await execFileAsync$3("defaults", [
		"read",
		"com.apple.LaunchServices/com.apple.launchservices.secure",
		"LSHandlers"
	]);
	return /LSHandlerRoleAll = "(?!-)(?<id>[^"]+?)";\s+?LSHandlerURLScheme = (?:http|https);/.exec(stdout)?.groups.id ?? "com.apple.Safari";
}

//#endregion
//#region ../../node_modules/.pnpm/run-applescript@7.0.0/node_modules/run-applescript/index.js
const execFileAsync$2 = promisify(execFile);
async function runAppleScript(script, { humanReadableOutput = true } = {}) {
	if (process$1.platform !== "darwin") throw new Error("macOS only");
	const { stdout } = await execFileAsync$2("osascript", [
		"-e",
		script,
		humanReadableOutput ? [] : ["-ss"]
	]);
	return stdout.trim();
}

//#endregion
//#region ../../node_modules/.pnpm/bundle-name@4.1.0/node_modules/bundle-name/index.js
async function bundleName(bundleId) {
	return runAppleScript(`tell application "Finder" to set app_path to application file id "${bundleId}" as string\ntell application "System Events" to get value of property list item "CFBundleName" of property list file (app_path & ":Contents:Info.plist")`);
}

//#endregion
//#region ../../node_modules/.pnpm/default-browser@5.2.1/node_modules/default-browser/windows.js
const execFileAsync$1 = promisify(execFile);
const windowsBrowserProgIds = {
	AppXq0fevzme2pys62n3e0fbqa7peapykr8v: {
		name: "Edge",
		id: "com.microsoft.edge.old"
	},
	MSEdgeDHTML: {
		name: "Edge",
		id: "com.microsoft.edge"
	},
	MSEdgeHTM: {
		name: "Edge",
		id: "com.microsoft.edge"
	},
	"IE.HTTP": {
		name: "Internet Explorer",
		id: "com.microsoft.ie"
	},
	FirefoxURL: {
		name: "Firefox",
		id: "org.mozilla.firefox"
	},
	ChromeHTML: {
		name: "Chrome",
		id: "com.google.chrome"
	},
	BraveHTML: {
		name: "Brave",
		id: "com.brave.Browser"
	},
	BraveBHTML: {
		name: "Brave Beta",
		id: "com.brave.Browser.beta"
	},
	BraveSSHTM: {
		name: "Brave Nightly",
		id: "com.brave.Browser.nightly"
	}
};
var UnknownBrowserError = class extends Error {};
async function defaultBrowser$1(_execFileAsync = execFileAsync$1) {
	const { stdout } = await _execFileAsync("reg", [
		"QUERY",
		" HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice",
		"/v",
		"ProgId"
	]);
	const match = /ProgId\s*REG_SZ\s*(?<id>\S+)/.exec(stdout);
	if (!match) throw new UnknownBrowserError(`Cannot find Windows browser in stdout: ${JSON.stringify(stdout)}`);
	const { id } = match.groups;
	const browser = windowsBrowserProgIds[id];
	if (!browser) throw new UnknownBrowserError(`Unknown browser ID: ${id}`);
	return browser;
}

//#endregion
//#region ../../node_modules/.pnpm/default-browser@5.2.1/node_modules/default-browser/index.js
const execFileAsync = promisify(execFile);
const titleize = (string) => string.toLowerCase().replaceAll(/(?:^|\s|-)\S/g, (x) => x.toUpperCase());
async function defaultBrowser() {
	if (process$1.platform === "darwin") {
		const id = await defaultBrowserId();
		return {
			name: await bundleName(id),
			id
		};
	}
	if (process$1.platform === "linux") {
		const { stdout } = await execFileAsync("xdg-mime", [
			"query",
			"default",
			"x-scheme-handler/http"
		]);
		const id = stdout.trim();
		return {
			name: titleize(id.replace(/.desktop$/, "").replace("-", " ")),
			id
		};
	}
	if (process$1.platform === "win32") return defaultBrowser$1();
	throw new Error("Only macOS, Linux, and Windows are supported");
}

//#endregion
//#region ../../node_modules/.pnpm/open@10.2.0/node_modules/open/index.js
const execFile$1 = promisify(childProcess.execFile);
const __dirname = path.dirname(fileURLToPath(import.meta.url));
const localXdgOpenPath = path.join(__dirname, "xdg-open");
const { platform, arch } = process$1;
/**
Get the default browser name in Windows from WSL.

@returns {Promise<string>} Browser name.
*/
async function getWindowsDefaultBrowserFromWsl() {
	const powershellPath = await powerShellPath();
	const rawCommand = String.raw`(Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice").ProgId`;
	const { stdout } = await execFile$1(powershellPath, [
		"-NoProfile",
		"-NonInteractive",
		"-ExecutionPolicy",
		"Bypass",
		"-EncodedCommand",
		Buffer$1.from(rawCommand, "utf16le").toString("base64")
	], { encoding: "utf8" });
	const progId = stdout.trim();
	const browserMap = {
		ChromeHTML: "com.google.chrome",
		BraveHTML: "com.brave.Browser",
		MSEdgeHTM: "com.microsoft.edge",
		FirefoxURL: "org.mozilla.firefox"
	};
	return browserMap[progId] ? { id: browserMap[progId] } : {};
}
const pTryEach = async (array, mapper) => {
	let latestError;
	for (const item of array) try {
		return await mapper(item);
	} catch (error$1) {
		latestError = error$1;
	}
	throw latestError;
};
const baseOpen = async (options$1) => {
	options$1 = {
		wait: false,
		background: false,
		newInstance: false,
		allowNonzeroExitCode: false,
		...options$1
	};
	if (Array.isArray(options$1.app)) return pTryEach(options$1.app, (singleApp) => baseOpen({
		...options$1,
		app: singleApp
	}));
	let { name: app, arguments: appArguments = [] } = options$1.app ?? {};
	appArguments = [...appArguments];
	if (Array.isArray(app)) return pTryEach(app, (appName) => baseOpen({
		...options$1,
		app: {
			name: appName,
			arguments: appArguments
		}
	}));
	if (app === "browser" || app === "browserPrivate") {
		const ids = {
			"com.google.chrome": "chrome",
			"google-chrome.desktop": "chrome",
			"com.brave.Browser": "brave",
			"org.mozilla.firefox": "firefox",
			"firefox.desktop": "firefox",
			"com.microsoft.msedge": "edge",
			"com.microsoft.edge": "edge",
			"com.microsoft.edgemac": "edge",
			"microsoft-edge.desktop": "edge"
		};
		const flags = {
			chrome: "--incognito",
			brave: "--incognito",
			firefox: "--private-window",
			edge: "--inPrivate"
		};
		const browser = is_wsl_default ? await getWindowsDefaultBrowserFromWsl() : await defaultBrowser();
		if (browser.id in ids) {
			const browserName = ids[browser.id];
			if (app === "browserPrivate") appArguments.push(flags[browserName]);
			return baseOpen({
				...options$1,
				app: {
					name: apps[browserName],
					arguments: appArguments
				}
			});
		}
		throw new Error(`${browser.name} is not supported as a default browser`);
	}
	let command;
	const cliArguments = [];
	const childProcessOptions = {};
	if (platform === "darwin") {
		command = "open";
		if (options$1.wait) cliArguments.push("--wait-apps");
		if (options$1.background) cliArguments.push("--background");
		if (options$1.newInstance) cliArguments.push("--new");
		if (app) cliArguments.push("-a", app);
	} else if (platform === "win32" || is_wsl_default && !isInsideContainer() && !app) {
		command = await powerShellPath();
		cliArguments.push("-NoProfile", "-NonInteractive", "-ExecutionPolicy", "Bypass", "-EncodedCommand");
		if (!is_wsl_default) childProcessOptions.windowsVerbatimArguments = true;
		const encodedArguments = ["Start"];
		if (options$1.wait) encodedArguments.push("-Wait");
		if (app) {
			encodedArguments.push(`"\`"${app}\`""`);
			if (options$1.target) appArguments.push(options$1.target);
		} else if (options$1.target) encodedArguments.push(`"${options$1.target}"`);
		if (appArguments.length > 0) {
			appArguments = appArguments.map((argument) => `"\`"${argument}\`""`);
			encodedArguments.push("-ArgumentList", appArguments.join(","));
		}
		options$1.target = Buffer$1.from(encodedArguments.join(" "), "utf16le").toString("base64");
	} else {
		if (app) command = app;
		else {
			const isBundled = !__dirname || __dirname === "/";
			let exeLocalXdgOpen = false;
			try {
				await fsp.access(localXdgOpenPath, constants.X_OK);
				exeLocalXdgOpen = true;
			} catch {}
			command = process$1.versions.electron ?? (platform === "android" || isBundled || !exeLocalXdgOpen) ? "xdg-open" : localXdgOpenPath;
		}
		if (appArguments.length > 0) cliArguments.push(...appArguments);
		if (!options$1.wait) {
			childProcessOptions.stdio = "ignore";
			childProcessOptions.detached = true;
		}
	}
	if (platform === "darwin" && appArguments.length > 0) cliArguments.push("--args", ...appArguments);
	if (options$1.target) cliArguments.push(options$1.target);
	const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
	if (options$1.wait) return new Promise((resolve$4, reject) => {
		subprocess.once("error", reject);
		subprocess.once("close", (exitCode) => {
			if (!options$1.allowNonzeroExitCode && exitCode > 0) {
				reject(/* @__PURE__ */ new Error(`Exited with code ${exitCode}`));
				return;
			}
			resolve$4(subprocess);
		});
	});
	subprocess.unref();
	return subprocess;
};
const open = (target, options$1) => {
	if (typeof target !== "string") throw new TypeError("Expected a `target`");
	return baseOpen({
		...options$1,
		target
	});
};
function detectArchBinary(binary) {
	if (typeof binary === "string" || Array.isArray(binary)) return binary;
	const { [arch]: archBinary } = binary;
	if (!archBinary) throw new Error(`${arch} is not supported`);
	return archBinary;
}
function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
	if (wsl && is_wsl_default) return detectArchBinary(wsl);
	if (!platformBinary) throw new Error(`${platform} is not supported`);
	return detectArchBinary(platformBinary);
}
const apps = {};
defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
	darwin: "google chrome",
	win32: "chrome",
	linux: [
		"google-chrome",
		"google-chrome-stable",
		"chromium"
	]
}, { wsl: {
	ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
	x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
} }));
defineLazyProperty(apps, "brave", () => detectPlatformBinary({
	darwin: "brave browser",
	win32: "brave",
	linux: ["brave-browser", "brave"]
}, { wsl: {
	ia32: "/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe",
	x64: ["/mnt/c/Program Files/BraveSoftware/Brave-Browser/Application/brave.exe", "/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe"]
} }));
defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
	darwin: "firefox",
	win32: String.raw`C:\Program Files\Mozilla Firefox\firefox.exe`,
	linux: "firefox"
}, { wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe" }));
defineLazyProperty(apps, "edge", () => detectPlatformBinary({
	darwin: "microsoft edge",
	win32: "msedge",
	linux: ["microsoft-edge", "microsoft-edge-dev"]
}, { wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe" }));
defineLazyProperty(apps, "browser", () => "browser");
defineLazyProperty(apps, "browserPrivate", () => "browserPrivate");
var open_default = open;

//#endregion
//#region ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js
var require_windows = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js": ((exports, module) => {
	module.exports = isexe$3;
	isexe$3.sync = sync$2;
	var fs$4 = __require("fs");
	function checkPathExt(path$13, options$1) {
		var pathext = options$1.pathExt !== void 0 ? options$1.pathExt : process.env.PATHEXT;
		if (!pathext) return true;
		pathext = pathext.split(";");
		if (pathext.indexOf("") !== -1) return true;
		for (var i$1 = 0; i$1 < pathext.length; i$1++) {
			var p = pathext[i$1].toLowerCase();
			if (p && path$13.substr(-p.length).toLowerCase() === p) return true;
		}
		return false;
	}
	function checkStat$1(stat$4, path$13, options$1) {
		if (!stat$4.isSymbolicLink() && !stat$4.isFile()) return false;
		return checkPathExt(path$13, options$1);
	}
	function isexe$3(path$13, options$1, cb) {
		fs$4.stat(path$13, function(er, stat$4) {
			cb(er, er ? false : checkStat$1(stat$4, path$13, options$1));
		});
	}
	function sync$2(path$13, options$1) {
		return checkStat$1(fs$4.statSync(path$13), path$13, options$1);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js
var require_mode = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js": ((exports, module) => {
	module.exports = isexe$2;
	isexe$2.sync = sync$1;
	var fs$3 = __require("fs");
	function isexe$2(path$13, options$1, cb) {
		fs$3.stat(path$13, function(er, stat$4) {
			cb(er, er ? false : checkStat(stat$4, options$1));
		});
	}
	function sync$1(path$13, options$1) {
		return checkStat(fs$3.statSync(path$13), options$1);
	}
	function checkStat(stat$4, options$1) {
		return stat$4.isFile() && checkMode(stat$4, options$1);
	}
	function checkMode(stat$4, options$1) {
		var mod = stat$4.mode;
		var uid = stat$4.uid;
		var gid = stat$4.gid;
		var myUid = options$1.uid !== void 0 ? options$1.uid : process.getuid && process.getuid();
		var myGid = options$1.gid !== void 0 ? options$1.gid : process.getgid && process.getgid();
		var u = parseInt("100", 8);
		var g = parseInt("010", 8);
		var o$1 = parseInt("001", 8);
		var ug = u | g;
		return mod & o$1 || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js
var require_isexe = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js": ((exports, module) => {
	__require("fs");
	var core;
	if (process.platform === "win32" || global.TESTING_WINDOWS) core = require_windows();
	else core = require_mode();
	module.exports = isexe$1;
	isexe$1.sync = sync;
	function isexe$1(path$13, options$1, cb) {
		if (typeof options$1 === "function") {
			cb = options$1;
			options$1 = {};
		}
		if (!cb) {
			if (typeof Promise !== "function") throw new TypeError("callback not provided");
			return new Promise(function(resolve$4, reject) {
				isexe$1(path$13, options$1 || {}, function(er, is) {
					if (er) reject(er);
					else resolve$4(is);
				});
			});
		}
		core(path$13, options$1 || {}, function(er, is) {
			if (er) {
				if (er.code === "EACCES" || options$1 && options$1.ignoreErrors) {
					er = null;
					is = false;
				}
			}
			cb(er, is);
		});
	}
	function sync(path$13, options$1) {
		try {
			return core.sync(path$13, options$1 || {});
		} catch (er) {
			if (options$1 && options$1.ignoreErrors || er.code === "EACCES") return false;
			else throw er;
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js
var require_which = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js": ((exports, module) => {
	const isWindows$1 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
	const path$4 = __require("path");
	const COLON = isWindows$1 ? ";" : ":";
	const isexe = require_isexe();
	const getNotFoundError = (cmd) => Object.assign(/* @__PURE__ */ new Error(`not found: ${cmd}`), { code: "ENOENT" });
	const getPathInfo = (cmd, opt) => {
		const colon = opt.colon || COLON;
		const pathEnv = cmd.match(/\//) || isWindows$1 && cmd.match(/\\/) ? [""] : [...isWindows$1 ? [process.cwd()] : [], ...(opt.path || process.env.PATH || "").split(colon)];
		const pathExtExe = isWindows$1 ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
		const pathExt = isWindows$1 ? pathExtExe.split(colon) : [""];
		if (isWindows$1) {
			if (cmd.indexOf(".") !== -1 && pathExt[0] !== "") pathExt.unshift("");
		}
		return {
			pathEnv,
			pathExt,
			pathExtExe
		};
	};
	const which$1 = (cmd, opt, cb) => {
		if (typeof opt === "function") {
			cb = opt;
			opt = {};
		}
		if (!opt) opt = {};
		const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
		const found$1 = [];
		const step = (i$1) => new Promise((resolve$4, reject) => {
			if (i$1 === pathEnv.length) return opt.all && found$1.length ? resolve$4(found$1) : reject(getNotFoundError(cmd));
			const ppRaw = pathEnv[i$1];
			const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
			const pCmd = path$4.join(pathPart, cmd);
			resolve$4(subStep(!pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd, i$1, 0));
		});
		const subStep = (p, i$1, ii) => new Promise((resolve$4, reject) => {
			if (ii === pathExt.length) return resolve$4(step(i$1 + 1));
			const ext = pathExt[ii];
			isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
				if (!er && is) if (opt.all) found$1.push(p + ext);
				else return resolve$4(p + ext);
				return resolve$4(subStep(p, i$1, ii + 1));
			});
		});
		return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
	};
	const whichSync = (cmd, opt) => {
		opt = opt || {};
		const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
		const found$1 = [];
		for (let i$1 = 0; i$1 < pathEnv.length; i$1++) {
			const ppRaw = pathEnv[i$1];
			const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
			const pCmd = path$4.join(pathPart, cmd);
			const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
			for (let j = 0; j < pathExt.length; j++) {
				const cur = p + pathExt[j];
				try {
					if (isexe.sync(cur, { pathExt: pathExtExe })) if (opt.all) found$1.push(cur);
					else return cur;
				} catch (ex) {}
			}
		}
		if (opt.all && found$1.length) return found$1;
		if (opt.nothrow) return null;
		throw getNotFoundError(cmd);
	};
	module.exports = which$1;
	which$1.sync = whichSync;
}) });

//#endregion
//#region ../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js
var require_path_key = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js": ((exports, module) => {
	const pathKey = (options$1 = {}) => {
		const environment = options$1.env || process.env;
		if ((options$1.platform || process.platform) !== "win32") return "PATH";
		return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
	};
	module.exports = pathKey;
	module.exports.default = pathKey;
}) });

//#endregion
//#region ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/resolveCommand.js": ((exports, module) => {
	const path$3 = __require("path");
	const which = require_which();
	const getPathKey = require_path_key();
	function resolveCommandAttempt(parsed, withoutPathExt) {
		const env$1 = parsed.options.env || process.env;
		const cwd = process.cwd();
		const hasCustomCwd = parsed.options.cwd != null;
		const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
		if (shouldSwitchCwd) try {
			process.chdir(parsed.options.cwd);
		} catch (err$2) {}
		let resolved;
		try {
			resolved = which.sync(parsed.command, {
				path: env$1[getPathKey({ env: env$1 })],
				pathExt: withoutPathExt ? path$3.delimiter : void 0
			});
		} catch (e$1) {} finally {
			if (shouldSwitchCwd) process.chdir(cwd);
		}
		if (resolved) resolved = path$3.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
		return resolved;
	}
	function resolveCommand$1(parsed) {
		return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
	}
	module.exports = resolveCommand$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/escape.js
var require_escape = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/escape.js": ((exports, module) => {
	const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
	function escapeCommand(arg) {
		arg = arg.replace(metaCharsRegExp, "^$1");
		return arg;
	}
	function escapeArgument(arg, doubleEscapeMetaChars) {
		arg = `${arg}`;
		arg = arg.replace(/(?=(\\+?)?)\1"/g, "$1$1\\\"");
		arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1");
		arg = `"${arg}"`;
		arg = arg.replace(metaCharsRegExp, "^$1");
		if (doubleEscapeMetaChars) arg = arg.replace(metaCharsRegExp, "^$1");
		return arg;
	}
	module.exports.command = escapeCommand;
	module.exports.argument = escapeArgument;
}) });

//#endregion
//#region ../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js
var require_shebang_regex = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js": ((exports, module) => {
	module.exports = /^#!(.*)/;
}) });

//#endregion
//#region ../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js
var require_shebang_command = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js": ((exports, module) => {
	const shebangRegex = require_shebang_regex();
	module.exports = (string = "") => {
		const match = string.match(shebangRegex);
		if (!match) return null;
		const [path$13, argument] = match[0].replace(/#! ?/, "").split(" ");
		const binary = path$13.split("/").pop();
		if (binary === "env") return argument;
		return argument ? `${binary} ${argument}` : binary;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/readShebang.js": ((exports, module) => {
	const fs$2 = __require("fs");
	const shebangCommand = require_shebang_command();
	function readShebang$1(command) {
		const size = 150;
		const buffer = Buffer.alloc(size);
		let fd$1;
		try {
			fd$1 = fs$2.openSync(command, "r");
			fs$2.readSync(fd$1, buffer, 0, size, 0);
			fs$2.closeSync(fd$1);
		} catch (e$1) {}
		return shebangCommand(buffer.toString());
	}
	module.exports = readShebang$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/parse.js
var require_parse = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/parse.js": ((exports, module) => {
	const path$2 = __require("path");
	const resolveCommand = require_resolveCommand();
	const escape$1 = require_escape();
	const readShebang = require_readShebang();
	const isWin$1 = process.platform === "win32";
	const isExecutableRegExp = /\.(?:com|exe)$/i;
	const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
	function detectShebang(parsed) {
		parsed.file = resolveCommand(parsed);
		const shebang = parsed.file && readShebang(parsed.file);
		if (shebang) {
			parsed.args.unshift(parsed.file);
			parsed.command = shebang;
			return resolveCommand(parsed);
		}
		return parsed.file;
	}
	function parseNonShell(parsed) {
		if (!isWin$1) return parsed;
		const commandFile = detectShebang(parsed);
		const needsShell = !isExecutableRegExp.test(commandFile);
		if (parsed.options.forceShell || needsShell) {
			const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
			parsed.command = path$2.normalize(parsed.command);
			parsed.command = escape$1.command(parsed.command);
			parsed.args = parsed.args.map((arg) => escape$1.argument(arg, needsDoubleEscapeMetaChars));
			parsed.args = [
				"/d",
				"/s",
				"/c",
				`"${[parsed.command].concat(parsed.args).join(" ")}"`
			];
			parsed.command = process.env.comspec || "cmd.exe";
			parsed.options.windowsVerbatimArguments = true;
		}
		return parsed;
	}
	function parse$6(command, args, options$1) {
		if (args && !Array.isArray(args)) {
			options$1 = args;
			args = null;
		}
		args = args ? args.slice(0) : [];
		options$1 = Object.assign({}, options$1);
		const parsed = {
			command,
			args,
			options: options$1,
			file: void 0,
			original: {
				command,
				args
			}
		};
		return options$1.shell ? parsed : parseNonShell(parsed);
	}
	module.exports = parse$6;
}) });

//#endregion
//#region ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/enoent.js
var require_enoent = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/enoent.js": ((exports, module) => {
	const isWin = process.platform === "win32";
	function notFoundError(original, syscall) {
		return Object.assign(/* @__PURE__ */ new Error(`${syscall} ${original.command} ENOENT`), {
			code: "ENOENT",
			errno: "ENOENT",
			syscall: `${syscall} ${original.command}`,
			path: original.command,
			spawnargs: original.args
		});
	}
	function hookChildProcess(cp$1, parsed) {
		if (!isWin) return;
		const originalEmit = cp$1.emit;
		cp$1.emit = function(name, arg1) {
			if (name === "exit") {
				const err$2 = verifyENOENT(arg1, parsed);
				if (err$2) return originalEmit.call(cp$1, "error", err$2);
			}
			return originalEmit.apply(cp$1, arguments);
		};
	}
	function verifyENOENT(status$1, parsed) {
		if (isWin && status$1 === 1 && !parsed.file) return notFoundError(parsed.original, "spawn");
		return null;
	}
	function verifyENOENTSync(status$1, parsed) {
		if (isWin && status$1 === 1 && !parsed.file) return notFoundError(parsed.original, "spawnSync");
		return null;
	}
	module.exports = {
		hookChildProcess,
		verifyENOENT,
		verifyENOENTSync,
		notFoundError
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/index.js
var require_cross_spawn = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/index.js": ((exports, module) => {
	const cp = __require("child_process");
	const parse$5 = require_parse();
	const enoent = require_enoent();
	function spawn$1(command, args, options$1) {
		const parsed = parse$5(command, args, options$1);
		const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
		enoent.hookChildProcess(spawned, parsed);
		return spawned;
	}
	function spawnSync(command, args, options$1) {
		const parsed = parse$5(command, args, options$1);
		const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
		result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
		return result;
	}
	module.exports = spawn$1;
	module.exports.spawn = spawn$1;
	module.exports.sync = spawnSync;
	module.exports._parse = parse$5;
	module.exports._enoent = enoent;
}) });

//#endregion
//#region src/node/server/openBrowser.ts
var import_cross_spawn = /* @__PURE__ */ __toESM(require_cross_spawn(), 1);
var import_picocolors$19 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
/**
* Reads the BROWSER environment variable and decides what to do with it.
*/
function openBrowser(url$3, opt, logger) {
	const browser = typeof opt === "string" ? opt : process.env.BROWSER || "";
	if (browser.toLowerCase().endsWith(".js")) executeNodeScript(browser, url$3, logger);
	else if (browser.toLowerCase() !== "none") startBrowserProcess(browser, process.env.BROWSER_ARGS ? process.env.BROWSER_ARGS.split(" ") : [], url$3, logger);
}
function executeNodeScript(scriptPath, url$3, logger) {
	const extraArgs = process.argv.slice(2);
	(0, import_cross_spawn.default)(process.execPath, [
		scriptPath,
		...extraArgs,
		url$3
	], { stdio: "inherit" }).on("close", (code) => {
		if (code !== 0) logger.error(import_picocolors$19.default.red(`\nThe script specified as BROWSER environment variable failed.\n\n${import_picocolors$19.default.cyan(scriptPath)} exited with code ${code}.`), { error: null });
	});
}
const supportedChromiumBrowsers = [
	"Google Chrome Canary",
	"Google Chrome Dev",
	"Google Chrome Beta",
	"Google Chrome",
	"Microsoft Edge",
	"Brave Browser",
	"Vivaldi",
	"Chromium"
];
async function startBrowserProcess(browser, browserArgs, url$3, logger) {
	const preferredOSXBrowser = browser === "google chrome" ? "Google Chrome" : browser;
	if (process.platform === "darwin" && (!preferredOSXBrowser || supportedChromiumBrowsers.includes(preferredOSXBrowser))) try {
		const ps = await execAsync("ps cax");
		const openedBrowser = preferredOSXBrowser && ps.includes(preferredOSXBrowser) ? preferredOSXBrowser : supportedChromiumBrowsers.find((b) => ps.includes(b));
		if (openedBrowser) {
			await execAsync(`osascript openChrome.js "${url$3}" "${openedBrowser}"`, { cwd: join(VITE_PACKAGE_DIR, "bin") });
			return true;
		}
	} catch {}
	if (process.platform === "darwin" && browser === "open") browser = void 0;
	try {
		const options$1 = browser ? { app: {
			name: browser,
			arguments: browserArgs
		} } : {};
		new Promise((_, reject) => {
			open_default(url$3, options$1).then((subprocess) => {
				subprocess.on("error", reject);
			}).catch(reject);
		}).catch((err$2) => {
			logger.error(err$2.stack || err$2.message);
		});
		return true;
	} catch {
		return false;
	}
}
function execAsync(command, options$1) {
	return new Promise((resolve$4, reject) => {
		exec(command, options$1, (error$1, stdout) => {
			if (error$1) reject(error$1);
			else resolve$4(stdout.toString());
		});
	});
}

//#endregion
//#region src/node/shortcuts.ts
var import_picocolors$18 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
function bindCLIShortcuts(server, opts) {
	if (!server.httpServer || !process.stdin.isTTY || process.env.CI) return;
	const isDev = isDevServer(server);
	if (isDev) server._shortcutsOptions = opts;
	if (opts?.print) server.config.logger.info(import_picocolors$18.default.dim(import_picocolors$18.default.green("  ➜")) + import_picocolors$18.default.dim("  press ") + import_picocolors$18.default.bold("h + enter") + import_picocolors$18.default.dim(" to show help"));
	const shortcuts = (opts?.customShortcuts ?? []).concat(isDev ? BASE_DEV_SHORTCUTS : BASE_PREVIEW_SHORTCUTS);
	let actionRunning = false;
	const onInput = async (input) => {
		if (actionRunning) return;
		if (input === "h") {
			const loggedKeys = /* @__PURE__ */ new Set();
			server.config.logger.info("\n  Shortcuts");
			for (const shortcut$1 of shortcuts) {
				if (loggedKeys.has(shortcut$1.key)) continue;
				loggedKeys.add(shortcut$1.key);
				if (shortcut$1.action == null) continue;
				server.config.logger.info(import_picocolors$18.default.dim("  press ") + import_picocolors$18.default.bold(`${shortcut$1.key} + enter`) + import_picocolors$18.default.dim(` to ${shortcut$1.description}`));
			}
			return;
		}
		const shortcut = shortcuts.find((shortcut$1) => shortcut$1.key === input);
		if (!shortcut || shortcut.action == null) return;
		actionRunning = true;
		await shortcut.action(server);
		actionRunning = false;
	};
	const rl = readline.createInterface({ input: process.stdin });
	rl.on("line", onInput);
	server.httpServer.on("close", () => rl.close());
}
const BASE_DEV_SHORTCUTS = [
	{
		key: "r",
		description: "restart the server",
		async action(server) {
			await restartServerWithUrls(server);
		}
	},
	{
		key: "u",
		description: "show server url",
		action(server) {
			server.config.logger.info("");
			server.printUrls();
		}
	},
	{
		key: "o",
		description: "open in browser",
		action(server) {
			server.openBrowser();
		}
	},
	{
		key: "c",
		description: "clear console",
		action(server) {
			server.config.logger.clearScreen("error");
		}
	},
	{
		key: "q",
		description: "quit",
		async action(server) {
			try {
				await server.close();
			} finally {
				process.exit();
			}
		}
	}
];
const BASE_PREVIEW_SHORTCUTS = [{
	key: "o",
	description: "open in browser",
	action(server) {
		const url$3 = server.resolvedUrls?.local[0] ?? server.resolvedUrls?.network[0];
		if (url$3) openBrowser(url$3, true, server.config.logger);
		else server.config.logger.warn("No URL available to open in browser");
	}
}, {
	key: "q",
	description: "quit",
	async action(server) {
		try {
			await server.close();
		} finally {
			process.exit();
		}
	}
}];

//#endregion
//#region src/node/watch.ts
var import_picocolors$17 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
function getResolvedOutDirs(root, outDir, outputOptions) {
	const resolvedOutDir = path.resolve(root, outDir);
	if (!outputOptions) return new Set([resolvedOutDir]);
	return new Set(arraify(outputOptions).map(({ dir }) => dir ? path.resolve(root, dir) : resolvedOutDir));
}
function resolveEmptyOutDir(emptyOutDir, root, outDirs, logger) {
	if (emptyOutDir != null) return emptyOutDir;
	for (const outDir of outDirs) if (!normalizePath(outDir).startsWith(withTrailingSlash(root))) {
		logger?.warn(import_picocolors$17.default.yellow(`\n${import_picocolors$17.default.bold(`(!)`)} outDir ${import_picocolors$17.default.white(import_picocolors$17.default.dim(outDir))} is not inside project root and will not be emptied.\nUse --emptyOutDir to override.\n`));
		return false;
	}
	return true;
}
function resolveChokidarOptions(options$1, resolvedOutDirs, emptyOutDir, cacheDir) {
	const { ignored: ignoredList,...otherOptions } = options$1 ?? {};
	const ignored = [
		"**/.git/**",
		"**/node_modules/**",
		"**/test-results/**",
		escapePath(cacheDir) + "/**",
		...arraify(ignoredList || [])
	];
	if (emptyOutDir) ignored.push(...[...resolvedOutDirs].map((outDir) => escapePath(outDir) + "/**"));
	return {
		ignored,
		ignoreInitial: true,
		ignorePermissionErrors: true,
		...otherOptions
	};
}
var NoopWatcher = class extends EventEmitter {
	constructor(options$1) {
		super();
		this.options = options$1;
	}
	add() {
		return this;
	}
	unwatch() {
		return this;
	}
	getWatched() {
		return {};
	}
	ref() {
		return this;
	}
	unref() {
		return this;
	}
	async close() {}
};
function createNoopWatcher(options$1) {
	return new NoopWatcher(options$1);
}

//#endregion
//#region ../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/constants.js
var require_constants = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/constants.js": ((exports, module) => {
	const BINARY_TYPES$2 = [
		"nodebuffer",
		"arraybuffer",
		"fragments"
	];
	const hasBlob$1 = typeof Blob !== "undefined";
	if (hasBlob$1) BINARY_TYPES$2.push("blob");
	module.exports = {
		BINARY_TYPES: BINARY_TYPES$2,
		EMPTY_BUFFER: Buffer.alloc(0),
		GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
		hasBlob: hasBlob$1,
		kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
		kListener: Symbol("kListener"),
		kStatusCode: Symbol("status-code"),
		kWebSocket: Symbol("websocket"),
		NOOP: () => {}
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/buffer-util.js
var require_buffer_util = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/buffer-util.js": ((exports, module) => {
	const { EMPTY_BUFFER: EMPTY_BUFFER$3 } = require_constants();
	const FastBuffer$2 = Buffer[Symbol.species];
	/**
	* Merges an array of buffers into a new buffer.
	*
	* @param {Buffer[]} list The array of buffers to concat
	* @param {Number} totalLength The total length of buffers in the list
	* @return {Buffer} The resulting buffer
	* @public
	*/
	function concat$1(list, totalLength) {
		if (list.length === 0) return EMPTY_BUFFER$3;
		if (list.length === 1) return list[0];
		const target = Buffer.allocUnsafe(totalLength);
		let offset$1 = 0;
		for (let i$1 = 0; i$1 < list.length; i$1++) {
			const buf = list[i$1];
			target.set(buf, offset$1);
			offset$1 += buf.length;
		}
		if (offset$1 < totalLength) return new FastBuffer$2(target.buffer, target.byteOffset, offset$1);
		return target;
	}
	/**
	* Masks a buffer using the given mask.
	*
	* @param {Buffer} source The buffer to mask
	* @param {Buffer} mask The mask to use
	* @param {Buffer} output The buffer where to store the result
	* @param {Number} offset The offset at which to start writing
	* @param {Number} length The number of bytes to mask.
	* @public
	*/
	function _mask(source, mask, output, offset$1, length) {
		for (let i$1 = 0; i$1 < length; i$1++) output[offset$1 + i$1] = source[i$1] ^ mask[i$1 & 3];
	}
	/**
	* Unmasks a buffer using the given mask.
	*
	* @param {Buffer} buffer The buffer to unmask
	* @param {Buffer} mask The mask to use
	* @public
	*/
	function _unmask(buffer, mask) {
		for (let i$1 = 0; i$1 < buffer.length; i$1++) buffer[i$1] ^= mask[i$1 & 3];
	}
	/**
	* Converts a buffer to an `ArrayBuffer`.
	*
	* @param {Buffer} buf The buffer to convert
	* @return {ArrayBuffer} Converted buffer
	* @public
	*/
	function toArrayBuffer$1(buf) {
		if (buf.length === buf.buffer.byteLength) return buf.buffer;
		return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
	}
	/**
	* Converts `data` to a `Buffer`.
	*
	* @param {*} data The data to convert
	* @return {Buffer} The buffer
	* @throws {TypeError}
	* @public
	*/
	function toBuffer$2(data) {
		toBuffer$2.readOnly = true;
		if (Buffer.isBuffer(data)) return data;
		let buf;
		if (data instanceof ArrayBuffer) buf = new FastBuffer$2(data);
		else if (ArrayBuffer.isView(data)) buf = new FastBuffer$2(data.buffer, data.byteOffset, data.byteLength);
		else {
			buf = Buffer.from(data);
			toBuffer$2.readOnly = false;
		}
		return buf;
	}
	module.exports = {
		concat: concat$1,
		mask: _mask,
		toArrayBuffer: toArrayBuffer$1,
		toBuffer: toBuffer$2,
		unmask: _unmask
	};
	/* istanbul ignore else  */
	if (!process.env.WS_NO_BUFFER_UTIL) try {
		const bufferUtil$1 = __require("bufferutil");
		module.exports.mask = function(source, mask, output, offset$1, length) {
			if (length < 48) _mask(source, mask, output, offset$1, length);
			else bufferUtil$1.mask(source, mask, output, offset$1, length);
		};
		module.exports.unmask = function(buffer, mask) {
			if (buffer.length < 32) _unmask(buffer, mask);
			else bufferUtil$1.unmask(buffer, mask);
		};
	} catch (e$1) {}
}) });

//#endregion
//#region ../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/limiter.js
var require_limiter = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/limiter.js": ((exports, module) => {
	const kDone = Symbol("kDone");
	const kRun = Symbol("kRun");
	/**
	* A very simple job queue with adjustable concurrency. Adapted from
	* https://github.com/STRML/async-limiter
	*/
	var Limiter$1 = class {
		/**
		* Creates a new `Limiter`.
		*
		* @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
		*     to run concurrently
		*/
		constructor(concurrency) {
			this[kDone] = () => {
				this.pending--;
				this[kRun]();
			};
			this.concurrency = concurrency || Infinity;
			this.jobs = [];
			this.pending = 0;
		}
		/**
		* Adds a job to the queue.
		*
		* @param {Function} job The job to run
		* @public
		*/
		add(job) {
			this.jobs.push(job);
			this[kRun]();
		}
		/**
		* Removes a job from the queue and runs it if possible.
		*
		* @private
		*/
		[kRun]() {
			if (this.pending === this.concurrency) return;
			if (this.jobs.length) {
				const job = this.jobs.shift();
				this.pending++;
				job(this[kDone]);
			}
		}
	};
	module.exports = Limiter$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/permessage-deflate.js": ((exports, module) => {
	const zlib$1 = __require("zlib");
	const bufferUtil = require_buffer_util();
	const Limiter = require_limiter();
	const { kStatusCode: kStatusCode$2 } = require_constants();
	const FastBuffer$1 = Buffer[Symbol.species];
	const TRAILER = Buffer.from([
		0,
		0,
		255,
		255
	]);
	const kPerMessageDeflate = Symbol("permessage-deflate");
	const kTotalLength = Symbol("total-length");
	const kCallback = Symbol("callback");
	const kBuffers = Symbol("buffers");
	const kError$1 = Symbol("error");
	let zlibLimiter;
	/**
	* permessage-deflate implementation.
	*/
	var PerMessageDeflate$4 = class {
		/**
		* Creates a PerMessageDeflate instance.
		*
		* @param {Object} [options] Configuration options
		* @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
		*     for, or request, a custom client window size
		* @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
		*     acknowledge disabling of client context takeover
		* @param {Number} [options.concurrencyLimit=10] The number of concurrent
		*     calls to zlib
		* @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
		*     use of a custom server window size
		* @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
		*     disabling of server context takeover
		* @param {Number} [options.threshold=1024] Size (in bytes) below which
		*     messages should not be compressed if context takeover is disabled
		* @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
		*     deflate
		* @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
		*     inflate
		* @param {Boolean} [isServer=false] Create the instance in either server or
		*     client mode
		* @param {Number} [maxPayload=0] The maximum allowed message length
		*/
		constructor(options$1, isServer, maxPayload) {
			this._maxPayload = maxPayload | 0;
			this._options = options$1 || {};
			this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
			this._isServer = !!isServer;
			this._deflate = null;
			this._inflate = null;
			this.params = null;
			if (!zlibLimiter) zlibLimiter = new Limiter(this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10);
		}
		/**
		* @type {String}
		*/
		static get extensionName() {
			return "permessage-deflate";
		}
		/**
		* Create an extension negotiation offer.
		*
		* @return {Object} Extension parameters
		* @public
		*/
		offer() {
			const params = {};
			if (this._options.serverNoContextTakeover) params.server_no_context_takeover = true;
			if (this._options.clientNoContextTakeover) params.client_no_context_takeover = true;
			if (this._options.serverMaxWindowBits) params.server_max_window_bits = this._options.serverMaxWindowBits;
			if (this._options.clientMaxWindowBits) params.client_max_window_bits = this._options.clientMaxWindowBits;
			else if (this._options.clientMaxWindowBits == null) params.client_max_window_bits = true;
			return params;
		}
		/**
		* Accept an extension negotiation offer/response.
		*
		* @param {Array} configurations The extension negotiation offers/reponse
		* @return {Object} Accepted configuration
		* @public
		*/
		accept(configurations) {
			configurations = this.normalizeParams(configurations);
			this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
			return this.params;
		}
		/**
		* Releases all resources used by the extension.
		*
		* @public
		*/
		cleanup() {
			if (this._inflate) {
				this._inflate.close();
				this._inflate = null;
			}
			if (this._deflate) {
				const callback = this._deflate[kCallback];
				this._deflate.close();
				this._deflate = null;
				if (callback) callback(/* @__PURE__ */ new Error("The deflate stream was closed while data was being processed"));
			}
		}
		/**
		*  Accept an extension negotiation offer.
		*
		* @param {Array} offers The extension negotiation offers
		* @return {Object} Accepted configuration
		* @private
		*/
		acceptAsServer(offers) {
			const opts = this._options;
			const accepted = offers.find((params) => {
				if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) return false;
				return true;
			});
			if (!accepted) throw new Error("None of the extension offers can be accepted");
			if (opts.serverNoContextTakeover) accepted.server_no_context_takeover = true;
			if (opts.clientNoContextTakeover) accepted.client_no_context_takeover = true;
			if (typeof opts.serverMaxWindowBits === "number") accepted.server_max_window_bits = opts.serverMaxWindowBits;
			if (typeof opts.clientMaxWindowBits === "number") accepted.client_max_window_bits = opts.clientMaxWindowBits;
			else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) delete accepted.client_max_window_bits;
			return accepted;
		}
		/**
		* Accept the extension negotiation response.
		*
		* @param {Array} response The extension negotiation response
		* @return {Object} Accepted configuration
		* @private
		*/
		acceptAsClient(response) {
			const params = response[0];
			if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) throw new Error("Unexpected parameter \"client_no_context_takeover\"");
			if (!params.client_max_window_bits) {
				if (typeof this._options.clientMaxWindowBits === "number") params.client_max_window_bits = this._options.clientMaxWindowBits;
			} else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) throw new Error("Unexpected or invalid parameter \"client_max_window_bits\"");
			return params;
		}
		/**
		* Normalize parameters.
		*
		* @param {Array} configurations The extension negotiation offers/reponse
		* @return {Array} The offers/response with normalized parameters
		* @private
		*/
		normalizeParams(configurations) {
			configurations.forEach((params) => {
				Object.keys(params).forEach((key) => {
					let value$1 = params[key];
					if (value$1.length > 1) throw new Error(`Parameter "${key}" must have only a single value`);
					value$1 = value$1[0];
					if (key === "client_max_window_bits") {
						if (value$1 !== true) {
							const num = +value$1;
							if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value$1}`);
							value$1 = num;
						} else if (!this._isServer) throw new TypeError(`Invalid value for parameter "${key}": ${value$1}`);
					} else if (key === "server_max_window_bits") {
						const num = +value$1;
						if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value$1}`);
						value$1 = num;
					} else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
						if (value$1 !== true) throw new TypeError(`Invalid value for parameter "${key}": ${value$1}`);
					} else throw new Error(`Unknown parameter "${key}"`);
					params[key] = value$1;
				});
			});
			return configurations;
		}
		/**
		* Decompress data. Concurrency limited.
		*
		* @param {Buffer} data Compressed data
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @public
		*/
		decompress(data, fin, callback) {
			zlibLimiter.add((done) => {
				this._decompress(data, fin, (err$2, result) => {
					done();
					callback(err$2, result);
				});
			});
		}
		/**
		* Compress data. Concurrency limited.
		*
		* @param {(Buffer|String)} data Data to compress
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @public
		*/
		compress(data, fin, callback) {
			zlibLimiter.add((done) => {
				this._compress(data, fin, (err$2, result) => {
					done();
					callback(err$2, result);
				});
			});
		}
		/**
		* Decompress data.
		*
		* @param {Buffer} data Compressed data
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @private
		*/
		_decompress(data, fin, callback) {
			const endpoint = this._isServer ? "client" : "server";
			if (!this._inflate) {
				const key = `${endpoint}_max_window_bits`;
				const windowBits = typeof this.params[key] !== "number" ? zlib$1.Z_DEFAULT_WINDOWBITS : this.params[key];
				this._inflate = zlib$1.createInflateRaw({
					...this._options.zlibInflateOptions,
					windowBits
				});
				this._inflate[kPerMessageDeflate] = this;
				this._inflate[kTotalLength] = 0;
				this._inflate[kBuffers] = [];
				this._inflate.on("error", inflateOnError);
				this._inflate.on("data", inflateOnData);
			}
			this._inflate[kCallback] = callback;
			this._inflate.write(data);
			if (fin) this._inflate.write(TRAILER);
			this._inflate.flush(() => {
				const err$2 = this._inflate[kError$1];
				if (err$2) {
					this._inflate.close();
					this._inflate = null;
					callback(err$2);
					return;
				}
				const data$1 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
				if (this._inflate._readableState.endEmitted) {
					this._inflate.close();
					this._inflate = null;
				} else {
					this._inflate[kTotalLength] = 0;
					this._inflate[kBuffers] = [];
					if (fin && this.params[`${endpoint}_no_context_takeover`]) this._inflate.reset();
				}
				callback(null, data$1);
			});
		}
		/**
		* Compress data.
		*
		* @param {(Buffer|String)} data Data to compress
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @private
		*/
		_compress(data, fin, callback) {
			const endpoint = this._isServer ? "server" : "client";
			if (!this._deflate) {
				const key = `${endpoint}_max_window_bits`;
				const windowBits = typeof this.params[key] !== "number" ? zlib$1.Z_DEFAULT_WINDOWBITS : this.params[key];
				this._deflate = zlib$1.createDeflateRaw({
					...this._options.zlibDeflateOptions,
					windowBits
				});
				this._deflate[kTotalLength] = 0;
				this._deflate[kBuffers] = [];
				this._deflate.on("data", deflateOnData);
			}
			this._deflate[kCallback] = callback;
			this._deflate.write(data);
			this._deflate.flush(zlib$1.Z_SYNC_FLUSH, () => {
				if (!this._deflate) return;
				let data$1 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
				if (fin) data$1 = new FastBuffer$1(data$1.buffer, data$1.byteOffset, data$1.length - 4);
				this._deflate[kCallback] = null;
				this._deflate[kTotalLength] = 0;
				this._deflate[kBuffers] = [];
				if (fin && this.params[`${endpoint}_no_context_takeover`]) this._deflate.reset();
				callback(null, data$1);
			});
		}
	};
	module.exports = PerMessageDeflate$4;
	/**
	* The listener of the `zlib.DeflateRaw` stream `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function deflateOnData(chunk) {
		this[kBuffers].push(chunk);
		this[kTotalLength] += chunk.length;
	}
	/**
	* The listener of the `zlib.InflateRaw` stream `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function inflateOnData(chunk) {
		this[kTotalLength] += chunk.length;
		if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
			this[kBuffers].push(chunk);
			return;
		}
		this[kError$1] = /* @__PURE__ */ new RangeError("Max payload size exceeded");
		this[kError$1].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
		this[kError$1][kStatusCode$2] = 1009;
		this.removeListener("data", inflateOnData);
		this.reset();
	}
	/**
	* The listener of the `zlib.InflateRaw` stream `'error'` event.
	*
	* @param {Error} err The emitted error
	* @private
	*/
	function inflateOnError(err$2) {
		this[kPerMessageDeflate]._inflate = null;
		if (this[kError$1]) {
			this[kCallback](this[kError$1]);
			return;
		}
		err$2[kStatusCode$2] = 1007;
		this[kCallback](err$2);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/validation.js
var require_validation = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/validation.js": ((exports, module) => {
	const { isUtf8 } = __require("buffer");
	const { hasBlob } = require_constants();
	const tokenChars$2 = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		0,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		1,
		1,
		0,
		1,
		1,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		1,
		0,
		1,
		0
	];
	/**
	* Checks if a status code is allowed in a close frame.
	*
	* @param {Number} code The status code
	* @return {Boolean} `true` if the status code is valid, else `false`
	* @public
	*/
	function isValidStatusCode$2(code) {
		return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
	}
	/**
	* Checks if a given buffer contains only correct UTF-8.
	* Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
	* Markus Kuhn.
	*
	* @param {Buffer} buf The buffer to check
	* @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
	* @public
	*/
	function _isValidUTF8(buf) {
		const len = buf.length;
		let i$1 = 0;
		while (i$1 < len) if ((buf[i$1] & 128) === 0) i$1++;
		else if ((buf[i$1] & 224) === 192) {
			if (i$1 + 1 === len || (buf[i$1 + 1] & 192) !== 128 || (buf[i$1] & 254) === 192) return false;
			i$1 += 2;
		} else if ((buf[i$1] & 240) === 224) {
			if (i$1 + 2 >= len || (buf[i$1 + 1] & 192) !== 128 || (buf[i$1 + 2] & 192) !== 128 || buf[i$1] === 224 && (buf[i$1 + 1] & 224) === 128 || buf[i$1] === 237 && (buf[i$1 + 1] & 224) === 160) return false;
			i$1 += 3;
		} else if ((buf[i$1] & 248) === 240) {
			if (i$1 + 3 >= len || (buf[i$1 + 1] & 192) !== 128 || (buf[i$1 + 2] & 192) !== 128 || (buf[i$1 + 3] & 192) !== 128 || buf[i$1] === 240 && (buf[i$1 + 1] & 240) === 128 || buf[i$1] === 244 && buf[i$1 + 1] > 143 || buf[i$1] > 244) return false;
			i$1 += 4;
		} else return false;
		return true;
	}
	/**
	* Determines whether a value is a `Blob`.
	*
	* @param {*} value The value to be tested
	* @return {Boolean} `true` if `value` is a `Blob`, else `false`
	* @private
	*/
	function isBlob$2(value$1) {
		return hasBlob && typeof value$1 === "object" && typeof value$1.arrayBuffer === "function" && typeof value$1.type === "string" && typeof value$1.stream === "function" && (value$1[Symbol.toStringTag] === "Blob" || value$1[Symbol.toStringTag] === "File");
	}
	module.exports = {
		isBlob: isBlob$2,
		isValidStatusCode: isValidStatusCode$2,
		isValidUTF8: _isValidUTF8,
		tokenChars: tokenChars$2
	};
	if (isUtf8) module.exports.isValidUTF8 = function(buf) {
		return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
	};
	else if (!process.env.WS_NO_UTF_8_VALIDATE) try {
		const isValidUTF8$1 = __require("utf-8-validate");
		module.exports.isValidUTF8 = function(buf) {
			return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8$1(buf);
		};
	} catch (e$1) {}
}) });

//#endregion
//#region ../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/receiver.js
var require_receiver = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/receiver.js": ((exports, module) => {
	const { Writable: Writable$1 } = __require("stream");
	const PerMessageDeflate$3 = require_permessage_deflate();
	const { BINARY_TYPES: BINARY_TYPES$1, EMPTY_BUFFER: EMPTY_BUFFER$2, kStatusCode: kStatusCode$1, kWebSocket: kWebSocket$3 } = require_constants();
	const { concat, toArrayBuffer, unmask } = require_buffer_util();
	const { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = require_validation();
	const FastBuffer = Buffer[Symbol.species];
	const GET_INFO = 0;
	const GET_PAYLOAD_LENGTH_16 = 1;
	const GET_PAYLOAD_LENGTH_64 = 2;
	const GET_MASK = 3;
	const GET_DATA = 4;
	const INFLATING = 5;
	const DEFER_EVENT = 6;
	/**
	* HyBi Receiver implementation.
	*
	* @extends Writable
	*/
	var Receiver$2 = class extends Writable$1 {
		/**
		* Creates a Receiver instance.
		*
		* @param {Object} [options] Options object
		* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {String} [options.binaryType=nodebuffer] The type for binary data
		* @param {Object} [options.extensions] An object containing the negotiated
		*     extensions
		* @param {Boolean} [options.isServer=false] Specifies whether to operate in
		*     client or server mode
		* @param {Number} [options.maxPayload=0] The maximum allowed message length
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		*/
		constructor(options$1 = {}) {
			super();
			this._allowSynchronousEvents = options$1.allowSynchronousEvents !== void 0 ? options$1.allowSynchronousEvents : true;
			this._binaryType = options$1.binaryType || BINARY_TYPES$1[0];
			this._extensions = options$1.extensions || {};
			this._isServer = !!options$1.isServer;
			this._maxPayload = options$1.maxPayload | 0;
			this._skipUTF8Validation = !!options$1.skipUTF8Validation;
			this[kWebSocket$3] = void 0;
			this._bufferedBytes = 0;
			this._buffers = [];
			this._compressed = false;
			this._payloadLength = 0;
			this._mask = void 0;
			this._fragmented = 0;
			this._masked = false;
			this._fin = false;
			this._opcode = 0;
			this._totalPayloadLength = 0;
			this._messageLength = 0;
			this._fragments = [];
			this._errored = false;
			this._loop = false;
			this._state = GET_INFO;
		}
		/**
		* Implements `Writable.prototype._write()`.
		*
		* @param {Buffer} chunk The chunk of data to write
		* @param {String} encoding The character encoding of `chunk`
		* @param {Function} cb Callback
		* @private
		*/
		_write(chunk, encoding, cb) {
			if (this._opcode === 8 && this._state == GET_INFO) return cb();
			this._bufferedBytes += chunk.length;
			this._buffers.push(chunk);
			this.startLoop(cb);
		}
		/**
		* Consumes `n` bytes from the buffered data.
		*
		* @param {Number} n The number of bytes to consume
		* @return {Buffer} The consumed bytes
		* @private
		*/
		consume(n$2) {
			this._bufferedBytes -= n$2;
			if (n$2 === this._buffers[0].length) return this._buffers.shift();
			if (n$2 < this._buffers[0].length) {
				const buf = this._buffers[0];
				this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n$2, buf.length - n$2);
				return new FastBuffer(buf.buffer, buf.byteOffset, n$2);
			}
			const dst = Buffer.allocUnsafe(n$2);
			do {
				const buf = this._buffers[0];
				const offset$1 = dst.length - n$2;
				if (n$2 >= buf.length) dst.set(this._buffers.shift(), offset$1);
				else {
					dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n$2), offset$1);
					this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n$2, buf.length - n$2);
				}
				n$2 -= buf.length;
			} while (n$2 > 0);
			return dst;
		}
		/**
		* Starts the parsing loop.
		*
		* @param {Function} cb Callback
		* @private
		*/
		startLoop(cb) {
			this._loop = true;
			do
				switch (this._state) {
					case GET_INFO:
						this.getInfo(cb);
						break;
					case GET_PAYLOAD_LENGTH_16:
						this.getPayloadLength16(cb);
						break;
					case GET_PAYLOAD_LENGTH_64:
						this.getPayloadLength64(cb);
						break;
					case GET_MASK:
						this.getMask();
						break;
					case GET_DATA:
						this.getData(cb);
						break;
					case INFLATING:
					case DEFER_EVENT:
						this._loop = false;
						return;
				}
			while (this._loop);
			if (!this._errored) cb();
		}
		/**
		* Reads the first two bytes of a frame.
		*
		* @param {Function} cb Callback
		* @private
		*/
		getInfo(cb) {
			if (this._bufferedBytes < 2) {
				this._loop = false;
				return;
			}
			const buf = this.consume(2);
			if ((buf[0] & 48) !== 0) {
				cb(this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3"));
				return;
			}
			const compressed = (buf[0] & 64) === 64;
			if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {
				cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
				return;
			}
			this._fin = (buf[0] & 128) === 128;
			this._opcode = buf[0] & 15;
			this._payloadLength = buf[1] & 127;
			if (this._opcode === 0) {
				if (compressed) {
					cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
					return;
				}
				if (!this._fragmented) {
					cb(this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE"));
					return;
				}
				this._opcode = this._fragmented;
			} else if (this._opcode === 1 || this._opcode === 2) {
				if (this._fragmented) {
					cb(this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE"));
					return;
				}
				this._compressed = compressed;
			} else if (this._opcode > 7 && this._opcode < 11) {
				if (!this._fin) {
					cb(this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN"));
					return;
				}
				if (compressed) {
					cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
					return;
				}
				if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
					cb(this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"));
					return;
				}
			} else {
				cb(this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE"));
				return;
			}
			if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
			this._masked = (buf[1] & 128) === 128;
			if (this._isServer) {
				if (!this._masked) {
					cb(this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK"));
					return;
				}
			} else if (this._masked) {
				cb(this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK"));
				return;
			}
			if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
			else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
			else this.haveLength(cb);
		}
		/**
		* Gets extended payload length (7+16).
		*
		* @param {Function} cb Callback
		* @private
		*/
		getPayloadLength16(cb) {
			if (this._bufferedBytes < 2) {
				this._loop = false;
				return;
			}
			this._payloadLength = this.consume(2).readUInt16BE(0);
			this.haveLength(cb);
		}
		/**
		* Gets extended payload length (7+64).
		*
		* @param {Function} cb Callback
		* @private
		*/
		getPayloadLength64(cb) {
			if (this._bufferedBytes < 8) {
				this._loop = false;
				return;
			}
			const buf = this.consume(8);
			const num = buf.readUInt32BE(0);
			if (num > Math.pow(2, 21) - 1) {
				cb(this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"));
				return;
			}
			this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
			this.haveLength(cb);
		}
		/**
		* Payload length has been read.
		*
		* @param {Function} cb Callback
		* @private
		*/
		haveLength(cb) {
			if (this._payloadLength && this._opcode < 8) {
				this._totalPayloadLength += this._payloadLength;
				if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
					cb(this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
					return;
				}
			}
			if (this._masked) this._state = GET_MASK;
			else this._state = GET_DATA;
		}
		/**
		* Reads mask bytes.
		*
		* @private
		*/
		getMask() {
			if (this._bufferedBytes < 4) {
				this._loop = false;
				return;
			}
			this._mask = this.consume(4);
			this._state = GET_DATA;
		}
		/**
		* Reads data bytes.
		*
		* @param {Function} cb Callback
		* @private
		*/
		getData(cb) {
			let data = EMPTY_BUFFER$2;
			if (this._payloadLength) {
				if (this._bufferedBytes < this._payloadLength) {
					this._loop = false;
					return;
				}
				data = this.consume(this._payloadLength);
				if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) unmask(data, this._mask);
			}
			if (this._opcode > 7) {
				this.controlMessage(data, cb);
				return;
			}
			if (this._compressed) {
				this._state = INFLATING;
				this.decompress(data, cb);
				return;
			}
			if (data.length) {
				this._messageLength = this._totalPayloadLength;
				this._fragments.push(data);
			}
			this.dataMessage(cb);
		}
		/**
		* Decompresses data.
		*
		* @param {Buffer} data Compressed data
		* @param {Function} cb Callback
		* @private
		*/
		decompress(data, cb) {
			this._extensions[PerMessageDeflate$3.extensionName].decompress(data, this._fin, (err$2, buf) => {
				if (err$2) return cb(err$2);
				if (buf.length) {
					this._messageLength += buf.length;
					if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
						cb(this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
						return;
					}
					this._fragments.push(buf);
				}
				this.dataMessage(cb);
				if (this._state === GET_INFO) this.startLoop(cb);
			});
		}
		/**
		* Handles a data message.
		*
		* @param {Function} cb Callback
		* @private
		*/
		dataMessage(cb) {
			if (!this._fin) {
				this._state = GET_INFO;
				return;
			}
			const messageLength = this._messageLength;
			const fragments = this._fragments;
			this._totalPayloadLength = 0;
			this._messageLength = 0;
			this._fragmented = 0;
			this._fragments = [];
			if (this._opcode === 2) {
				let data;
				if (this._binaryType === "nodebuffer") data = concat(fragments, messageLength);
				else if (this._binaryType === "arraybuffer") data = toArrayBuffer(concat(fragments, messageLength));
				else if (this._binaryType === "blob") data = new Blob(fragments);
				else data = fragments;
				if (this._allowSynchronousEvents) {
					this.emit("message", data, true);
					this._state = GET_INFO;
				} else {
					this._state = DEFER_EVENT;
					setImmediate(() => {
						this.emit("message", data, true);
						this._state = GET_INFO;
						this.startLoop(cb);
					});
				}
			} else {
				const buf = concat(fragments, messageLength);
				if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
					cb(this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8"));
					return;
				}
				if (this._state === INFLATING || this._allowSynchronousEvents) {
					this.emit("message", buf, false);
					this._state = GET_INFO;
				} else {
					this._state = DEFER_EVENT;
					setImmediate(() => {
						this.emit("message", buf, false);
						this._state = GET_INFO;
						this.startLoop(cb);
					});
				}
			}
		}
		/**
		* Handles a control message.
		*
		* @param {Buffer} data Data to handle
		* @return {(Error|RangeError|undefined)} A possible error
		* @private
		*/
		controlMessage(data, cb) {
			if (this._opcode === 8) {
				if (data.length === 0) {
					this._loop = false;
					this.emit("conclude", 1005, EMPTY_BUFFER$2);
					this.end();
				} else {
					const code = data.readUInt16BE(0);
					if (!isValidStatusCode$1(code)) {
						cb(this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE"));
						return;
					}
					const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
					if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
						cb(this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8"));
						return;
					}
					this._loop = false;
					this.emit("conclude", code, buf);
					this.end();
				}
				this._state = GET_INFO;
				return;
			}
			if (this._allowSynchronousEvents) {
				this.emit(this._opcode === 9 ? "ping" : "pong", data);
				this._state = GET_INFO;
			} else {
				this._state = DEFER_EVENT;
				setImmediate(() => {
					this.emit(this._opcode === 9 ? "ping" : "pong", data);
					this._state = GET_INFO;
					this.startLoop(cb);
				});
			}
		}
		/**
		* Builds an error object.
		*
		* @param {function(new:Error|RangeError)} ErrorCtor The error constructor
		* @param {String} message The error message
		* @param {Boolean} prefix Specifies whether or not to add a default prefix to
		*     `message`
		* @param {Number} statusCode The status code
		* @param {String} errorCode The exposed error code
		* @return {(Error|RangeError)} The error
		* @private
		*/
		createError(ErrorCtor, message, prefix, statusCode, errorCode) {
			this._loop = false;
			this._errored = true;
			const err$2 = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
			Error.captureStackTrace(err$2, this.createError);
			err$2.code = errorCode;
			err$2[kStatusCode$1] = statusCode;
			return err$2;
		}
	};
	module.exports = Receiver$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/sender.js
var require_sender = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/sender.js": ((exports, module) => {
	const { Duplex: Duplex$3 } = __require("stream");
	const { randomFillSync } = __require("crypto");
	const PerMessageDeflate$2 = require_permessage_deflate();
	const { EMPTY_BUFFER: EMPTY_BUFFER$1, kWebSocket: kWebSocket$2, NOOP: NOOP$2 } = require_constants();
	const { isBlob: isBlob$1, isValidStatusCode } = require_validation();
	const { mask: applyMask, toBuffer: toBuffer$1 } = require_buffer_util();
	const kByteLength = Symbol("kByteLength");
	const maskBuffer = Buffer.alloc(4);
	const RANDOM_POOL_SIZE = 8 * 1024;
	let randomPool;
	let randomPoolPointer = RANDOM_POOL_SIZE;
	const DEFAULT = 0;
	const DEFLATING = 1;
	const GET_BLOB_DATA = 2;
	/**
	* HyBi Sender implementation.
	*/
	var Sender$2 = class Sender$2 {
		/**
		* Creates a Sender instance.
		*
		* @param {Duplex} socket The connection socket
		* @param {Object} [extensions] An object containing the negotiated extensions
		* @param {Function} [generateMask] The function used to generate the masking
		*     key
		*/
		constructor(socket, extensions$1, generateMask) {
			this._extensions = extensions$1 || {};
			if (generateMask) {
				this._generateMask = generateMask;
				this._maskBuffer = Buffer.alloc(4);
			}
			this._socket = socket;
			this._firstFragment = true;
			this._compress = false;
			this._bufferedBytes = 0;
			this._queue = [];
			this._state = DEFAULT;
			this.onerror = NOOP$2;
			this[kWebSocket$2] = void 0;
		}
		/**
		* Frames a piece of data according to the HyBi WebSocket protocol.
		*
		* @param {(Buffer|String)} data The data to frame
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @return {(Buffer|String)[]} The framed data
		* @public
		*/
		static frame(data, options$1) {
			let mask;
			let merge$1 = false;
			let offset$1 = 2;
			let skipMasking = false;
			if (options$1.mask) {
				mask = options$1.maskBuffer || maskBuffer;
				if (options$1.generateMask) options$1.generateMask(mask);
				else {
					if (randomPoolPointer === RANDOM_POOL_SIZE) {
						/* istanbul ignore else  */
						if (randomPool === void 0) randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
						randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
						randomPoolPointer = 0;
					}
					mask[0] = randomPool[randomPoolPointer++];
					mask[1] = randomPool[randomPoolPointer++];
					mask[2] = randomPool[randomPoolPointer++];
					mask[3] = randomPool[randomPoolPointer++];
				}
				skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
				offset$1 = 6;
			}
			let dataLength;
			if (typeof data === "string") if ((!options$1.mask || skipMasking) && options$1[kByteLength] !== void 0) dataLength = options$1[kByteLength];
			else {
				data = Buffer.from(data);
				dataLength = data.length;
			}
			else {
				dataLength = data.length;
				merge$1 = options$1.mask && options$1.readOnly && !skipMasking;
			}
			let payloadLength = dataLength;
			if (dataLength >= 65536) {
				offset$1 += 8;
				payloadLength = 127;
			} else if (dataLength > 125) {
				offset$1 += 2;
				payloadLength = 126;
			}
			const target = Buffer.allocUnsafe(merge$1 ? dataLength + offset$1 : offset$1);
			target[0] = options$1.fin ? options$1.opcode | 128 : options$1.opcode;
			if (options$1.rsv1) target[0] |= 64;
			target[1] = payloadLength;
			if (payloadLength === 126) target.writeUInt16BE(dataLength, 2);
			else if (payloadLength === 127) {
				target[2] = target[3] = 0;
				target.writeUIntBE(dataLength, 4, 6);
			}
			if (!options$1.mask) return [target, data];
			target[1] |= 128;
			target[offset$1 - 4] = mask[0];
			target[offset$1 - 3] = mask[1];
			target[offset$1 - 2] = mask[2];
			target[offset$1 - 1] = mask[3];
			if (skipMasking) return [target, data];
			if (merge$1) {
				applyMask(data, mask, target, offset$1, dataLength);
				return [target];
			}
			applyMask(data, mask, data, 0, dataLength);
			return [target, data];
		}
		/**
		* Sends a close message to the other peer.
		*
		* @param {Number} [code] The status code component of the body
		* @param {(String|Buffer)} [data] The message component of the body
		* @param {Boolean} [mask=false] Specifies whether or not to mask the message
		* @param {Function} [cb] Callback
		* @public
		*/
		close(code, data, mask, cb) {
			let buf;
			if (code === void 0) buf = EMPTY_BUFFER$1;
			else if (typeof code !== "number" || !isValidStatusCode(code)) throw new TypeError("First argument must be a valid error code number");
			else if (data === void 0 || !data.length) {
				buf = Buffer.allocUnsafe(2);
				buf.writeUInt16BE(code, 0);
			} else {
				const length = Buffer.byteLength(data);
				if (length > 123) throw new RangeError("The message must not be greater than 123 bytes");
				buf = Buffer.allocUnsafe(2 + length);
				buf.writeUInt16BE(code, 0);
				if (typeof data === "string") buf.write(data, 2);
				else buf.set(data, 2);
			}
			const options$1 = {
				[kByteLength]: buf.length,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 8,
				readOnly: false,
				rsv1: false
			};
			if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				buf,
				false,
				options$1,
				cb
			]);
			else this.sendFrame(Sender$2.frame(buf, options$1), cb);
		}
		/**
		* Sends a ping message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Boolean} [mask=false] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		ping(data, mask, cb) {
			let byteLength;
			let readOnly;
			if (typeof data === "string") {
				byteLength = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob$1(data)) {
				byteLength = data.size;
				readOnly = false;
			} else {
				data = toBuffer$1(data);
				byteLength = data.length;
				readOnly = toBuffer$1.readOnly;
			}
			if (byteLength > 125) throw new RangeError("The data size must not be greater than 125 bytes");
			const options$1 = {
				[kByteLength]: byteLength,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 9,
				readOnly,
				rsv1: false
			};
			if (isBlob$1(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				false,
				options$1,
				cb
			]);
			else this.getBlobData(data, false, options$1, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				false,
				options$1,
				cb
			]);
			else this.sendFrame(Sender$2.frame(data, options$1), cb);
		}
		/**
		* Sends a pong message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Boolean} [mask=false] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		pong(data, mask, cb) {
			let byteLength;
			let readOnly;
			if (typeof data === "string") {
				byteLength = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob$1(data)) {
				byteLength = data.size;
				readOnly = false;
			} else {
				data = toBuffer$1(data);
				byteLength = data.length;
				readOnly = toBuffer$1.readOnly;
			}
			if (byteLength > 125) throw new RangeError("The data size must not be greater than 125 bytes");
			const options$1 = {
				[kByteLength]: byteLength,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 10,
				readOnly,
				rsv1: false
			};
			if (isBlob$1(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				false,
				options$1,
				cb
			]);
			else this.getBlobData(data, false, options$1, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				false,
				options$1,
				cb
			]);
			else this.sendFrame(Sender$2.frame(data, options$1), cb);
		}
		/**
		* Sends a data message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Object} options Options object
		* @param {Boolean} [options.binary=false] Specifies whether `data` is binary
		*     or text
		* @param {Boolean} [options.compress=false] Specifies whether or not to
		*     compress `data`
		* @param {Boolean} [options.fin=false] Specifies whether the fragment is the
		*     last one
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		send(data, options$1, cb) {
			const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
			let opcode = options$1.binary ? 2 : 1;
			let rsv1 = options$1.compress;
			let byteLength;
			let readOnly;
			if (typeof data === "string") {
				byteLength = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob$1(data)) {
				byteLength = data.size;
				readOnly = false;
			} else {
				data = toBuffer$1(data);
				byteLength = data.length;
				readOnly = toBuffer$1.readOnly;
			}
			if (this._firstFragment) {
				this._firstFragment = false;
				if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) rsv1 = byteLength >= perMessageDeflate._threshold;
				this._compress = rsv1;
			} else {
				rsv1 = false;
				opcode = 0;
			}
			if (options$1.fin) this._firstFragment = true;
			const opts = {
				[kByteLength]: byteLength,
				fin: options$1.fin,
				generateMask: this._generateMask,
				mask: options$1.mask,
				maskBuffer: this._maskBuffer,
				opcode,
				readOnly,
				rsv1
			};
			if (isBlob$1(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				this._compress,
				opts,
				cb
			]);
			else this.getBlobData(data, this._compress, opts, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				this._compress,
				opts,
				cb
			]);
			else this.dispatch(data, this._compress, opts, cb);
		}
		/**
		* Gets the contents of a blob as binary data.
		*
		* @param {Blob} blob The blob
		* @param {Boolean} [compress=false] Specifies whether or not to compress
		*     the data
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @param {Function} [cb] Callback
		* @private
		*/
		getBlobData(blob, compress, options$1, cb) {
			this._bufferedBytes += options$1[kByteLength];
			this._state = GET_BLOB_DATA;
			blob.arrayBuffer().then((arrayBuffer) => {
				if (this._socket.destroyed) {
					const err$2 = /* @__PURE__ */ new Error("The socket was closed while the blob was being read");
					process.nextTick(callCallbacks, this, err$2, cb);
					return;
				}
				this._bufferedBytes -= options$1[kByteLength];
				const data = toBuffer$1(arrayBuffer);
				if (!compress) {
					this._state = DEFAULT;
					this.sendFrame(Sender$2.frame(data, options$1), cb);
					this.dequeue();
				} else this.dispatch(data, compress, options$1, cb);
			}).catch((err$2) => {
				process.nextTick(onError, this, err$2, cb);
			});
		}
		/**
		* Dispatches a message.
		*
		* @param {(Buffer|String)} data The message to send
		* @param {Boolean} [compress=false] Specifies whether or not to compress
		*     `data`
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @param {Function} [cb] Callback
		* @private
		*/
		dispatch(data, compress, options$1, cb) {
			if (!compress) {
				this.sendFrame(Sender$2.frame(data, options$1), cb);
				return;
			}
			const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
			this._bufferedBytes += options$1[kByteLength];
			this._state = DEFLATING;
			perMessageDeflate.compress(data, options$1.fin, (_, buf) => {
				if (this._socket.destroyed) {
					callCallbacks(this, /* @__PURE__ */ new Error("The socket was closed while data was being compressed"), cb);
					return;
				}
				this._bufferedBytes -= options$1[kByteLength];
				this._state = DEFAULT;
				options$1.readOnly = false;
				this.sendFrame(Sender$2.frame(buf, options$1), cb);
				this.dequeue();
			});
		}
		/**
		* Executes queued send operations.
		*
		* @private
		*/
		dequeue() {
			while (this._state === DEFAULT && this._queue.length) {
				const params = this._queue.shift();
				this._bufferedBytes -= params[3][kByteLength];
				Reflect.apply(params[0], this, params.slice(1));
			}
		}
		/**
		* Enqueues a send operation.
		*
		* @param {Array} params Send operation parameters.
		* @private
		*/
		enqueue(params) {
			this._bufferedBytes += params[3][kByteLength];
			this._queue.push(params);
		}
		/**
		* Sends a frame.
		*
		* @param {(Buffer | String)[]} list The frame to send
		* @param {Function} [cb] Callback
		* @private
		*/
		sendFrame(list, cb) {
			if (list.length === 2) {
				this._socket.cork();
				this._socket.write(list[0]);
				this._socket.write(list[1], cb);
				this._socket.uncork();
			} else this._socket.write(list[0], cb);
		}
	};
	module.exports = Sender$2;
	/**
	* Calls queued callbacks with an error.
	*
	* @param {Sender} sender The `Sender` instance
	* @param {Error} err The error to call the callbacks with
	* @param {Function} [cb] The first callback
	* @private
	*/
	function callCallbacks(sender, err$2, cb) {
		if (typeof cb === "function") cb(err$2);
		for (let i$1 = 0; i$1 < sender._queue.length; i$1++) {
			const params = sender._queue[i$1];
			const callback = params[params.length - 1];
			if (typeof callback === "function") callback(err$2);
		}
	}
	/**
	* Handles a `Sender` error.
	*
	* @param {Sender} sender The `Sender` instance
	* @param {Error} err The error
	* @param {Function} [cb] The first pending callback
	* @private
	*/
	function onError(sender, err$2, cb) {
		callCallbacks(sender, err$2, cb);
		sender.onerror(err$2);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/event-target.js
var require_event_target = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/event-target.js": ((exports, module) => {
	const { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = require_constants();
	const kCode = Symbol("kCode");
	const kData = Symbol("kData");
	const kError = Symbol("kError");
	const kMessage = Symbol("kMessage");
	const kReason = Symbol("kReason");
	const kTarget = Symbol("kTarget");
	const kType = Symbol("kType");
	const kWasClean = Symbol("kWasClean");
	/**
	* Class representing an event.
	*/
	var Event$1 = class {
		/**
		* Create a new `Event`.
		*
		* @param {String} type The name of the event
		* @throws {TypeError} If the `type` argument is not specified
		*/
		constructor(type) {
			this[kTarget] = null;
			this[kType] = type;
		}
		/**
		* @type {*}
		*/
		get target() {
			return this[kTarget];
		}
		/**
		* @type {String}
		*/
		get type() {
			return this[kType];
		}
	};
	Object.defineProperty(Event$1.prototype, "target", { enumerable: true });
	Object.defineProperty(Event$1.prototype, "type", { enumerable: true });
	/**
	* Class representing a close event.
	*
	* @extends Event
	*/
	var CloseEvent = class extends Event$1 {
		/**
		* Create a new `CloseEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {Number} [options.code=0] The status code explaining why the
		*     connection was closed
		* @param {String} [options.reason=''] A human-readable string explaining why
		*     the connection was closed
		* @param {Boolean} [options.wasClean=false] Indicates whether or not the
		*     connection was cleanly closed
		*/
		constructor(type, options$1 = {}) {
			super(type);
			this[kCode] = options$1.code === void 0 ? 0 : options$1.code;
			this[kReason] = options$1.reason === void 0 ? "" : options$1.reason;
			this[kWasClean] = options$1.wasClean === void 0 ? false : options$1.wasClean;
		}
		/**
		* @type {Number}
		*/
		get code() {
			return this[kCode];
		}
		/**
		* @type {String}
		*/
		get reason() {
			return this[kReason];
		}
		/**
		* @type {Boolean}
		*/
		get wasClean() {
			return this[kWasClean];
		}
	};
	Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
	/**
	* Class representing an error event.
	*
	* @extends Event
	*/
	var ErrorEvent = class extends Event$1 {
		/**
		* Create a new `ErrorEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {*} [options.error=null] The error that generated this event
		* @param {String} [options.message=''] The error message
		*/
		constructor(type, options$1 = {}) {
			super(type);
			this[kError] = options$1.error === void 0 ? null : options$1.error;
			this[kMessage] = options$1.message === void 0 ? "" : options$1.message;
		}
		/**
		* @type {*}
		*/
		get error() {
			return this[kError];
		}
		/**
		* @type {String}
		*/
		get message() {
			return this[kMessage];
		}
	};
	Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
	Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
	/**
	* Class representing a message event.
	*
	* @extends Event
	*/
	var MessageEvent = class extends Event$1 {
		/**
		* Create a new `MessageEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {*} [options.data=null] The message content
		*/
		constructor(type, options$1 = {}) {
			super(type);
			this[kData] = options$1.data === void 0 ? null : options$1.data;
		}
		/**
		* @type {*}
		*/
		get data() {
			return this[kData];
		}
	};
	Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
	/**
	* This provides methods for emulating the `EventTarget` interface. It's not
	* meant to be used directly.
	*
	* @mixin
	*/
	const EventTarget = {
		addEventListener(type, handler, options$1 = {}) {
			for (const listener$1 of this.listeners(type)) if (!options$1[kForOnEventAttribute$1] && listener$1[kListener$1] === handler && !listener$1[kForOnEventAttribute$1]) return;
			let wrapper;
			if (type === "message") wrapper = function onMessage(data, isBinary) {
				const event = new MessageEvent("message", { data: isBinary ? data : data.toString() });
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else if (type === "close") wrapper = function onClose(code, message) {
				const event = new CloseEvent("close", {
					code,
					reason: message.toString(),
					wasClean: this._closeFrameReceived && this._closeFrameSent
				});
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else if (type === "error") wrapper = function onError$1(error$1) {
				const event = new ErrorEvent("error", {
					error: error$1,
					message: error$1.message
				});
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else if (type === "open") wrapper = function onOpen() {
				const event = new Event$1("open");
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else return;
			wrapper[kForOnEventAttribute$1] = !!options$1[kForOnEventAttribute$1];
			wrapper[kListener$1] = handler;
			if (options$1.once) this.once(type, wrapper);
			else this.on(type, wrapper);
		},
		removeEventListener(type, handler) {
			for (const listener$1 of this.listeners(type)) if (listener$1[kListener$1] === handler && !listener$1[kForOnEventAttribute$1]) {
				this.removeListener(type, listener$1);
				break;
			}
		}
	};
	module.exports = {
		CloseEvent,
		ErrorEvent,
		Event: Event$1,
		EventTarget,
		MessageEvent
	};
	/**
	* Call an event listener
	*
	* @param {(Function|Object)} listener The listener to call
	* @param {*} thisArg The value to use as `this`` when calling the listener
	* @param {Event} event The event to pass to the listener
	* @private
	*/
	function callListener(listener$1, thisArg, event) {
		if (typeof listener$1 === "object" && listener$1.handleEvent) listener$1.handleEvent.call(listener$1, event);
		else listener$1.call(thisArg, event);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/extension.js
var require_extension = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/extension.js": ((exports, module) => {
	const { tokenChars: tokenChars$1 } = require_validation();
	/**
	* Adds an offer to the map of extension offers or a parameter to the map of
	* parameters.
	*
	* @param {Object} dest The map of extension offers or parameters
	* @param {String} name The extension or parameter name
	* @param {(Object|Boolean|String)} elem The extension parameters or the
	*     parameter value
	* @private
	*/
	function push(dest, name, elem) {
		if (dest[name] === void 0) dest[name] = [elem];
		else dest[name].push(elem);
	}
	/**
	* Parses the `Sec-WebSocket-Extensions` header into an object.
	*
	* @param {String} header The field value of the header
	* @return {Object} The parsed object
	* @public
	*/
	function parse$4(header) {
		const offers = Object.create(null);
		let params = Object.create(null);
		let mustUnescape = false;
		let isEscaping = false;
		let inQuotes = false;
		let extensionName;
		let paramName;
		let start = -1;
		let code = -1;
		let end = -1;
		let i$1 = 0;
		for (; i$1 < header.length; i$1++) {
			code = header.charCodeAt(i$1);
			if (extensionName === void 0) if (end === -1 && tokenChars$1[code] === 1) {
				if (start === -1) start = i$1;
			} else if (i$1 !== 0 && (code === 32 || code === 9)) {
				if (end === -1 && start !== -1) end = i$1;
			} else if (code === 59 || code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i$1}`);
				if (end === -1) end = i$1;
				const name = header.slice(start, end);
				if (code === 44) {
					push(offers, name, params);
					params = Object.create(null);
				} else extensionName = name;
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i$1}`);
			else if (paramName === void 0) if (end === -1 && tokenChars$1[code] === 1) {
				if (start === -1) start = i$1;
			} else if (code === 32 || code === 9) {
				if (end === -1 && start !== -1) end = i$1;
			} else if (code === 59 || code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i$1}`);
				if (end === -1) end = i$1;
				push(params, header.slice(start, end), true);
				if (code === 44) {
					push(offers, extensionName, params);
					params = Object.create(null);
					extensionName = void 0;
				}
				start = end = -1;
			} else if (code === 61 && start !== -1 && end === -1) {
				paramName = header.slice(start, i$1);
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i$1}`);
			else if (isEscaping) {
				if (tokenChars$1[code] !== 1) throw new SyntaxError(`Unexpected character at index ${i$1}`);
				if (start === -1) start = i$1;
				else if (!mustUnescape) mustUnescape = true;
				isEscaping = false;
			} else if (inQuotes) if (tokenChars$1[code] === 1) {
				if (start === -1) start = i$1;
			} else if (code === 34 && start !== -1) {
				inQuotes = false;
				end = i$1;
			} else if (code === 92) isEscaping = true;
			else throw new SyntaxError(`Unexpected character at index ${i$1}`);
			else if (code === 34 && header.charCodeAt(i$1 - 1) === 61) inQuotes = true;
			else if (end === -1 && tokenChars$1[code] === 1) {
				if (start === -1) start = i$1;
			} else if (start !== -1 && (code === 32 || code === 9)) {
				if (end === -1) end = i$1;
			} else if (code === 59 || code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i$1}`);
				if (end === -1) end = i$1;
				let value$1 = header.slice(start, end);
				if (mustUnescape) {
					value$1 = value$1.replace(/\\/g, "");
					mustUnescape = false;
				}
				push(params, paramName, value$1);
				if (code === 44) {
					push(offers, extensionName, params);
					params = Object.create(null);
					extensionName = void 0;
				}
				paramName = void 0;
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i$1}`);
		}
		if (start === -1 || inQuotes || code === 32 || code === 9) throw new SyntaxError("Unexpected end of input");
		if (end === -1) end = i$1;
		const token = header.slice(start, end);
		if (extensionName === void 0) push(offers, token, params);
		else {
			if (paramName === void 0) push(params, token, true);
			else if (mustUnescape) push(params, paramName, token.replace(/\\/g, ""));
			else push(params, paramName, token);
			push(offers, extensionName, params);
		}
		return offers;
	}
	/**
	* Builds the `Sec-WebSocket-Extensions` header field value.
	*
	* @param {Object} extensions The map of extensions and parameters to format
	* @return {String} A string representing the given object
	* @public
	*/
	function format$2(extensions$1) {
		return Object.keys(extensions$1).map((extension$1) => {
			let configurations = extensions$1[extension$1];
			if (!Array.isArray(configurations)) configurations = [configurations];
			return configurations.map((params) => {
				return [extension$1].concat(Object.keys(params).map((k) => {
					let values = params[k];
					if (!Array.isArray(values)) values = [values];
					return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
				})).join("; ");
			}).join(", ");
		}).join(", ");
	}
	module.exports = {
		format: format$2,
		parse: parse$4
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/websocket.js
var require_websocket = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/websocket.js": ((exports, module) => {
	const EventEmitter$2 = __require("events");
	const https$3 = __require("https");
	const http$5 = __require("http");
	const net$1 = __require("net");
	const tls = __require("tls");
	const { randomBytes, createHash: createHash$1 } = __require("crypto");
	const { Duplex: Duplex$2, Readable } = __require("stream");
	const { URL: URL$3 } = __require("url");
	const PerMessageDeflate$1 = require_permessage_deflate();
	const Receiver$1 = require_receiver();
	const Sender$1 = require_sender();
	const { isBlob } = require_validation();
	const { BINARY_TYPES, EMPTY_BUFFER, GUID: GUID$1, kForOnEventAttribute, kListener, kStatusCode, kWebSocket: kWebSocket$1, NOOP: NOOP$1 } = require_constants();
	const { EventTarget: { addEventListener, removeEventListener } } = require_event_target();
	const { format: format$1, parse: parse$3 } = require_extension();
	const { toBuffer } = require_buffer_util();
	const closeTimeout = 30 * 1e3;
	const kAborted = Symbol("kAborted");
	const protocolVersions = [8, 13];
	const readyStates = [
		"CONNECTING",
		"OPEN",
		"CLOSING",
		"CLOSED"
	];
	const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
	/**
	* Class representing a WebSocket.
	*
	* @extends EventEmitter
	*/
	var WebSocket$2 = class WebSocket$2 extends EventEmitter$2 {
		/**
		* Create a new `WebSocket`.
		*
		* @param {(String|URL)} address The URL to which to connect
		* @param {(String|String[])} [protocols] The subprotocols
		* @param {Object} [options] Connection options
		*/
		constructor(address, protocols, options$1) {
			super();
			this._binaryType = BINARY_TYPES[0];
			this._closeCode = 1006;
			this._closeFrameReceived = false;
			this._closeFrameSent = false;
			this._closeMessage = EMPTY_BUFFER;
			this._closeTimer = null;
			this._errorEmitted = false;
			this._extensions = {};
			this._paused = false;
			this._protocol = "";
			this._readyState = WebSocket$2.CONNECTING;
			this._receiver = null;
			this._sender = null;
			this._socket = null;
			if (address !== null) {
				this._bufferedAmount = 0;
				this._isServer = false;
				this._redirects = 0;
				if (protocols === void 0) protocols = [];
				else if (!Array.isArray(protocols)) if (typeof protocols === "object" && protocols !== null) {
					options$1 = protocols;
					protocols = [];
				} else protocols = [protocols];
				initAsClient(this, address, protocols, options$1);
			} else {
				this._autoPong = options$1.autoPong;
				this._isServer = true;
			}
		}
		/**
		* For historical reasons, the custom "nodebuffer" type is used by the default
		* instead of "blob".
		*
		* @type {String}
		*/
		get binaryType() {
			return this._binaryType;
		}
		set binaryType(type) {
			if (!BINARY_TYPES.includes(type)) return;
			this._binaryType = type;
			if (this._receiver) this._receiver._binaryType = type;
		}
		/**
		* @type {Number}
		*/
		get bufferedAmount() {
			if (!this._socket) return this._bufferedAmount;
			return this._socket._writableState.length + this._sender._bufferedBytes;
		}
		/**
		* @type {String}
		*/
		get extensions() {
			return Object.keys(this._extensions).join();
		}
		/**
		* @type {Boolean}
		*/
		get isPaused() {
			return this._paused;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onclose() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onerror() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onopen() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onmessage() {
			return null;
		}
		/**
		* @type {String}
		*/
		get protocol() {
			return this._protocol;
		}
		/**
		* @type {Number}
		*/
		get readyState() {
			return this._readyState;
		}
		/**
		* @type {String}
		*/
		get url() {
			return this._url;
		}
		/**
		* Set up the socket and the internal resources.
		*
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Object} options Options object
		* @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Number} [options.maxPayload=0] The maximum allowed message size
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		* @private
		*/
		setSocket(socket, head, options$1) {
			const receiver = new Receiver$1({
				allowSynchronousEvents: options$1.allowSynchronousEvents,
				binaryType: this.binaryType,
				extensions: this._extensions,
				isServer: this._isServer,
				maxPayload: options$1.maxPayload,
				skipUTF8Validation: options$1.skipUTF8Validation
			});
			const sender = new Sender$1(socket, this._extensions, options$1.generateMask);
			this._receiver = receiver;
			this._sender = sender;
			this._socket = socket;
			receiver[kWebSocket$1] = this;
			sender[kWebSocket$1] = this;
			socket[kWebSocket$1] = this;
			receiver.on("conclude", receiverOnConclude);
			receiver.on("drain", receiverOnDrain);
			receiver.on("error", receiverOnError);
			receiver.on("message", receiverOnMessage);
			receiver.on("ping", receiverOnPing);
			receiver.on("pong", receiverOnPong);
			sender.onerror = senderOnError;
			if (socket.setTimeout) socket.setTimeout(0);
			if (socket.setNoDelay) socket.setNoDelay();
			if (head.length > 0) socket.unshift(head);
			socket.on("close", socketOnClose);
			socket.on("data", socketOnData);
			socket.on("end", socketOnEnd);
			socket.on("error", socketOnError$1);
			this._readyState = WebSocket$2.OPEN;
			this.emit("open");
		}
		/**
		* Emit the `'close'` event.
		*
		* @private
		*/
		emitClose() {
			if (!this._socket) {
				this._readyState = WebSocket$2.CLOSED;
				this.emit("close", this._closeCode, this._closeMessage);
				return;
			}
			if (this._extensions[PerMessageDeflate$1.extensionName]) this._extensions[PerMessageDeflate$1.extensionName].cleanup();
			this._receiver.removeAllListeners();
			this._readyState = WebSocket$2.CLOSED;
			this.emit("close", this._closeCode, this._closeMessage);
		}
		/**
		* Start a closing handshake.
		*
		*          +----------+   +-----------+   +----------+
		*     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
		*    |     +----------+   +-----------+   +----------+     |
		*          +----------+   +-----------+         |
		* CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
		*          +----------+   +-----------+   |
		*    |           |                        |   +---+        |
		*                +------------------------+-->|fin| - - - -
		*    |         +---+                      |   +---+
		*     - - - - -|fin|<---------------------+
		*              +---+
		*
		* @param {Number} [code] Status code explaining why the connection is closing
		* @param {(String|Buffer)} [data] The reason why the connection is
		*     closing
		* @public
		*/
		close(code, data) {
			if (this.readyState === WebSocket$2.CLOSED) return;
			if (this.readyState === WebSocket$2.CONNECTING) {
				abortHandshake$1(this, this._req, "WebSocket was closed before the connection was established");
				return;
			}
			if (this.readyState === WebSocket$2.CLOSING) {
				if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) this._socket.end();
				return;
			}
			this._readyState = WebSocket$2.CLOSING;
			this._sender.close(code, data, !this._isServer, (err$2) => {
				if (err$2) return;
				this._closeFrameSent = true;
				if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) this._socket.end();
			});
			setCloseTimer(this);
		}
		/**
		* Pause the socket.
		*
		* @public
		*/
		pause() {
			if (this.readyState === WebSocket$2.CONNECTING || this.readyState === WebSocket$2.CLOSED) return;
			this._paused = true;
			this._socket.pause();
		}
		/**
		* Send a ping.
		*
		* @param {*} [data] The data to send
		* @param {Boolean} [mask] Indicates whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when the ping is sent
		* @public
		*/
		ping(data, mask, cb) {
			if (this.readyState === WebSocket$2.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof data === "function") {
				cb = data;
				data = mask = void 0;
			} else if (typeof mask === "function") {
				cb = mask;
				mask = void 0;
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket$2.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			if (mask === void 0) mask = !this._isServer;
			this._sender.ping(data || EMPTY_BUFFER, mask, cb);
		}
		/**
		* Send a pong.
		*
		* @param {*} [data] The data to send
		* @param {Boolean} [mask] Indicates whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when the pong is sent
		* @public
		*/
		pong(data, mask, cb) {
			if (this.readyState === WebSocket$2.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof data === "function") {
				cb = data;
				data = mask = void 0;
			} else if (typeof mask === "function") {
				cb = mask;
				mask = void 0;
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket$2.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			if (mask === void 0) mask = !this._isServer;
			this._sender.pong(data || EMPTY_BUFFER, mask, cb);
		}
		/**
		* Resume the socket.
		*
		* @public
		*/
		resume() {
			if (this.readyState === WebSocket$2.CONNECTING || this.readyState === WebSocket$2.CLOSED) return;
			this._paused = false;
			if (!this._receiver._writableState.needDrain) this._socket.resume();
		}
		/**
		* Send a data message.
		*
		* @param {*} data The message to send
		* @param {Object} [options] Options object
		* @param {Boolean} [options.binary] Specifies whether `data` is binary or
		*     text
		* @param {Boolean} [options.compress] Specifies whether or not to compress
		*     `data`
		* @param {Boolean} [options.fin=true] Specifies whether the fragment is the
		*     last one
		* @param {Boolean} [options.mask] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when data is written out
		* @public
		*/
		send(data, options$1, cb) {
			if (this.readyState === WebSocket$2.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof options$1 === "function") {
				cb = options$1;
				options$1 = {};
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket$2.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			const opts = {
				binary: typeof data !== "string",
				mask: !this._isServer,
				compress: true,
				fin: true,
				...options$1
			};
			if (!this._extensions[PerMessageDeflate$1.extensionName]) opts.compress = false;
			this._sender.send(data || EMPTY_BUFFER, opts, cb);
		}
		/**
		* Forcibly close the connection.
		*
		* @public
		*/
		terminate() {
			if (this.readyState === WebSocket$2.CLOSED) return;
			if (this.readyState === WebSocket$2.CONNECTING) {
				abortHandshake$1(this, this._req, "WebSocket was closed before the connection was established");
				return;
			}
			if (this._socket) {
				this._readyState = WebSocket$2.CLOSING;
				this._socket.destroy();
			}
		}
	};
	/**
	* @constant {Number} CONNECTING
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket$2, "CONNECTING", {
		enumerable: true,
		value: readyStates.indexOf("CONNECTING")
	});
	/**
	* @constant {Number} CONNECTING
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket$2.prototype, "CONNECTING", {
		enumerable: true,
		value: readyStates.indexOf("CONNECTING")
	});
	/**
	* @constant {Number} OPEN
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket$2, "OPEN", {
		enumerable: true,
		value: readyStates.indexOf("OPEN")
	});
	/**
	* @constant {Number} OPEN
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket$2.prototype, "OPEN", {
		enumerable: true,
		value: readyStates.indexOf("OPEN")
	});
	/**
	* @constant {Number} CLOSING
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket$2, "CLOSING", {
		enumerable: true,
		value: readyStates.indexOf("CLOSING")
	});
	/**
	* @constant {Number} CLOSING
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket$2.prototype, "CLOSING", {
		enumerable: true,
		value: readyStates.indexOf("CLOSING")
	});
	/**
	* @constant {Number} CLOSED
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket$2, "CLOSED", {
		enumerable: true,
		value: readyStates.indexOf("CLOSED")
	});
	/**
	* @constant {Number} CLOSED
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket$2.prototype, "CLOSED", {
		enumerable: true,
		value: readyStates.indexOf("CLOSED")
	});
	[
		"binaryType",
		"bufferedAmount",
		"extensions",
		"isPaused",
		"protocol",
		"readyState",
		"url"
	].forEach((property) => {
		Object.defineProperty(WebSocket$2.prototype, property, { enumerable: true });
	});
	[
		"open",
		"error",
		"close",
		"message"
	].forEach((method) => {
		Object.defineProperty(WebSocket$2.prototype, `on${method}`, {
			enumerable: true,
			get() {
				for (const listener$1 of this.listeners(method)) if (listener$1[kForOnEventAttribute]) return listener$1[kListener];
				return null;
			},
			set(handler) {
				for (const listener$1 of this.listeners(method)) if (listener$1[kForOnEventAttribute]) {
					this.removeListener(method, listener$1);
					break;
				}
				if (typeof handler !== "function") return;
				this.addEventListener(method, handler, { [kForOnEventAttribute]: true });
			}
		});
	});
	WebSocket$2.prototype.addEventListener = addEventListener;
	WebSocket$2.prototype.removeEventListener = removeEventListener;
	module.exports = WebSocket$2;
	/**
	* Initialize a WebSocket client.
	*
	* @param {WebSocket} websocket The client to initialize
	* @param {(String|URL)} address The URL to which to connect
	* @param {Array} protocols The subprotocols
	* @param {Object} [options] Connection options
	* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
	*     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
	*     times in the same tick
	* @param {Boolean} [options.autoPong=true] Specifies whether or not to
	*     automatically send a pong in response to a ping
	* @param {Function} [options.finishRequest] A function which can be used to
	*     customize the headers of each http request before it is sent
	* @param {Boolean} [options.followRedirects=false] Whether or not to follow
	*     redirects
	* @param {Function} [options.generateMask] The function used to generate the
	*     masking key
	* @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
	*     handshake request
	* @param {Number} [options.maxPayload=104857600] The maximum allowed message
	*     size
	* @param {Number} [options.maxRedirects=10] The maximum number of redirects
	*     allowed
	* @param {String} [options.origin] Value of the `Origin` or
	*     `Sec-WebSocket-Origin` header
	* @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
	*     permessage-deflate
	* @param {Number} [options.protocolVersion=13] Value of the
	*     `Sec-WebSocket-Version` header
	* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	*     not to skip UTF-8 validation for text and close messages
	* @private
	*/
	function initAsClient(websocket, address, protocols, options$1) {
		const opts = {
			allowSynchronousEvents: true,
			autoPong: true,
			protocolVersion: protocolVersions[1],
			maxPayload: 100 * 1024 * 1024,
			skipUTF8Validation: false,
			perMessageDeflate: true,
			followRedirects: false,
			maxRedirects: 10,
			...options$1,
			socketPath: void 0,
			hostname: void 0,
			protocol: void 0,
			timeout: void 0,
			method: "GET",
			host: void 0,
			path: void 0,
			port: void 0
		};
		websocket._autoPong = opts.autoPong;
		if (!protocolVersions.includes(opts.protocolVersion)) throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
		let parsedUrl;
		if (address instanceof URL$3) parsedUrl = address;
		else try {
			parsedUrl = new URL$3(address);
		} catch (e$1) {
			throw new SyntaxError(`Invalid URL: ${address}`);
		}
		if (parsedUrl.protocol === "http:") parsedUrl.protocol = "ws:";
		else if (parsedUrl.protocol === "https:") parsedUrl.protocol = "wss:";
		websocket._url = parsedUrl.href;
		const isSecure = parsedUrl.protocol === "wss:";
		const isIpcUrl = parsedUrl.protocol === "ws+unix:";
		let invalidUrlMessage;
		if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) invalidUrlMessage = "The URL's protocol must be one of \"ws:\", \"wss:\", \"http:\", \"https:\", or \"ws+unix:\"";
		else if (isIpcUrl && !parsedUrl.pathname) invalidUrlMessage = "The URL's pathname is empty";
		else if (parsedUrl.hash) invalidUrlMessage = "The URL contains a fragment identifier";
		if (invalidUrlMessage) {
			const err$2 = new SyntaxError(invalidUrlMessage);
			if (websocket._redirects === 0) throw err$2;
			else {
				emitErrorAndClose(websocket, err$2);
				return;
			}
		}
		const defaultPort = isSecure ? 443 : 80;
		const key = randomBytes(16).toString("base64");
		const request = isSecure ? https$3.request : http$5.request;
		const protocolSet = /* @__PURE__ */ new Set();
		let perMessageDeflate;
		opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
		opts.defaultPort = opts.defaultPort || defaultPort;
		opts.port = parsedUrl.port || defaultPort;
		opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
		opts.headers = {
			...opts.headers,
			"Sec-WebSocket-Version": opts.protocolVersion,
			"Sec-WebSocket-Key": key,
			Connection: "Upgrade",
			Upgrade: "websocket"
		};
		opts.path = parsedUrl.pathname + parsedUrl.search;
		opts.timeout = opts.handshakeTimeout;
		if (opts.perMessageDeflate) {
			perMessageDeflate = new PerMessageDeflate$1(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
			opts.headers["Sec-WebSocket-Extensions"] = format$1({ [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer() });
		}
		if (protocols.length) {
			for (const protocol of protocols) {
				if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) throw new SyntaxError("An invalid or duplicated subprotocol was specified");
				protocolSet.add(protocol);
			}
			opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
		}
		if (opts.origin) if (opts.protocolVersion < 13) opts.headers["Sec-WebSocket-Origin"] = opts.origin;
		else opts.headers.Origin = opts.origin;
		if (parsedUrl.username || parsedUrl.password) opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
		if (isIpcUrl) {
			const parts = opts.path.split(":");
			opts.socketPath = parts[0];
			opts.path = parts[1];
		}
		let req$4;
		if (opts.followRedirects) {
			if (websocket._redirects === 0) {
				websocket._originalIpc = isIpcUrl;
				websocket._originalSecure = isSecure;
				websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
				const headers = options$1 && options$1.headers;
				options$1 = {
					...options$1,
					headers: {}
				};
				if (headers) for (const [key$1, value$1] of Object.entries(headers)) options$1.headers[key$1.toLowerCase()] = value$1;
			} else if (websocket.listenerCount("redirect") === 0) {
				const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
				if (!isSameHost || websocket._originalSecure && !isSecure) {
					delete opts.headers.authorization;
					delete opts.headers.cookie;
					if (!isSameHost) delete opts.headers.host;
					opts.auth = void 0;
				}
			}
			if (opts.auth && !options$1.headers.authorization) options$1.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
			req$4 = websocket._req = request(opts);
			if (websocket._redirects) websocket.emit("redirect", websocket.url, req$4);
		} else req$4 = websocket._req = request(opts);
		if (opts.timeout) req$4.on("timeout", () => {
			abortHandshake$1(websocket, req$4, "Opening handshake has timed out");
		});
		req$4.on("error", (err$2) => {
			if (req$4 === null || req$4[kAborted]) return;
			req$4 = websocket._req = null;
			emitErrorAndClose(websocket, err$2);
		});
		req$4.on("response", (res) => {
			const location$1 = res.headers.location;
			const statusCode = res.statusCode;
			if (location$1 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
				if (++websocket._redirects > opts.maxRedirects) {
					abortHandshake$1(websocket, req$4, "Maximum redirects exceeded");
					return;
				}
				req$4.abort();
				let addr;
				try {
					addr = new URL$3(location$1, address);
				} catch (e$1) {
					emitErrorAndClose(websocket, /* @__PURE__ */ new SyntaxError(`Invalid URL: ${location$1}`));
					return;
				}
				initAsClient(websocket, addr, protocols, options$1);
			} else if (!websocket.emit("unexpected-response", req$4, res)) abortHandshake$1(websocket, req$4, `Unexpected server response: ${res.statusCode}`);
		});
		req$4.on("upgrade", (res, socket, head) => {
			websocket.emit("upgrade", res);
			if (websocket.readyState !== WebSocket$2.CONNECTING) return;
			req$4 = websocket._req = null;
			const upgrade = res.headers.upgrade;
			if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
				abortHandshake$1(websocket, socket, "Invalid Upgrade header");
				return;
			}
			const digest = createHash$1("sha1").update(key + GUID$1).digest("base64");
			if (res.headers["sec-websocket-accept"] !== digest) {
				abortHandshake$1(websocket, socket, "Invalid Sec-WebSocket-Accept header");
				return;
			}
			const serverProt = res.headers["sec-websocket-protocol"];
			let protError;
			if (serverProt !== void 0) {
				if (!protocolSet.size) protError = "Server sent a subprotocol but none was requested";
				else if (!protocolSet.has(serverProt)) protError = "Server sent an invalid subprotocol";
			} else if (protocolSet.size) protError = "Server sent no subprotocol";
			if (protError) {
				abortHandshake$1(websocket, socket, protError);
				return;
			}
			if (serverProt) websocket._protocol = serverProt;
			const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
			if (secWebSocketExtensions !== void 0) {
				if (!perMessageDeflate) {
					abortHandshake$1(websocket, socket, "Server sent a Sec-WebSocket-Extensions header but no extension was requested");
					return;
				}
				let extensions$1;
				try {
					extensions$1 = parse$3(secWebSocketExtensions);
				} catch (err$2) {
					abortHandshake$1(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
					return;
				}
				const extensionNames = Object.keys(extensions$1);
				if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {
					abortHandshake$1(websocket, socket, "Server indicated an extension that was not requested");
					return;
				}
				try {
					perMessageDeflate.accept(extensions$1[PerMessageDeflate$1.extensionName]);
				} catch (err$2) {
					abortHandshake$1(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
					return;
				}
				websocket._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;
			}
			websocket.setSocket(socket, head, {
				allowSynchronousEvents: opts.allowSynchronousEvents,
				generateMask: opts.generateMask,
				maxPayload: opts.maxPayload,
				skipUTF8Validation: opts.skipUTF8Validation
			});
		});
		if (opts.finishRequest) opts.finishRequest(req$4, websocket);
		else req$4.end();
	}
	/**
	* Emit the `'error'` and `'close'` events.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {Error} The error to emit
	* @private
	*/
	function emitErrorAndClose(websocket, err$2) {
		websocket._readyState = WebSocket$2.CLOSING;
		websocket._errorEmitted = true;
		websocket.emit("error", err$2);
		websocket.emitClose();
	}
	/**
	* Create a `net.Socket` and initiate a connection.
	*
	* @param {Object} options Connection options
	* @return {net.Socket} The newly created socket used to start the connection
	* @private
	*/
	function netConnect(options$1) {
		options$1.path = options$1.socketPath;
		return net$1.connect(options$1);
	}
	/**
	* Create a `tls.TLSSocket` and initiate a connection.
	*
	* @param {Object} options Connection options
	* @return {tls.TLSSocket} The newly created socket used to start the connection
	* @private
	*/
	function tlsConnect(options$1) {
		options$1.path = void 0;
		if (!options$1.servername && options$1.servername !== "") options$1.servername = net$1.isIP(options$1.host) ? "" : options$1.host;
		return tls.connect(options$1);
	}
	/**
	* Abort the handshake and emit an error.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
	*     abort or the socket to destroy
	* @param {String} message The error message
	* @private
	*/
	function abortHandshake$1(websocket, stream$3, message) {
		websocket._readyState = WebSocket$2.CLOSING;
		const err$2 = new Error(message);
		Error.captureStackTrace(err$2, abortHandshake$1);
		if (stream$3.setHeader) {
			stream$3[kAborted] = true;
			stream$3.abort();
			if (stream$3.socket && !stream$3.socket.destroyed) stream$3.socket.destroy();
			process.nextTick(emitErrorAndClose, websocket, err$2);
		} else {
			stream$3.destroy(err$2);
			stream$3.once("error", websocket.emit.bind(websocket, "error"));
			stream$3.once("close", websocket.emitClose.bind(websocket));
		}
	}
	/**
	* Handle cases where the `ping()`, `pong()`, or `send()` methods are called
	* when the `readyState` attribute is `CLOSING` or `CLOSED`.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {*} [data] The data to send
	* @param {Function} [cb] Callback
	* @private
	*/
	function sendAfterClose(websocket, data, cb) {
		if (data) {
			const length = isBlob(data) ? data.size : toBuffer(data).length;
			if (websocket._socket) websocket._sender._bufferedBytes += length;
			else websocket._bufferedAmount += length;
		}
		if (cb) {
			const err$2 = /* @__PURE__ */ new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
			process.nextTick(cb, err$2);
		}
	}
	/**
	* The listener of the `Receiver` `'conclude'` event.
	*
	* @param {Number} code The status code
	* @param {Buffer} reason The reason for closing
	* @private
	*/
	function receiverOnConclude(code, reason) {
		const websocket = this[kWebSocket$1];
		websocket._closeFrameReceived = true;
		websocket._closeMessage = reason;
		websocket._closeCode = code;
		if (websocket._socket[kWebSocket$1] === void 0) return;
		websocket._socket.removeListener("data", socketOnData);
		process.nextTick(resume, websocket._socket);
		if (code === 1005) websocket.close();
		else websocket.close(code, reason);
	}
	/**
	* The listener of the `Receiver` `'drain'` event.
	*
	* @private
	*/
	function receiverOnDrain() {
		const websocket = this[kWebSocket$1];
		if (!websocket.isPaused) websocket._socket.resume();
	}
	/**
	* The listener of the `Receiver` `'error'` event.
	*
	* @param {(RangeError|Error)} err The emitted error
	* @private
	*/
	function receiverOnError(err$2) {
		const websocket = this[kWebSocket$1];
		if (websocket._socket[kWebSocket$1] !== void 0) {
			websocket._socket.removeListener("data", socketOnData);
			process.nextTick(resume, websocket._socket);
			websocket.close(err$2[kStatusCode]);
		}
		if (!websocket._errorEmitted) {
			websocket._errorEmitted = true;
			websocket.emit("error", err$2);
		}
	}
	/**
	* The listener of the `Receiver` `'finish'` event.
	*
	* @private
	*/
	function receiverOnFinish() {
		this[kWebSocket$1].emitClose();
	}
	/**
	* The listener of the `Receiver` `'message'` event.
	*
	* @param {Buffer|ArrayBuffer|Buffer[])} data The message
	* @param {Boolean} isBinary Specifies whether the message is binary or not
	* @private
	*/
	function receiverOnMessage(data, isBinary) {
		this[kWebSocket$1].emit("message", data, isBinary);
	}
	/**
	* The listener of the `Receiver` `'ping'` event.
	*
	* @param {Buffer} data The data included in the ping frame
	* @private
	*/
	function receiverOnPing(data) {
		const websocket = this[kWebSocket$1];
		if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP$1);
		websocket.emit("ping", data);
	}
	/**
	* The listener of the `Receiver` `'pong'` event.
	*
	* @param {Buffer} data The data included in the pong frame
	* @private
	*/
	function receiverOnPong(data) {
		this[kWebSocket$1].emit("pong", data);
	}
	/**
	* Resume a readable stream
	*
	* @param {Readable} stream The readable stream
	* @private
	*/
	function resume(stream$3) {
		stream$3.resume();
	}
	/**
	* The `Sender` error event handler.
	*
	* @param {Error} The error
	* @private
	*/
	function senderOnError(err$2) {
		const websocket = this[kWebSocket$1];
		if (websocket.readyState === WebSocket$2.CLOSED) return;
		if (websocket.readyState === WebSocket$2.OPEN) {
			websocket._readyState = WebSocket$2.CLOSING;
			setCloseTimer(websocket);
		}
		this._socket.end();
		if (!websocket._errorEmitted) {
			websocket._errorEmitted = true;
			websocket.emit("error", err$2);
		}
	}
	/**
	* Set a timer to destroy the underlying raw socket of a WebSocket.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @private
	*/
	function setCloseTimer(websocket) {
		websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), closeTimeout);
	}
	/**
	* The listener of the socket `'close'` event.
	*
	* @private
	*/
	function socketOnClose() {
		const websocket = this[kWebSocket$1];
		this.removeListener("close", socketOnClose);
		this.removeListener("data", socketOnData);
		this.removeListener("end", socketOnEnd);
		websocket._readyState = WebSocket$2.CLOSING;
		let chunk;
		if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) websocket._receiver.write(chunk);
		websocket._receiver.end();
		this[kWebSocket$1] = void 0;
		clearTimeout(websocket._closeTimer);
		if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) websocket.emitClose();
		else {
			websocket._receiver.on("error", receiverOnFinish);
			websocket._receiver.on("finish", receiverOnFinish);
		}
	}
	/**
	* The listener of the socket `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function socketOnData(chunk) {
		if (!this[kWebSocket$1]._receiver.write(chunk)) this.pause();
	}
	/**
	* The listener of the socket `'end'` event.
	*
	* @private
	*/
	function socketOnEnd() {
		const websocket = this[kWebSocket$1];
		websocket._readyState = WebSocket$2.CLOSING;
		websocket._receiver.end();
		this.end();
	}
	/**
	* The listener of the socket `'error'` event.
	*
	* @private
	*/
	function socketOnError$1() {
		const websocket = this[kWebSocket$1];
		this.removeListener("error", socketOnError$1);
		this.on("error", NOOP$1);
		if (websocket) {
			websocket._readyState = WebSocket$2.CLOSING;
			this.destroy();
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/stream.js
var require_stream = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/stream.js": ((exports, module) => {
	require_websocket();
	const { Duplex: Duplex$1 } = __require("stream");
	/**
	* Emits the `'close'` event on a stream.
	*
	* @param {Duplex} stream The stream.
	* @private
	*/
	function emitClose$1(stream$3) {
		stream$3.emit("close");
	}
	/**
	* The listener of the `'end'` event.
	*
	* @private
	*/
	function duplexOnEnd() {
		if (!this.destroyed && this._writableState.finished) this.destroy();
	}
	/**
	* The listener of the `'error'` event.
	*
	* @param {Error} err The error
	* @private
	*/
	function duplexOnError(err$2) {
		this.removeListener("error", duplexOnError);
		this.destroy();
		if (this.listenerCount("error") === 0) this.emit("error", err$2);
	}
	/**
	* Wraps a `WebSocket` in a duplex stream.
	*
	* @param {WebSocket} ws The `WebSocket` to wrap
	* @param {Object} [options] The options for the `Duplex` constructor
	* @return {Duplex} The duplex stream
	* @public
	*/
	function createWebSocketStream$1(ws, options$1) {
		let terminateOnDestroy = true;
		const duplex = new Duplex$1({
			...options$1,
			autoDestroy: false,
			emitClose: false,
			objectMode: false,
			writableObjectMode: false
		});
		ws.on("message", function message(msg, isBinary) {
			const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
			if (!duplex.push(data)) ws.pause();
		});
		ws.once("error", function error$1(err$2) {
			if (duplex.destroyed) return;
			terminateOnDestroy = false;
			duplex.destroy(err$2);
		});
		ws.once("close", function close$1() {
			if (duplex.destroyed) return;
			duplex.push(null);
		});
		duplex._destroy = function(err$2, callback) {
			if (ws.readyState === ws.CLOSED) {
				callback(err$2);
				process.nextTick(emitClose$1, duplex);
				return;
			}
			let called = false;
			ws.once("error", function error$1(err$3) {
				called = true;
				callback(err$3);
			});
			ws.once("close", function close$1() {
				if (!called) callback(err$2);
				process.nextTick(emitClose$1, duplex);
			});
			if (terminateOnDestroy) ws.terminate();
		};
		duplex._final = function(callback) {
			if (ws.readyState === ws.CONNECTING) {
				ws.once("open", function open$2() {
					duplex._final(callback);
				});
				return;
			}
			if (ws._socket === null) return;
			if (ws._socket._writableState.finished) {
				callback();
				if (duplex._readableState.endEmitted) duplex.destroy();
			} else {
				ws._socket.once("finish", function finish() {
					callback();
				});
				ws.close();
			}
		};
		duplex._read = function() {
			if (ws.isPaused) ws.resume();
		};
		duplex._write = function(chunk, encoding, callback) {
			if (ws.readyState === ws.CONNECTING) {
				ws.once("open", function open$2() {
					duplex._write(chunk, encoding, callback);
				});
				return;
			}
			ws.send(chunk, callback);
		};
		duplex.on("end", duplexOnEnd);
		duplex.on("error", duplexOnError);
		return duplex;
	}
	module.exports = createWebSocketStream$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/subprotocol.js
var require_subprotocol = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/subprotocol.js": ((exports, module) => {
	const { tokenChars } = require_validation();
	/**
	* Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
	*
	* @param {String} header The field value of the header
	* @return {Set} The subprotocol names
	* @public
	*/
	function parse$2(header) {
		const protocols = /* @__PURE__ */ new Set();
		let start = -1;
		let end = -1;
		let i$1 = 0;
		for (; i$1 < header.length; i$1++) {
			const code = header.charCodeAt(i$1);
			if (end === -1 && tokenChars[code] === 1) {
				if (start === -1) start = i$1;
			} else if (i$1 !== 0 && (code === 32 || code === 9)) {
				if (end === -1 && start !== -1) end = i$1;
			} else if (code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i$1}`);
				if (end === -1) end = i$1;
				const protocol$1 = header.slice(start, end);
				if (protocols.has(protocol$1)) throw new SyntaxError(`The "${protocol$1}" subprotocol is duplicated`);
				protocols.add(protocol$1);
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i$1}`);
		}
		if (start === -1 || end !== -1) throw new SyntaxError("Unexpected end of input");
		const protocol = header.slice(start, i$1);
		if (protocols.has(protocol)) throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
		protocols.add(protocol);
		return protocols;
	}
	module.exports = { parse: parse$2 };
}) });

//#endregion
//#region ../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/websocket-server.js
var require_websocket_server = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/lib/websocket-server.js": ((exports, module) => {
	const EventEmitter$1 = __require("events");
	const http$4 = __require("http");
	const { Duplex } = __require("stream");
	const { createHash } = __require("crypto");
	const extension = require_extension();
	const PerMessageDeflate = require_permessage_deflate();
	const subprotocol = require_subprotocol();
	const WebSocket$1 = require_websocket();
	const { GUID, kWebSocket } = require_constants();
	const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
	const RUNNING = 0;
	const CLOSING = 1;
	const CLOSED = 2;
	/**
	* Class representing a WebSocket server.
	*
	* @extends EventEmitter
	*/
	var WebSocketServer$1 = class extends EventEmitter$1 {
		/**
		* Create a `WebSocketServer` instance.
		*
		* @param {Object} options Configuration options
		* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {Boolean} [options.autoPong=true] Specifies whether or not to
		*     automatically send a pong in response to a ping
		* @param {Number} [options.backlog=511] The maximum length of the queue of
		*     pending connections
		* @param {Boolean} [options.clientTracking=true] Specifies whether or not to
		*     track clients
		* @param {Function} [options.handleProtocols] A hook to handle protocols
		* @param {String} [options.host] The hostname where to bind the server
		* @param {Number} [options.maxPayload=104857600] The maximum allowed message
		*     size
		* @param {Boolean} [options.noServer=false] Enable no server mode
		* @param {String} [options.path] Accept only connections matching this path
		* @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
		*     permessage-deflate
		* @param {Number} [options.port] The port where to bind the server
		* @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
		*     server to use
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		* @param {Function} [options.verifyClient] A hook to reject connections
		* @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
		*     class to use. It must be the `WebSocket` class or class that extends it
		* @param {Function} [callback] A listener for the `listening` event
		*/
		constructor(options$1, callback) {
			super();
			options$1 = {
				allowSynchronousEvents: true,
				autoPong: true,
				maxPayload: 100 * 1024 * 1024,
				skipUTF8Validation: false,
				perMessageDeflate: false,
				handleProtocols: null,
				clientTracking: true,
				verifyClient: null,
				noServer: false,
				backlog: null,
				server: null,
				host: null,
				path: null,
				port: null,
				WebSocket: WebSocket$1,
				...options$1
			};
			if (options$1.port == null && !options$1.server && !options$1.noServer || options$1.port != null && (options$1.server || options$1.noServer) || options$1.server && options$1.noServer) throw new TypeError("One and only one of the \"port\", \"server\", or \"noServer\" options must be specified");
			if (options$1.port != null) {
				this._server = http$4.createServer((req$4, res) => {
					const body = http$4.STATUS_CODES[426];
					res.writeHead(426, {
						"Content-Length": body.length,
						"Content-Type": "text/plain"
					});
					res.end(body);
				});
				this._server.listen(options$1.port, options$1.host, options$1.backlog, callback);
			} else if (options$1.server) this._server = options$1.server;
			if (this._server) {
				const emitConnection = this.emit.bind(this, "connection");
				this._removeListeners = addListeners(this._server, {
					listening: this.emit.bind(this, "listening"),
					error: this.emit.bind(this, "error"),
					upgrade: (req$4, socket, head) => {
						this.handleUpgrade(req$4, socket, head, emitConnection);
					}
				});
			}
			if (options$1.perMessageDeflate === true) options$1.perMessageDeflate = {};
			if (options$1.clientTracking) {
				this.clients = /* @__PURE__ */ new Set();
				this._shouldEmitClose = false;
			}
			this.options = options$1;
			this._state = RUNNING;
		}
		/**
		* Returns the bound address, the address family name, and port of the server
		* as reported by the operating system if listening on an IP socket.
		* If the server is listening on a pipe or UNIX domain socket, the name is
		* returned as a string.
		*
		* @return {(Object|String|null)} The address of the server
		* @public
		*/
		address() {
			if (this.options.noServer) throw new Error("The server is operating in \"noServer\" mode");
			if (!this._server) return null;
			return this._server.address();
		}
		/**
		* Stop the server from accepting new connections and emit the `'close'` event
		* when all existing connections are closed.
		*
		* @param {Function} [cb] A one-time listener for the `'close'` event
		* @public
		*/
		close(cb) {
			if (this._state === CLOSED) {
				if (cb) this.once("close", () => {
					cb(/* @__PURE__ */ new Error("The server is not running"));
				});
				process.nextTick(emitClose, this);
				return;
			}
			if (cb) this.once("close", cb);
			if (this._state === CLOSING) return;
			this._state = CLOSING;
			if (this.options.noServer || this.options.server) {
				if (this._server) {
					this._removeListeners();
					this._removeListeners = this._server = null;
				}
				if (this.clients) if (!this.clients.size) process.nextTick(emitClose, this);
				else this._shouldEmitClose = true;
				else process.nextTick(emitClose, this);
			} else {
				const server = this._server;
				this._removeListeners();
				this._removeListeners = this._server = null;
				server.close(() => {
					emitClose(this);
				});
			}
		}
		/**
		* See if a given request should be handled by this server instance.
		*
		* @param {http.IncomingMessage} req Request object to inspect
		* @return {Boolean} `true` if the request is valid, else `false`
		* @public
		*/
		shouldHandle(req$4) {
			if (this.options.path) {
				const index = req$4.url.indexOf("?");
				if ((index !== -1 ? req$4.url.slice(0, index) : req$4.url) !== this.options.path) return false;
			}
			return true;
		}
		/**
		* Handle a HTTP Upgrade request.
		*
		* @param {http.IncomingMessage} req The request object
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Function} cb Callback
		* @public
		*/
		handleUpgrade(req$4, socket, head, cb) {
			socket.on("error", socketOnError);
			const key = req$4.headers["sec-websocket-key"];
			const upgrade = req$4.headers.upgrade;
			const version$2 = +req$4.headers["sec-websocket-version"];
			if (req$4.method !== "GET") {
				abortHandshakeOrEmitwsClientError(this, req$4, socket, 405, "Invalid HTTP method");
				return;
			}
			if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
				abortHandshakeOrEmitwsClientError(this, req$4, socket, 400, "Invalid Upgrade header");
				return;
			}
			if (key === void 0 || !keyRegex.test(key)) {
				abortHandshakeOrEmitwsClientError(this, req$4, socket, 400, "Missing or invalid Sec-WebSocket-Key header");
				return;
			}
			if (version$2 !== 13 && version$2 !== 8) {
				abortHandshakeOrEmitwsClientError(this, req$4, socket, 400, "Missing or invalid Sec-WebSocket-Version header", { "Sec-WebSocket-Version": "13, 8" });
				return;
			}
			if (!this.shouldHandle(req$4)) {
				abortHandshake(socket, 400);
				return;
			}
			const secWebSocketProtocol = req$4.headers["sec-websocket-protocol"];
			let protocols = /* @__PURE__ */ new Set();
			if (secWebSocketProtocol !== void 0) try {
				protocols = subprotocol.parse(secWebSocketProtocol);
			} catch (err$2) {
				abortHandshakeOrEmitwsClientError(this, req$4, socket, 400, "Invalid Sec-WebSocket-Protocol header");
				return;
			}
			const secWebSocketExtensions = req$4.headers["sec-websocket-extensions"];
			const extensions$1 = {};
			if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
				const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
				try {
					const offers = extension.parse(secWebSocketExtensions);
					if (offers[PerMessageDeflate.extensionName]) {
						perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
						extensions$1[PerMessageDeflate.extensionName] = perMessageDeflate;
					}
				} catch (err$2) {
					abortHandshakeOrEmitwsClientError(this, req$4, socket, 400, "Invalid or unacceptable Sec-WebSocket-Extensions header");
					return;
				}
			}
			if (this.options.verifyClient) {
				const info = {
					origin: req$4.headers[`${version$2 === 8 ? "sec-websocket-origin" : "origin"}`],
					secure: !!(req$4.socket.authorized || req$4.socket.encrypted),
					req: req$4
				};
				if (this.options.verifyClient.length === 2) {
					this.options.verifyClient(info, (verified, code, message, headers) => {
						if (!verified) return abortHandshake(socket, code || 401, message, headers);
						this.completeUpgrade(extensions$1, key, protocols, req$4, socket, head, cb);
					});
					return;
				}
				if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
			}
			this.completeUpgrade(extensions$1, key, protocols, req$4, socket, head, cb);
		}
		/**
		* Upgrade the connection to WebSocket.
		*
		* @param {Object} extensions The accepted extensions
		* @param {String} key The value of the `Sec-WebSocket-Key` header
		* @param {Set} protocols The subprotocols
		* @param {http.IncomingMessage} req The request object
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Function} cb Callback
		* @throws {Error} If called more than once with the same socket
		* @private
		*/
		completeUpgrade(extensions$1, key, protocols, req$4, socket, head, cb) {
			if (!socket.readable || !socket.writable) return socket.destroy();
			if (socket[kWebSocket]) throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
			if (this._state > RUNNING) return abortHandshake(socket, 503);
			const headers = [
				"HTTP/1.1 101 Switching Protocols",
				"Upgrade: websocket",
				"Connection: Upgrade",
				`Sec-WebSocket-Accept: ${createHash("sha1").update(key + GUID).digest("base64")}`
			];
			const ws = new this.options.WebSocket(null, void 0, this.options);
			if (protocols.size) {
				const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req$4) : protocols.values().next().value;
				if (protocol) {
					headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
					ws._protocol = protocol;
				}
			}
			if (extensions$1[PerMessageDeflate.extensionName]) {
				const params = extensions$1[PerMessageDeflate.extensionName].params;
				const value$1 = extension.format({ [PerMessageDeflate.extensionName]: [params] });
				headers.push(`Sec-WebSocket-Extensions: ${value$1}`);
				ws._extensions = extensions$1;
			}
			this.emit("headers", headers, req$4);
			socket.write(headers.concat("\r\n").join("\r\n"));
			socket.removeListener("error", socketOnError);
			ws.setSocket(socket, head, {
				allowSynchronousEvents: this.options.allowSynchronousEvents,
				maxPayload: this.options.maxPayload,
				skipUTF8Validation: this.options.skipUTF8Validation
			});
			if (this.clients) {
				this.clients.add(ws);
				ws.on("close", () => {
					this.clients.delete(ws);
					if (this._shouldEmitClose && !this.clients.size) process.nextTick(emitClose, this);
				});
			}
			cb(ws, req$4);
		}
	};
	module.exports = WebSocketServer$1;
	/**
	* Add event listeners on an `EventEmitter` using a map of <event, listener>
	* pairs.
	*
	* @param {EventEmitter} server The event emitter
	* @param {Object.<String, Function>} map The listeners to add
	* @return {Function} A function that will remove the added listeners when
	*     called
	* @private
	*/
	function addListeners(server, map$1) {
		for (const event of Object.keys(map$1)) server.on(event, map$1[event]);
		return function removeListeners() {
			for (const event of Object.keys(map$1)) server.removeListener(event, map$1[event]);
		};
	}
	/**
	* Emit a `'close'` event on an `EventEmitter`.
	*
	* @param {EventEmitter} server The event emitter
	* @private
	*/
	function emitClose(server) {
		server._state = CLOSED;
		server.emit("close");
	}
	/**
	* Handle socket errors.
	*
	* @private
	*/
	function socketOnError() {
		this.destroy();
	}
	/**
	* Close the connection when preconditions are not fulfilled.
	*
	* @param {Duplex} socket The socket of the upgrade request
	* @param {Number} code The HTTP response status code
	* @param {String} [message] The HTTP response body
	* @param {Object} [headers] Additional HTTP response headers
	* @private
	*/
	function abortHandshake(socket, code, message, headers) {
		message = message || http$4.STATUS_CODES[code];
		headers = {
			Connection: "close",
			"Content-Type": "text/html",
			"Content-Length": Buffer.byteLength(message),
			...headers
		};
		socket.once("finish", socket.destroy);
		socket.end(`HTTP/1.1 ${code} ${http$4.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h$2) => `${h$2}: ${headers[h$2]}`).join("\r\n") + "\r\n\r\n" + message);
	}
	/**
	* Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
	* one listener for it, otherwise call `abortHandshake()`.
	*
	* @param {WebSocketServer} server The WebSocket server
	* @param {http.IncomingMessage} req The request object
	* @param {Duplex} socket The socket of the upgrade request
	* @param {Number} code The HTTP response status code
	* @param {String} message The HTTP response body
	* @param {Object} [headers] The HTTP response headers
	* @private
	*/
	function abortHandshakeOrEmitwsClientError(server, req$4, socket, code, message, headers) {
		if (server.listenerCount("wsClientError")) {
			const err$2 = new Error(message);
			Error.captureStackTrace(err$2, abortHandshakeOrEmitwsClientError);
			server.emit("wsClientError", err$2, socket, req$4);
		} else abortHandshake(socket, code, message, headers);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/ws@8.18.3/node_modules/ws/wrapper.mjs
var import_stream = /* @__PURE__ */ __toESM(require_stream(), 1);
var import_receiver = /* @__PURE__ */ __toESM(require_receiver(), 1);
var import_sender = /* @__PURE__ */ __toESM(require_sender(), 1);
var import_websocket = /* @__PURE__ */ __toESM(require_websocket(), 1);
var import_websocket_server = /* @__PURE__ */ __toESM(require_websocket_server(), 1);

//#endregion
//#region ../../node_modules/.pnpm/host-validation-middleware@0.1.2/node_modules/host-validation-middleware/dist/index.js
/**
* This function assumes that the input is not malformed.
* This is because we only care about browser requests.
* Non-browser clients can send any value they want anyway.
*/
function extractHostNameFromHostHeader(hostHeader) {
	const trimmedHost = hostHeader.trim();
	if (trimmedHost[0] === "[") {
		const endIpv6 = trimmedHost.indexOf("]");
		if (endIpv6 < 0) return { type: "invalid" };
		return net.isIP(trimmedHost.slice(1, endIpv6)) === 6 ? { type: "ipv6" } : { type: "invalid" };
	}
	const colonPos = trimmedHost.indexOf(":");
	const hostname = colonPos === -1 ? trimmedHost : trimmedHost.slice(0, colonPos);
	if (net.isIP(hostname) === 4) return { type: "ipv4" };
	return {
		type: "hostname",
		value: hostname
	};
}
const isFileOrExtensionProtocolRE = /^(?:file|.+-extension):/i;
function isHostAllowedInternal(hostHeader, allowedHosts) {
	if (isFileOrExtensionProtocolRE.test(hostHeader)) return true;
	const extracted = extractHostNameFromHostHeader(hostHeader);
	if (extracted.type === "invalid") return false;
	if (extracted.type === "ipv4" || extracted.type === "ipv6") return true;
	const hostname = extracted.value;
	if (hostname === "localhost" || hostname.endsWith(".localhost")) return true;
	for (const allowedHost of allowedHosts) {
		if (allowedHost === hostname) return true;
		if (allowedHost[0] === "." && (allowedHost.slice(1) === hostname || hostname.endsWith(allowedHost))) return true;
	}
	return false;
}
const cache = /* @__PURE__ */ new WeakMap();
/**
* Check if the host contained in the host header is allowed.
*
* This function will cache the result if the `allowedHosts` array is frozen.
*
* @param hostHeader - The value of host header. See [RFC 9110 7.2](https://datatracker.ietf.org/doc/html/rfc9110#name-host-and-authority).
* @param allowedHosts - The allowed host patterns. See the README for more details.
*/
function isHostAllowed(hostHeader, allowedHosts) {
	if (hostHeader === void 0) return true;
	let cachedAllowedHosts;
	if (Object.isFrozen(allowedHosts)) {
		if (!cache.has(allowedHosts)) cache.set(allowedHosts, /* @__PURE__ */ new Set());
		cachedAllowedHosts = cache.get(allowedHosts);
		if (cachedAllowedHosts.has(hostHeader)) return true;
	}
	const result = isHostAllowedInternal(hostHeader, allowedHosts);
	if (cachedAllowedHosts && result) cachedAllowedHosts.add(hostHeader);
	return result;
}
/**
* Middleware to validate the host header of incoming requests.
*
* If the host header is not in the allowed hosts list, a 403 Forbidden response
* is sent.
*/
function hostValidationMiddleware$1(options$1) {
	return async function hostValidationMiddleware$1$1(req$4, res, next) {
		const hostHeader = req$4.headers.host;
		if (!isHostAllowed(hostHeader, options$1.allowedHosts)) {
			const hostname = hostHeader?.replace(/:\d+$/, "") ?? "";
			const errorMessage = options$1.generateErrorMessage?.(hostname) ?? generateDefaultErrorMessage(hostname);
			res.writeHead(403, { "Content-Type": options$1.errorResponseContentType ?? "text/plain" });
			res.end(errorMessage);
			return;
		}
		next();
	};
}
function generateDefaultErrorMessage(hostname) {
	return `Blocked request. This host (${JSON.stringify(hostname)}) is not allowed.`;
}

//#endregion
//#region src/node/server/ws.ts
var import_picocolors$16 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const WebSocketServerRaw = process.versions.bun ? import.meta.require("ws").WebSocketServer : import_websocket_server.default;
const HMR_HEADER = "vite-hmr";
const isWebSocketServer = Symbol("isWebSocketServer");
const wsServerEvents = [
	"connection",
	"error",
	"headers",
	"listening",
	"message"
];
function noop$2() {}
function hasValidToken(config$2, url$3) {
	const token = url$3.searchParams.get("token");
	if (!token) return false;
	try {
		return crypto.timingSafeEqual(Buffer.from(token), Buffer.from(config$2.webSocketToken));
	} catch {}
	return false;
}
function createWebSocketServer(server, config$2, httpsOptions) {
	if (config$2.server.ws === false) return {
		[isWebSocketServer]: true,
		get clients() {
			return /* @__PURE__ */ new Set();
		},
		async close() {},
		on: noop$2,
		off: noop$2,
		setInvokeHandler: noop$2,
		handleInvoke: async () => ({ error: {
			name: "TransportError",
			message: "handleInvoke not implemented",
			stack: (/* @__PURE__ */ new Error()).stack
		} }),
		listen: noop$2,
		send: noop$2
	};
	let wsHttpServer = void 0;
	const hmr = isObject(config$2.server.hmr) && config$2.server.hmr;
	const hmrServer = hmr && hmr.server;
	const hmrPort = hmr && hmr.port;
	const wsServer = hmrServer || (!hmrPort || hmrPort === config$2.server.port) && server;
	let hmrServerWsListener;
	const customListeners = /* @__PURE__ */ new Map();
	const clientsMap = /* @__PURE__ */ new WeakMap();
	const port = hmrPort || 24678;
	const host = hmr && hmr.host || void 0;
	const allowedHosts = config$2.server.allowedHosts === true ? config$2.server.allowedHosts : Object.freeze([...config$2.server.allowedHosts]);
	const shouldHandle = (req$4) => {
		if (req$4.headers["sec-websocket-protocol"] === "vite-ping") return true;
		if (allowedHosts !== true && !isHostAllowed(req$4.headers.host, allowedHosts)) return false;
		if (config$2.legacy?.skipWebSocketTokenCheck) return true;
		if (req$4.headers.origin) return hasValidToken(config$2, new URL(`http://example.com${req$4.url}`));
		return true;
	};
	const handleUpgrade = (req$4, socket, head, isPing) => {
		wss.handleUpgrade(req$4, socket, head, (ws) => {
			if (isPing) {
				ws.close(1e3);
				return;
			}
			wss.emit("connection", ws, req$4);
		});
	};
	const wss = new WebSocketServerRaw({ noServer: true });
	wss.shouldHandle = shouldHandle;
	if (wsServer) {
		let hmrBase = config$2.base;
		const hmrPath = hmr ? hmr.path : void 0;
		if (hmrPath) hmrBase = path.posix.join(hmrBase, hmrPath);
		hmrServerWsListener = (req$4, socket, head) => {
			const protocol = req$4.headers["sec-websocket-protocol"];
			const parsedUrl = new URL(`http://example.com${req$4.url}`);
			if ([HMR_HEADER, "vite-ping"].includes(protocol) && parsedUrl.pathname === hmrBase) handleUpgrade(req$4, socket, head, protocol === "vite-ping");
		};
		wsServer.on("upgrade", hmrServerWsListener);
	} else {
		const route = ((_, res) => {
			const statusCode = 426;
			const body = STATUS_CODES[statusCode];
			if (!body) throw new Error(`No body text found for the ${statusCode} status code`);
			res.writeHead(statusCode, {
				"Content-Length": body.length,
				"Content-Type": "text/plain"
			});
			res.end(body);
		});
		if (httpsOptions) wsHttpServer = createServer$1(httpsOptions, route);
		else wsHttpServer = createServer(route);
		wsHttpServer.on("upgrade", (req$4, socket, head) => {
			const protocol = req$4.headers["sec-websocket-protocol"];
			if (protocol === "vite-ping" && server && !server.listening) {
				req$4.destroy();
				return;
			}
			handleUpgrade(req$4, socket, head, protocol === "vite-ping");
		});
		wsHttpServer.on("error", (e$1) => {
			if (e$1.code === "EADDRINUSE") config$2.logger.error(import_picocolors$16.default.red(`WebSocket server error: Port ${e$1.port} is already in use`), { error: e$1 });
			else config$2.logger.error(import_picocolors$16.default.red(`WebSocket server error:\n${e$1.stack || e$1.message}`), { error: e$1 });
		});
	}
	wss.on("connection", (socket) => {
		socket.on("message", (raw) => {
			if (!customListeners.size) return;
			let parsed;
			try {
				parsed = JSON.parse(String(raw));
			} catch {}
			if (!parsed || parsed.type !== "custom" || !parsed.event) return;
			const listeners = customListeners.get(parsed.event);
			if (!listeners?.size) return;
			const client = getSocketClient(socket);
			listeners.forEach((listener$1) => listener$1(parsed.data, client, parsed.invoke));
		});
		socket.on("error", (err$2) => {
			config$2.logger.error(`${import_picocolors$16.default.red(`ws error:`)}\n${err$2.stack}`, {
				timestamp: true,
				error: err$2
			});
		});
		socket.send(JSON.stringify({ type: "connected" }));
		if (bufferedError) {
			socket.send(JSON.stringify(bufferedError));
			bufferedError = null;
		}
	});
	wss.on("error", (e$1) => {
		if (e$1.code === "EADDRINUSE") config$2.logger.error(import_picocolors$16.default.red(`WebSocket server error: Port ${e$1.port} is already in use`), { error: e$1 });
		else config$2.logger.error(import_picocolors$16.default.red(`WebSocket server error:\n${e$1.stack || e$1.message}`), { error: e$1 });
	});
	function getSocketClient(socket) {
		if (!clientsMap.has(socket)) clientsMap.set(socket, {
			send: (...args) => {
				let payload;
				if (typeof args[0] === "string") payload = {
					type: "custom",
					event: args[0],
					data: args[1]
				};
				else payload = args[0];
				socket.send(JSON.stringify(payload));
			},
			socket
		});
		return clientsMap.get(socket);
	}
	let bufferedError = null;
	const normalizedHotChannel = normalizeHotChannel({
		send(payload) {
			if (payload.type === "error" && !wss.clients.size) {
				bufferedError = payload;
				return;
			}
			const stringified = JSON.stringify(payload);
			wss.clients.forEach((client) => {
				if (client.readyState === 1) client.send(stringified);
			});
		},
		on(event, fn) {
			if (!customListeners.has(event)) customListeners.set(event, /* @__PURE__ */ new Set());
			customListeners.get(event).add(fn);
		},
		off(event, fn) {
			customListeners.get(event)?.delete(fn);
		},
		listen() {
			wsHttpServer?.listen(port, host);
		},
		close() {
			if (hmrServerWsListener && wsServer) wsServer.off("upgrade", hmrServerWsListener);
			return new Promise((resolve$4, reject) => {
				wss.clients.forEach((client) => {
					client.terminate();
				});
				wss.close((err$2) => {
					if (err$2) reject(err$2);
					else if (wsHttpServer) wsHttpServer.close((err$3) => {
						if (err$3) reject(err$3);
						else resolve$4();
					});
					else resolve$4();
				});
			});
		}
	}, config$2.server.hmr !== false, false);
	return {
		...normalizedHotChannel,
		on: ((event, fn) => {
			if (wsServerEvents.includes(event)) {
				wss.on(event, fn);
				return;
			}
			normalizedHotChannel.on(event, fn);
		}),
		off: ((event, fn) => {
			if (wsServerEvents.includes(event)) {
				wss.off(event, fn);
				return;
			}
			normalizedHotChannel.off(event, fn);
		}),
		async close() {
			await normalizedHotChannel.close();
		},
		[isWebSocketServer]: true,
		get clients() {
			return new Set(Array.from(wss.clients).map(getSocketClient));
		}
	};
}

//#endregion
//#region src/node/server/middlewares/base.ts
function baseMiddleware(rawBase, middlewareMode) {
	return function viteBaseMiddleware(req$4, res, next) {
		const url$3 = req$4.url;
		const pathname = cleanUrl(url$3);
		const base = rawBase;
		if (pathname.startsWith(base)) {
			req$4.url = stripBase(url$3, base);
			return next();
		}
		if (middlewareMode) return next();
		if (pathname === "/" || pathname === "/index.html") {
			res.writeHead(302, { Location: base + url$3.slice(pathname.length) });
			res.end();
			return;
		}
		const redirectPath = withTrailingSlash(url$3) !== base ? joinUrlSegments(base, url$3) : base;
		if (req$4.headers.accept?.includes("text/html")) {
			res.writeHead(404, { "Content-Type": "text/html" });
			res.end(`The server is configured with a public base URL of ${base} - did you mean to visit <a href="${redirectPath}">${redirectPath}</a> instead?`);
			return;
		} else {
			res.writeHead(404, { "Content-Type": "text/plain" });
			res.end(`The server is configured with a public base URL of ${base} - did you mean to visit ${redirectPath} instead?`);
			return;
		}
	};
}

//#endregion
//#region ../../node_modules/.pnpm/http-proxy-3@1.22.0/node_modules/http-proxy-3/dist/lib/http-proxy/common.js
var require_common = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/http-proxy-3@1.22.0/node_modules/http-proxy-3/dist/lib/http-proxy/common.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isSSL = void 0;
	exports.setupOutgoing = setupOutgoing;
	exports.setupSocket = setupSocket;
	exports.getPort = getPort;
	exports.hasEncryptedConnection = hasEncryptedConnection;
	exports.urlJoin = urlJoin;
	exports.rewriteCookieProperty = rewriteCookieProperty;
	exports.toURL = toURL;
	const node_tls_1 = __require("node:tls");
	const upgradeHeader = /(^|,)\s*upgrade\s*($|,)/i;
	exports.isSSL = /^https|wss/;
	const HEADER_BLACKLIST = "trailer";
	const HTTP2_HEADER_BLACKLIST = [
		":method",
		":path",
		":scheme",
		":authority"
	];
	function setupOutgoing(outgoing, options$1, req$4, forward) {
		const target = options$1[forward || "target"];
		outgoing.port = +(target.port ?? (target.protocol !== void 0 && exports.isSSL.test(target.protocol) ? 443 : 80));
		for (const e$1 of [
			"host",
			"hostname",
			"socketPath",
			"pfx",
			"key",
			"passphrase",
			"cert",
			"ca",
			"ciphers",
			"secureProtocol"
		]) outgoing[e$1] = target[e$1];
		outgoing.method = options$1.method || req$4.method;
		outgoing.headers = { ...req$4.headers };
		if (options$1.headers) outgoing.headers = {
			...outgoing.headers,
			...options$1.headers
		};
		for (const header in outgoing.headers) if (HEADER_BLACKLIST == header.toLowerCase()) {
			delete outgoing.headers[header];
			break;
		}
		if (req$4.httpVersionMajor > 1) for (const header of HTTP2_HEADER_BLACKLIST) delete outgoing.headers[header];
		if (options$1.auth) {
			delete outgoing.headers.authorization;
			outgoing.auth = options$1.auth;
		}
		if (options$1.ca) outgoing.ca = options$1.ca;
		if (target.protocol !== void 0 && exports.isSSL.test(target.protocol)) outgoing.rejectUnauthorized = typeof options$1.secure === "undefined" ? true : options$1.secure;
		outgoing.agent = options$1.agent || false;
		outgoing.localAddress = options$1.localAddress;
		if (!outgoing.agent) {
			outgoing.headers = outgoing.headers || {};
			if (typeof outgoing.headers.connection !== "string" || !upgradeHeader.test(outgoing.headers.connection)) outgoing.headers.connection = "close";
		}
		const targetPath = target && options$1.prependPath !== false && "pathname" in target ? getPath(`${target.pathname}${target.search ?? ""}`) : "/";
		let outgoingPath = options$1.toProxy ? req$4.url : getPath(req$4.url);
		outgoingPath = !options$1.ignorePath ? outgoingPath : "";
		outgoing.path = urlJoin(targetPath, outgoingPath ?? "");
		if (options$1.changeOrigin) outgoing.headers.host = target.protocol !== void 0 && required(outgoing.port, target.protocol) && !hasPort(outgoing.host) ? outgoing.host + ":" + outgoing.port : outgoing.host;
		return outgoing;
	}
	function setupSocket(socket) {
		socket.setTimeout(0);
		socket.setNoDelay(true);
		socket.setKeepAlive(true, 0);
		return socket;
	}
	function getPort(req$4) {
		const res = req$4.headers.host ? req$4.headers.host.match(/:(\d+)/) : "";
		return res ? res[1] : hasEncryptedConnection(req$4) ? "443" : "80";
	}
	function hasEncryptedConnection(req$4) {
		const conn = req$4.connection;
		return conn instanceof node_tls_1.TLSSocket && conn.encrypted || Boolean(conn.pair);
	}
	function urlJoin(...args) {
		const queryParams = [];
		let queryParamRaw = "";
		args.forEach((url$3, index) => {
			const qpStart = url$3.indexOf("?");
			if (qpStart !== -1) {
				queryParams.push(url$3.substring(qpStart + 1));
				args[index] = url$3.substring(0, qpStart);
			}
		});
		queryParamRaw = queryParams.filter(Boolean).join("&");
		let retSegs = "";
		for (const seg of args) {
			if (!seg) continue;
			if (retSegs.endsWith("/")) if (seg.startsWith("/")) retSegs += seg.slice(1);
			else retSegs += seg;
			else if (seg.startsWith("/")) retSegs += seg;
			else retSegs += "/" + seg;
		}
		return queryParamRaw ? retSegs + "?" + queryParamRaw : retSegs;
	}
	function rewriteCookieProperty(header, config$2, property) {
		if (Array.isArray(header)) return header.map((headerElement) => {
			return rewriteCookieProperty(headerElement, config$2, property);
		});
		return header.replace(new RegExp("(;\\s*" + property + "=)([^;]+)", "i"), (match, prefix, previousValue) => {
			let newValue;
			if (previousValue in config$2) newValue = config$2[previousValue];
			else if ("*" in config$2) newValue = config$2["*"];
			else return match;
			if (newValue) return prefix + newValue;
			else return "";
		});
	}
	function hasPort(host) {
		return !!~host.indexOf(":");
	}
	function getPath(url$3) {
		if (url$3 === "" || url$3?.startsWith("?")) return url$3;
		const u = toURL(url$3);
		return `${u.pathname ?? ""}${u.search ?? ""}`;
	}
	function toURL(url$3) {
		if (url$3 instanceof URL) return url$3;
		else if (typeof url$3 === "object" && "href" in url$3 && typeof url$3.href === "string") url$3 = url$3.href;
		if (!url$3) url$3 = "";
		if (typeof url$3 != "string") url$3 = `${url$3}`;
		if (url$3.startsWith("//")) url$3 = `http://base.invalid${url$3}`;
		return new URL(url$3, "http://base.invalid");
	}
	function required(port, protocol) {
		protocol = protocol.split(":")[0];
		port = +port;
		if (!port) return false;
		switch (protocol) {
			case "http":
			case "ws": return port !== 80;
			case "https":
			case "wss": return port !== 443;
		}
		return port !== 0;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/http-proxy-3@1.22.0/node_modules/http-proxy-3/dist/lib/http-proxy/passes/web-outgoing.js
var require_web_outgoing = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/http-proxy-3@1.22.0/node_modules/http-proxy-3/dist/lib/http-proxy/passes/web-outgoing.js": ((exports) => {
	var __createBinding$3 = exports && exports.__createBinding || (Object.create ? (function(o$1, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$2[k];
	}));
	var __setModuleDefault$3 = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar$3 = exports && exports.__importStar || (function() {
		var ownKeys = function(o$1) {
			ownKeys = Object.getOwnPropertyNames || function(o$2) {
				var ar = [];
				for (var k in o$2) if (Object.prototype.hasOwnProperty.call(o$2, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys(o$1);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys(mod), i$1 = 0; i$1 < k.length; i$1++) if (k[i$1] !== "default") __createBinding$3(result, mod, k[i$1]);
			}
			__setModuleDefault$3(result, mod);
			return result;
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.removeChunked = removeChunked;
	exports.setConnection = setConnection;
	exports.setRedirectHostRewrite = setRedirectHostRewrite;
	exports.writeHeaders = writeHeaders;
	exports.writeStatusCode = writeStatusCode;
	const common$2 = __importStar$3(require_common());
	const redirectRegex = /^201|30(1|2|7|8)$/;
	function removeChunked(_req, _res, proxyRes) {
		delete proxyRes.headers["transfer-encoding"];
	}
	function setConnection(req$4, _res, proxyRes) {
		if (req$4.httpVersion === "1.0") proxyRes.headers["connection"] = req$4.headers["connection"] || "close";
		else if (req$4.httpVersion !== "2.0" && !proxyRes.headers["connection"]) proxyRes.headers["connection"] = req$4.headers["connection"] || "keep-alive";
	}
	function setRedirectHostRewrite(req$4, _res, proxyRes, options$1) {
		if ((options$1.hostRewrite || options$1.autoRewrite || options$1.protocolRewrite) && proxyRes.headers["location"] && redirectRegex.test(`${proxyRes.statusCode}`)) {
			const target = common$2.toURL(options$1.target);
			const location$1 = proxyRes.headers["location"];
			if (typeof location$1 != "string") return;
			const u = common$2.toURL(location$1);
			if (target.host != u.host) return;
			if (options$1.hostRewrite) u.host = options$1.hostRewrite;
			else if (options$1.autoRewrite) u.host = req$4.headers["host"] ?? "";
			if (options$1.protocolRewrite) u.protocol = options$1.protocolRewrite;
			proxyRes.headers["location"] = u.toString();
		}
	}
	function writeHeaders(_req, res, proxyRes, options$1) {
		const rewriteCookieDomainConfig = typeof options$1.cookieDomainRewrite === "string" ? { "*": options$1.cookieDomainRewrite } : options$1.cookieDomainRewrite;
		const rewriteCookiePathConfig = typeof options$1.cookiePathRewrite === "string" ? { "*": options$1.cookiePathRewrite } : options$1.cookiePathRewrite;
		const preserveHeaderKeyCase = options$1.preserveHeaderKeyCase;
		const setHeader = (key, header) => {
			if (header == void 0) return;
			if (rewriteCookieDomainConfig && key.toLowerCase() === "set-cookie") header = common$2.rewriteCookieProperty(header, rewriteCookieDomainConfig, "domain");
			if (rewriteCookiePathConfig && key.toLowerCase() === "set-cookie") header = common$2.rewriteCookieProperty(header, rewriteCookiePathConfig, "path");
			res.setHeader(String(key).trim(), header);
		};
		let rawHeaderKeyMap;
		if (preserveHeaderKeyCase && proxyRes.rawHeaders != void 0) {
			rawHeaderKeyMap = {};
			for (let i$1 = 0; i$1 < proxyRes.rawHeaders.length; i$1 += 2) {
				const key = proxyRes.rawHeaders[i$1];
				rawHeaderKeyMap[key.toLowerCase()] = key;
			}
		}
		for (const key0 in proxyRes.headers) {
			let key = key0;
			if (_req.httpVersionMajor > 1 && key === "connection") continue;
			const header = proxyRes.headers[key];
			if (preserveHeaderKeyCase && rawHeaderKeyMap) key = rawHeaderKeyMap[key] ?? key;
			setHeader(key, header);
		}
	}
	function writeStatusCode(_req, res, proxyRes) {
		res.statusCode = proxyRes.statusCode;
		if (proxyRes.statusMessage && _req.httpVersionMajor === 1) res.statusMessage = proxyRes.statusMessage;
	}
	exports.OUTGOING_PASSES = {
		removeChunked,
		setConnection,
		setRedirectHostRewrite,
		writeHeaders,
		writeStatusCode
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/follow-redirects@1.15.11_debug@4.4.3/node_modules/follow-redirects/debug.js
var require_debug = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/follow-redirects@1.15.11_debug@4.4.3/node_modules/follow-redirects/debug.js": ((exports, module) => {
	var debug$7;
	module.exports = function() {
		if (!debug$7) {
			try {
				debug$7 = require_node$1()("follow-redirects");
			} catch (error$1) {}
			if (typeof debug$7 !== "function") debug$7 = function() {};
		}
		debug$7.apply(null, arguments);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/follow-redirects@1.15.11_debug@4.4.3/node_modules/follow-redirects/index.js
var require_follow_redirects = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/follow-redirects@1.15.11_debug@4.4.3/node_modules/follow-redirects/index.js": ((exports, module) => {
	var url = __require("url");
	var URL$2 = url.URL;
	var http$3 = __require("http");
	var https$2 = __require("https");
	var Writable = __require("stream").Writable;
	var assert$1 = __require("assert");
	var debug$6 = require_debug();
	// istanbul ignore next
	(function detectUnsupportedEnvironment() {
		var looksLikeNode = typeof process !== "undefined";
		var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
		var looksLikeV8 = isFunction(Error.captureStackTrace);
		if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) console.warn("The follow-redirects package should be excluded from browser builds.");
	})();
	var useNativeURL = false;
	try {
		assert$1(new URL$2(""));
	} catch (error$1) {
		useNativeURL = error$1.code === "ERR_INVALID_URL";
	}
	var preservedUrlFields = [
		"auth",
		"host",
		"hostname",
		"href",
		"path",
		"pathname",
		"port",
		"protocol",
		"query",
		"search",
		"hash"
	];
	var events = [
		"abort",
		"aborted",
		"connect",
		"error",
		"socket",
		"timeout"
	];
	var eventHandlers = Object.create(null);
	events.forEach(function(event) {
		eventHandlers[event] = function(arg1, arg2, arg3) {
			this._redirectable.emit(event, arg1, arg2, arg3);
		};
	});
	var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
	var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
	var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded", RedirectionError);
	var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
	var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
	// istanbul ignore next
	var destroy = Writable.prototype.destroy || noop$1;
	function RedirectableRequest(options$1, responseCallback) {
		Writable.call(this);
		this._sanitizeOptions(options$1);
		this._options = options$1;
		this._ended = false;
		this._ending = false;
		this._redirectCount = 0;
		this._redirects = [];
		this._requestBodyLength = 0;
		this._requestBodyBuffers = [];
		if (responseCallback) this.on("response", responseCallback);
		var self$1 = this;
		this._onNativeResponse = function(response) {
			try {
				self$1._processResponse(response);
			} catch (cause) {
				self$1.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
			}
		};
		this._performRequest();
	}
	RedirectableRequest.prototype = Object.create(Writable.prototype);
	RedirectableRequest.prototype.abort = function() {
		destroyRequest(this._currentRequest);
		this._currentRequest.abort();
		this.emit("abort");
	};
	RedirectableRequest.prototype.destroy = function(error$1) {
		destroyRequest(this._currentRequest, error$1);
		destroy.call(this, error$1);
		return this;
	};
	RedirectableRequest.prototype.write = function(data, encoding, callback) {
		if (this._ending) throw new WriteAfterEndError();
		if (!isString(data) && !isBuffer(data)) throw new TypeError("data should be a string, Buffer or Uint8Array");
		if (isFunction(encoding)) {
			callback = encoding;
			encoding = null;
		}
		if (data.length === 0) {
			if (callback) callback();
			return;
		}
		if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
			this._requestBodyLength += data.length;
			this._requestBodyBuffers.push({
				data,
				encoding
			});
			this._currentRequest.write(data, encoding, callback);
		} else {
			this.emit("error", new MaxBodyLengthExceededError());
			this.abort();
		}
	};
	RedirectableRequest.prototype.end = function(data, encoding, callback) {
		if (isFunction(data)) {
			callback = data;
			data = encoding = null;
		} else if (isFunction(encoding)) {
			callback = encoding;
			encoding = null;
		}
		if (!data) {
			this._ended = this._ending = true;
			this._currentRequest.end(null, null, callback);
		} else {
			var self$1 = this;
			var currentRequest = this._currentRequest;
			this.write(data, encoding, function() {
				self$1._ended = true;
				currentRequest.end(null, null, callback);
			});
			this._ending = true;
		}
	};
	RedirectableRequest.prototype.setHeader = function(name, value$1) {
		this._options.headers[name] = value$1;
		this._currentRequest.setHeader(name, value$1);
	};
	RedirectableRequest.prototype.removeHeader = function(name) {
		delete this._options.headers[name];
		this._currentRequest.removeHeader(name);
	};
	RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
		var self$1 = this;
		function destroyOnTimeout(socket) {
			socket.setTimeout(msecs);
			socket.removeListener("timeout", socket.destroy);
			socket.addListener("timeout", socket.destroy);
		}
		function startTimer(socket) {
			if (self$1._timeout) clearTimeout(self$1._timeout);
			self$1._timeout = setTimeout(function() {
				self$1.emit("timeout");
				clearTimer();
			}, msecs);
			destroyOnTimeout(socket);
		}
		function clearTimer() {
			if (self$1._timeout) {
				clearTimeout(self$1._timeout);
				self$1._timeout = null;
			}
			self$1.removeListener("abort", clearTimer);
			self$1.removeListener("error", clearTimer);
			self$1.removeListener("response", clearTimer);
			self$1.removeListener("close", clearTimer);
			if (callback) self$1.removeListener("timeout", callback);
			if (!self$1.socket) self$1._currentRequest.removeListener("socket", startTimer);
		}
		if (callback) this.on("timeout", callback);
		if (this.socket) startTimer(this.socket);
		else this._currentRequest.once("socket", startTimer);
		this.on("socket", destroyOnTimeout);
		this.on("abort", clearTimer);
		this.on("error", clearTimer);
		this.on("response", clearTimer);
		this.on("close", clearTimer);
		return this;
	};
	[
		"flushHeaders",
		"getHeader",
		"setNoDelay",
		"setSocketKeepAlive"
	].forEach(function(method) {
		RedirectableRequest.prototype[method] = function(a, b) {
			return this._currentRequest[method](a, b);
		};
	});
	[
		"aborted",
		"connection",
		"socket"
	].forEach(function(property) {
		Object.defineProperty(RedirectableRequest.prototype, property, { get: function() {
			return this._currentRequest[property];
		} });
	});
	RedirectableRequest.prototype._sanitizeOptions = function(options$1) {
		if (!options$1.headers) options$1.headers = {};
		if (options$1.host) {
			if (!options$1.hostname) options$1.hostname = options$1.host;
			delete options$1.host;
		}
		if (!options$1.pathname && options$1.path) {
			var searchPos = options$1.path.indexOf("?");
			if (searchPos < 0) options$1.pathname = options$1.path;
			else {
				options$1.pathname = options$1.path.substring(0, searchPos);
				options$1.search = options$1.path.substring(searchPos);
			}
		}
	};
	RedirectableRequest.prototype._performRequest = function() {
		var protocol = this._options.protocol;
		var nativeProtocol = this._options.nativeProtocols[protocol];
		if (!nativeProtocol) throw new TypeError("Unsupported protocol " + protocol);
		if (this._options.agents) {
			var scheme = protocol.slice(0, -1);
			this._options.agent = this._options.agents[scheme];
		}
		var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
		request._redirectable = this;
		for (var event of events) request.on(event, eventHandlers[event]);
		this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : this._options.path;
		if (this._isRedirect) {
			var i$1 = 0;
			var self$1 = this;
			var buffers = this._requestBodyBuffers;
			(function writeNext(error$1) {
				// istanbul ignore else
				if (request === self$1._currentRequest) {
					// istanbul ignore if
					if (error$1) self$1.emit("error", error$1);
					else if (i$1 < buffers.length) {
						var buffer = buffers[i$1++];
						// istanbul ignore else
						if (!request.finished) request.write(buffer.data, buffer.encoding, writeNext);
					} else if (self$1._ended) request.end();
				}
			})();
		}
	};
	RedirectableRequest.prototype._processResponse = function(response) {
		var statusCode = response.statusCode;
		if (this._options.trackRedirects) this._redirects.push({
			url: this._currentUrl,
			headers: response.headers,
			statusCode
		});
		var location$1 = response.headers.location;
		if (!location$1 || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
			response.responseUrl = this._currentUrl;
			response.redirects = this._redirects;
			this.emit("response", response);
			this._requestBodyBuffers = [];
			return;
		}
		destroyRequest(this._currentRequest);
		response.destroy();
		if (++this._redirectCount > this._options.maxRedirects) throw new TooManyRedirectsError();
		var requestHeaders;
		var beforeRedirect = this._options.beforeRedirect;
		if (beforeRedirect) requestHeaders = Object.assign({ Host: response.req.getHeader("host") }, this._options.headers);
		var method = this._options.method;
		if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
			this._options.method = "GET";
			this._requestBodyBuffers = [];
			removeMatchingHeaders(/^content-/i, this._options.headers);
		}
		var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
		var currentUrlParts = parseUrl(this._currentUrl);
		var currentHost = currentHostHeader || currentUrlParts.host;
		var currentUrl = /^\w+:/.test(location$1) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
		var redirectUrl = resolveUrl(location$1, currentUrl);
		debug$6("redirecting to", redirectUrl.href);
		this._isRedirect = true;
		spreadUrlObject(redirectUrl, this._options);
		if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
		if (isFunction(beforeRedirect)) {
			beforeRedirect(this._options, {
				headers: response.headers,
				statusCode
			}, {
				url: currentUrl,
				method,
				headers: requestHeaders
			});
			this._sanitizeOptions(this._options);
		}
		this._performRequest();
	};
	function wrap(protocols) {
		var exports$1 = {
			maxRedirects: 21,
			maxBodyLength: 10 * 1024 * 1024
		};
		var nativeProtocols = {};
		Object.keys(protocols).forEach(function(scheme) {
			var protocol = scheme + ":";
			var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
			var wrappedProtocol = exports$1[scheme] = Object.create(nativeProtocol);
			function request(input, options$1, callback) {
				if (isURL(input)) input = spreadUrlObject(input);
				else if (isString(input)) input = spreadUrlObject(parseUrl(input));
				else {
					callback = options$1;
					options$1 = validateUrl(input);
					input = { protocol };
				}
				if (isFunction(options$1)) {
					callback = options$1;
					options$1 = null;
				}
				options$1 = Object.assign({
					maxRedirects: exports$1.maxRedirects,
					maxBodyLength: exports$1.maxBodyLength
				}, input, options$1);
				options$1.nativeProtocols = nativeProtocols;
				if (!isString(options$1.host) && !isString(options$1.hostname)) options$1.hostname = "::1";
				assert$1.equal(options$1.protocol, protocol, "protocol mismatch");
				debug$6("options", options$1);
				return new RedirectableRequest(options$1, callback);
			}
			function get$3(input, options$1, callback) {
				var wrappedRequest = wrappedProtocol.request(input, options$1, callback);
				wrappedRequest.end();
				return wrappedRequest;
			}
			Object.defineProperties(wrappedProtocol, {
				request: {
					value: request,
					configurable: true,
					enumerable: true,
					writable: true
				},
				get: {
					value: get$3,
					configurable: true,
					enumerable: true,
					writable: true
				}
			});
		});
		return exports$1;
	}
	function noop$1() {}
	function parseUrl(input) {
		var parsed;
		// istanbul ignore else
		if (useNativeURL) parsed = new URL$2(input);
		else {
			parsed = validateUrl(url.parse(input));
			if (!isString(parsed.protocol)) throw new InvalidUrlError({ input });
		}
		return parsed;
	}
	function resolveUrl(relative$3, base) {
		// istanbul ignore next
		return useNativeURL ? new URL$2(relative$3, base) : parseUrl(url.resolve(base, relative$3));
	}
	function validateUrl(input) {
		if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) throw new InvalidUrlError({ input: input.href || input });
		if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) throw new InvalidUrlError({ input: input.href || input });
		return input;
	}
	function spreadUrlObject(urlObject, target) {
		var spread = target || {};
		for (var key of preservedUrlFields) spread[key] = urlObject[key];
		if (spread.hostname.startsWith("[")) spread.hostname = spread.hostname.slice(1, -1);
		if (spread.port !== "") spread.port = Number(spread.port);
		spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
		return spread;
	}
	function removeMatchingHeaders(regex, headers) {
		var lastValue;
		for (var header in headers) if (regex.test(header)) {
			lastValue = headers[header];
			delete headers[header];
		}
		return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
	}
	function createErrorType(code, message, baseClass) {
		function CustomError(properties) {
			// istanbul ignore else
			if (isFunction(Error.captureStackTrace)) Error.captureStackTrace(this, this.constructor);
			Object.assign(this, properties || {});
			this.code = code;
			this.message = this.cause ? message + ": " + this.cause.message : message;
		}
		CustomError.prototype = new (baseClass || Error)();
		Object.defineProperties(CustomError.prototype, {
			constructor: {
				value: CustomError,
				enumerable: false
			},
			name: {
				value: "Error [" + code + "]",
				enumerable: false
			}
		});
		return CustomError;
	}
	function destroyRequest(request, error$1) {
		for (var event of events) request.removeListener(event, eventHandlers[event]);
		request.on("error", noop$1);
		request.destroy(error$1);
	}
	function isSubdomain(subdomain, domain) {
		assert$1(isString(subdomain) && isString(domain));
		var dot = subdomain.length - domain.length - 1;
		return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
	}
	function isString(value$1) {
		return typeof value$1 === "string" || value$1 instanceof String;
	}
	function isFunction(value$1) {
		return typeof value$1 === "function";
	}
	function isBuffer(value$1) {
		return typeof value$1 === "object" && "length" in value$1;
	}
	function isURL(value$1) {
		return URL$2 && value$1 instanceof URL$2;
	}
	module.exports = wrap({
		http: http$3,
		https: https$2
	});
	module.exports.wrap = wrap;
}) });

//#endregion
//#region ../../node_modules/.pnpm/http-proxy-3@1.22.0/node_modules/http-proxy-3/dist/lib/http-proxy/passes/web-incoming.js
var require_web_incoming = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/http-proxy-3@1.22.0/node_modules/http-proxy-3/dist/lib/http-proxy/passes/web-incoming.js": ((exports) => {
	var __createBinding$2 = exports && exports.__createBinding || (Object.create ? (function(o$1, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$2[k];
	}));
	var __setModuleDefault$2 = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar$2 = exports && exports.__importStar || (function() {
		var ownKeys = function(o$1) {
			ownKeys = Object.getOwnPropertyNames || function(o$2) {
				var ar = [];
				for (var k in o$2) if (Object.prototype.hasOwnProperty.call(o$2, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys(o$1);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys(mod), i$1 = 0; i$1 < k.length; i$1++) if (k[i$1] !== "default") __createBinding$2(result, mod, k[i$1]);
			}
			__setModuleDefault$2(result, mod);
			return result;
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.deleteLength = deleteLength;
	exports.timeout = timeout;
	exports.XHeaders = XHeaders$1;
	exports.stream = stream$1;
	const http$2 = __importStar$2(__require("node:http"));
	const https$1 = __importStar$2(__require("node:https"));
	const web_outgoing_1$1 = require_web_outgoing();
	const common$1 = __importStar$2(require_common());
	const followRedirects = __importStar$2(require_follow_redirects());
	const web_o$1 = Object.values(web_outgoing_1$1.OUTGOING_PASSES);
	const nativeAgents = {
		http: http$2,
		https: https$1
	};
	function deleteLength(req$4) {
		if ((req$4.method === "DELETE" || req$4.method === "OPTIONS") && !req$4.headers["content-length"]) {
			req$4.headers["content-length"] = "0";
			delete req$4.headers["transfer-encoding"];
		}
	}
	function timeout(req$4, _res, options$1) {
		if (options$1.timeout) req$4.socket.setTimeout(options$1.timeout);
	}
	function XHeaders$1(req$4, _res, options$1) {
		if (!options$1.xfwd) return;
		const encrypted = common$1.hasEncryptedConnection(req$4);
		const values = {
			for: req$4.connection.remoteAddress || req$4.socket.remoteAddress,
			port: common$1.getPort(req$4),
			proto: encrypted ? "https" : "http"
		};
		for (const header of [
			"for",
			"port",
			"proto"
		]) req$4.headers["x-forwarded-" + header] = (req$4.headers["x-forwarded-" + header] || "") + (req$4.headers["x-forwarded-" + header] ? "," : "") + values[header];
		req$4.headers["x-forwarded-host"] = req$4.headers["x-forwarded-host"] || req$4.headers["host"] || "";
	}
	function stream$1(req$4, res, options$1, _, server, cb) {
		server.emit("start", req$4, res, options$1.target || options$1.forward);
		const agents = options$1.followRedirects ? followRedirects : nativeAgents;
		const http$7 = agents.http;
		const https$4 = agents.https;
		if (options$1.forward) {
			const proto$2 = options$1.forward.protocol === "https:" ? https$4 : http$7;
			const outgoingOptions$1 = common$1.setupOutgoing(options$1.ssl || {}, options$1, req$4, "forward");
			const forwardReq = proto$2.request(outgoingOptions$1);
			const forwardError = createErrorHandler(forwardReq, options$1.forward);
			req$4.on("error", forwardError);
			forwardReq.on("error", forwardError);
			(options$1.buffer || req$4).pipe(forwardReq);
			if (!options$1.target) return res.end();
		}
		const proto$1 = options$1.target.protocol === "https:" ? https$4 : http$7;
		const outgoingOptions = common$1.setupOutgoing(options$1.ssl || {}, options$1, req$4);
		const proxyReq = proto$1.request(outgoingOptions);
		proxyReq.on("socket", (socket) => {
			if (server && !proxyReq.getHeader("expect")) server.emit("proxyReq", proxyReq, req$4, res, options$1, socket);
		});
		if (options$1.proxyTimeout) proxyReq.setTimeout(options$1.proxyTimeout, () => {
			proxyReq.destroy();
		});
		res.on("close", () => {
			if (!res.writableFinished) proxyReq.destroy();
		});
		const proxyError = createErrorHandler(proxyReq, options$1.target);
		req$4.on("error", proxyError);
		proxyReq.on("error", proxyError);
		function createErrorHandler(proxyReq$1, url$3) {
			return (err$2) => {
				if (req$4.socket.destroyed && err$2.code === "ECONNRESET") {
					server.emit("econnreset", err$2, req$4, res, url$3);
					proxyReq$1.destroy();
					return;
				}
				if (cb) cb(err$2, req$4, res, url$3);
				else server.emit("error", err$2, req$4, res, url$3);
			};
		}
		(options$1.buffer || req$4).pipe(proxyReq);
		proxyReq.on("response", (proxyRes) => {
			server?.emit("proxyRes", proxyRes, req$4, res);
			if (!res.headersSent && !options$1.selfHandleResponse) for (const pass of web_o$1) pass(req$4, res, proxyRes, options$1);
			if (!res.finished) {
				proxyRes.on("end", () => {
					server?.emit("end", req$4, res, proxyRes);
				});
				if (!options$1.selfHandleResponse) proxyRes.pipe(res);
			} else server?.emit("end", req$4, res, proxyRes);
		});
	}
	exports.WEB_PASSES = {
		deleteLength,
		timeout,
		XHeaders: XHeaders$1,
		stream: stream$1
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/http-proxy-3@1.22.0/node_modules/http-proxy-3/dist/lib/http-proxy/passes/ws-incoming.js
var require_ws_incoming = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/http-proxy-3@1.22.0/node_modules/http-proxy-3/dist/lib/http-proxy/passes/ws-incoming.js": ((exports) => {
	var __createBinding$1 = exports && exports.__createBinding || (Object.create ? (function(o$1, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$2[k];
	}));
	var __setModuleDefault$1 = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar$1 = exports && exports.__importStar || (function() {
		var ownKeys = function(o$1) {
			ownKeys = Object.getOwnPropertyNames || function(o$2) {
				var ar = [];
				for (var k in o$2) if (Object.prototype.hasOwnProperty.call(o$2, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys(o$1);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys(mod), i$1 = 0; i$1 < k.length; i$1++) if (k[i$1] !== "default") __createBinding$1(result, mod, k[i$1]);
			}
			__setModuleDefault$1(result, mod);
			return result;
		};
	})();
	var __importDefault$1 = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.numOpenSockets = numOpenSockets;
	exports.checkMethodAndHeader = checkMethodAndHeader;
	exports.XHeaders = XHeaders;
	exports.stream = stream;
	const http$1 = __importStar$1(__require("node:http"));
	const https = __importStar$1(__require("node:https"));
	const common = __importStar$1(require_common());
	const web_outgoing_1 = require_web_outgoing();
	const log$1 = (0, __importDefault$1(require_node$1()).default)("http-proxy-3:ws-incoming");
	const web_o = Object.values(web_outgoing_1.OUTGOING_PASSES);
	function createSocketCounter(name) {
		let sockets = /* @__PURE__ */ new Set();
		return ({ add, rm } = {}) => {
			if (add) {
				if (!add.id) add.id = Math.random();
				if (!sockets.has(add.id)) sockets.add(add.id);
			}
			if (rm) {
				if (!rm.id) rm.id = Math.random();
				if (sockets.has(rm.id)) sockets.delete(rm.id);
			}
			log$1("socket counter:", { [name]: sockets.size }, add ? "add" : rm ? "rm" : "");
			return sockets.size;
		};
	}
	const socketCounter = createSocketCounter("socket");
	const proxySocketCounter = createSocketCounter("proxySocket");
	var MockResponse = class {
		constructor() {
			this.headers = {};
			this.statusCode = 200;
			this.statusMessage = "";
		}
		setHeader(key, value$1) {
			this.headers[key] = value$1;
			return this;
		}
	};
	function numOpenSockets() {
		return socketCounter() + proxySocketCounter();
	}
	function checkMethodAndHeader(req$4, socket) {
		log$1("websocket: checkMethodAndHeader");
		if (req$4.method !== "GET" || !req$4.headers.upgrade) {
			socket.destroy();
			return true;
		}
		if (req$4.headers.upgrade.toLowerCase() !== "websocket") {
			socket.destroy();
			return true;
		}
	}
	function XHeaders(req$4, _socket, options$1) {
		if (!options$1.xfwd) return;
		log$1("websocket: XHeaders");
		const values = {
			for: req$4.connection.remoteAddress || req$4.socket.remoteAddress,
			port: common.getPort(req$4),
			proto: common.hasEncryptedConnection(req$4) ? "wss" : "ws"
		};
		for (const header of [
			"for",
			"port",
			"proto"
		]) req$4.headers["x-forwarded-" + header] = (req$4.headers["x-forwarded-" + header] || "") + (req$4.headers["x-forwarded-" + header] ? "," : "") + values[header];
	}
	function stream(req$4, socket, options$1, head, server, cb) {
		log$1("websocket: new stream");
		const proxySockets = [];
		socketCounter({ add: socket });
		const cleanUpProxySockets = () => {
			for (const p of proxySockets) p.end();
		};
		socket.on("close", () => {
			socketCounter({ rm: socket });
			cleanUpProxySockets();
		});
		socket.on("error", cleanUpProxySockets);
		const createHttpHeader = (line, headers) => {
			return Object.keys(headers).reduce((head$1, key) => {
				const value$1 = headers[key];
				if (!Array.isArray(value$1)) {
					head$1.push(key + ": " + value$1);
					return head$1;
				}
				for (let i$1 = 0; i$1 < value$1.length; i$1++) head$1.push(key + ": " + value$1[i$1]);
				return head$1;
			}, [line]).join("\r\n") + "\r\n\r\n";
		};
		common.setupSocket(socket);
		if (head && head.length) socket.unshift(head);
		const proto$1 = common.isSSL.test(options$1.target.protocol) ? https : http$1;
		const outgoingOptions = common.setupOutgoing(options$1.ssl || {}, options$1, req$4);
		const proxyReq = proto$1.request(outgoingOptions);
		if (server) server.emit("proxyReqWs", proxyReq, req$4, socket, options$1, head);
		proxyReq.on("error", onOutgoingError);
		proxyReq.on("upgrade", (proxyRes, proxySocket, proxyHead) => {
			log$1("upgrade");
			proxySocketCounter({ add: proxySocket });
			proxySockets.push(proxySocket);
			proxySocket.on("close", () => {
				proxySocketCounter({ rm: proxySocket });
			});
			proxySocket.on("error", onOutgoingError);
			proxySocket.on("end", () => {
				server.emit("close", proxyRes, proxySocket, proxyHead);
			});
			proxySocket.on("close", () => {
				socket.end();
			});
			common.setupSocket(proxySocket);
			if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);
			socket.write(createHttpHeader("HTTP/1.1 101 Switching Protocols", proxyRes.headers));
			proxySocket.pipe(socket).pipe(proxySocket);
			server.emit("open", proxySocket);
		});
		function onOutgoingError(err$2) {
			if (cb) cb(err$2, req$4, socket);
			else server.emit("error", err$2, req$4, socket);
			socket.destroySoon();
		}
		proxyReq.on("response", (proxyRes) => {
			log$1("got non-ws HTTP response", {
				statusCode: proxyRes.statusCode,
				statusMessage: proxyRes.statusMessage
			});
			const res = new MockResponse();
			for (const pass of web_o) pass(req$4, res, proxyRes, options$1);
			let writeChunk = (chunk) => {
				socket.write(chunk);
			};
			if (req$4.httpVersion === "1.1" && proxyRes.headers["content-length"] === void 0) {
				res.headers["transfer-encoding"] = "chunked";
				writeChunk = (chunk) => {
					socket.write(chunk.length.toString(16));
					socket.write("\r\n");
					socket.write(chunk);
					socket.write("\r\n");
				};
			}
			const proxyHead = createHttpHeader(`HTTP/${req$4.httpVersion} ${proxyRes.statusCode} ${proxyRes.statusMessage}`, res.headers);
			if (!socket.destroyed) {
				socket.write(proxyHead);
				proxyRes.on("data", (chunk) => {
					writeChunk(chunk);
				});
				proxyRes.on("end", () => {
					writeChunk("");
					socket.destroySoon();
				});
			} else proxyRes.resume();
		});
		proxyReq.end();
	}
	exports.WS_PASSES = {
		checkMethodAndHeader,
		XHeaders,
		stream
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/http-proxy-3@1.22.0/node_modules/http-proxy-3/dist/lib/http-proxy/index.js
var require_http_proxy = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/http-proxy-3@1.22.0/node_modules/http-proxy-3/dist/lib/http-proxy/index.js": ((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m$2[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys = function(o$1) {
			ownKeys = Object.getOwnPropertyNames || function(o$2) {
				var ar = [];
				for (var k in o$2) if (Object.prototype.hasOwnProperty.call(o$2, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys(o$1);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys(mod), i$1 = 0; i$1 < k.length; i$1++) if (k[i$1] !== "default") __createBinding(result, mod, k[i$1]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	const http = __importStar(__require("node:http"));
	const http2 = __importStar(__require("node:http2"));
	const web_incoming_1 = require_web_incoming();
	const ws_incoming_1$1 = require_ws_incoming();
	const node_events_1 = __require("node:events");
	const debug_1 = __importDefault(require_node$1());
	const common_1 = require_common();
	const log = (0, debug_1.default)("http-proxy-3");
	var ProxyServer = class ProxyServer extends node_events_1.EventEmitter {
		/**
		* Creates the proxy server with specified options.
		* @param options - Config object passed to the proxy
		*/
		constructor(options$1 = {}) {
			super();
			this.createRightProxy = (type) => {
				log("createRightProxy", { type });
				return (options$2) => {
					return (...args) => {
						const req$4 = args[0];
						log("proxy: ", {
							type,
							path: req$4.url
						});
						const res = args[1];
						const passes = type === "ws" ? this.wsPasses : this.webPasses;
						if (type == "ws") res.on("error", (err$2) => {
							this.emit("error", err$2, req$4, res);
						});
						let counter = args.length - 1;
						let head;
						let cb;
						if (typeof args[counter] === "function") {
							cb = args[counter];
							counter--;
						}
						let requestOptions;
						if (!(args[counter] instanceof Buffer) && args[counter] !== res) {
							requestOptions = {
								...options$2,
								...args[counter]
							};
							counter--;
						} else requestOptions = { ...options$2 };
						if (args[counter] instanceof Buffer) head = args[counter];
						for (const e$1 of ["target", "forward"]) if (typeof requestOptions[e$1] === "string") requestOptions[e$1] = (0, common_1.toURL)(requestOptions[e$1]);
						if (!requestOptions.target && !requestOptions.forward) {
							this.emit("error", /* @__PURE__ */ new Error("Must set target or forward"), req$4, res);
							return;
						}
						for (const pass of passes)
 /**
						* Call of passes functions
						*     pass(req, res, options, head)
						*
						* In WebSockets case, the `res` variable
						* refer to the connection socket
						*    pass(req, socket, options, head)
						*/
						if (pass(req$4, res, requestOptions, head, this, cb)) break;
					};
				};
			};
			this.onError = (err$2) => {
				if (this.listeners("error").length === 1) throw err$2;
			};
			/**
			* A function that wraps the object in a webserver, for your convenience
			* @param port - Port to listen on
			* @param hostname - The hostname to listen on
			*/
			this.listen = (port, hostname) => {
				log("listen", {
					port,
					hostname
				});
				const requestListener = (req$4, res) => {
					this.web(req$4, res);
				};
				this._server = this.options.ssl ? http2.createSecureServer({
					...this.options.ssl,
					allowHTTP1: true
				}, requestListener) : http.createServer(requestListener);
				if (this.options.ws) this._server.on("upgrade", (req$4, socket, head) => {
					this.ws(req$4, socket, head);
				});
				this._server.listen(port, hostname);
				return this;
			};
			this.address = () => {
				return this._server?.address();
			};
			/**
			* A function that closes the inner webserver and stops listening on given port
			*/
			this.close = (cb) => {
				if (this._server == null) {
					cb?.();
					return;
				}
				this._server.close((err$2) => {
					this._server = null;
					cb?.(err$2);
				});
			};
			this.before = (type, passName, cb) => {
				if (type !== "ws" && type !== "web") throw new Error("type must be `web` or `ws`");
				const passes = type === "ws" ? this.wsPasses : this.webPasses;
				let i$1 = false;
				passes.forEach((v, idx) => {
					if (v.name === passName) i$1 = idx;
				});
				if (i$1 === false) throw new Error("No such pass");
				passes.splice(i$1, 0, cb);
			};
			this.after = (type, passName, cb) => {
				if (type !== "ws" && type !== "web") throw new Error("type must be `web` or `ws`");
				const passes = type === "ws" ? this.wsPasses : this.webPasses;
				let i$1 = false;
				passes.forEach((v, idx) => {
					if (v.name === passName) i$1 = idx;
				});
				if (i$1 === false) throw new Error("No such pass");
				passes.splice(i$1++, 0, cb);
			};
			log("creating a ProxyServer", options$1);
			options$1.prependPath = options$1.prependPath === false ? false : true;
			this.options = options$1;
			this.web = this.createRightProxy("web")(options$1);
			this.ws = this.createRightProxy("ws")(options$1);
			this.webPasses = Object.values(web_incoming_1.WEB_PASSES);
			this.wsPasses = Object.values(ws_incoming_1$1.WS_PASSES);
			this.on("error", this.onError);
		}
		/**
		* Creates the proxy server with specified options.
		* @param options Config object passed to the proxy
		* @returns Proxy object with handlers for `ws` and `web` requests
		*/
		static createProxyServer(options$1) {
			return new ProxyServer(options$1);
		}
		/**
		* Creates the proxy server with specified options.
		* @param options Config object passed to the proxy
		* @returns Proxy object with handlers for `ws` and `web` requests
		*/
		static createServer(options$1) {
			return new ProxyServer(options$1);
		}
		/**
		* Creates the proxy server with specified options.
		* @param options Config object passed to the proxy
		* @returns Proxy object with handlers for `ws` and `web` requests
		*/
		static createProxy(options$1) {
			return new ProxyServer(options$1);
		}
	};
	exports.ProxyServer = ProxyServer;
}) });

//#endregion
//#region ../../node_modules/.pnpm/http-proxy-3@1.22.0/node_modules/http-proxy-3/dist/lib/index.js
var require_lib = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/http-proxy-3@1.22.0/node_modules/http-proxy-3/dist/lib/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.numOpenSockets = exports.ProxyServer = void 0;
	exports.createProxyServer = createProxyServer;
	const index_1 = require_http_proxy();
	Object.defineProperty(exports, "ProxyServer", {
		enumerable: true,
		get: function() {
			return index_1.ProxyServer;
		}
	});
	var ws_incoming_1 = require_ws_incoming();
	Object.defineProperty(exports, "numOpenSockets", {
		enumerable: true,
		get: function() {
			return ws_incoming_1.numOpenSockets;
		}
	});
	/**
	* Creates the proxy server.
	*
	* Examples:
	*
	*    httpProxy.createProxyServer({ .. }, 8000)
	*    // => '{ web: [Function], ws: [Function] ... }'
	*
	* @param {Object} Options Config object passed to the proxy
	*
	* @return {Object} Proxy Proxy object with handlers for `ws` and `web` requests
	*
	* @api public
	*/
	function createProxyServer(options$1 = {}) {
		return new index_1.ProxyServer(options$1);
	}
}) });

//#endregion
//#region src/node/server/middlewares/proxy.ts
var import_lib$2 = /* @__PURE__ */ __toESM(require_lib(), 1);
var import_picocolors$15 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const debug$5 = createDebugger("vite:proxy");
const rewriteOriginHeader = (proxyReq, options$1, config$2) => {
	if (options$1.rewriteWsOrigin) {
		const { target } = options$1;
		if (proxyReq.headersSent) {
			config$2.logger.warn(import_picocolors$15.default.yellow(`Unable to rewrite Origin header as headers are already sent.`));
			return;
		}
		if (proxyReq.getHeader("origin") && target) {
			const changedOrigin = typeof target === "object" ? `${target.protocol ?? "http:"}//${target.host}` : target;
			proxyReq.setHeader("origin", changedOrigin);
		}
	}
};
function proxyMiddleware(httpServer, options$1, config$2) {
	const proxies = {};
	Object.keys(options$1).forEach((context) => {
		let opts = options$1[context];
		if (!opts) return;
		if (typeof opts === "string") opts = {
			target: opts,
			changeOrigin: true
		};
		const proxy = import_lib$2.createProxyServer(opts);
		if (opts.configure) opts.configure(proxy, opts);
		proxy.on("error", (err$2, _req, res) => {
			if ("req" in res) {
				config$2.logger.error(`${import_picocolors$15.default.red(`http proxy error: ${res.req.url}`)}\n${err$2.stack}`, {
					timestamp: true,
					error: err$2
				});
				if (!res.headersSent && !res.writableEnded) res.writeHead(500, { "Content-Type": "text/plain" }).end();
			} else {
				config$2.logger.error(`${import_picocolors$15.default.red(`ws proxy error:`)}\n${err$2.stack}`, {
					timestamp: true,
					error: err$2
				});
				res.end();
			}
		});
		proxy.on("proxyReqWs", (proxyReq, _req, socket, options$2) => {
			rewriteOriginHeader(proxyReq, options$2, config$2);
			socket.on("error", (err$2) => {
				config$2.logger.error(`${import_picocolors$15.default.red(`ws proxy socket error:`)}\n${err$2.stack}`, {
					timestamp: true,
					error: err$2
				});
			});
		});
		proxies[context] = [proxy, { ...opts }];
	});
	if (httpServer) httpServer.on("upgrade", async (req$4, socket, head) => {
		const url$3 = req$4.url;
		for (const context in proxies) if (doesProxyContextMatchUrl(context, url$3)) {
			const [proxy, opts] = proxies[context];
			if (opts.ws || opts.target?.toString().startsWith("ws:") || opts.target?.toString().startsWith("wss:")) {
				if (opts.bypass) try {
					const bypassResult = await opts.bypass(req$4, void 0, opts);
					if (typeof bypassResult === "string") {
						debug$5?.(`bypass: ${req$4.url} -> ${bypassResult}`);
						req$4.url = bypassResult;
						return;
					}
					if (bypassResult === false) {
						debug$5?.(`bypass: ${req$4.url} -> 404`);
						socket.end("HTTP/1.1 404 Not Found\r\n\r\n", "");
						return;
					}
				} catch (err$2) {
					config$2.logger.error(`${import_picocolors$15.default.red(`ws proxy bypass error:`)}\n${err$2.stack}`, {
						timestamp: true,
						error: err$2
					});
					return;
				}
				if (opts.rewrite) req$4.url = opts.rewrite(url$3);
				debug$5?.(`${req$4.url} -> ws ${opts.target}`);
				proxy.ws(req$4, socket, head);
				return;
			}
		}
	});
	return async function viteProxyMiddleware(req$4, res, next) {
		const url$3 = req$4.url;
		for (const context in proxies) if (doesProxyContextMatchUrl(context, url$3)) {
			const [proxy, opts] = proxies[context];
			const options$2 = {};
			if (opts.bypass) try {
				const bypassResult = await opts.bypass(req$4, res, opts);
				if (typeof bypassResult === "string") {
					debug$5?.(`bypass: ${req$4.url} -> ${bypassResult}`);
					req$4.url = bypassResult;
					if (res.writableEnded) return;
					return next();
				}
				if (bypassResult === false) {
					debug$5?.(`bypass: ${req$4.url} -> 404`);
					res.statusCode = 404;
					return res.end();
				}
			} catch (e$1) {
				debug$5?.(`bypass: ${req$4.url} -> ${e$1}`);
				return next(e$1);
			}
			debug$5?.(`${req$4.url} -> ${opts.target || opts.forward}`);
			if (opts.rewrite) req$4.url = opts.rewrite(req$4.url);
			proxy.web(req$4, res, options$2);
			return;
		}
		next();
	};
}
function doesProxyContextMatchUrl(context, url$3) {
	return context[0] === "^" && new RegExp(context).test(url$3) || url$3.startsWith(context);
}

//#endregion
//#region src/node/server/middlewares/htmlFallback.ts
const debug$4 = createDebugger("vite:html-fallback");
function htmlFallbackMiddleware(root, spaFallback) {
	return function viteHtmlFallbackMiddleware(req$4, _res, next) {
		if (req$4.method !== "GET" && req$4.method !== "HEAD" || req$4.url === "/favicon.ico" || !(req$4.headers.accept === void 0 || req$4.headers.accept === "" || req$4.headers.accept.includes("text/html") || req$4.headers.accept.includes("*/*"))) return next();
		const url$3 = cleanUrl(req$4.url);
		let pathname;
		try {
			pathname = decodeURIComponent(url$3);
		} catch {
			return next();
		}
		if (pathname.endsWith(".html")) {
			const filePath = path.join(root, pathname);
			if (fs.existsSync(filePath)) {
				debug$4?.(`Rewriting ${req$4.method} ${req$4.url} to ${url$3}`);
				req$4.url = url$3;
				return next();
			}
		} else if (pathname.endsWith("/")) {
			const filePath = path.join(root, pathname, "index.html");
			if (fs.existsSync(filePath)) {
				const newUrl = url$3 + "index.html";
				debug$4?.(`Rewriting ${req$4.method} ${req$4.url} to ${newUrl}`);
				req$4.url = newUrl;
				return next();
			}
		} else {
			const filePath = path.join(root, pathname + ".html");
			if (fs.existsSync(filePath)) {
				const newUrl = url$3 + ".html";
				debug$4?.(`Rewriting ${req$4.method} ${req$4.url} to ${newUrl}`);
				req$4.url = newUrl;
				return next();
			}
		}
		if (spaFallback) {
			debug$4?.(`Rewriting ${req$4.method} ${req$4.url} to /index.html`);
			req$4.url = "/index.html";
		}
		next();
	};
}

//#endregion
//#region ../../node_modules/.pnpm/etag@1.8.1/node_modules/etag/index.js
var require_etag = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/etag@1.8.1/node_modules/etag/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = etag;
	/**
	* Module dependencies.
	* @private
	*/
	var crypto$1 = __require("crypto");
	var Stats = __require("fs").Stats;
	/**
	* Module variables.
	* @private
	*/
	var toString = Object.prototype.toString;
	/**
	* Generate an entity tag.
	*
	* @param {Buffer|string} entity
	* @return {string}
	* @private
	*/
	function entitytag(entity) {
		if (entity.length === 0) return "\"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk\"";
		var hash$1 = crypto$1.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
		return "\"" + (typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length).toString(16) + "-" + hash$1 + "\"";
	}
	/**
	* Create a simple ETag.
	*
	* @param {string|Buffer|Stats} entity
	* @param {object} [options]
	* @param {boolean} [options.weak]
	* @return {String}
	* @public
	*/
	function etag(entity, options$1) {
		if (entity == null) throw new TypeError("argument entity is required");
		var isStats = isstats(entity);
		var weak = options$1 && typeof options$1.weak === "boolean" ? options$1.weak : isStats;
		if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
		var tag = isStats ? stattag(entity) : entitytag(entity);
		return weak ? "W/" + tag : tag;
	}
	/**
	* Determine if object is a Stats object.
	*
	* @param {object} obj
	* @return {boolean}
	* @api private
	*/
	function isstats(obj) {
		if (typeof Stats === "function" && obj instanceof Stats) return true;
		return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
	}
	/**
	* Generate a tag for a stat.
	*
	* @param {object} stat
	* @return {string}
	* @private
	*/
	function stattag(stat$4) {
		var mtime = stat$4.mtime.getTime().toString(16);
		return "\"" + stat$4.size.toString(16) + "-" + mtime + "\"";
	}
}) });

//#endregion
//#region src/node/server/send.ts
var import_convert_source_map$1 = /* @__PURE__ */ __toESM(require_convert_source_map(), 1);
var import_etag$1 = /* @__PURE__ */ __toESM(require_etag(), 1);
const debug$3 = createDebugger("vite:send", { onlyWhenFocused: true });
const alias$1 = {
	js: "text/javascript",
	css: "text/css",
	html: "text/html",
	json: "application/json"
};
function send(req$4, res, content, type, options$1) {
	const { etag: etag$1 = (0, import_etag$1.default)(content, { weak: true }), cacheControl = "no-cache", headers, map: map$1 } = options$1;
	if (res.writableEnded) return;
	if (req$4.headers["if-none-match"] === etag$1) {
		res.statusCode = 304;
		res.end();
		return;
	}
	res.setHeader("Content-Type", alias$1[type] || type);
	res.setHeader("Cache-Control", cacheControl);
	res.setHeader("Etag", etag$1);
	if (headers) for (const name in headers) res.setHeader(name, headers[name]);
	if (map$1 && "version" in map$1 && map$1.mappings) {
		if (type === "js" || type === "css") content = getCodeWithSourcemap(type, content.toString(), map$1);
	} else if (type === "js" && (!map$1 || map$1.mappings !== "")) {
		const code = content.toString();
		if (import_convert_source_map$1.default.mapFileCommentRegex.test(code)) debug$3?.(`Skipped injecting fallback sourcemap for ${req$4.url}`);
		else {
			const urlWithoutTimestamp = removeTimestampQuery(req$4.url);
			content = getCodeWithSourcemap(type, code, new MagicString(code).generateMap({
				source: path.basename(urlWithoutTimestamp),
				hires: "boundary",
				includeContent: true
			}));
		}
	}
	res.statusCode = 200;
	if (req$4.method === "HEAD") res.end();
	else res.end(content);
}

//#endregion
//#region ../../node_modules/.pnpm/totalist@3.0.1/node_modules/totalist/sync/index.mjs
function totalist(dir, callback, pre = "") {
	dir = resolve$1(".", dir);
	let arr = readdirSync(dir);
	let i$1 = 0, abs, stats;
	for (; i$1 < arr.length; i$1++) {
		abs = join$1(dir, arr[i$1]);
		stats = statSync(abs);
		stats.isDirectory() ? totalist(abs, callback, join$1(pre, arr[i$1])) : callback(join$1(pre, arr[i$1]), abs, stats);
	}
}

//#endregion
//#region ../../node_modules/.pnpm/@polka+url@1.0.0-next.28/node_modules/@polka/url/build.mjs
/**
* @typedef ParsedURL
* @type {import('.').ParsedURL}
*/
/**
* @typedef Request
* @property {string} url
* @property {ParsedURL} _parsedUrl
*/
/**
* @param {Request} req
* @returns {ParsedURL|void}
*/
function parse$1(req$4) {
	let raw = req$4.url;
	if (raw == null) return;
	let prev = req$4._parsedUrl;
	if (prev && prev.raw === raw) return prev;
	let pathname = raw, search = "", query;
	if (raw.length > 1) {
		let idx = raw.indexOf("?", 1);
		if (idx !== -1) {
			search = raw.substring(idx);
			pathname = raw.substring(0, idx);
			if (search.length > 1) query = qs.parse(search.substring(1));
		}
	}
	return req$4._parsedUrl = {
		pathname,
		search,
		query,
		raw
	};
}

//#endregion
//#region ../../node_modules/.pnpm/sirv@3.0.2_patch_hash=c07c56eb72faea34341d465cde2314e89db472106ed378181e3447893af6bf95/node_modules/sirv/build.mjs
const noop = () => {};
function isMatch(uri, arr) {
	for (let i$1 = 0; i$1 < arr.length; i$1++) if (arr[i$1].test(uri)) return true;
}
function toAssume(uri, extns) {
	let i$1 = 0, x, len = uri.length - 1;
	if (uri.charCodeAt(len) === 47) uri = uri.substring(0, len);
	let arr = [], tmp = `${uri}/index`;
	for (; i$1 < extns.length; i$1++) {
		x = extns[i$1] ? `.${extns[i$1]}` : "";
		if (uri) arr.push(uri + x);
		arr.push(tmp + x);
	}
	return arr;
}
function viaCache(cache$1, uri, extns) {
	let i$1 = 0, data, arr = toAssume(uri, extns);
	for (; i$1 < arr.length; i$1++) if (data = cache$1[arr[i$1]]) return data;
}
function viaLocal(dir, isEtag, uri, extns, shouldServe) {
	let i$1 = 0, arr = toAssume(uri, extns);
	let abs, stats, name, headers;
	for (; i$1 < arr.length; i$1++) {
		abs = normalize(join(dir, name = arr[i$1]));
		if (abs.startsWith(dir) && fs$1.existsSync(abs)) {
			stats = fs$1.statSync(abs);
			if (stats.isDirectory()) continue;
			if (shouldServe && !shouldServe(abs)) continue;
			headers = toHeaders(name, stats, isEtag);
			headers["Cache-Control"] = isEtag ? "no-cache" : "no-store";
			return {
				abs,
				stats,
				headers
			};
		}
	}
}
function is404(req$4, res) {
	return res.statusCode = 404, res.end();
}
function send$1(req$4, res, file, stats, headers) {
	let code = 200, tmp, opts = {};
	headers = { ...headers };
	for (let key in headers) {
		tmp = res.getHeader(key);
		if (tmp) headers[key] = tmp;
	}
	if (tmp = res.getHeader("content-type")) headers["Content-Type"] = tmp;
	if (req$4.headers.range) {
		code = 206;
		let [x, y$2] = req$4.headers.range.replace("bytes=", "").split("-");
		let end = opts.end = parseInt(y$2, 10) || stats.size - 1;
		let start = opts.start = parseInt(x, 10) || 0;
		if (end >= stats.size) end = stats.size - 1;
		if (start >= stats.size) {
			res.setHeader("Content-Range", `bytes */${stats.size}`);
			res.statusCode = 416;
			return res.end();
		}
		headers["Content-Range"] = `bytes ${start}-${end}/${stats.size}`;
		headers["Content-Length"] = end - start + 1;
		headers["Accept-Ranges"] = "bytes";
	}
	res.writeHead(code, headers);
	fs$1.createReadStream(file, opts).pipe(res);
}
const ENCODING = {
	".br": "br",
	".gz": "gzip"
};
function toHeaders(name, stats, isEtag) {
	let enc = ENCODING[name.slice(-3)];
	let ctype = lookup(name.slice(0, enc && -3)) || "";
	if (ctype === "text/html") ctype += ";charset=utf-8";
	let headers = {
		"Content-Length": stats.size,
		"Content-Type": ctype,
		"Last-Modified": stats.mtime.toUTCString()
	};
	if (enc) headers["Content-Encoding"] = enc;
	if (isEtag) headers["ETag"] = `W/"${stats.size}-${stats.mtime.getTime()}"`;
	return headers;
}
function build_default(dir, opts = {}) {
	dir = resolve(dir || ".");
	let isNotFound = opts.onNoMatch || is404;
	let setHeaders$1 = opts.setHeaders || noop;
	let extensions$1 = opts.extensions || ["html", "htm"];
	let gzips = opts.gzip && extensions$1.map((x) => `${x}.gz`).concat("gz");
	let brots = opts.brotli && extensions$1.map((x) => `${x}.br`).concat("br");
	const FILES = {};
	let fallback = "/";
	let isEtag = !!opts.etag;
	let isSPA = !!opts.single;
	if (typeof opts.single === "string") {
		let idx = opts.single.lastIndexOf(".");
		fallback += !!~idx ? opts.single.substring(0, idx) : opts.single;
	}
	let ignores = [];
	if (opts.ignores !== false) {
		ignores.push(/[/]([A-Za-z\s\d~$._-]+\.\w+){1,}$/);
		if (opts.dotfiles) ignores.push(/\/\.\w/);
		else ignores.push(/\/\.well-known/);
		[].concat(opts.ignores || []).forEach((x) => {
			ignores.push(new RegExp(x, "i"));
		});
	}
	let cc = opts.maxAge != null && `public,max-age=${opts.maxAge}`;
	if (cc && opts.immutable) cc += ",immutable";
	else if (cc && opts.maxAge === 0) cc += ",must-revalidate";
	if (!opts.dev) totalist(dir, (name, abs, stats) => {
		if (/\.well-known[\\+\/]/.test(name)) {} else if (!opts.dotfiles && /(^\.|[\\+|\/+]\.)/.test(name)) return;
		let headers = toHeaders(name, stats, isEtag);
		if (cc) headers["Cache-Control"] = cc;
		FILES["/" + name.normalize().replace(/\\+/g, "/")] = {
			abs,
			stats,
			headers
		};
	});
	let lookup$1 = opts.dev ? viaLocal.bind(0, dir.endsWith(sep) ? dir : dir + sep, isEtag) : viaCache.bind(0, FILES);
	return function(req$4, res, next) {
		let extns = [""];
		let pathname = parse$1(req$4).pathname;
		let val = req$4.headers["accept-encoding"] || "";
		if (gzips && val.includes("gzip")) extns.unshift(...gzips);
		if (brots && /(br|brotli)/i.test(val)) extns.unshift(...brots);
		extns.push(...extensions$1);
		if (pathname.indexOf("%") !== -1) try {
			pathname = decodeURI(pathname);
		} catch (err$2) {}
		let data = lookup$1(pathname, extns, opts.shouldServe) || isSPA && !isMatch(pathname, ignores) && lookup$1(fallback, extns, opts.shouldServe);
		if (!data) return next ? next() : isNotFound(req$4, res);
		if (isEtag && req$4.headers["if-none-match"] === data.headers["ETag"]) {
			res.writeHead(304);
			return res.end();
		}
		if (gzips || brots) res.setHeader("Vary", "Accept-Encoding");
		setHeaders$1(res, pathname, data.stats);
		send$1(req$4, res, data.abs, data.stats, data.headers);
	};
}

//#endregion
//#region src/node/server/middlewares/static.ts
var import_escape_html$1 = /* @__PURE__ */ __toESM(require_escape_html(), 1);
const knownJavascriptExtensionRE = /\.(?:[tj]sx?|[cm][tj]s)$/;
const ERR_DENIED_FILE = "ERR_DENIED_FILE";
const sirvOptions = ({ config: config$2, getHeaders, disableFsServeCheck }) => {
	return {
		dev: true,
		etag: true,
		extensions: [],
		setHeaders(res, pathname) {
			if (knownJavascriptExtensionRE.test(pathname)) res.setHeader("Content-Type", "text/javascript");
			const headers = getHeaders();
			if (headers) for (const name in headers) res.setHeader(name, headers[name]);
		},
		shouldServe: disableFsServeCheck ? void 0 : (filePath) => {
			const servingAccessResult = checkLoadingAccess(config$2, filePath);
			if (servingAccessResult === "denied") {
				const error$1 = /* @__PURE__ */ new Error("denied access");
				error$1.code = ERR_DENIED_FILE;
				error$1.path = filePath;
				throw error$1;
			}
			if (servingAccessResult === "fallback") return false;
			return true;
		}
	};
};
function servePublicMiddleware(server, publicFiles) {
	const dir = server.config.publicDir;
	const serve = build_default(dir, sirvOptions({
		config: server.config,
		getHeaders: () => server.config.server.headers,
		disableFsServeCheck: true
	}));
	const toFilePath = (url$3) => {
		let filePath = cleanUrl(url$3);
		if (filePath.indexOf("%") !== -1) try {
			filePath = decodeURI(filePath);
		} catch {}
		return normalizePath(filePath);
	};
	return function viteServePublicMiddleware(req$4, res, next) {
		if (publicFiles && !publicFiles.has(toFilePath(req$4.url)) || isImportRequest(req$4.url) || isInternalRequest(req$4.url) || urlRE.test(req$4.url)) return next();
		serve(req$4, res, next);
	};
}
function serveStaticMiddleware(server) {
	const dir = server.config.root;
	const serve = build_default(dir, sirvOptions({
		config: server.config,
		getHeaders: () => server.config.server.headers
	}));
	return function viteServeStaticMiddleware(req$4, res, next) {
		const cleanedUrl = cleanUrl(req$4.url);
		if (cleanedUrl.endsWith("/") || path.extname(cleanedUrl) === ".html" || isInternalRequest(req$4.url) || req$4.url?.startsWith("//")) return next();
		const url$3 = new URL(req$4.url, "http://example.com");
		const pathname = decodeURIIfPossible(url$3.pathname);
		if (pathname === void 0) return next();
		let redirectedPathname;
		for (const { find: find$1, replacement } of server.config.resolve.alias) if (typeof find$1 === "string" ? pathname.startsWith(find$1) : find$1.test(pathname)) {
			redirectedPathname = pathname.replace(find$1, replacement);
			break;
		}
		if (redirectedPathname) {
			if (redirectedPathname.startsWith(withTrailingSlash(dir))) redirectedPathname = redirectedPathname.slice(dir.length);
		}
		const resolvedPathname = redirectedPathname || pathname;
		let fileUrl = path.resolve(dir, removeLeadingSlash(resolvedPathname));
		if (resolvedPathname.endsWith("/") && fileUrl[fileUrl.length - 1] !== "/") fileUrl = withTrailingSlash(fileUrl);
		if (redirectedPathname) {
			url$3.pathname = encodeURI(redirectedPathname);
			req$4.url = url$3.href.slice(url$3.origin.length);
		}
		try {
			serve(req$4, res, next);
		} catch (e$1) {
			if (e$1 && "code" in e$1 && e$1.code === ERR_DENIED_FILE) {
				respondWithAccessDenied(e$1.path, server, res);
				return;
			}
			throw e$1;
		}
	};
}
function serveRawFsMiddleware(server) {
	const serveFromRoot = build_default("/", sirvOptions({
		config: server.config,
		getHeaders: () => server.config.server.headers
	}));
	return function viteServeRawFsMiddleware(req$4, res, next) {
		if (req$4.url.startsWith(FS_PREFIX)) {
			const url$3 = new URL(req$4.url, "http://example.com");
			const pathname = decodeURIIfPossible(url$3.pathname);
			if (pathname === void 0) return next();
			let newPathname = pathname.slice(FS_PREFIX.length);
			if (isWindows) newPathname = newPathname.replace(/^[A-Z]:/i, "");
			url$3.pathname = encodeURI(newPathname);
			req$4.url = url$3.href.slice(url$3.origin.length);
			try {
				serveFromRoot(req$4, res, next);
			} catch (e$1) {
				if (e$1 && "code" in e$1 && e$1.code === ERR_DENIED_FILE) {
					respondWithAccessDenied(e$1.path, server, res);
					return;
				}
				throw e$1;
			}
		} else next();
	};
}
function isFileServingAllowed(configOrUrl, urlOrServer) {
	const config$2 = typeof urlOrServer === "string" ? configOrUrl : urlOrServer.config;
	const url$3 = typeof urlOrServer === "string" ? urlOrServer : configOrUrl;
	if (!config$2.server.fs.strict) return true;
	return isFileLoadingAllowed(config$2, fsPathFromUrl(url$3));
}
/**
* Warning: parameters are not validated, only works with normalized absolute paths
*
* @param targetPath - normalized absolute path
* @param filePath - normalized absolute path
*/
function isFileInTargetPath(targetPath, filePath) {
	return isSameFilePath(targetPath, filePath) || isParentDirectory(targetPath, filePath);
}
/**
* Warning: parameters are not validated, only works with normalized absolute paths
*/
function isFileLoadingAllowed(config$2, filePath) {
	const { fs: fs$12 } = config$2.server;
	if (!fs$12.strict) return true;
	const filePathWithoutTrailingSlash = filePath.endsWith("/") ? filePath.slice(0, -1) : filePath;
	if (config$2.fsDenyGlob(filePathWithoutTrailingSlash)) return false;
	if (config$2.safeModulePaths.has(filePath)) return true;
	if (fs$12.allow.some((uri) => isFileInTargetPath(uri, filePath))) return true;
	return false;
}
function checkLoadingAccess(config$2, path$13) {
	if (isFileLoadingAllowed(config$2, slash(path$13))) return "allowed";
	if (isFileReadable(path$13)) return "denied";
	return "fallback";
}
function respondWithAccessDenied(id, server, res) {
	const urlMessage = `The request id "${id}" is outside of Vite serving allow list.`;
	const hintMessage = `
${server.config.server.fs.allow.map((i$1) => `- ${i$1}`).join("\n")}

Refer to docs https://vite.dev/config/server-options.html#server-fs-allow for configurations and more details.`;
	server.config.logger.error(urlMessage);
	server.config.logger.warnOnce(hintMessage + "\n");
	res.statusCode = 403;
	res.write(renderRestrictedErrorHTML(urlMessage + "\n" + hintMessage));
	res.end();
}
function renderRestrictedErrorHTML(msg) {
	return String.raw`
    <body>
      <h1>403 Restricted</h1>
      <p>${(0, import_escape_html$1.default)(msg).replace(/\n/g, "<br/>")}</p>
      <style>
        body {
          padding: 1em 2em;
        }
      </style>
    </body>
  `;
}

//#endregion
//#region src/node/server/transformRequest.ts
var import_etag = /* @__PURE__ */ __toESM(require_etag(), 1);
var import_picocolors$14 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const ERR_LOAD_URL = "ERR_LOAD_URL";
const ERR_LOAD_PUBLIC_URL = "ERR_LOAD_PUBLIC_URL";
const ERR_DENIED_ID = "ERR_DENIED_ID";
const debugLoad = createDebugger("vite:load");
const debugTransform = createDebugger("vite:transform");
const debugCache$1 = createDebugger("vite:cache");
function transformRequest(environment, url$3, options$1 = {}) {
	if (environment._closing && environment.config.dev.recoverable) throwClosedServerError();
	const timestamp = monotonicDateNow();
	url$3 = removeTimestampQuery(url$3);
	const pending = environment._pendingRequests.get(url$3);
	if (pending) return environment.moduleGraph.getModuleByUrl(url$3).then((module$1) => {
		if (!module$1 || pending.timestamp > module$1.lastInvalidationTimestamp) return pending.request;
		else {
			pending.abort();
			return transformRequest(environment, url$3, options$1);
		}
	});
	const request = doTransform(environment, url$3, options$1, timestamp);
	let cleared = false;
	const clearCache = () => {
		if (!cleared) {
			environment._pendingRequests.delete(url$3);
			cleared = true;
		}
	};
	environment._pendingRequests.set(url$3, {
		request,
		timestamp,
		abort: clearCache
	});
	return request.finally(clearCache);
}
async function doTransform(environment, url$3, options$1, timestamp) {
	const { pluginContainer } = environment;
	let module$1 = await environment.moduleGraph.getModuleByUrl(url$3);
	if (module$1) {
		const cached = await getCachedTransformResult(environment, url$3, module$1, timestamp);
		if (cached) return cached;
	}
	const resolved = module$1 ? void 0 : await pluginContainer.resolveId(url$3, void 0) ?? void 0;
	const id = module$1?.id ?? resolved?.id ?? url$3;
	module$1 ??= environment.moduleGraph.getModuleById(id);
	if (module$1) {
		await environment.moduleGraph._ensureEntryFromUrl(url$3, void 0, resolved);
		const cached = await getCachedTransformResult(environment, url$3, module$1, timestamp);
		if (cached) return cached;
	}
	const result = loadAndTransform(environment, id, url$3, options$1, timestamp, module$1, resolved);
	const { depsOptimizer } = environment;
	if (!depsOptimizer?.isOptimizedDepFile(id)) environment._registerRequestProcessing(id, () => result);
	return result;
}
async function getCachedTransformResult(environment, url$3, module$1, timestamp) {
	const prettyUrl = debugCache$1 ? prettifyUrl(url$3, environment.config.root) : "";
	const softInvalidatedTransformResult = await handleModuleSoftInvalidation(environment, module$1, timestamp);
	if (softInvalidatedTransformResult) {
		debugCache$1?.(`[memory-hmr] ${prettyUrl}`);
		return softInvalidatedTransformResult;
	}
	const cached = module$1.transformResult;
	if (cached) {
		debugCache$1?.(`[memory] ${prettyUrl}`);
		return cached;
	}
}
async function loadAndTransform(environment, id, url$3, options$1, timestamp, mod, resolved) {
	const { config: config$2, pluginContainer, logger } = environment;
	const prettyUrl = debugLoad || debugTransform ? prettifyUrl(url$3, config$2.root) : "";
	const moduleGraph = environment.moduleGraph;
	if (options$1.allowId && !options$1.allowId(id)) {
		const err$2 = /* @__PURE__ */ new Error(`Denied ID ${id}`);
		err$2.code = ERR_DENIED_ID;
		err$2.id = id;
		throw err$2;
	}
	let code = null;
	let map$1 = null;
	const loadStart = debugLoad ? performance$1.now() : 0;
	const loadResult = await pluginContainer.load(id);
	if (loadResult == null) {
		const file = cleanUrl(id);
		if (environment.config.consumer === "server" || isFileLoadingAllowed(environment.getTopLevelConfig(), slash(file))) {
			try {
				code = await fsp.readFile(file, "utf-8");
				debugLoad?.(`${timeFrom(loadStart)} [fs] ${prettyUrl}`);
			} catch (e$1) {
				if (e$1.code !== "ENOENT" && e$1.code !== "EISDIR") throw e$1;
			}
			if (code != null && environment.pluginContainer.watcher) ensureWatchedFile(environment.pluginContainer.watcher, file, config$2.root);
		}
		if (code) try {
			const extracted = await extractSourcemapFromFile(code, file);
			if (extracted) {
				code = extracted.code;
				map$1 = extracted.map;
			}
		} catch (e$1) {
			logger.warn(`Failed to load source map for ${file}.\n${e$1}`, { timestamp: true });
		}
	} else {
		debugLoad?.(`${timeFrom(loadStart)} [plugin] ${prettyUrl}`);
		if (isObject(loadResult)) {
			code = loadResult.code;
			map$1 = loadResult.map;
		} else code = loadResult;
	}
	if (code == null) {
		const isPublicFile = checkPublicFile(url$3, environment.getTopLevelConfig());
		let publicDirName = path.relative(config$2.root, config$2.publicDir);
		if (publicDirName[0] !== ".") publicDirName = "/" + publicDirName;
		const msg = isPublicFile ? `This file is in ${publicDirName} and will be copied as-is during build without going through the plugin transforms, and therefore should not be imported from source code. It can only be referenced via HTML tags.` : `Does the file exist?`;
		const importerMod = moduleGraph.idToModuleMap.get(id)?.importers.values().next().value;
		const importer = importerMod?.file || importerMod?.url;
		const err$2 = /* @__PURE__ */ new Error(`Failed to load url ${url$3} (resolved id: ${id})${importer ? ` in ${importer}` : ""}. ${msg}`);
		err$2.code = isPublicFile ? ERR_LOAD_PUBLIC_URL : ERR_LOAD_URL;
		throw err$2;
	}
	if (environment._closing && environment.config.dev.recoverable) throwClosedServerError();
	mod ??= await moduleGraph._ensureEntryFromUrl(url$3, void 0, resolved);
	const transformStart = debugTransform ? performance$1.now() : 0;
	const transformResult = await pluginContainer.transform(code, id, { inMap: map$1 });
	const originalCode = code;
	if (transformResult.code === originalCode) debugTransform?.(timeFrom(transformStart) + import_picocolors$14.default.dim(` [skipped] ${prettyUrl}`));
	else {
		debugTransform?.(`${timeFrom(transformStart)} ${prettyUrl}`);
		code = transformResult.code;
		map$1 = transformResult.map;
	}
	let normalizedMap;
	if (typeof map$1 === "string") normalizedMap = JSON.parse(map$1);
	else if (map$1) normalizedMap = map$1;
	else normalizedMap = null;
	if (normalizedMap && "version" in normalizedMap && mod.file) {
		if (normalizedMap.mappings) await injectSourcesContent(normalizedMap, mod.file, logger);
		const sourcemapPath = `${mod.file}.map`;
		applySourcemapIgnoreList(normalizedMap, sourcemapPath, config$2.server.sourcemapIgnoreList, logger);
		if (path.isAbsolute(mod.file)) {
			let modDirname;
			for (let sourcesIndex = 0; sourcesIndex < normalizedMap.sources.length; ++sourcesIndex) {
				const sourcePath = normalizedMap.sources[sourcesIndex];
				if (sourcePath) {
					if (path.isAbsolute(sourcePath)) {
						modDirname ??= path.dirname(mod.file);
						normalizedMap.sources[sourcesIndex] = path.relative(modDirname, sourcePath);
					}
				}
			}
		}
	}
	if (environment._closing && environment.config.dev.recoverable) throwClosedServerError();
	const topLevelConfig = environment.getTopLevelConfig();
	const result = environment.config.dev.moduleRunnerTransform ? await ssrTransform(code, normalizedMap, url$3, originalCode, { json: { stringify: topLevelConfig.json.stringify === true && topLevelConfig.json.namedExports !== true } }) : {
		code,
		map: normalizedMap,
		etag: (0, import_etag.default)(code, { weak: true })
	};
	if (timestamp > mod.lastInvalidationTimestamp) moduleGraph.updateModuleTransformResult(mod, result);
	return result;
}
/**
* When a module is soft-invalidated, we can preserve its previous `transformResult` and
* return similar code to before:
*
* - Client: We need to transform the import specifiers with new timestamps
* - SSR: We don't need to change anything as `ssrLoadModule` controls it
*/
async function handleModuleSoftInvalidation(environment, mod, timestamp) {
	const transformResult = mod.invalidationState;
	mod.invalidationState = void 0;
	if (!transformResult || transformResult === "HARD_INVALIDATED") return;
	if (mod.transformResult) throw new Error(`Internal server error: Soft-invalidated module "${mod.url}" should not have existing transform result`);
	let result;
	if (transformResult.ssr) result = transformResult;
	else {
		await init;
		const source = transformResult.code;
		const s$2 = new MagicString(source);
		const [imports] = parse(source, mod.id || void 0);
		for (const imp of imports) {
			let rawUrl = source.slice(imp.s, imp.e);
			if (rawUrl === "import.meta") continue;
			const hasQuotes = rawUrl[0] === "\"" || rawUrl[0] === "'";
			if (hasQuotes) rawUrl = rawUrl.slice(1, -1);
			const urlWithoutTimestamp = removeTimestampQuery(rawUrl);
			const hmrUrl = unwrapId(stripBase(removeImportQuery(urlWithoutTimestamp), environment.config.base));
			for (const importedMod of mod.importedModules) {
				if (importedMod.url !== hmrUrl) continue;
				if (importedMod.lastHMRTimestamp > 0) {
					const replacedUrl = injectQuery(urlWithoutTimestamp, `t=${importedMod.lastHMRTimestamp}`);
					const start = hasQuotes ? imp.s + 1 : imp.s;
					const end = hasQuotes ? imp.e - 1 : imp.e;
					s$2.overwrite(start, end, replacedUrl);
				}
				if (imp.d === -1 && environment.config.dev.preTransformRequests) environment.warmupRequest(hmrUrl);
				break;
			}
		}
		const code = s$2.toString();
		result = {
			...transformResult,
			code,
			etag: (0, import_etag.default)(code, { weak: true })
		};
	}
	if (timestamp > mod.lastInvalidationTimestamp) environment.moduleGraph.updateModuleTransformResult(mod, result);
	return result;
}

//#endregion
//#region src/node/assetSource.ts
const ALLOWED_META_NAME = [
	"msapplication-tileimage",
	"msapplication-square70x70logo",
	"msapplication-square150x150logo",
	"msapplication-wide310x150logo",
	"msapplication-square310x310logo",
	"msapplication-config",
	"twitter:image"
];
const ALLOWED_META_PROPERTY = [
	"og:image",
	"og:image:url",
	"og:image:secure_url",
	"og:audio",
	"og:audio:secure_url",
	"og:video",
	"og:video:secure_url"
];
const DEFAULT_HTML_ASSET_SOURCES = {
	audio: { srcAttributes: ["src"] },
	embed: { srcAttributes: ["src"] },
	img: {
		srcAttributes: ["src"],
		srcsetAttributes: ["srcset"]
	},
	image: { srcAttributes: ["href", "xlink:href"] },
	input: { srcAttributes: ["src"] },
	link: {
		srcAttributes: ["href"],
		srcsetAttributes: ["imagesrcset"]
	},
	object: { srcAttributes: ["data"] },
	source: {
		srcAttributes: ["src"],
		srcsetAttributes: ["srcset"]
	},
	track: { srcAttributes: ["src"] },
	use: { srcAttributes: ["href", "xlink:href"] },
	video: { srcAttributes: ["src", "poster"] },
	meta: {
		srcAttributes: ["content"],
		filter({ attributes }) {
			if (attributes.name && ALLOWED_META_NAME.includes(attributes.name.trim().toLowerCase())) return true;
			if (attributes.property && ALLOWED_META_PROPERTY.includes(attributes.property.trim().toLowerCase())) return true;
			return false;
		}
	}
};
/**
* Given a HTML node, find all attributes that references an asset to be processed
*/
function getNodeAssetAttributes(node) {
	const matched = DEFAULT_HTML_ASSET_SOURCES[node.nodeName];
	if (!matched) return [];
	const attributes = {};
	for (const attr of node.attrs) attributes[getAttrKey(attr)] = attr.value;
	if ("vite-ignore" in attributes) return [{
		type: "remove",
		key: "vite-ignore",
		value: "",
		attributes,
		location: node.sourceCodeLocation.attrs["vite-ignore"]
	}];
	const actions = [];
	function handleAttributeKey(key, type) {
		const value$1 = attributes[key];
		if (!value$1) return;
		if (matched.filter && !matched.filter({
			key,
			value: value$1,
			attributes
		})) return;
		const location$1 = node.sourceCodeLocation.attrs[key];
		actions.push({
			type,
			key,
			value: value$1,
			attributes,
			location: location$1
		});
	}
	matched.srcAttributes?.forEach((key) => handleAttributeKey(key, "src"));
	matched.srcsetAttributes?.forEach((key) => handleAttributeKey(key, "srcset"));
	return actions;
}
function getAttrKey(attr) {
	return attr.prefix === void 0 ? attr.name : `${attr.prefix}:${attr.name}`;
}

//#endregion
//#region src/node/plugins/modulePreloadPolyfill.ts
const modulePreloadPolyfillId = "vite/modulepreload-polyfill";
const resolvedModulePreloadPolyfillId = "\0" + modulePreloadPolyfillId + ".js";
function modulePreloadPolyfillPlugin(config$2) {
	let polyfillString;
	return {
		name: "vite:modulepreload-polyfill",
		resolveId: {
			filter: { id: exactRegex(modulePreloadPolyfillId) },
			handler(_id) {
				return resolvedModulePreloadPolyfillId;
			}
		},
		load: {
			filter: { id: exactRegex(resolvedModulePreloadPolyfillId) },
			handler(_id) {
				if (config$2.command !== "build" || this.environment.config.consumer !== "client") return "";
				if (!polyfillString) polyfillString = `${isModernFlag}&&(${polyfill.toString()}());`;
				return {
					code: polyfillString,
					moduleSideEffects: true
				};
			}
		}
	};
}
function polyfill() {
	const relList = document.createElement("link").relList;
	if (relList && relList.supports && relList.supports("modulepreload")) return;
	for (const link of document.querySelectorAll("link[rel=\"modulepreload\"]")) processPreload(link);
	new MutationObserver((mutations) => {
		for (const mutation of mutations) {
			if (mutation.type !== "childList") continue;
			for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
		}
	}).observe(document, {
		childList: true,
		subtree: true
	});
	function getFetchOpts(link) {
		const fetchOpts = {};
		if (link.integrity) fetchOpts.integrity = link.integrity;
		if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
		if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
		else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
		else fetchOpts.credentials = "same-origin";
		return fetchOpts;
	}
	function processPreload(link) {
		if (link.ep) return;
		link.ep = true;
		const fetchOpts = getFetchOpts(link);
		fetch(link.href, fetchOpts);
	}
}

//#endregion
//#region src/node/plugins/html.ts
var import_picocolors$13 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
var import_escape_html = /* @__PURE__ */ __toESM(require_escape_html(), 1);
const htmlProxyRE$1 = /[?&]html-proxy=?(?:&inline-css)?(?:&style-attr)?&index=(\d+)\.(?:js|css)$/;
const isHtmlProxyRE = /[?&]html-proxy\b/;
const inlineCSSRE$1 = /__VITE_INLINE_CSS__([a-z\d]{8}_\d+)__/g;
const inlineImportRE = /(?<!(?<!\.\.)\.)\bimport\s*\(("(?:[^"]|(?<=\\)")*"|'(?:[^']|(?<=\\)')*')\)/dg;
const htmlLangRE = /\.(?:html|htm)$/;
const spaceRe = /[\t\n\f\r ]/;
const importMapRE = /[ \t]*<script[^>]*type\s*=\s*(?:"importmap"|'importmap'|importmap)[^>]*>.*?<\/script>/is;
const importMapAppendRE = new RegExp([/[ \t]*<script[^>]*type\s*=\s*(?:"module"|'module'|module)[^>]*>/i, /[ \t]*<link[^>]*rel\s*=\s*(?:"modulepreload"|'modulepreload'|modulepreload)[\s\S]*?\/>/i].map((r$1) => r$1.source).join("|"), "i");
const isHTMLProxy = (id) => isHtmlProxyRE.test(id);
const isHTMLRequest = (request) => htmlLangRE.test(request);
const htmlProxyMap = /* @__PURE__ */ new WeakMap();
const htmlProxyResult = /* @__PURE__ */ new Map();
function htmlInlineProxyPlugin(config$2) {
	htmlProxyMap.set(config$2, /* @__PURE__ */ new Map());
	return {
		name: "vite:html-inline-proxy",
		resolveId: {
			filter: { id: isHtmlProxyRE },
			handler(id) {
				return id;
			}
		},
		load: {
			filter: { id: isHtmlProxyRE },
			handler(id) {
				const proxyMatch = htmlProxyRE$1.exec(id);
				if (proxyMatch) {
					const index = Number(proxyMatch[1]);
					const url$3 = cleanUrl(id).replace(normalizePath(config$2.root), "");
					const result = htmlProxyMap.get(config$2).get(url$3)?.[index];
					if (result) return {
						...result,
						moduleSideEffects: true
					};
					else throw new Error(`No matching HTML proxy module found from ${id}`);
				}
			}
		}
	};
}
function addToHTMLProxyCache(config$2, filePath, index, result) {
	if (!htmlProxyMap.get(config$2)) htmlProxyMap.set(config$2, /* @__PURE__ */ new Map());
	if (!htmlProxyMap.get(config$2).get(filePath)) htmlProxyMap.get(config$2).set(filePath, []);
	htmlProxyMap.get(config$2).get(filePath)[index] = result;
}
function addToHTMLProxyTransformResult(hash$1, code) {
	htmlProxyResult.set(hash$1, code);
}
const noInlineLinkRels = new Set([
	"icon",
	"apple-touch-icon",
	"apple-touch-startup-image",
	"manifest"
]);
const isAsyncScriptMap = /* @__PURE__ */ new WeakMap();
function nodeIsElement(node) {
	return node.nodeName[0] !== "#";
}
function traverseNodes(node, visitor) {
	if (node.nodeName === "template") node = node.content;
	visitor(node);
	if (nodeIsElement(node) || node.nodeName === "#document" || node.nodeName === "#document-fragment") node.childNodes.forEach((childNode) => traverseNodes(childNode, visitor));
}
async function traverseHtml(html, filePath, warn, visitor) {
	const { parse: parse$17 } = await import("./dist.js");
	const warnings = {};
	traverseNodes(parse$17(html, {
		scriptingEnabled: false,
		sourceCodeLocationInfo: true,
		onParseError: (e$1) => {
			handleParseError(e$1, html, filePath, warnings);
		}
	}), visitor);
	for (const message of Object.values(warnings)) warn(import_picocolors$13.default.yellow(`\n${message}`));
}
function getScriptInfo(node) {
	let src;
	let srcSourceCodeLocation;
	let isModule = false;
	let isAsync = false;
	let isIgnored = false;
	for (const p of node.attrs) {
		if (p.prefix !== void 0) continue;
		if (p.name === "src") {
			if (!src) {
				src = p;
				srcSourceCodeLocation = node.sourceCodeLocation?.attrs["src"];
			}
		} else if (p.name === "type" && p.value === "module") isModule = true;
		else if (p.name === "async") isAsync = true;
		else if (p.name === "vite-ignore") isIgnored = true;
	}
	return {
		src,
		srcSourceCodeLocation,
		isModule,
		isAsync,
		isIgnored
	};
}
const attrValueStartRE = /=\s*(.)/;
function overwriteAttrValue(s$2, sourceCodeLocation, newValue) {
	const srcString = s$2.slice(sourceCodeLocation.startOffset, sourceCodeLocation.endOffset);
	const valueStart = attrValueStartRE.exec(srcString);
	if (!valueStart) throw new Error(`[vite:html] internal error, failed to overwrite attribute value`);
	const wrapOffset = valueStart[1] === "\"" || valueStart[1] === "'" ? 1 : 0;
	const valueOffset = valueStart.index + valueStart[0].length - 1;
	s$2.update(sourceCodeLocation.startOffset + valueOffset + wrapOffset, sourceCodeLocation.endOffset - wrapOffset, newValue);
	return s$2;
}
function removeViteIgnoreAttr(s$2, sourceCodeLocation) {
	const loc = sourceCodeLocation.attrs?.["vite-ignore"];
	if (loc) s$2.remove(loc.startOffset, loc.endOffset);
	return s$2;
}
/**
* Format parse5 @type {ParserError} to @type {RollupError}
*/
function formatParseError(parserError, id, html) {
	return {
		code: parserError.code,
		message: `parse5 error code ${parserError.code}`,
		frame: generateCodeFrame(html, parserError.startOffset, parserError.endOffset),
		loc: {
			file: id,
			line: parserError.startLine,
			column: parserError.startCol
		}
	};
}
function handleParseError(parserError, html, filePath, warnings) {
	switch (parserError.code) {
		case "missing-doctype": return;
		case "abandoned-head-element-child": return;
		case "duplicate-attribute": return;
		case "non-void-html-element-start-tag-with-trailing-solidus": return;
		case "unexpected-question-mark-instead-of-tag-name": return;
	}
	const parseError = formatParseError(parserError, filePath, html);
	warnings[parseError.code] ??= `Unable to parse HTML; ${parseError.message}\n at ${parseError.loc.file}:${parseError.loc.line}:${parseError.loc.column}\n` + parseError.frame;
}
/**
* Compiles index.html into an entry js module
*/
function buildHtmlPlugin(config$2) {
	const [preHooks, normalHooks, postHooks] = resolveHtmlTransforms(config$2.plugins);
	preHooks.unshift(injectCspNonceMetaTagHook(config$2));
	preHooks.unshift(preImportMapHook(config$2));
	preHooks.push(htmlEnvHook(config$2));
	postHooks.push(injectNonceAttributeTagHook(config$2));
	postHooks.push(postImportMapHook());
	const processedHtml = perEnvironmentState(() => /* @__PURE__ */ new Map());
	const isExcludedUrl = (url$3) => url$3[0] === "#" || isExternalUrl(url$3) || isDataUrl(url$3);
	isAsyncScriptMap.set(config$2, /* @__PURE__ */ new Map());
	return {
		name: "vite:build-html",
		transform: {
			filter: { id: /\.html$/ },
			async handler(html, id) {
				id = normalizePath(id);
				const relativeUrlPath = normalizePath(path.relative(config$2.root, id));
				const publicPath = `/${relativeUrlPath}`;
				const publicBase = getBaseInHTML(relativeUrlPath, config$2);
				const publicToRelative = (filename) => publicBase + filename;
				const toOutputPublicFilePath = (url$3) => toOutputFilePathInHtml(url$3.slice(1), "public", relativeUrlPath, "html", config$2, publicToRelative);
				const nodeStartWithLeadingWhitespace = (node) => {
					const startOffset = node.sourceCodeLocation.startOffset;
					if (startOffset === 0) return 0;
					const lineStartOffset = startOffset - node.sourceCodeLocation.startCol;
					let isLineEmpty = false;
					try {
						isLineEmpty = !s$2.slice(Math.max(0, lineStartOffset), startOffset).trim();
					} catch {}
					return isLineEmpty ? lineStartOffset : startOffset;
				};
				html = await applyHtmlTransforms(html, preHooks, this, {
					path: publicPath,
					filename: id
				});
				let js = "";
				const s$2 = new MagicString(html);
				const scriptUrls = [];
				const styleUrls = [];
				let inlineModuleIndex = -1;
				let everyScriptIsAsync = true;
				let someScriptsAreAsync = false;
				let someScriptsAreDefer = false;
				const assetUrlsPromises = [];
				const namedOutput = Object.keys(config$2.build.rollupOptions.input || {});
				const processAssetUrl = async (url$3, shouldInline$1) => {
					if (url$3 !== "" && !namedOutput.includes(url$3) && !namedOutput.includes(removeLeadingSlash(url$3))) try {
						return await urlToBuiltUrl(this, url$3, id, shouldInline$1);
					} catch (e$1) {
						if (e$1.code !== "ENOENT") throw e$1;
					}
					return url$3;
				};
				const setModuleSideEffectPromises = [];
				await traverseHtml(html, id, config$2.logger.warn, (node) => {
					if (!nodeIsElement(node)) return;
					let shouldRemove = false;
					if (node.nodeName === "script") {
						const { src, srcSourceCodeLocation, isModule, isAsync, isIgnored } = getScriptInfo(node);
						if (isIgnored) removeViteIgnoreAttr(s$2, node.sourceCodeLocation);
						else {
							const url$3 = src && src.value;
							const isPublicFile = !!(url$3 && checkPublicFile(url$3, config$2));
							if (isPublicFile) overwriteAttrValue(s$2, srcSourceCodeLocation, partialEncodeURIPath(toOutputPublicFilePath(url$3)));
							if (isModule) {
								inlineModuleIndex++;
								if (url$3 && !isExcludedUrl(url$3) && !isPublicFile) {
									setModuleSideEffectPromises.push(this.resolve(url$3, id).then((resolved) => {
										if (!resolved) return Promise.reject(/* @__PURE__ */ new Error(`Failed to resolve ${url$3} from ${id}`));
										const moduleInfo = this.getModuleInfo(resolved.id);
										if (moduleInfo) moduleInfo.moduleSideEffects = true;
										else if (!resolved.external) return this.load(resolved).then((mod) => {
											mod.moduleSideEffects = true;
										});
									}));
									js += `\nimport ${JSON.stringify(url$3)}`;
									shouldRemove = true;
								} else if (node.childNodes.length) {
									const contents = node.childNodes.pop().value;
									addToHTMLProxyCache(config$2, id.replace(normalizePath(config$2.root), ""), inlineModuleIndex, { code: contents });
									js += `\nimport "${id}?html-proxy&index=${inlineModuleIndex}.js"`;
									shouldRemove = true;
								}
								everyScriptIsAsync &&= isAsync;
								someScriptsAreAsync ||= isAsync;
								someScriptsAreDefer ||= !isAsync;
							} else if (url$3 && !isPublicFile) {
								if (!isExcludedUrl(url$3)) config$2.logger.warn(`<script src="${url$3}"> in "${publicPath}" can't be bundled without type="module" attribute`);
							} else if (node.childNodes.length) {
								const scriptNode = node.childNodes.pop();
								scriptUrls.push(...extractImportExpressionFromClassicScript(scriptNode));
							}
						}
					}
					const assetAttributes = getNodeAssetAttributes(node);
					for (const attr of assetAttributes) if (attr.type === "remove") {
						s$2.remove(attr.location.startOffset, attr.location.endOffset);
						continue;
					} else if (attr.type === "srcset") assetUrlsPromises.push((async () => {
						const processedEncodedUrl = await processSrcSet(attr.value, async ({ url: url$3 }) => {
							const decodedUrl = decodeURIIfPossible(url$3);
							if (decodedUrl !== void 0 && !isExcludedUrl(decodedUrl)) {
								const result = await processAssetUrl(url$3);
								return result !== decodedUrl ? encodeURIPath(result) : url$3;
							}
							return url$3;
						});
						if (processedEncodedUrl !== attr.value) overwriteAttrValue(s$2, attr.location, processedEncodedUrl);
					})());
					else if (attr.type === "src") {
						const url$3 = decodeURIIfPossible(attr.value);
						if (url$3 === void 0) {} else if (checkPublicFile(url$3, config$2)) overwriteAttrValue(s$2, attr.location, partialEncodeURIPath(toOutputPublicFilePath(url$3)));
						else if (!isExcludedUrl(url$3)) if (node.nodeName === "link" && isCSSRequest(url$3) && !("media" in attr.attributes || "disabled" in attr.attributes)) {
							const importExpression = `\nimport ${JSON.stringify(url$3)}`;
							styleUrls.push({
								url: url$3,
								start: nodeStartWithLeadingWhitespace(node),
								end: node.sourceCodeLocation.endOffset
							});
							js += importExpression;
						} else {
							const shouldInline$1 = node.nodeName === "link" && attr.attributes.rel && parseRelAttr(attr.attributes.rel).some((v) => noInlineLinkRels.has(v)) ? false : void 0;
							assetUrlsPromises.push((async () => {
								const processedUrl = await processAssetUrl(url$3, shouldInline$1);
								if (processedUrl !== url$3) overwriteAttrValue(s$2, attr.location, partialEncodeURIPath(processedUrl));
							})());
						}
					}
					const inlineStyle = findNeedTransformStyleAttribute(node);
					if (inlineStyle) {
						inlineModuleIndex++;
						const code = inlineStyle.attr.value;
						addToHTMLProxyCache(config$2, id.replace(normalizePath(config$2.root), ""), inlineModuleIndex, { code });
						js += `\nimport "${id}?html-proxy&inline-css&style-attr&index=${inlineModuleIndex}.css"`;
						const hash$1 = getHash(cleanUrl(id));
						overwriteAttrValue(s$2, inlineStyle.location, `__VITE_INLINE_CSS__${hash$1}_${inlineModuleIndex}__`);
					}
					if (node.nodeName === "style" && node.childNodes.length) {
						const styleNode = node.childNodes.pop();
						const filePath = id.replace(normalizePath(config$2.root), "");
						inlineModuleIndex++;
						addToHTMLProxyCache(config$2, filePath, inlineModuleIndex, { code: styleNode.value });
						js += `\nimport "${id}?html-proxy&inline-css&index=${inlineModuleIndex}.css"`;
						const hash$1 = getHash(cleanUrl(id));
						s$2.update(styleNode.sourceCodeLocation.startOffset, styleNode.sourceCodeLocation.endOffset, `__VITE_INLINE_CSS__${hash$1}_${inlineModuleIndex}__`);
					}
					if (shouldRemove) s$2.remove(nodeStartWithLeadingWhitespace(node), node.sourceCodeLocation.endOffset);
				});
				isAsyncScriptMap.get(config$2).set(id, everyScriptIsAsync);
				if (someScriptsAreAsync && someScriptsAreDefer) config$2.logger.warn(`\nMixed async and defer script modules in ${id}, output script will fallback to defer. Every script, including inline ones, need to be marked as async for your output script to be async.`);
				await Promise.all(assetUrlsPromises);
				for (const { start, end, url: url$3 } of scriptUrls) if (checkPublicFile(url$3, config$2)) s$2.update(start, end, partialEncodeURIPath(toOutputPublicFilePath(url$3)));
				else if (!isExcludedUrl(url$3)) s$2.update(start, end, partialEncodeURIPath(await urlToBuiltUrl(this, url$3, id)));
				const resolvedStyleUrls = await Promise.all(styleUrls.map(async (styleUrl) => ({
					...styleUrl,
					resolved: await this.resolve(styleUrl.url, id)
				})));
				for (const { start, end, url: url$3, resolved } of resolvedStyleUrls) if (resolved == null) {
					config$2.logger.warnOnce(`\n${url$3} doesn't exist at build time, it will remain unchanged to be resolved at runtime`);
					const importExpression = `\nimport ${JSON.stringify(url$3)}`;
					js = js.replace(importExpression, "");
				} else s$2.remove(start, end);
				processedHtml(this).set(id, s$2.toString());
				const { modulePreload } = this.environment.config.build;
				if (modulePreload !== false && modulePreload.polyfill && (someScriptsAreAsync || someScriptsAreDefer)) js = `import "${modulePreloadPolyfillId}";\n${js}`;
				await Promise.all(setModuleSideEffectPromises);
				return {
					code: js,
					moduleSideEffects: "no-treeshake"
				};
			}
		},
		async generateBundle(options$1, bundle) {
			const analyzedImportedCssFiles = /* @__PURE__ */ new Map();
			const inlineEntryChunk = /* @__PURE__ */ new Set();
			const getImportedChunks = (chunk, seen$1 = /* @__PURE__ */ new Set()) => {
				const chunks = [];
				chunk.imports.forEach((file) => {
					const importee = bundle[file];
					if (importee) {
						if (importee.type === "chunk" && !seen$1.has(file)) {
							seen$1.add(file);
							chunks.push(...getImportedChunks(importee, seen$1));
							chunks.push(importee);
						}
					} else chunks.push(file);
				});
				return chunks;
			};
			const toScriptTag = (chunkOrUrl, toOutputPath, isAsync) => ({
				tag: "script",
				attrs: {
					...isAsync ? { async: true } : {},
					type: "module",
					crossorigin: true,
					src: typeof chunkOrUrl === "string" ? chunkOrUrl : toOutputPath(chunkOrUrl.fileName)
				}
			});
			const toPreloadTag = (filename, toOutputPath) => ({
				tag: "link",
				attrs: {
					rel: "modulepreload",
					crossorigin: true,
					href: toOutputPath(filename)
				}
			});
			const toStyleSheetLinkTag = (file, toOutputPath) => ({
				tag: "link",
				attrs: {
					rel: "stylesheet",
					crossorigin: true,
					href: toOutputPath(file)
				}
			});
			const getCssFilesForChunk = (chunk, seenChunks = /* @__PURE__ */ new Set(), seenCss = /* @__PURE__ */ new Set()) => {
				if (seenChunks.has(chunk.fileName)) return [];
				seenChunks.add(chunk.fileName);
				if (analyzedImportedCssFiles.has(chunk)) {
					const additionals = analyzedImportedCssFiles.get(chunk).filter((file) => !seenCss.has(file));
					additionals.forEach((file) => seenCss.add(file));
					return additionals;
				}
				const files = [];
				chunk.imports.forEach((file) => {
					const importee = bundle[file];
					if (importee?.type === "chunk") files.push(...getCssFilesForChunk(importee, seenChunks, seenCss));
				});
				analyzedImportedCssFiles.set(chunk, files);
				chunk.viteMetadata.importedCss.forEach((file) => {
					if (!seenCss.has(file)) {
						seenCss.add(file);
						files.push(file);
					}
				});
				return files;
			};
			const getCssTagsForChunk = (chunk, toOutputPath) => getCssFilesForChunk(chunk).map((file) => toStyleSheetLinkTag(file, toOutputPath));
			for (const [normalizedId, html] of processedHtml(this)) {
				const relativeUrlPath = normalizePath(path.relative(config$2.root, normalizedId));
				const assetsBase = getBaseInHTML(relativeUrlPath, config$2);
				const toOutputFilePath = (filename, type) => {
					if (isExternalUrl(filename)) return filename;
					else return toOutputFilePathInHtml(filename, type, relativeUrlPath, "html", config$2, (filename$1) => assetsBase + filename$1);
				};
				const toOutputAssetFilePath = (filename) => toOutputFilePath(filename, "asset");
				const toOutputPublicAssetFilePath = (filename) => toOutputFilePath(filename, "public");
				const isAsync = isAsyncScriptMap.get(config$2).get(normalizedId);
				let result = html;
				const chunk = Object.values(bundle).find((chunk$1) => chunk$1.type === "chunk" && chunk$1.isEntry && chunk$1.facadeModuleId && normalizePath(chunk$1.facadeModuleId) === normalizedId);
				let canInlineEntry = false;
				if (chunk) {
					if (options$1.format === "es" && isEntirelyImport(chunk.code)) canInlineEntry = true;
					const imports = getImportedChunks(chunk);
					let assetTags;
					if (canInlineEntry) assetTags = imports.map((chunk$1) => toScriptTag(chunk$1, toOutputAssetFilePath, isAsync));
					else {
						const { modulePreload } = this.environment.config.build;
						assetTags = [toScriptTag(chunk, toOutputAssetFilePath, isAsync)];
						if (modulePreload !== false) {
							const resolveDependencies = typeof modulePreload === "object" && modulePreload.resolveDependencies;
							const importsFileNames = imports.filter((chunkOrUrl) => typeof chunkOrUrl !== "string").map((chunk$1) => chunk$1.fileName);
							const resolvedDeps = resolveDependencies ? resolveDependencies(chunk.fileName, importsFileNames, {
								hostId: relativeUrlPath,
								hostType: "html"
							}) : importsFileNames;
							assetTags.push(...resolvedDeps.map((i$1) => toPreloadTag(i$1, toOutputAssetFilePath)));
						}
					}
					assetTags.push(...getCssTagsForChunk(chunk, toOutputAssetFilePath));
					result = injectToHead(result, assetTags);
				}
				if (!this.environment.config.build.cssCodeSplit) {
					const cssBundleName = cssBundleNameCache.get(config$2);
					const cssChunk = cssBundleName && Object.values(bundle).find((chunk$1) => chunk$1.type === "asset" && chunk$1.names.includes(cssBundleName));
					if (cssChunk) result = injectToHead(result, [{
						tag: "link",
						attrs: {
							rel: "stylesheet",
							crossorigin: true,
							href: toOutputAssetFilePath(cssChunk.fileName)
						}
					}]);
				}
				let match;
				let s$2;
				inlineCSSRE$1.lastIndex = 0;
				while (match = inlineCSSRE$1.exec(result)) {
					s$2 ||= new MagicString(result);
					const { 0: full, 1: scopedName } = match;
					const cssTransformedCode = htmlProxyResult.get(scopedName);
					s$2.update(match.index, match.index + full.length, cssTransformedCode);
				}
				if (s$2) result = s$2.toString();
				result = await applyHtmlTransforms(result, [...normalHooks, ...postHooks], this, {
					path: "/" + relativeUrlPath,
					filename: normalizedId,
					bundle,
					chunk
				});
				result = result.replace(assetUrlRE, (_, fileHash, postfix = "") => {
					const file = this.getFileName(fileHash);
					if (chunk) chunk.viteMetadata.importedAssets.add(cleanUrl(file));
					return encodeURIPath(toOutputAssetFilePath(file)) + postfix;
				});
				result = result.replace(publicAssetUrlRE, (_, fileHash) => {
					const publicAssetPath = toOutputPublicAssetFilePath(getPublicAssetFilename(fileHash, config$2));
					return encodeURIPath(URL$1.canParse(publicAssetPath) ? publicAssetPath : normalizePath(publicAssetPath));
				});
				if (chunk && canInlineEntry) inlineEntryChunk.add(chunk.fileName);
				const shortEmitName = normalizePath(path.relative(config$2.root, normalizedId));
				this.emitFile({
					type: "asset",
					originalFileName: normalizedId,
					fileName: shortEmitName,
					source: result
				});
			}
			for (const fileName of inlineEntryChunk) delete bundle[fileName];
		}
	};
}
function parseRelAttr(attr) {
	return attr.split(spaceRe).map((v) => v.toLowerCase());
}
function findNeedTransformStyleAttribute(node) {
	const attr = node.attrs.find((prop) => prop.prefix === void 0 && prop.name === "style" && (prop.value.includes("url(") || prop.value.includes("image-set(")));
	if (!attr) return void 0;
	return {
		attr,
		location: node.sourceCodeLocation?.attrs?.["style"]
	};
}
function extractImportExpressionFromClassicScript(scriptTextNode) {
	const startOffset = scriptTextNode.sourceCodeLocation.startOffset;
	const cleanCode = stripLiteral(scriptTextNode.value);
	const scriptUrls = [];
	let match;
	inlineImportRE.lastIndex = 0;
	while (match = inlineImportRE.exec(cleanCode)) {
		const [, [urlStart, urlEnd]] = match.indices;
		const start = urlStart + 1;
		const end = urlEnd - 1;
		scriptUrls.push({
			start: start + startOffset,
			end: end + startOffset,
			url: scriptTextNode.value.slice(start, end)
		});
	}
	return scriptUrls;
}
function preImportMapHook(config$2) {
	return (html, ctx) => {
		const importMapIndex = html.search(importMapRE);
		if (importMapIndex < 0) return;
		const importMapAppendIndex = html.search(importMapAppendRE);
		if (importMapAppendIndex < 0) return;
		if (importMapAppendIndex < importMapIndex) {
			const relativeHtml = normalizePath(path.relative(config$2.root, ctx.filename));
			config$2.logger.warnOnce(import_picocolors$13.default.yellow(import_picocolors$13.default.bold(`(!) <script type="importmap"> should come before <script type="module"> and <link rel="modulepreload"> in /${relativeHtml}`)));
		}
	};
}
/**
* Move importmap before the first module script and modulepreload link
*/
function postImportMapHook() {
	return (html) => {
		if (!importMapAppendRE.test(html)) return;
		let importMap;
		html = html.replace(importMapRE, (match) => {
			importMap = match;
			return "";
		});
		if (importMap) html = html.replace(importMapAppendRE, (match) => `${importMap}\n${match}`);
		return html;
	};
}
function injectCspNonceMetaTagHook(config$2) {
	return () => {
		if (!config$2.html?.cspNonce) return;
		return [{
			tag: "meta",
			injectTo: "head",
			attrs: {
				property: "csp-nonce",
				nonce: config$2.html.cspNonce
			}
		}];
	};
}
/**
* Support `%ENV_NAME%` syntax in html files
*/
function htmlEnvHook(config$2) {
	const pattern = /%(\S+?)%/g;
	const envPrefix = resolveEnvPrefix({ envPrefix: config$2.envPrefix });
	const env$1 = { ...config$2.env };
	for (const key in config$2.define) if (key.startsWith(`import.meta.env.`)) {
		const val = config$2.define[key];
		if (typeof val === "string") try {
			const parsed = JSON.parse(val);
			env$1[key.slice(16)] = typeof parsed === "string" ? parsed : val;
		} catch {
			env$1[key.slice(16)] = val;
		}
		else env$1[key.slice(16)] = JSON.stringify(val);
	}
	return (html, ctx) => {
		return html.replace(pattern, (text, key) => {
			if (key in env$1) return env$1[key];
			else {
				if (envPrefix.some((prefix) => key.startsWith(prefix))) {
					const relativeHtml = normalizePath(path.relative(config$2.root, ctx.filename));
					config$2.logger.warn(import_picocolors$13.default.yellow(import_picocolors$13.default.bold(`(!) ${text} is not defined in env variables found in /${relativeHtml}. Is the variable mistyped?`)));
				}
				return text;
			}
		});
	};
}
function injectNonceAttributeTagHook(config$2) {
	const processRelType = new Set([
		"stylesheet",
		"modulepreload",
		"preload"
	]);
	return async (html, { filename }) => {
		const nonce = config$2.html?.cspNonce;
		if (!nonce) return;
		const s$2 = new MagicString(html);
		await traverseHtml(html, filename, config$2.logger.warn, (node) => {
			if (!nodeIsElement(node)) return;
			const { nodeName, attrs, sourceCodeLocation } = node;
			if (nodeName === "script" || nodeName === "style" || nodeName === "link" && attrs.some((attr) => attr.name === "rel" && parseRelAttr(attr.value).some((a) => processRelType.has(a)))) {
				if (attrs.some(({ name }) => name === "nonce")) return;
				const startTagEndOffset = sourceCodeLocation.startTag.endOffset;
				const appendOffset = html[startTagEndOffset - 2] === "/" ? 2 : 1;
				s$2.appendRight(startTagEndOffset - appendOffset, ` nonce="${nonce}"`);
			}
		});
		return s$2.toString();
	};
}
function resolveHtmlTransforms(plugins$1) {
	const preHooks = [];
	const normalHooks = [];
	const postHooks = [];
	for (const plugin of plugins$1) {
		const hook = plugin.transformIndexHtml;
		if (!hook) continue;
		if (typeof hook === "function") normalHooks.push(hook);
		else {
			const handler = hook.handler;
			if (hook.order === "pre") preHooks.push(handler);
			else if (hook.order === "post") postHooks.push(handler);
			else normalHooks.push(handler);
		}
	}
	return [
		preHooks,
		normalHooks,
		postHooks
	];
}
const elementsAllowedInHead = new Set([
	"title",
	"base",
	"link",
	"style",
	"meta",
	"script",
	"noscript",
	"template"
]);
function headTagInsertCheck(tags, ctx) {
	if (!tags.length) return;
	const { logger } = ctx.server?.config || {};
	const disallowedTags = tags.filter((tagDescriptor) => !elementsAllowedInHead.has(tagDescriptor.tag));
	if (disallowedTags.length) {
		const dedupedTags = unique(disallowedTags.map((tagDescriptor) => `<${tagDescriptor.tag}>`));
		logger?.warn(import_picocolors$13.default.yellow(import_picocolors$13.default.bold(`[${dedupedTags.join(",")}] can not be used inside the <head> Element, please check the 'injectTo' value`)));
	}
}
async function applyHtmlTransforms(html, hooks, pluginContext, ctx) {
	for (const hook of hooks) {
		const res = await hook.call(pluginContext, html, ctx);
		if (!res) continue;
		if (typeof res === "string") html = res;
		else {
			let tags;
			if (Array.isArray(res)) tags = res;
			else {
				html = res.html || html;
				tags = res.tags;
			}
			let headTags;
			let headPrependTags;
			let bodyTags;
			let bodyPrependTags;
			for (const tag of tags) switch (tag.injectTo) {
				case "body":
					(bodyTags ??= []).push(tag);
					break;
				case "body-prepend":
					(bodyPrependTags ??= []).push(tag);
					break;
				case "head":
					(headTags ??= []).push(tag);
					break;
				default: (headPrependTags ??= []).push(tag);
			}
			headTagInsertCheck([...headTags || [], ...headPrependTags || []], ctx);
			if (headPrependTags) html = injectToHead(html, headPrependTags, true);
			if (headTags) html = injectToHead(html, headTags);
			if (bodyPrependTags) html = injectToBody(html, bodyPrependTags, true);
			if (bodyTags) html = injectToBody(html, bodyTags);
		}
	}
	return html;
}
const importRE = /\bimport\s*(?:"[^"]*[^\\]"|'[^']*[^\\]');*/g;
const commentRE = /\/\*[\s\S]*?\*\/|\/\/.*$/gm;
function isEntirelyImport(code) {
	return !code.replace(importRE, "").replace(commentRE, "").trim().length;
}
function getBaseInHTML(urlRelativePath, config$2) {
	return config$2.base === "./" || config$2.base === "" ? path.posix.join(path.posix.relative(urlRelativePath, "").slice(0, -2), "./") : config$2.base;
}
const headInjectRE = /([ \t]*)<\/head>/i;
const headPrependInjectRE = /([ \t]*)<head[^>]*>/i;
const htmlInjectRE = /<\/html>/i;
const htmlPrependInjectRE = /([ \t]*)<html[^>]*>/i;
const bodyInjectRE = /([ \t]*)<\/body>/i;
const bodyPrependInjectRE = /([ \t]*)<body[^>]*>/i;
const doctypePrependInjectRE = /<!doctype html>/i;
function injectToHead(html, tags, prepend = false) {
	if (tags.length === 0) return html;
	if (prepend) {
		if (headPrependInjectRE.test(html)) return html.replace(headPrependInjectRE, (match, p1) => `${match}\n${serializeTags(tags, incrementIndent(p1))}`);
	} else {
		if (headInjectRE.test(html)) return html.replace(headInjectRE, (match, p1) => `${serializeTags(tags, incrementIndent(p1))}${match}`);
		if (bodyPrependInjectRE.test(html)) return html.replace(bodyPrependInjectRE, (match, p1) => `${serializeTags(tags, p1)}\n${match}`);
	}
	return prependInjectFallback(html, tags);
}
function injectToBody(html, tags, prepend = false) {
	if (tags.length === 0) return html;
	if (prepend) {
		if (bodyPrependInjectRE.test(html)) return html.replace(bodyPrependInjectRE, (match, p1) => `${match}\n${serializeTags(tags, incrementIndent(p1))}`);
		if (headInjectRE.test(html)) return html.replace(headInjectRE, (match, p1) => `${match}\n${serializeTags(tags, p1)}`);
		return prependInjectFallback(html, tags);
	} else {
		if (bodyInjectRE.test(html)) return html.replace(bodyInjectRE, (match, p1) => `${serializeTags(tags, incrementIndent(p1))}${match}`);
		if (htmlInjectRE.test(html)) return html.replace(htmlInjectRE, `${serializeTags(tags)}\n$&`);
		return html + `\n` + serializeTags(tags);
	}
}
function prependInjectFallback(html, tags) {
	if (htmlPrependInjectRE.test(html)) return html.replace(htmlPrependInjectRE, `$&\n${serializeTags(tags)}`);
	if (doctypePrependInjectRE.test(html)) return html.replace(doctypePrependInjectRE, `$&\n${serializeTags(tags)}`);
	return serializeTags(tags) + html;
}
const unaryTags = new Set([
	"link",
	"meta",
	"base"
]);
function serializeTag({ tag, attrs, children }, indent = "") {
	if (unaryTags.has(tag)) return `<${tag}${serializeAttrs(attrs)}>`;
	else return `<${tag}${serializeAttrs(attrs)}>${serializeTags(children, incrementIndent(indent))}</${tag}>`;
}
function serializeTags(tags, indent = "") {
	if (typeof tags === "string") return tags;
	else if (tags && tags.length) return tags.map((tag) => `${indent}${serializeTag(tag, indent)}\n`).join("");
	return "";
}
function serializeAttrs(attrs) {
	let res = "";
	for (const key in attrs) if (typeof attrs[key] === "boolean") res += attrs[key] ? ` ${key}` : ``;
	else res += ` ${key}="${(0, import_escape_html.default)(attrs[key])}"`;
	return res;
}
function incrementIndent(indent = "") {
	return `${indent}${indent[0] === "	" ? "	" : "  "}`;
}

//#endregion
//#region src/node/server/middlewares/transform.ts
var import_picocolors$12 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const debugCache = createDebugger("vite:cache");
const knownIgnoreList = new Set(["/", "/favicon.ico"]);
const documentFetchDests = new Set([
	"document",
	"iframe",
	"frame",
	"fencedframe"
]);
function isDocumentFetchDest(req$4) {
	const fetchDest = req$4.headers["sec-fetch-dest"];
	return fetchDest !== void 0 && documentFetchDests.has(fetchDest);
}
const urlRE$1 = /[?&]url\b/;
const rawRE$1 = /[?&]raw\b/;
const inlineRE$2 = /[?&]inline\b/;
const svgRE = /\.svg\b/;
function isServerAccessDeniedForTransform(config$2, id) {
	if (rawRE$1.test(id) || urlRE$1.test(id) || inlineRE$2.test(id) || svgRE.test(id)) return checkLoadingAccess(config$2, id) !== "allowed";
	return false;
}
/**
* A middleware that short-circuits the middleware chain to serve cached transformed modules
*/
function cachedTransformMiddleware(server) {
	return function viteCachedTransformMiddleware(req$4, res, next) {
		const environment = server.environments.client;
		if (isDocumentFetchDest(req$4)) {
			res.appendHeader("Vary", "Sec-Fetch-Dest");
			return next();
		}
		const ifNoneMatch = req$4.headers["if-none-match"];
		if (ifNoneMatch) {
			const moduleByEtag = environment.moduleGraph.getModuleByEtag(ifNoneMatch);
			if (moduleByEtag?.transformResult?.etag === ifNoneMatch && moduleByEtag.url === req$4.url) {
				if (!isCSSRequest(req$4.url)) {
					debugCache?.(`[304] ${prettifyUrl(req$4.url, server.config.root)}`);
					res.statusCode = 304;
					return res.end();
				}
			}
		}
		next();
	};
}
function transformMiddleware(server) {
	const { root, publicDir } = server.config;
	const publicDirInRoot = publicDir.startsWith(withTrailingSlash(root));
	const publicPath = `${publicDir.slice(root.length)}/`;
	return async function viteTransformMiddleware(req$4, res, next) {
		const environment = server.environments.client;
		if (req$4.method !== "GET" && req$4.method !== "HEAD" || knownIgnoreList.has(req$4.url) || isDocumentFetchDest(req$4)) return next();
		let url$3;
		try {
			url$3 = decodeURI(removeTimestampQuery(req$4.url)).replace(NULL_BYTE_PLACEHOLDER, "\0");
		} catch (e$1) {
			if (e$1 instanceof URIError) {
				server.config.logger.warn(import_picocolors$12.default.yellow(`Malformed URI sequence in request URL: ${removeTimestampQuery(req$4.url)}`));
				return next();
			}
			return next(e$1);
		}
		const withoutQuery = cleanUrl(url$3);
		try {
			if (withoutQuery.endsWith(".map")) if (environment.depsOptimizer?.isOptimizedDepUrl(url$3)) {
				const sourcemapPath = url$3.startsWith(FS_PREFIX) ? fsPathFromId(url$3) : normalizePath(path.resolve(server.config.root, url$3.slice(1)));
				try {
					const map$1 = JSON.parse(await fsp.readFile(sourcemapPath, "utf-8"));
					applySourcemapIgnoreList(map$1, sourcemapPath, server.config.server.sourcemapIgnoreList, server.config.logger);
					return send(req$4, res, JSON.stringify(map$1), "json", { headers: server.config.server.headers });
				} catch {
					const dummySourceMap = {
						version: 3,
						file: sourcemapPath.replace(/\.map$/, ""),
						sources: [],
						sourcesContent: [],
						names: [],
						mappings: ";;;;;;;;;"
					};
					return send(req$4, res, JSON.stringify(dummySourceMap), "json", {
						cacheControl: "no-cache",
						headers: server.config.server.headers
					});
				}
			} else {
				const originalUrl = url$3.replace(/\.map($|\?)/, "$1");
				const map$1 = (await environment.moduleGraph.getModuleByUrl(originalUrl))?.transformResult?.map;
				if (map$1) return send(req$4, res, JSON.stringify(map$1), "json", { headers: server.config.server.headers });
				else return next();
			}
			if (publicDirInRoot && url$3.startsWith(publicPath)) warnAboutExplicitPublicPathInUrl(url$3);
			if (req$4.headers["sec-fetch-dest"] === "script" || isJSRequest(url$3) || isImportRequest(url$3) || isCSSRequest(url$3) || isHTMLProxy(url$3)) {
				url$3 = removeImportQuery(url$3);
				url$3 = unwrapId(url$3);
				if (isCSSRequest(url$3)) {
					if (req$4.headers.accept?.includes("text/css") && !isDirectRequest(url$3)) url$3 = injectQuery(url$3, "direct");
					const ifNoneMatch = req$4.headers["if-none-match"];
					if (ifNoneMatch && (await environment.moduleGraph.getModuleByUrl(url$3))?.transformResult?.etag === ifNoneMatch) {
						debugCache?.(`[304] ${prettifyUrl(url$3, server.config.root)}`);
						res.statusCode = 304;
						return res.end();
					}
				}
				const result = await environment.transformRequest(url$3, { allowId(id) {
					return id[0] === "\0" || !isServerAccessDeniedForTransform(server.config, id);
				} });
				if (result) {
					const depsOptimizer = environment.depsOptimizer;
					const type = isDirectCSSRequest(url$3) ? "css" : "js";
					const isDep = DEP_VERSION_RE.test(url$3) || depsOptimizer?.isOptimizedDepUrl(url$3);
					return send(req$4, res, result.code, type, {
						etag: result.etag,
						cacheControl: isDep ? "max-age=31536000,immutable" : "no-cache",
						headers: server.config.server.headers,
						map: result.map
					});
				}
			}
		} catch (e$1) {
			if (e$1?.code === ERR_OPTIMIZE_DEPS_PROCESSING_ERROR) {
				if (!res.writableEnded) {
					res.statusCode = 504;
					res.statusMessage = "Optimize Deps Processing Error";
					res.end();
				}
				server.config.logger.error(e$1.message);
				return;
			}
			if (e$1?.code === ERR_OUTDATED_OPTIMIZED_DEP) {
				if (!res.writableEnded) {
					res.statusCode = 504;
					res.statusMessage = "Outdated Optimize Dep";
					res.end();
				}
				return;
			}
			if (e$1?.code === ERR_CLOSED_SERVER) {
				if (!res.writableEnded) {
					res.statusCode = 504;
					res.statusMessage = "Outdated Request";
					res.end();
				}
				return;
			}
			if (e$1?.code === ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR) {
				if (!res.writableEnded) {
					res.statusCode = 404;
					res.end();
				}
				server.config.logger.warn(import_picocolors$12.default.yellow(e$1.message));
				return;
			}
			if (e$1?.code === ERR_LOAD_URL) return next();
			if (e$1?.code === ERR_DENIED_ID) {
				const id = e$1.id;
				const servingAccessResult = checkLoadingAccess(server.config, id);
				if (servingAccessResult === "denied") {
					respondWithAccessDenied(id, server, res);
					return true;
				}
				if (servingAccessResult === "fallback") {
					next();
					return true;
				}
				throw new Error(`Unexpected access result for id ${id}`);
			}
			return next(e$1);
		}
		next();
	};
	function warnAboutExplicitPublicPathInUrl(url$3) {
		let warning;
		if (isImportRequest(url$3)) {
			const rawUrl = removeImportQuery(url$3);
			if (urlRE$1.test(url$3)) warning = `Assets in the public directory are served at the root path.\nInstead of ${import_picocolors$12.default.cyan(rawUrl)}, use ${import_picocolors$12.default.cyan(rawUrl.replace(publicPath, "/"))}.`;
			else warning = `Assets in public directory cannot be imported from JavaScript.
If you intend to import that asset, put the file in the src directory, and use ${import_picocolors$12.default.cyan(rawUrl.replace(publicPath, "/src/"))} instead of ${import_picocolors$12.default.cyan(rawUrl)}.\nIf you intend to use the URL of that asset, use ${import_picocolors$12.default.cyan(injectQuery(rawUrl.replace(publicPath, "/"), "url"))}.`;
		} else warning = `Files in the public directory are served at the root path.\nInstead of ${import_picocolors$12.default.cyan(url$3)}, use ${import_picocolors$12.default.cyan(url$3.replace(publicPath, "/"))}.`;
		server.config.logger.warn(import_picocolors$12.default.yellow(warning));
	}
}

//#endregion
//#region src/node/server/middlewares/indexHtml.ts
function createDevHtmlTransformFn(config$2) {
	const [preHooks, normalHooks, postHooks] = resolveHtmlTransforms(config$2.plugins);
	const transformHooks = [
		preImportMapHook(config$2),
		injectCspNonceMetaTagHook(config$2),
		...preHooks,
		htmlEnvHook(config$2),
		devHtmlHook,
		...normalHooks,
		...postHooks,
		injectNonceAttributeTagHook(config$2),
		postImportMapHook()
	];
	const pluginContext = new BasicMinimalPluginContext({
		...basePluginContextMeta,
		watchMode: true
	}, config$2.logger);
	return (server, url$3, html, originalUrl) => {
		return applyHtmlTransforms(html, transformHooks, pluginContext, {
			path: url$3,
			filename: getHtmlFilename(url$3, server),
			server,
			originalUrl
		});
	};
}
function getHtmlFilename(url$3, server) {
	if (url$3.startsWith(FS_PREFIX)) return decodeURIComponent(fsPathFromId(url$3));
	else return decodeURIComponent(normalizePath(path.join(server.config.root, url$3.slice(1))));
}
function shouldPreTransform(url$3, config$2) {
	return !checkPublicFile(url$3, config$2) && (isJSRequest(url$3) || isCSSRequest(url$3));
}
const wordCharRE = /\w/;
function isBareRelative(url$3) {
	return wordCharRE.test(url$3[0]) && !url$3.includes(":");
}
const processNodeUrl = (url$3, useSrcSetReplacer, config$2, htmlPath, originalUrl, server, isClassicScriptLink) => {
	const replacer = (url$4) => {
		if (url$4[0] === "/" && url$4[1] !== "/" || (url$4[0] === "." || isBareRelative(url$4)) && originalUrl && originalUrl !== "/" && htmlPath === "/index.html") url$4 = path.posix.join(config$2.base, url$4);
		let preTransformUrl;
		if (!isClassicScriptLink && shouldPreTransform(url$4, config$2)) {
			if (url$4[0] === "/" && url$4[1] !== "/") preTransformUrl = url$4;
			else if (url$4[0] === "." || isBareRelative(url$4)) preTransformUrl = path.posix.join(config$2.base, path.posix.dirname(htmlPath), url$4);
		}
		if (server) {
			const mod = server.environments.client.moduleGraph.urlToModuleMap.get(preTransformUrl || url$4);
			if (mod && mod.lastHMRTimestamp > 0) url$4 = injectQuery(url$4, `t=${mod.lastHMRTimestamp}`);
		}
		if (server && preTransformUrl) {
			try {
				preTransformUrl = decodeURI(preTransformUrl);
			} catch {
				return url$4;
			}
			preTransformRequest(server, preTransformUrl, config$2.decodedBase);
		}
		return url$4;
	};
	return useSrcSetReplacer ? processSrcSetSync(url$3, ({ url: url$4 }) => replacer(url$4)) : replacer(url$3);
};
const devHtmlHook = async (html, { path: htmlPath, filename, server, originalUrl }) => {
	const { config: config$2, watcher } = server;
	const base = config$2.base || "/";
	const decodedBase = config$2.decodedBase || "/";
	let proxyModulePath;
	let proxyModuleUrl;
	const trailingSlash = htmlPath.endsWith("/");
	if (!trailingSlash && fs.existsSync(filename)) {
		proxyModulePath = htmlPath;
		proxyModuleUrl = proxyModulePath;
	} else {
		proxyModulePath = `\0${`${htmlPath}${trailingSlash ? "index.html" : ""}`}`;
		proxyModuleUrl = wrapId(proxyModulePath);
	}
	proxyModuleUrl = joinUrlSegments(decodedBase, proxyModuleUrl);
	const s$2 = new MagicString(html);
	let inlineModuleIndex = -1;
	const proxyCacheUrl = decodeURI(cleanUrl(proxyModulePath).replace(normalizePath(config$2.root), ""));
	const styleUrl = [];
	const inlineStyles = [];
	const inlineModulePaths = [];
	const addInlineModule = (node, ext) => {
		inlineModuleIndex++;
		const contentNode = node.childNodes[0];
		const code = contentNode.value;
		let map$1;
		if (proxyModulePath[0] !== "\0") {
			map$1 = new MagicString(html).snip(contentNode.sourceCodeLocation.startOffset, contentNode.sourceCodeLocation.endOffset).generateMap({ hires: "boundary" });
			map$1.sources = [filename];
			map$1.file = filename;
		}
		addToHTMLProxyCache(config$2, proxyCacheUrl, inlineModuleIndex, {
			code,
			map: map$1
		});
		const modulePath = `${proxyModuleUrl}?html-proxy&index=${inlineModuleIndex}.${ext}`;
		inlineModulePaths.push(modulePath);
		s$2.update(node.sourceCodeLocation.startOffset, node.sourceCodeLocation.endOffset, `<script type="module" src="${modulePath}"><\/script>`);
		preTransformRequest(server, modulePath, decodedBase);
	};
	await traverseHtml(html, filename, config$2.logger.warn, (node) => {
		if (!nodeIsElement(node)) return;
		if (node.nodeName === "script") {
			const { src, srcSourceCodeLocation, isModule, isIgnored } = getScriptInfo(node);
			if (isIgnored) removeViteIgnoreAttr(s$2, node.sourceCodeLocation);
			else if (src) {
				const processedUrl = processNodeUrl(src.value, false, config$2, htmlPath, originalUrl, server, !isModule);
				if (processedUrl !== src.value) overwriteAttrValue(s$2, srcSourceCodeLocation, processedUrl);
			} else if (isModule && node.childNodes.length) addInlineModule(node, "js");
			else if (node.childNodes.length) {
				const scriptNode = node.childNodes[node.childNodes.length - 1];
				for (const { url: url$3, start, end } of extractImportExpressionFromClassicScript(scriptNode)) {
					const processedUrl = processNodeUrl(url$3, false, config$2, htmlPath, originalUrl);
					if (processedUrl !== url$3) s$2.update(start, end, processedUrl);
				}
			}
		}
		const inlineStyle = findNeedTransformStyleAttribute(node);
		if (inlineStyle) {
			inlineModuleIndex++;
			inlineStyles.push({
				index: inlineModuleIndex,
				location: inlineStyle.location,
				code: inlineStyle.attr.value
			});
		}
		if (node.nodeName === "style" && node.childNodes.length) {
			const children = node.childNodes[0];
			styleUrl.push({
				start: children.sourceCodeLocation.startOffset,
				end: children.sourceCodeLocation.endOffset,
				code: children.value
			});
		}
		const assetAttributes = getNodeAssetAttributes(node);
		for (const attr of assetAttributes) if (attr.type === "remove") s$2.remove(attr.location.startOffset, attr.location.endOffset);
		else {
			const processedUrl = processNodeUrl(attr.value, attr.type === "srcset", config$2, htmlPath, originalUrl);
			if (processedUrl !== attr.value) overwriteAttrValue(s$2, attr.location, processedUrl);
		}
	});
	const clientModuelGraph = server?.environments.client.moduleGraph;
	if (clientModuelGraph) await Promise.all(inlineModulePaths.map(async (url$3) => {
		const module$1 = await clientModuelGraph.getModuleByUrl(url$3);
		if (module$1) clientModuelGraph.invalidateModule(module$1);
	}));
	await Promise.all([...styleUrl.map(async ({ start, end, code }, index) => {
		const url$3 = `${proxyModulePath}?html-proxy&direct&index=${index}.css`;
		const mod = await server.environments.client.moduleGraph.ensureEntryFromUrl(url$3, false);
		ensureWatchedFile(watcher, mod.file, config$2.root);
		const result = await server.environments.client.pluginContainer.transform(code, mod.id);
		let content = "";
		if (result.map && "version" in result.map) {
			if (result.map.mappings) await injectSourcesContent(result.map, proxyModulePath, config$2.logger);
			content = getCodeWithSourcemap("css", result.code, result.map);
		} else content = result.code;
		s$2.overwrite(start, end, content);
	}), ...inlineStyles.map(async ({ index, location: location$1, code }) => {
		const url$3 = `${proxyModulePath}?html-proxy&inline-css&style-attr&index=${index}.css`;
		const mod = await server.environments.client.moduleGraph.ensureEntryFromUrl(url$3, false);
		ensureWatchedFile(watcher, mod.file, config$2.root);
		await server?.environments.client.pluginContainer.transform(code, mod.id);
		const hash$1 = getHash(cleanUrl(mod.id));
		overwriteAttrValue(s$2, location$1, htmlProxyResult.get(`${hash$1}_${index}`) ?? "");
	})]);
	html = s$2.toString();
	return {
		html,
		tags: [{
			tag: "script",
			attrs: {
				type: "module",
				src: path.posix.join(base, CLIENT_PUBLIC_PATH)
			},
			injectTo: "head-prepend"
		}]
	};
};
function indexHtmlMiddleware(root, server) {
	const isDev = isDevServer(server);
	return async function viteIndexHtmlMiddleware(req$4, res, next) {
		if (res.writableEnded) return next();
		const url$3 = req$4.url && cleanUrl(req$4.url);
		if (url$3?.endsWith(".html") && req$4.headers["sec-fetch-dest"] !== "script") {
			let filePath;
			if (isDev && url$3.startsWith(FS_PREFIX)) filePath = decodeURIComponent(fsPathFromId(url$3));
			else filePath = normalizePath(path.resolve(path.join(root, decodeURIComponent(url$3))));
			if (isDev) {
				const servingAccessResult = checkLoadingAccess(server.config, filePath);
				if (servingAccessResult === "denied") return respondWithAccessDenied(filePath, server, res);
				if (servingAccessResult === "fallback") return next();
			} else if (!isParentDirectory(root, filePath)) return next();
			if (fs.existsSync(filePath)) {
				const headers = isDev ? server.config.server.headers : server.config.preview.headers;
				try {
					let html = await fsp.readFile(filePath, "utf-8");
					if (isDev) html = await server.transformIndexHtml(url$3, html, req$4.originalUrl);
					return send(req$4, res, html, "html", { headers });
				} catch (e$1) {
					return next(e$1);
				}
			}
		}
		next();
	};
}
function preTransformRequest(server, decodedUrl, decodedBase) {
	if (!server.config.server.preTransformRequests) return;
	decodedUrl = unwrapId(stripBase(decodedUrl, decodedBase));
	server.warmupRequest(decodedUrl);
}

//#endregion
//#region src/node/server/middlewares/time.ts
const logTime = createDebugger("vite:time");
function timeMiddleware(root) {
	return function viteTimeMiddleware(req$4, res, next) {
		const start = performance$1.now();
		const end = res.end;
		res.end = (...args) => {
			logTime?.(`${timeFrom(start)} ${prettifyUrl(req$4.url, root)}`);
			return end.call(res, ...args);
		};
		next();
	};
}

//#endregion
//#region src/node/server/mixedModuleGraph.ts
/**
* Backward compatible ModuleNode and ModuleGraph with mixed nodes from both the client and ssr environments
* It would be good to take the types names for the new EnvironmentModuleNode and EnvironmentModuleGraph but we can't
* do that at this point without breaking to much code in the ecosystem.
* We are going to deprecate these types and we can try to use them back in the future.
*/
const EMPTY_OBJECT$1 = Object.freeze({});
var ModuleNode = class {
	_moduleGraph;
	_clientModule;
	_ssrModule;
	constructor(moduleGraph, clientModule, ssrModule) {
		this._moduleGraph = moduleGraph;
		this._clientModule = clientModule;
		this._ssrModule = ssrModule;
	}
	_get(prop) {
		return this._clientModule?.[prop] ?? this._ssrModule?.[prop];
	}
	_set(prop, value$1) {
		if (this._clientModule) this._clientModule[prop] = value$1;
		if (this._ssrModule) this._ssrModule[prop] = value$1;
	}
	_wrapModuleSet(prop, module$1) {
		if (!module$1) return /* @__PURE__ */ new Set();
		return createBackwardCompatibleModuleSet(this._moduleGraph, prop, module$1);
	}
	_getModuleSetUnion(prop) {
		const importedModules = /* @__PURE__ */ new Set();
		const ids = /* @__PURE__ */ new Set();
		if (this._clientModule) for (const mod of this._clientModule[prop]) {
			if (mod.id) ids.add(mod.id);
			importedModules.add(this._moduleGraph.getBackwardCompatibleModuleNode(mod));
		}
		if (this._ssrModule) {
			for (const mod of this._ssrModule[prop]) if (mod.id && !ids.has(mod.id)) importedModules.add(this._moduleGraph.getBackwardCompatibleModuleNode(mod));
		}
		return importedModules;
	}
	_getModuleInfoUnion(prop) {
		const _clientValue = this._clientModule?.[prop];
		const _ssrValue = this._ssrModule?.[prop];
		if (_clientValue == null && _ssrValue == null) return void 0;
		return new Proxy({}, { get: (_, key) => {
			if (key === "meta") return this.meta || EMPTY_OBJECT$1;
			if (_clientValue) {
				if (key in _clientValue) return _clientValue[key];
			}
			if (_ssrValue) {
				if (key in _ssrValue) return _ssrValue[key];
			}
		} });
	}
	_getModuleObjectUnion(prop) {
		const _clientValue = this._clientModule?.[prop];
		const _ssrValue = this._ssrModule?.[prop];
		if (_clientValue == null && _ssrValue == null) return void 0;
		const info = {};
		if (_ssrValue) Object.assign(info, _ssrValue);
		if (_clientValue) Object.assign(info, _clientValue);
		return info;
	}
	get url() {
		return this._get("url");
	}
	set url(value$1) {
		this._set("url", value$1);
	}
	get id() {
		return this._get("id");
	}
	set id(value$1) {
		this._set("id", value$1);
	}
	get file() {
		return this._get("file");
	}
	set file(value$1) {
		this._set("file", value$1);
	}
	get type() {
		return this._get("type");
	}
	get info() {
		return this._getModuleInfoUnion("info");
	}
	get meta() {
		return this._getModuleObjectUnion("meta");
	}
	get importers() {
		return this._getModuleSetUnion("importers");
	}
	get clientImportedModules() {
		return this._wrapModuleSet("importedModules", this._clientModule);
	}
	get ssrImportedModules() {
		return this._wrapModuleSet("importedModules", this._ssrModule);
	}
	get importedModules() {
		return this._getModuleSetUnion("importedModules");
	}
	get acceptedHmrDeps() {
		return this._wrapModuleSet("acceptedHmrDeps", this._clientModule);
	}
	get acceptedHmrExports() {
		return this._clientModule?.acceptedHmrExports ?? null;
	}
	get importedBindings() {
		return this._clientModule?.importedBindings ?? null;
	}
	get isSelfAccepting() {
		return this._clientModule?.isSelfAccepting;
	}
	get transformResult() {
		return this._clientModule?.transformResult ?? null;
	}
	set transformResult(value$1) {
		if (this._clientModule) this._clientModule.transformResult = value$1;
	}
	get ssrTransformResult() {
		return this._ssrModule?.transformResult ?? null;
	}
	set ssrTransformResult(value$1) {
		if (this._ssrModule) this._ssrModule.transformResult = value$1;
	}
	get ssrModule() {
		return this._ssrModule?.ssrModule ?? null;
	}
	get ssrError() {
		return this._ssrModule?.ssrError ?? null;
	}
	get lastHMRTimestamp() {
		return Math.max(this._clientModule?.lastHMRTimestamp ?? 0, this._ssrModule?.lastHMRTimestamp ?? 0);
	}
	set lastHMRTimestamp(value$1) {
		if (this._clientModule) this._clientModule.lastHMRTimestamp = value$1;
		if (this._ssrModule) this._ssrModule.lastHMRTimestamp = value$1;
	}
	get lastInvalidationTimestamp() {
		return Math.max(this._clientModule?.lastInvalidationTimestamp ?? 0, this._ssrModule?.lastInvalidationTimestamp ?? 0);
	}
	get invalidationState() {
		return this._clientModule?.invalidationState;
	}
	get ssrInvalidationState() {
		return this._ssrModule?.invalidationState;
	}
};
function mapIterator(iterable, transform$2) {
	return {
		[Symbol.iterator]() {
			return this;
		},
		next() {
			const r$1 = iterable.next();
			return r$1.done ? r$1 : {
				value: transform$2(r$1.value),
				done: false
			};
		}
	};
}
var ModuleGraph = class {
	/** @internal */
	_moduleGraphs;
	/** @internal */
	get _client() {
		return this._moduleGraphs.client();
	}
	/** @internal */
	get _ssr() {
		return this._moduleGraphs.ssr();
	}
	urlToModuleMap;
	idToModuleMap;
	etagToModuleMap;
	fileToModulesMap;
	moduleNodeCache = new DualWeakMap();
	constructor(moduleGraphs) {
		this._moduleGraphs = moduleGraphs;
		const getModuleMapUnion = (prop) => () => {
			if (this._ssr[prop].size === 0) return this._client[prop];
			const map$1 = new Map(this._client[prop]);
			for (const [key, module$1] of this._ssr[prop]) if (!map$1.has(key)) map$1.set(key, module$1);
			return map$1;
		};
		this.urlToModuleMap = createBackwardCompatibleModuleMap(this, "urlToModuleMap", getModuleMapUnion("urlToModuleMap"));
		this.idToModuleMap = createBackwardCompatibleModuleMap(this, "idToModuleMap", getModuleMapUnion("idToModuleMap"));
		this.etagToModuleMap = createBackwardCompatibleModuleMap(this, "etagToModuleMap", () => this._client.etagToModuleMap);
		this.fileToModulesMap = createBackwardCompatibleFileToModulesMap(this);
	}
	getModuleById(id) {
		const clientModule = this._client.getModuleById(id);
		const ssrModule = this._ssr.getModuleById(id);
		if (!clientModule && !ssrModule) return;
		return this.getBackwardCompatibleModuleNodeDual(clientModule, ssrModule);
	}
	async getModuleByUrl(url$3, _ssr) {
		const [clientModule, ssrModule] = await Promise.all([this._client.getModuleByUrl(url$3), this._ssr.getModuleByUrl(url$3)]);
		if (!clientModule && !ssrModule) return;
		return this.getBackwardCompatibleModuleNodeDual(clientModule, ssrModule);
	}
	getModulesByFile(file) {
		const clientModules = this._client.getModulesByFile(file);
		const ssrModules = this._ssr.getModulesByFile(file);
		if (!clientModules && !ssrModules) return;
		const result = /* @__PURE__ */ new Set();
		if (clientModules) for (const mod of clientModules) result.add(this.getBackwardCompatibleBrowserModuleNode(mod));
		if (ssrModules) {
			for (const mod of ssrModules) if (mod.id == null || !this._client.getModuleById(mod.id)) result.add(this.getBackwardCompatibleServerModuleNode(mod));
		}
		return result;
	}
	onFileChange(file) {
		this._client.onFileChange(file);
		this._ssr.onFileChange(file);
	}
	onFileDelete(file) {
		this._client.onFileDelete(file);
		this._ssr.onFileDelete(file);
	}
	/** @internal */
	_getModuleGraph(environment) {
		switch (environment) {
			case "client": return this._client;
			case "ssr": return this._ssr;
			default: throw new Error(`Invalid module node environment ${environment}`);
		}
	}
	invalidateModule(mod, seen$1 = /* @__PURE__ */ new Set(), timestamp = monotonicDateNow(), isHmr = false, softInvalidate = false) {
		if (mod._clientModule) this._client.invalidateModule(mod._clientModule, new Set([...seen$1].map((mod$1) => mod$1._clientModule).filter(Boolean)), timestamp, isHmr, softInvalidate);
		if (mod._ssrModule) this._ssr.invalidateModule(mod._ssrModule, new Set([...seen$1].map((mod$1) => mod$1._ssrModule).filter(Boolean)), timestamp, isHmr, softInvalidate);
	}
	invalidateAll() {
		this._client.invalidateAll();
		this._ssr.invalidateAll();
	}
	async ensureEntryFromUrl(rawUrl, ssr, setIsSelfAccepting = true) {
		const module$1 = await (ssr ? this._ssr : this._client).ensureEntryFromUrl(rawUrl, setIsSelfAccepting);
		return this.getBackwardCompatibleModuleNode(module$1);
	}
	createFileOnlyEntry(file) {
		const clientModule = this._client.createFileOnlyEntry(file);
		const ssrModule = this._ssr.createFileOnlyEntry(file);
		return this.getBackwardCompatibleModuleNodeDual(clientModule, ssrModule);
	}
	async resolveUrl(url$3, ssr) {
		return ssr ? this._ssr.resolveUrl(url$3) : this._client.resolveUrl(url$3);
	}
	updateModuleTransformResult(mod, result, ssr) {
		const environment = ssr ? "ssr" : "client";
		this._getModuleGraph(environment).updateModuleTransformResult(environment === "client" ? mod._clientModule : mod._ssrModule, result);
	}
	getModuleByEtag(etag$1) {
		const mod = this._client.etagToModuleMap.get(etag$1);
		return mod && this.getBackwardCompatibleBrowserModuleNode(mod);
	}
	getBackwardCompatibleBrowserModuleNode(clientModule) {
		return this.getBackwardCompatibleModuleNodeDual(clientModule, clientModule.id ? this._ssr.getModuleById(clientModule.id) : void 0);
	}
	getBackwardCompatibleServerModuleNode(ssrModule) {
		return this.getBackwardCompatibleModuleNodeDual(ssrModule.id ? this._client.getModuleById(ssrModule.id) : void 0, ssrModule);
	}
	getBackwardCompatibleModuleNode(mod) {
		return mod.environment === "client" ? this.getBackwardCompatibleBrowserModuleNode(mod) : this.getBackwardCompatibleServerModuleNode(mod);
	}
	getBackwardCompatibleModuleNodeDual(clientModule, ssrModule) {
		const cached = this.moduleNodeCache.get(clientModule, ssrModule);
		if (cached) return cached;
		const moduleNode = new ModuleNode(this, clientModule, ssrModule);
		this.moduleNodeCache.set(clientModule, ssrModule, moduleNode);
		return moduleNode;
	}
};
var DualWeakMap = class {
	map = /* @__PURE__ */ new WeakMap();
	undefinedKey = {};
	get(key1, key2) {
		const k1 = key1 ?? this.undefinedKey;
		const k2 = key2 ?? this.undefinedKey;
		return this.map.get(k1)?.get(k2);
	}
	set(key1, key2, value$1) {
		const k1 = key1 ?? this.undefinedKey;
		const k2 = key2 ?? this.undefinedKey;
		if (!this.map.has(k1)) this.map.set(k1, /* @__PURE__ */ new Map());
		this.map.get(k1).set(k2, value$1);
	}
};
function createBackwardCompatibleModuleSet(moduleGraph, prop, module$1) {
	return {
		[Symbol.iterator]() {
			return this.keys();
		},
		has(key) {
			if (!key.id) return false;
			const keyModule = moduleGraph._getModuleGraph(module$1.environment).getModuleById(key.id);
			return keyModule !== void 0 && module$1[prop].has(keyModule);
		},
		values() {
			return this.keys();
		},
		keys() {
			return mapIterator(module$1[prop].keys(), (mod) => moduleGraph.getBackwardCompatibleModuleNode(mod));
		},
		get size() {
			return module$1[prop].size;
		},
		forEach(callback, thisArg) {
			return module$1[prop].forEach((mod) => {
				const backwardCompatibleMod = moduleGraph.getBackwardCompatibleModuleNode(mod);
				callback.call(thisArg, backwardCompatibleMod, backwardCompatibleMod, this);
			});
		}
	};
}
function createBackwardCompatibleModuleMap(moduleGraph, prop, getModuleMap) {
	return {
		[Symbol.iterator]() {
			return this.entries();
		},
		get(key) {
			const clientModule = moduleGraph._client[prop].get(key);
			const ssrModule = moduleGraph._ssr[prop].get(key);
			if (!clientModule && !ssrModule) return;
			return moduleGraph.getBackwardCompatibleModuleNodeDual(clientModule, ssrModule);
		},
		set(key, mod) {
			const clientModule = mod._clientModule;
			if (clientModule) moduleGraph._client[prop].set(key, clientModule);
			const ssrModule = mod._ssrModule;
			if (ssrModule) moduleGraph._ssr[prop].set(key, ssrModule);
		},
		keys() {
			return getModuleMap().keys();
		},
		values() {
			return mapIterator(getModuleMap().values(), (mod) => moduleGraph.getBackwardCompatibleModuleNode(mod));
		},
		entries() {
			return mapIterator(getModuleMap().entries(), ([key, mod]) => [key, moduleGraph.getBackwardCompatibleModuleNode(mod)]);
		},
		get size() {
			return getModuleMap().size;
		},
		forEach(callback, thisArg) {
			return getModuleMap().forEach((mod, key) => {
				const backwardCompatibleMod = moduleGraph.getBackwardCompatibleModuleNode(mod);
				callback.call(thisArg, backwardCompatibleMod, key, this);
			});
		}
	};
}
function createBackwardCompatibleFileToModulesMap(moduleGraph) {
	const getFileToModulesMap = () => {
		if (!moduleGraph._ssr.fileToModulesMap.size) return moduleGraph._client.fileToModulesMap;
		const map$1 = new Map(moduleGraph._client.fileToModulesMap);
		for (const [key, modules] of moduleGraph._ssr.fileToModulesMap) {
			const modulesSet = map$1.get(key);
			if (!modulesSet) map$1.set(key, modules);
			else for (const ssrModule of modules) {
				let hasModule = false;
				for (const clientModule of modulesSet) {
					hasModule ||= clientModule.id === ssrModule.id;
					if (hasModule) break;
				}
				if (!hasModule) modulesSet.add(ssrModule);
			}
		}
		return map$1;
	};
	const getBackwardCompatibleModules = (modules) => new Set([...modules].map((mod) => moduleGraph.getBackwardCompatibleModuleNode(mod)));
	return {
		[Symbol.iterator]() {
			return this.entries();
		},
		get(key) {
			const clientModules = moduleGraph._client.fileToModulesMap.get(key);
			const ssrModules = moduleGraph._ssr.fileToModulesMap.get(key);
			if (!clientModules && !ssrModules) return;
			const modules = clientModules ?? /* @__PURE__ */ new Set();
			if (ssrModules) {
				for (const ssrModule of ssrModules) if (ssrModule.id) {
					let found$1 = false;
					for (const mod of modules) {
						found$1 ||= mod.id === ssrModule.id;
						if (found$1) break;
					}
					if (!found$1) modules.add(ssrModule);
				}
			}
			return getBackwardCompatibleModules(modules);
		},
		keys() {
			return getFileToModulesMap().keys();
		},
		values() {
			return mapIterator(getFileToModulesMap().values(), getBackwardCompatibleModules);
		},
		entries() {
			return mapIterator(getFileToModulesMap().entries(), ([key, modules]) => [key, getBackwardCompatibleModules(modules)]);
		},
		get size() {
			return getFileToModulesMap().size;
		},
		forEach(callback, thisArg) {
			return getFileToModulesMap().forEach((modules, key) => {
				callback.call(thisArg, getBackwardCompatibleModules(modules), key, this);
			});
		}
	};
}

//#endregion
//#region src/node/server/middlewares/notFound.ts
function notFoundMiddleware() {
	return function vite404Middleware(_, res) {
		res.statusCode = 404;
		res.end();
	};
}

//#endregion
//#region src/node/server/searchRoot.ts
const ROOT_FILES = ["pnpm-workspace.yaml", "lerna.json"];
function hasWorkspacePackageJSON(root) {
	const path$13 = join(root, "package.json");
	if (!isFileReadable(path$13)) return false;
	try {
		return !!(JSON.parse(fs.readFileSync(path$13, "utf-8")) || {}).workspaces;
	} catch {
		return false;
	}
}
function hasRootFile(root) {
	return ROOT_FILES.some((file) => fs.existsSync(join(root, file)));
}
function hasPackageJSON(root) {
	const path$13 = join(root, "package.json");
	return fs.existsSync(path$13);
}
/**
* Search up for the nearest `package.json`
*/
function searchForPackageRoot(current, root = current) {
	if (hasPackageJSON(current)) return current;
	const dir = dirname(current);
	if (!dir || dir === current) return root;
	return searchForPackageRoot(dir, root);
}
/**
* Search up for the nearest workspace root
*/
function searchForWorkspaceRoot(current, root = searchForPackageRoot(current)) {
	if (hasRootFile(current)) return current;
	if (hasWorkspacePackageJSON(current)) return current;
	const dir = dirname(current);
	if (!dir || dir === current) return root;
	return searchForWorkspaceRoot(dir, root);
}

//#endregion
//#region src/node/server/middlewares/hostCheck.ts
function getAdditionalAllowedHosts(resolvedServerOptions, resolvedPreviewOptions) {
	const list = [];
	if (typeof resolvedServerOptions.host === "string" && resolvedServerOptions.host) list.push(resolvedServerOptions.host);
	if (typeof resolvedServerOptions.hmr === "object" && resolvedServerOptions.hmr.host) list.push(resolvedServerOptions.hmr.host);
	if (typeof resolvedPreviewOptions.host === "string" && resolvedPreviewOptions.host) list.push(resolvedPreviewOptions.host);
	if (resolvedServerOptions.origin) try {
		const serverOriginUrl = new URL(resolvedServerOptions.origin);
		list.push(serverOriginUrl.hostname);
	} catch {}
	return list;
}
function hostValidationMiddleware(allowedHosts, isPreview) {
	return hostValidationMiddleware$1({
		allowedHosts: Object.freeze([...allowedHosts]),
		generateErrorMessage(hostname) {
			const hostnameWithQuotes = JSON.stringify(hostname);
			return `Blocked request. This host (${hostnameWithQuotes}) is not allowed.\nTo allow this host, add ${hostnameWithQuotes} to \`${`${isPreview ? "preview" : "server"}.allowedHosts`}\` in vite.config.js.`;
		}
	});
}

//#endregion
//#region src/node/server/middlewares/rejectInvalidRequest.ts
function rejectInvalidRequestMiddleware() {
	return function viteRejectInvalidRequestMiddleware(req$4, res, next) {
		if (req$4.url?.includes("#")) {
			res.writeHead(400);
			res.end();
			return;
		}
		return next();
	};
}

//#endregion
//#region src/node/server/index.ts
var import_connect$1 = /* @__PURE__ */ __toESM(require_connect(), 1);
var import_lib$1 = /* @__PURE__ */ __toESM(require_lib$1(), 1);
var import_picocolors$11 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
var import_chokidar = /* @__PURE__ */ __toESM(require_chokidar(), 1);
var import_launch_editor_middleware = /* @__PURE__ */ __toESM(require_launch_editor_middleware(), 1);
const usedConfigs = /* @__PURE__ */ new WeakSet();
function createServer$2(inlineConfig = {}) {
	return _createServer(inlineConfig, { listen: true });
}
async function _createServer(inlineConfig = {}, options$1) {
	const config$2 = isResolvedConfig(inlineConfig) ? inlineConfig : await resolveConfig(inlineConfig, "serve");
	if (usedConfigs.has(config$2)) throw new Error(`There is already a server associated with the config.`);
	if (config$2.command !== "serve") throw new Error(`Config was resolved for a "build", expected a "serve" command.`);
	usedConfigs.add(config$2);
	const initPublicFilesPromise = initPublicFiles(config$2);
	const { root, server: serverConfig } = config$2;
	const httpsOptions = await resolveHttpsConfig(config$2.server.https);
	const { middlewareMode } = serverConfig;
	const resolvedOutDirs = getResolvedOutDirs(config$2.root, config$2.build.outDir, config$2.build.rollupOptions.output);
	const emptyOutDir = resolveEmptyOutDir(config$2.build.emptyOutDir, config$2.root, resolvedOutDirs);
	const resolvedWatchOptions = resolveChokidarOptions({
		disableGlobbing: true,
		...serverConfig.watch
	}, resolvedOutDirs, emptyOutDir, config$2.cacheDir);
	const middlewares = (0, import_connect$1.default)();
	const httpServer = middlewareMode ? null : await resolveHttpServer(serverConfig, middlewares, httpsOptions);
	const ws = createWebSocketServer(httpServer, config$2, httpsOptions);
	const publicFiles = await initPublicFilesPromise;
	const { publicDir } = config$2;
	if (httpServer) setClientErrorHandler(httpServer, config$2.logger);
	const watcher = serverConfig.watch !== null ? import_chokidar.watch([
		root,
		...config$2.configFileDependencies,
		...getEnvFilesForMode(config$2.mode, config$2.envDir),
		...publicDir && publicFiles ? [publicDir] : []
	], resolvedWatchOptions) : createNoopWatcher(resolvedWatchOptions);
	const environments = {};
	for (const [name, environmentOptions] of Object.entries(config$2.environments)) environments[name] = await environmentOptions.dev.createEnvironment(name, config$2, { ws });
	for (const environment of Object.values(environments)) {
		const previousInstance = options$1.previousEnvironments?.[environment.name];
		await environment.init({
			watcher,
			previousInstance
		});
	}
	let moduleGraph = new ModuleGraph({
		client: () => environments.client.moduleGraph,
		ssr: () => environments.ssr.moduleGraph
	});
	let pluginContainer = createPluginContainer(environments);
	const closeHttpServer = createServerCloseFn(httpServer);
	const devHtmlTransformFn = createDevHtmlTransformFn(config$2);
	let closeServerPromise;
	const closeServer = async () => {
		if (!middlewareMode) teardownSIGTERMListener(closeServerAndExit);
		await Promise.allSettled([
			watcher.close(),
			ws.close(),
			Promise.allSettled(Object.values(server.environments).map((environment) => environment.close())),
			closeHttpServer(),
			server._ssrCompatModuleRunner?.close()
		]);
		server.resolvedUrls = null;
		server._ssrCompatModuleRunner = void 0;
	};
	let hot = ws;
	let server = {
		config: config$2,
		middlewares,
		httpServer,
		watcher,
		ws,
		get hot() {
			warnFutureDeprecation(config$2, "removeServerHot");
			return hot;
		},
		set hot(h$2) {
			hot = h$2;
		},
		environments,
		get pluginContainer() {
			warnFutureDeprecation(config$2, "removeServerPluginContainer");
			return pluginContainer;
		},
		set pluginContainer(p) {
			pluginContainer = p;
		},
		get moduleGraph() {
			warnFutureDeprecation(config$2, "removeServerModuleGraph");
			return moduleGraph;
		},
		set moduleGraph(graph) {
			moduleGraph = graph;
		},
		resolvedUrls: null,
		ssrTransform(code, inMap, url$3, originalCode = code) {
			return ssrTransform(code, inMap, url$3, originalCode, { json: { stringify: config$2.json.stringify === true && config$2.json.namedExports !== true } });
		},
		transformRequest(url$3, options$2) {
			warnFutureDeprecation(config$2, "removeServerTransformRequest");
			return server.environments[options$2?.ssr ? "ssr" : "client"].transformRequest(url$3);
		},
		warmupRequest(url$3, options$2) {
			warnFutureDeprecation(config$2, "removeServerWarmupRequest");
			return server.environments[options$2?.ssr ? "ssr" : "client"].warmupRequest(url$3);
		},
		transformIndexHtml(url$3, html, originalUrl) {
			return devHtmlTransformFn(server, url$3, html, originalUrl);
		},
		async ssrLoadModule(url$3, opts) {
			warnFutureDeprecation(config$2, "removeSsrLoadModule");
			return ssrLoadModule(url$3, server, opts?.fixStacktrace);
		},
		ssrFixStacktrace(e$1) {
			warnFutureDeprecation(config$2, "removeSsrLoadModule", "ssrFixStacktrace doesn't need to be used for Environment Module Runners.");
			ssrFixStacktrace(e$1, server.environments.ssr.moduleGraph);
		},
		ssrRewriteStacktrace(stack) {
			warnFutureDeprecation(config$2, "removeSsrLoadModule", "ssrRewriteStacktrace doesn't need to be used for Environment Module Runners.");
			return ssrRewriteStacktrace(stack, server.environments.ssr.moduleGraph);
		},
		async reloadModule(module$1) {
			warnFutureDeprecation(config$2, "removeServerReloadModule");
			if (serverConfig.hmr !== false && module$1.file) {
				const environmentModule = module$1._clientModule ?? module$1._ssrModule;
				updateModules(environments[environmentModule.environment], module$1.file, [environmentModule], monotonicDateNow());
			}
		},
		async listen(port, isRestart) {
			const hostname = await resolveHostname(config$2.server.host);
			if (httpServer) httpServer.prependListener("listening", () => {
				server.resolvedUrls = resolveServerUrls(httpServer, config$2.server, hostname, httpsOptions, config$2);
			});
			await startServer(server, hostname, port);
			if (httpServer) {
				if (!isRestart && config$2.server.open) server.openBrowser();
			}
			return server;
		},
		openBrowser() {
			const options$2 = server.config.server;
			const url$3 = getServerUrlByHost(server.resolvedUrls, options$2.host);
			if (url$3) {
				const path$13 = typeof options$2.open === "string" ? new URL(options$2.open, url$3).href : url$3;
				if (server.config.server.preTransformRequests) setTimeout(() => {
					(path$13.startsWith("https:") ? get$1 : get)(path$13, { headers: { Accept: "text/html" } }, (res) => {
						res.on("end", () => {});
					}).on("error", () => {}).end();
				}, 0);
				openBrowser(path$13, true, server.config.logger);
			} else server.config.logger.warn("No URL available to open in browser");
		},
		async close() {
			if (!closeServerPromise) closeServerPromise = closeServer();
			return closeServerPromise;
		},
		printUrls() {
			if (server.resolvedUrls) printServerUrls(server.resolvedUrls, serverConfig.host, config$2.logger.info);
			else if (middlewareMode) throw new Error("cannot print server URLs in middleware mode.");
			else throw new Error("cannot print server URLs before server.listen is called.");
		},
		bindCLIShortcuts(options$2) {
			bindCLIShortcuts(server, options$2);
		},
		async restart(forceOptimize) {
			if (!server._restartPromise) {
				server._forceOptimizeOnRestart = !!forceOptimize;
				server._restartPromise = restartServer(server).finally(() => {
					server._restartPromise = null;
					server._forceOptimizeOnRestart = false;
				});
			}
			return server._restartPromise;
		},
		waitForRequestsIdle(ignoredId) {
			return environments.client.waitForRequestsIdle(ignoredId);
		},
		_setInternalServer(_server) {
			server = _server;
		},
		_restartPromise: null,
		_forceOptimizeOnRestart: false,
		_shortcutsOptions: void 0
	};
	const reflexServer = new Proxy(server, {
		get: (_, property) => {
			return server[property];
		},
		set: (_, property, value$1) => {
			server[property] = value$1;
			return true;
		}
	});
	const closeServerAndExit = async (_, exitCode) => {
		try {
			await server.close();
		} finally {
			process.exitCode ??= exitCode ? 128 + exitCode : void 0;
			process.exit();
		}
	};
	if (!middlewareMode) setupSIGTERMListener(closeServerAndExit);
	const onHMRUpdate = async (type, file) => {
		if (serverConfig.hmr !== false) await handleHMRUpdate(type, file, server);
	};
	const onFileAddUnlink = async (file, isUnlink) => {
		file = normalizePath(file);
		reloadOnTsconfigChange(server, file);
		await pluginContainer.watchChange(file, { event: isUnlink ? "delete" : "create" });
		if (publicDir && publicFiles) {
			if (file.startsWith(publicDir)) {
				const path$13 = file.slice(publicDir.length);
				publicFiles[isUnlink ? "delete" : "add"](path$13);
				if (!isUnlink) {
					const clientModuleGraph = server.environments.client.moduleGraph;
					const etag$1 = (await clientModuleGraph.getModuleByUrl(path$13))?.transformResult?.etag;
					if (etag$1) clientModuleGraph.etagToModuleMap.delete(etag$1);
				}
			}
		}
		if (isUnlink) for (const environment of Object.values(server.environments)) environment.moduleGraph.onFileDelete(file);
		await onHMRUpdate(isUnlink ? "delete" : "create", file);
	};
	watcher.on("change", async (file) => {
		file = normalizePath(file);
		reloadOnTsconfigChange(server, file);
		await pluginContainer.watchChange(file, { event: "update" });
		for (const environment of Object.values(server.environments)) environment.moduleGraph.onFileChange(file);
		await onHMRUpdate("update", file);
	});
	watcher.on("add", (file) => {
		onFileAddUnlink(file, false);
	});
	watcher.on("unlink", (file) => {
		onFileAddUnlink(file, true);
	});
	if (!middlewareMode && httpServer) httpServer.once("listening", () => {
		serverConfig.port = httpServer.address().port;
	});
	if (process.env.DEBUG) middlewares.use(timeMiddleware(root));
	middlewares.use(rejectInvalidRequestMiddleware());
	const { cors } = serverConfig;
	if (cors !== false) middlewares.use((0, import_lib$1.default)(typeof cors === "boolean" ? {} : cors));
	const { allowedHosts } = serverConfig;
	if (allowedHosts !== true && !serverConfig.https) middlewares.use(hostValidationMiddleware(allowedHosts, false));
	const configureServerContext = new BasicMinimalPluginContext({
		...basePluginContextMeta,
		watchMode: true
	}, config$2.logger);
	const postHooks = [];
	for (const hook of config$2.getSortedPluginHooks("configureServer")) postHooks.push(await hook.call(configureServerContext, reflexServer));
	middlewares.use(cachedTransformMiddleware(server));
	const { proxy } = serverConfig;
	if (proxy) {
		const middlewareServer = (isObject(middlewareMode) ? middlewareMode.server : null) || httpServer;
		middlewares.use(proxyMiddleware(middlewareServer, proxy, config$2));
	}
	if (config$2.base !== "/") middlewares.use(baseMiddleware(config$2.rawBase, !!middlewareMode));
	middlewares.use("/__open-in-editor", (0, import_launch_editor_middleware.default)());
	middlewares.use(function viteHMRPingMiddleware(req$4, res, next) {
		if (req$4.headers["accept"] === "text/x-vite-ping") res.writeHead(204).end();
		else next();
	});
	if (publicDir) middlewares.use(servePublicMiddleware(server, publicFiles));
	middlewares.use(transformMiddleware(server));
	middlewares.use(serveRawFsMiddleware(server));
	middlewares.use(serveStaticMiddleware(server));
	if (config$2.appType === "spa" || config$2.appType === "mpa") middlewares.use(htmlFallbackMiddleware(root, config$2.appType === "spa"));
	postHooks.forEach((fn) => fn && fn());
	if (config$2.appType === "spa" || config$2.appType === "mpa") {
		middlewares.use(indexHtmlMiddleware(root, server));
		middlewares.use(notFoundMiddleware());
	}
	middlewares.use(errorMiddleware(server, !!middlewareMode));
	let initingServer;
	let serverInited = false;
	const initServer = async (onListen) => {
		if (serverInited) return;
		if (initingServer) return initingServer;
		initingServer = (async function() {
			await environments.client.pluginContainer.buildStart();
			if (onListen || options$1.listen) await Promise.all(Object.values(environments).map((e$1) => e$1.listen(server)));
			initingServer = void 0;
			serverInited = true;
		})();
		return initingServer;
	};
	if (!middlewareMode && httpServer) {
		const listen = httpServer.listen.bind(httpServer);
		httpServer.listen = (async (port, ...args) => {
			try {
				await initServer(true);
			} catch (e$1) {
				httpServer.emit("error", e$1);
				return;
			}
			return listen(port, ...args);
		});
	} else await initServer(false);
	return server;
}
async function startServer(server, hostname, inlinePort) {
	const httpServer = server.httpServer;
	if (!httpServer) throw new Error("Cannot call server.listen in middleware mode.");
	const options$1 = server.config.server;
	const configPort = inlinePort ?? options$1.port;
	const port = (!configPort || configPort === server._configServerPort ? server._currentServerPort : configPort) ?? DEFAULT_DEV_PORT;
	server._configServerPort = configPort;
	server._currentServerPort = await httpServerStart(httpServer, {
		port,
		strictPort: options$1.strictPort,
		host: hostname.host,
		logger: server.config.logger
	});
}
function createServerCloseFn(server) {
	if (!server) return () => Promise.resolve();
	let hasListened = false;
	const openSockets = /* @__PURE__ */ new Set();
	server.on("connection", (socket) => {
		openSockets.add(socket);
		socket.on("close", () => {
			openSockets.delete(socket);
		});
	});
	server.once("listening", () => {
		hasListened = true;
	});
	return () => new Promise((resolve$4, reject) => {
		openSockets.forEach((s$2) => s$2.destroy());
		if (hasListened) server.close((err$2) => {
			if (err$2) reject(err$2);
			else resolve$4();
		});
		else resolve$4();
	});
}
function resolvedAllowDir(root, dir) {
	return normalizePath(path.resolve(root, dir));
}
const serverConfigDefaults = Object.freeze({
	port: DEFAULT_DEV_PORT,
	strictPort: false,
	host: "localhost",
	allowedHosts: [],
	https: void 0,
	open: false,
	proxy: void 0,
	cors: { origin: defaultAllowedOrigins },
	headers: {},
	warmup: {
		clientFiles: [],
		ssrFiles: []
	},
	middlewareMode: false,
	fs: {
		strict: true,
		deny: [
			".env",
			".env.*",
			"*.{crt,pem}",
			"**/.git/**"
		]
	},
	preTransformRequests: true,
	perEnvironmentStartEndDuringDev: false
});
function resolveServerOptions(root, raw, logger) {
	const _server = mergeWithDefaults({
		...serverConfigDefaults,
		host: void 0,
		sourcemapIgnoreList: isInNodeModules
	}, raw ?? {});
	const server = {
		..._server,
		fs: {
			..._server.fs,
			allow: raw?.fs?.allow ?? [searchForWorkspaceRoot(root)]
		},
		sourcemapIgnoreList: _server.sourcemapIgnoreList === false ? () => false : _server.sourcemapIgnoreList
	};
	let allowDirs = server.fs.allow;
	if (process.versions.pnp) {
		const cwd = searchForPackageRoot(root);
		try {
			const yarnCacheDir = execSync(`yarn config get ${execSync("yarn config get enableGlobalCache", { cwd }).toString().trim() === "true" ? "globalFolder" : "cacheFolder"}`, { cwd }).toString().trim();
			allowDirs.push(yarnCacheDir);
		} catch (e$1) {
			logger.warn(`Get yarn cache dir error: ${e$1.message}`, { timestamp: true });
		}
	}
	allowDirs = allowDirs.map((i$1) => resolvedAllowDir(root, i$1));
	const resolvedClientDir = resolvedAllowDir(root, CLIENT_DIR);
	if (!allowDirs.some((dir) => isParentDirectory(dir, resolvedClientDir))) allowDirs.push(resolvedClientDir);
	server.fs.allow = allowDirs;
	if (server.origin?.endsWith("/")) {
		server.origin = server.origin.slice(0, -1);
		logger.warn(import_picocolors$11.default.yellow(`${import_picocolors$11.default.bold("(!)")} server.origin should not end with "/". Using "${server.origin}" instead.`));
	}
	if (process.env.__VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS && Array.isArray(server.allowedHosts)) {
		const additionalHost = process.env.__VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS;
		server.allowedHosts = [...server.allowedHosts, additionalHost];
	}
	return server;
}
async function restartServer(server) {
	global.__vite_start_time = performance$1.now();
	const shortcutsOptions = server._shortcutsOptions;
	let inlineConfig = server.config.inlineConfig;
	if (server._forceOptimizeOnRestart) inlineConfig = mergeConfig(inlineConfig, { forceOptimizeDeps: true });
	{
		let newServer = null;
		try {
			newServer = await _createServer(inlineConfig, {
				listen: false,
				previousEnvironments: server.environments
			});
		} catch (err$2) {
			server.config.logger.error(err$2.message, { timestamp: true });
			server.config.logger.error("server restart failed", { timestamp: true });
			return;
		}
		await server.close();
		const middlewares = server.middlewares;
		newServer._configServerPort = server._configServerPort;
		newServer._currentServerPort = server._currentServerPort;
		Object.assign(server, newServer);
		middlewares.stack = newServer.middlewares.stack;
		server.middlewares = middlewares;
		newServer._setInternalServer(server);
	}
	const { logger, server: { port, middlewareMode } } = server.config;
	if (!middlewareMode) await server.listen(port, true);
	else await Promise.all(Object.values(server.environments).map((e$1) => e$1.listen(server)));
	logger.info("server restarted.", { timestamp: true });
	if (shortcutsOptions) {
		shortcutsOptions.print = false;
		bindCLIShortcuts(server, shortcutsOptions);
	}
}
/**
* Internal function to restart the Vite server and print URLs if changed
*/
async function restartServerWithUrls(server) {
	if (server.config.server.middlewareMode) {
		await server.restart();
		return;
	}
	const { port: prevPort, host: prevHost } = server.config.server;
	const prevUrls = server.resolvedUrls;
	await server.restart();
	const { logger, server: { port, host } } = server.config;
	if ((port ?? DEFAULT_DEV_PORT) !== (prevPort ?? DEFAULT_DEV_PORT) || host !== prevHost || diffDnsOrderChange(prevUrls, server.resolvedUrls)) {
		logger.info("");
		server.printUrls();
	}
}

//#endregion
//#region src/node/server/hmr.ts
var import_picocolors$10 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const debugHmr = createDebugger("vite:hmr");
const whitespaceRE = /\s/;
const normalizedClientDir = normalizePath(CLIENT_DIR);
function getShortName(file, root) {
	return file.startsWith(withTrailingSlash(root)) ? path.posix.relative(root, file) : file;
}
const normalizeHotChannel = (channel, enableHmr, normalizeClient = true) => {
	const normalizedListenerMap = /* @__PURE__ */ new WeakMap();
	const listenersForEvents = /* @__PURE__ */ new Map();
	let invokeHandlers;
	let listenerForInvokeHandler;
	const handleInvoke = async (payload) => {
		if (!invokeHandlers) return { error: {
			name: "TransportError",
			message: "invokeHandlers is not set",
			stack: (/* @__PURE__ */ new Error()).stack
		} };
		const { name, data: args } = payload.data;
		try {
			const invokeHandler = invokeHandlers[name];
			return { result: await invokeHandler(...args) };
		} catch (error$1) {
			return { error: {
				name: error$1.name,
				message: error$1.message,
				stack: error$1.stack,
				...error$1
			} };
		}
	};
	return {
		...channel,
		on: (event, fn) => {
			if (event === "connection" || !normalizeClient) {
				channel.on?.(event, fn);
				return;
			}
			const listenerWithNormalizedClient = (data, client) => {
				fn(data, { send: (...args) => {
					let payload;
					if (typeof args[0] === "string") payload = {
						type: "custom",
						event: args[0],
						data: args[1]
					};
					else payload = args[0];
					client.send(payload);
				} });
			};
			normalizedListenerMap.set(fn, listenerWithNormalizedClient);
			channel.on?.(event, listenerWithNormalizedClient);
			if (!listenersForEvents.has(event)) listenersForEvents.set(event, /* @__PURE__ */ new Set());
			listenersForEvents.get(event).add(listenerWithNormalizedClient);
		},
		off: (event, fn) => {
			if (event === "connection" || !normalizeClient) {
				channel.off?.(event, fn);
				return;
			}
			const normalizedListener = normalizedListenerMap.get(fn);
			if (normalizedListener) {
				channel.off?.(event, normalizedListener);
				listenersForEvents.get(event)?.delete(normalizedListener);
			}
		},
		setInvokeHandler(_invokeHandlers) {
			invokeHandlers = _invokeHandlers;
			if (!_invokeHandlers) {
				if (listenerForInvokeHandler) channel.off?.("vite:invoke", listenerForInvokeHandler);
				return;
			}
			listenerForInvokeHandler = async (payload, client) => {
				const responseInvoke = payload.id.replace("send", "response");
				client.send({
					type: "custom",
					event: "vite:invoke",
					data: {
						name: payload.name,
						id: responseInvoke,
						data: await handleInvoke({
							type: "custom",
							event: "vite:invoke",
							data: payload
						})
					}
				});
			};
			channel.on?.("vite:invoke", listenerForInvokeHandler);
		},
		handleInvoke,
		send: (...args) => {
			let payload;
			if (typeof args[0] === "string") payload = {
				type: "custom",
				event: args[0],
				data: args[1]
			};
			else payload = args[0];
			if (enableHmr || payload.type === "connected" || payload.type === "ping" || payload.type === "custom" || payload.type === "error") channel.send?.(payload);
		},
		listen() {
			return channel.listen?.();
		},
		close() {
			return channel.close?.();
		}
	};
};
function getSortedPluginsByHotUpdateHook(plugins$1) {
	const sortedPlugins = [];
	let pre = 0, normal = 0, post = 0;
	for (const plugin of plugins$1) {
		const hook = plugin["hotUpdate"] ?? plugin["handleHotUpdate"];
		if (hook) {
			if (typeof hook === "object") {
				if (hook.order === "pre") {
					sortedPlugins.splice(pre++, 0, plugin);
					continue;
				}
				if (hook.order === "post") {
					sortedPlugins.splice(pre + normal + post++, 0, plugin);
					continue;
				}
			}
			sortedPlugins.splice(pre + normal++, 0, plugin);
		}
	}
	return sortedPlugins;
}
const sortedHotUpdatePluginsCache = /* @__PURE__ */ new WeakMap();
function getSortedHotUpdatePlugins(environment) {
	let sortedPlugins = sortedHotUpdatePluginsCache.get(environment);
	if (!sortedPlugins) {
		sortedPlugins = getSortedPluginsByHotUpdateHook(environment.plugins);
		sortedHotUpdatePluginsCache.set(environment, sortedPlugins);
	}
	return sortedPlugins;
}
async function handleHMRUpdate(type, file, server) {
	const { config: config$2 } = server;
	const mixedModuleGraph = ignoreDeprecationWarnings(() => server.moduleGraph);
	const environments = Object.values(server.environments);
	const shortFile = getShortName(file, config$2.root);
	const isConfig = file === config$2.configFile;
	const isConfigDependency = config$2.configFileDependencies.some((name) => file === name);
	const isEnv = config$2.envDir !== false && getEnvFilesForMode(config$2.mode, config$2.envDir).includes(file);
	if (isConfig || isConfigDependency || isEnv) {
		debugHmr?.(`[config change] ${import_picocolors$10.default.dim(shortFile)}`);
		config$2.logger.info(import_picocolors$10.default.green(`${normalizePath(path.relative(process.cwd(), file))} changed, restarting server...`), {
			clear: true,
			timestamp: true
		});
		try {
			await restartServerWithUrls(server);
		} catch (e$1) {
			config$2.logger.error(import_picocolors$10.default.red(e$1));
		}
		return;
	}
	debugHmr?.(`[file change] ${import_picocolors$10.default.dim(shortFile)}`);
	if (file.startsWith(withTrailingSlash(normalizedClientDir))) {
		environments.forEach(({ hot }) => hot.send({
			type: "full-reload",
			path: "*",
			triggeredBy: path.resolve(config$2.root, file)
		}));
		return;
	}
	const timestamp = monotonicDateNow();
	const contextMeta = {
		type,
		file,
		timestamp,
		read: () => readModifiedFile(file),
		server
	};
	const hotMap = /* @__PURE__ */ new Map();
	for (const environment of Object.values(server.environments)) {
		const mods = new Set(environment.moduleGraph.getModulesByFile(file));
		if (type === "create") for (const mod of environment.moduleGraph._hasResolveFailedErrorModules) mods.add(mod);
		const options$1 = {
			...contextMeta,
			modules: [...mods]
		};
		hotMap.set(environment, { options: options$1 });
	}
	const mixedMods = new Set(mixedModuleGraph.getModulesByFile(file));
	const mixedHmrContext = {
		...contextMeta,
		modules: [...mixedMods]
	};
	const contextForHandleHotUpdate = new BasicMinimalPluginContext({
		...basePluginContextMeta,
		watchMode: true
	}, config$2.logger);
	const clientEnvironment = server.environments.client;
	const ssrEnvironment = server.environments.ssr;
	const clientContext = clientEnvironment.pluginContainer.minimalContext;
	const clientHotUpdateOptions = hotMap.get(clientEnvironment).options;
	const ssrHotUpdateOptions = hotMap.get(ssrEnvironment)?.options;
	try {
		for (const plugin of getSortedHotUpdatePlugins(server.environments.client)) if (plugin.hotUpdate) {
			const filteredModules = await getHookHandler(plugin.hotUpdate).call(clientContext, clientHotUpdateOptions);
			if (filteredModules) {
				clientHotUpdateOptions.modules = filteredModules;
				mixedHmrContext.modules = mixedHmrContext.modules.filter((mixedMod) => filteredModules.some((mod) => mixedMod.id === mod.id) || ssrHotUpdateOptions?.modules.some((ssrMod) => ssrMod.id === mixedMod.id));
				mixedHmrContext.modules.push(...filteredModules.filter((mod) => !mixedHmrContext.modules.some((mixedMod) => mixedMod.id === mod.id)).map((mod) => mixedModuleGraph.getBackwardCompatibleModuleNode(mod)));
			}
		} else if (type === "update") {
			warnFutureDeprecation(config$2, "removePluginHookHandleHotUpdate", `Used in plugin "${plugin.name}".`, false);
			const filteredModules = await getHookHandler(plugin.handleHotUpdate).call(contextForHandleHotUpdate, mixedHmrContext);
			if (filteredModules) {
				mixedHmrContext.modules = filteredModules;
				clientHotUpdateOptions.modules = clientHotUpdateOptions.modules.filter((mod) => filteredModules.some((mixedMod) => mod.id === mixedMod.id));
				clientHotUpdateOptions.modules.push(...filteredModules.filter((mixedMod) => !clientHotUpdateOptions.modules.some((mod) => mod.id === mixedMod.id)).map((mixedMod) => mixedMod._clientModule).filter(Boolean));
				if (ssrHotUpdateOptions) {
					ssrHotUpdateOptions.modules = ssrHotUpdateOptions.modules.filter((mod) => filteredModules.some((mixedMod) => mod.id === mixedMod.id));
					ssrHotUpdateOptions.modules.push(...filteredModules.filter((mixedMod) => !ssrHotUpdateOptions.modules.some((mod) => mod.id === mixedMod.id)).map((mixedMod) => mixedMod._ssrModule).filter(Boolean));
				}
			}
		}
	} catch (error$1) {
		hotMap.get(server.environments.client).error = error$1;
	}
	for (const environment of Object.values(server.environments)) {
		if (environment.name === "client") continue;
		const hot = hotMap.get(environment);
		const context = environment.pluginContainer.minimalContext;
		try {
			for (const plugin of getSortedHotUpdatePlugins(environment)) if (plugin.hotUpdate) {
				const filteredModules = await getHookHandler(plugin.hotUpdate).call(context, hot.options);
				if (filteredModules) hot.options.modules = filteredModules;
			}
		} catch (error$1) {
			hot.error = error$1;
		}
	}
	async function hmr(environment) {
		try {
			const { options: options$1, error: error$1 } = hotMap.get(environment);
			if (error$1) throw error$1;
			if (!options$1.modules.length) {
				if (file.endsWith(".html") && environment.name === "client") {
					environment.logger.info(import_picocolors$10.default.green(`page reload `) + import_picocolors$10.default.dim(shortFile), {
						clear: true,
						timestamp: true
					});
					environment.hot.send({
						type: "full-reload",
						path: config$2.server.middlewareMode ? "*" : "/" + normalizePath(path.relative(config$2.root, file))
					});
				} else debugHmr?.(`(${environment.name}) [no modules matched] ${import_picocolors$10.default.dim(shortFile)}`);
				return;
			}
			updateModules(environment, shortFile, options$1.modules, timestamp);
		} catch (err$2) {
			environment.hot.send({
				type: "error",
				err: prepareError(err$2)
			});
		}
	}
	await (server.config.server.hotUpdateEnvironments ?? ((server$1, hmr$1) => {
		return Promise.all(Object.values(server$1.environments).map((environment) => hmr$1(environment)));
	}))(server, hmr);
}
function updateModules(environment, file, modules, timestamp, firstInvalidatedBy) {
	const { hot } = environment;
	const updates = [];
	const invalidatedModules = /* @__PURE__ */ new Set();
	const traversedModules = /* @__PURE__ */ new Set();
	let needFullReload = modules.length === 0;
	for (const mod of modules) {
		const boundaries = [];
		const hasDeadEnd = propagateUpdate(mod, traversedModules, boundaries);
		environment.moduleGraph.invalidateModule(mod, invalidatedModules, timestamp, true);
		if (needFullReload) continue;
		if (hasDeadEnd) {
			needFullReload = hasDeadEnd;
			continue;
		}
		if (firstInvalidatedBy && boundaries.some(({ acceptedVia }) => normalizeHmrUrl(acceptedVia.url) === firstInvalidatedBy)) {
			needFullReload = "circular import invalidate";
			continue;
		}
		updates.push(...boundaries.map(({ boundary, acceptedVia, isWithinCircularImport }) => ({
			type: `${boundary.type}-update`,
			timestamp,
			path: normalizeHmrUrl(boundary.url),
			acceptedPath: normalizeHmrUrl(acceptedVia.url),
			explicitImportRequired: boundary.type === "js" ? isExplicitImportRequired(acceptedVia.url) : false,
			isWithinCircularImport,
			firstInvalidatedBy
		})));
	}
	const isClientHtmlChange = file.endsWith(".html") && environment.name === "client" && modules.every((mod) => mod.type !== "js");
	if (needFullReload || isClientHtmlChange) {
		const reason = typeof needFullReload === "string" ? import_picocolors$10.default.dim(` (${needFullReload})`) : "";
		environment.logger.info(import_picocolors$10.default.green(`page reload `) + import_picocolors$10.default.dim(file) + reason, {
			clear: !firstInvalidatedBy,
			timestamp: true
		});
		hot.send({
			type: "full-reload",
			triggeredBy: path.resolve(environment.config.root, file),
			path: !isClientHtmlChange || environment.config.server.middlewareMode || updates.length > 0 ? "*" : "/" + file
		});
		return;
	}
	if (updates.length === 0) {
		debugHmr?.(import_picocolors$10.default.yellow(`no update happened `) + import_picocolors$10.default.dim(file));
		return;
	}
	environment.logger.info(import_picocolors$10.default.green(`hmr update `) + import_picocolors$10.default.dim([...new Set(updates.map((u) => u.path))].join(", ")), {
		clear: !firstInvalidatedBy,
		timestamp: true
	});
	hot.send({
		type: "update",
		updates
	});
}
function areAllImportsAccepted(importedBindings, acceptedExports) {
	for (const binding of importedBindings) if (!acceptedExports.has(binding)) return false;
	return true;
}
function propagateUpdate(node, traversedModules, boundaries, currentChain = [node]) {
	if (traversedModules.has(node)) return false;
	traversedModules.add(node);
	if (node.id && node.isSelfAccepting === void 0) {
		debugHmr?.(`[propagate update] stop propagation because not analyzed: ${import_picocolors$10.default.dim(node.id)}`);
		return false;
	}
	if (node.isSelfAccepting) {
		const boundary = node;
		boundaries.push({
			boundary,
			acceptedVia: boundary,
			isWithinCircularImport: isNodeWithinCircularImports(node, currentChain)
		});
		return false;
	}
	if (node.acceptedHmrExports) {
		const boundary = node;
		boundaries.push({
			boundary,
			acceptedVia: boundary,
			isWithinCircularImport: isNodeWithinCircularImports(node, currentChain)
		});
	} else if (!node.importers.size) return true;
	for (const importer of node.importers) {
		const subChain = currentChain.concat(importer);
		if (importer.acceptedHmrDeps.has(node)) {
			boundaries.push({
				boundary: importer,
				acceptedVia: node,
				isWithinCircularImport: isNodeWithinCircularImports(importer, subChain)
			});
			continue;
		}
		if (node.id && node.acceptedHmrExports && importer.importedBindings) {
			const importedBindingsFromNode = importer.importedBindings.get(node.id);
			if (importedBindingsFromNode && areAllImportsAccepted(importedBindingsFromNode, node.acceptedHmrExports)) continue;
		}
		if (!currentChain.includes(importer) && propagateUpdate(importer, traversedModules, boundaries, subChain)) return true;
	}
	return false;
}
/**
* Check importers recursively if it's an import loop. An accepted module within
* an import loop cannot recover its execution order and should be reloaded.
*
* @param node The node that accepts HMR and is a boundary
* @param nodeChain The chain of nodes/imports that lead to the node.
*   (The last node in the chain imports the `node` parameter)
* @param currentChain The current chain tracked from the `node` parameter
* @param traversedModules The set of modules that have traversed
*/
function isNodeWithinCircularImports(node, nodeChain, currentChain = [node], traversedModules = /* @__PURE__ */ new Set()) {
	if (traversedModules.has(node)) return false;
	traversedModules.add(node);
	for (const importer of node.importers) {
		if (importer === node) continue;
		const importerIndex = nodeChain.indexOf(importer);
		if (importerIndex > -1) {
			if (debugHmr) {
				const importChain = [
					importer,
					...[...currentChain].reverse(),
					...nodeChain.slice(importerIndex, -1).reverse()
				];
				debugHmr(import_picocolors$10.default.yellow(`circular imports detected: `) + importChain.map((m$2) => import_picocolors$10.default.dim(m$2.url)).join(" -> "));
			}
			return true;
		}
		if (!currentChain.includes(importer)) {
			const result = isNodeWithinCircularImports(importer, nodeChain, currentChain.concat(importer), traversedModules);
			if (result) return result;
		}
	}
	return false;
}
function handlePrunedModules(mods, { hot }) {
	const t$1 = monotonicDateNow();
	mods.forEach((mod) => {
		mod.lastHMRTimestamp = t$1;
		mod.lastHMRInvalidationReceived = false;
		debugHmr?.(`[dispose] ${import_picocolors$10.default.dim(mod.file)}`);
	});
	hot.send({
		type: "prune",
		paths: [...mods].map((m$2) => m$2.url)
	});
}
var LexerState = /* @__PURE__ */ function(LexerState$1) {
	LexerState$1[LexerState$1["inCall"] = 0] = "inCall";
	LexerState$1[LexerState$1["inSingleQuoteString"] = 1] = "inSingleQuoteString";
	LexerState$1[LexerState$1["inDoubleQuoteString"] = 2] = "inDoubleQuoteString";
	LexerState$1[LexerState$1["inTemplateString"] = 3] = "inTemplateString";
	LexerState$1[LexerState$1["inArray"] = 4] = "inArray";
	return LexerState$1;
}(LexerState || {});
/**
* Lex import.meta.hot.accept() for accepted deps.
* Since hot.accept() can only accept string literals or array of string
* literals, we don't really need a heavy @babel/parse call on the entire source.
*
* @returns selfAccepts
*/
function lexAcceptedHmrDeps(code, start, urls) {
	let state = LexerState.inCall;
	let prevState = LexerState.inCall;
	let currentDep = "";
	function addDep(index) {
		urls.add({
			url: currentDep,
			start: index - currentDep.length - 1,
			end: index + 1
		});
		currentDep = "";
	}
	for (let i$1 = start; i$1 < code.length; i$1++) {
		const char = code.charAt(i$1);
		switch (state) {
			case LexerState.inCall:
			case LexerState.inArray:
				if (char === `'`) {
					prevState = state;
					state = LexerState.inSingleQuoteString;
				} else if (char === `"`) {
					prevState = state;
					state = LexerState.inDoubleQuoteString;
				} else if (char === "`") {
					prevState = state;
					state = LexerState.inTemplateString;
				} else if (whitespaceRE.test(char)) continue;
				else if (state === LexerState.inCall) if (char === `[`) state = LexerState.inArray;
				else return true;
				else if (char === `]`) return false;
				else if (char === ",") continue;
				else error(i$1);
				break;
			case LexerState.inSingleQuoteString:
				if (char === `'`) {
					addDep(i$1);
					if (prevState === LexerState.inCall) return false;
					else state = prevState;
				} else currentDep += char;
				break;
			case LexerState.inDoubleQuoteString:
				if (char === `"`) {
					addDep(i$1);
					if (prevState === LexerState.inCall) return false;
					else state = prevState;
				} else currentDep += char;
				break;
			case LexerState.inTemplateString:
				if (char === "`") {
					addDep(i$1);
					if (prevState === LexerState.inCall) return false;
					else state = prevState;
				} else if (char === "$" && code.charAt(i$1 + 1) === "{") error(i$1);
				else currentDep += char;
				break;
			default: throw new Error("unknown import.meta.hot lexer state");
		}
	}
	return false;
}
function lexAcceptedHmrExports(code, start, exportNames) {
	const urls = /* @__PURE__ */ new Set();
	lexAcceptedHmrDeps(code, start, urls);
	for (const { url: url$3 } of urls) exportNames.add(url$3);
	return urls.size > 0;
}
function normalizeHmrUrl(url$3) {
	if (url$3[0] !== "." && url$3[0] !== "/") url$3 = wrapId(url$3);
	return url$3;
}
function error(pos) {
	const err$2 = /* @__PURE__ */ new Error("import.meta.hot.accept() can only accept string literals or an Array of string literals.");
	err$2.pos = pos;
	throw err$2;
}
async function readModifiedFile(file) {
	const content = await fsp.readFile(file, "utf-8");
	if (!content) {
		const mtime = (await fsp.stat(file)).mtimeMs;
		for (let n$2 = 0; n$2 < 10; n$2++) {
			await new Promise((r$1) => setTimeout(r$1, 10));
			if ((await fsp.stat(file)).mtimeMs !== mtime) break;
		}
		return await fsp.readFile(file, "utf-8");
	} else return content;
}
function createServerHotChannel() {
	const innerEmitter = new EventEmitter();
	const outsideEmitter = new EventEmitter();
	return {
		send(payload) {
			outsideEmitter.emit("send", payload);
		},
		off(event, listener$1) {
			innerEmitter.off(event, listener$1);
		},
		on: ((event, listener$1) => {
			innerEmitter.on(event, listener$1);
		}),
		close() {
			innerEmitter.removeAllListeners();
			outsideEmitter.removeAllListeners();
		},
		listen() {
			innerEmitter.emit("connection");
		},
		api: {
			innerEmitter,
			outsideEmitter
		}
	};
}

//#endregion
//#region src/node/plugins/define.ts
const nonJsRe = /\.json(?:$|\?)/;
const isNonJsRequest = (request) => nonJsRe.test(request);
const importMetaEnvMarker = "__vite_import_meta_env__";
const importMetaEnvKeyReCache = /* @__PURE__ */ new Map();
const escapedDotRE = /(?<!\\)\\./g;
function definePlugin(config$2) {
	const isBuild = config$2.command === "build";
	const isBuildLib = isBuild && config$2.build.lib;
	const processEnv = {};
	if (!isBuildLib) {
		const nodeEnv = process.env.NODE_ENV || config$2.mode;
		Object.assign(processEnv, {
			"process.env": `{}`,
			"global.process.env": `{}`,
			"globalThis.process.env": `{}`,
			"process.env.NODE_ENV": JSON.stringify(nodeEnv),
			"global.process.env.NODE_ENV": JSON.stringify(nodeEnv),
			"globalThis.process.env.NODE_ENV": JSON.stringify(nodeEnv)
		});
	}
	const importMetaKeys = {};
	const importMetaEnvKeys = {};
	const importMetaFallbackKeys = {};
	if (isBuild) {
		importMetaKeys["import.meta.hot"] = `undefined`;
		for (const key in config$2.env) {
			const val = JSON.stringify(config$2.env[key]);
			importMetaKeys[`import.meta.env.${key}`] = val;
			importMetaEnvKeys[key] = val;
		}
		importMetaKeys["import.meta.env.SSR"] = `undefined`;
		importMetaFallbackKeys["import.meta.env"] = `undefined`;
	}
	function generatePattern(environment) {
		const keepProcessEnv = environment.config.keepProcessEnv;
		const userDefine = {};
		const userDefineEnv = {};
		for (const key in environment.config.define) {
			userDefine[key] = handleDefineValue(environment.config.define[key]);
			if (isBuild && key.startsWith("import.meta.env.")) userDefineEnv[key.slice(16)] = environment.config.define[key];
		}
		const define$1 = {
			...keepProcessEnv ? {} : processEnv,
			...importMetaKeys,
			...userDefine,
			...importMetaFallbackKeys
		};
		const ssr = environment.config.consumer === "server";
		if ("import.meta.env.SSR" in define$1) define$1["import.meta.env.SSR"] = ssr + "";
		if ("import.meta.env" in define$1) define$1["import.meta.env"] = importMetaEnvMarker;
		const importMetaEnvVal = serializeDefine({
			...importMetaEnvKeys,
			SSR: ssr + "",
			...userDefineEnv
		});
		const patternKeys = Object.keys(userDefine);
		if (!keepProcessEnv && Object.keys(processEnv).length) patternKeys.push("process.env");
		if (Object.keys(importMetaKeys).length) patternKeys.push("import.meta.env", "import.meta.hot");
		return [
			define$1,
			patternKeys.length ? new RegExp(patternKeys.map((key) => escapeRegex(key).replaceAll(escapedDotRE, "\\??\\.")).join("|")) : null,
			importMetaEnvVal
		];
	}
	const patternsCache = /* @__PURE__ */ new WeakMap();
	function getPattern(environment) {
		let pattern = patternsCache.get(environment);
		if (!pattern) {
			pattern = generatePattern(environment);
			patternsCache.set(environment, pattern);
		}
		return pattern;
	}
	return {
		name: "vite:define",
		transform: { async handler(code, id) {
			if (this.environment.config.consumer === "client" && !isBuild) return;
			if (isHTMLRequest(id) || isCSSRequest(id) || isNonJsRequest(id) || config$2.assetsInclude(id)) return;
			let [define$1, pattern, importMetaEnvVal] = getPattern(this.environment);
			if (!pattern) return;
			pattern.lastIndex = 0;
			if (!pattern.test(code)) return;
			const hasDefineImportMetaEnv = "import.meta.env" in define$1;
			let marker = importMetaEnvMarker;
			if (hasDefineImportMetaEnv && code.includes(marker)) {
				let i$1 = 1;
				do
					marker = importMetaEnvMarker + i$1++;
				while (code.includes(marker));
				if (marker !== importMetaEnvMarker) define$1 = {
					...define$1,
					"import.meta.env": marker
				};
			}
			const result = await replaceDefine(this.environment, code, id, define$1);
			if (hasDefineImportMetaEnv) {
				result.code = result.code.replaceAll(getImportMetaEnvKeyRe(marker), (m$2) => "undefined".padEnd(m$2.length));
				if (result.code.includes(marker)) {
					result.code = `const ${marker} = ${importMetaEnvVal};\n` + result.code;
					if (result.map) {
						const map$1 = JSON.parse(result.map);
						map$1.mappings = ";" + map$1.mappings;
						result.map = map$1;
					}
				}
			}
			return result;
		} }
	};
}
async function replaceDefine(environment, code, id, define$1) {
	const result = await transform(code, {
		loader: "js",
		charset: (environment.config.esbuild || {}).charset ?? "utf8",
		platform: "neutral",
		define: define$1,
		sourcefile: id,
		sourcemap: environment.config.command === "build" ? !!environment.config.build.sourcemap : true
	});
	if (result.map.includes("<define:")) {
		const originalMap = new TraceMap(result.map);
		if (originalMap.sources.length >= 2) {
			const sourceIndex = originalMap.sources.indexOf(id);
			const decoded = decodedMap(originalMap);
			decoded.sources = [id];
			decoded.mappings = decoded.mappings.map((segments) => segments.filter((segment) => {
				const index = segment[1];
				segment[1] = 0;
				return index === sourceIndex;
			}));
			result.map = JSON.stringify(encodedMap(new TraceMap(decoded)));
		}
	}
	return {
		code: result.code,
		map: result.map || null
	};
}
/**
* Like `JSON.stringify` but keeps raw string values as a literal
* in the generated code. For example: `"window"` would refer to
* the global `window` object directly.
*/
function serializeDefine(define$1) {
	let res = `{`;
	const keys = Object.keys(define$1).sort();
	for (let i$1 = 0; i$1 < keys.length; i$1++) {
		const key = keys[i$1];
		const val = define$1[key];
		res += `${JSON.stringify(key)}: ${handleDefineValue(val)}`;
		if (i$1 !== keys.length - 1) res += `, `;
	}
	return res + `}`;
}
function handleDefineValue(value$1) {
	if (typeof value$1 === "undefined") return "undefined";
	if (typeof value$1 === "string") return value$1;
	return JSON.stringify(value$1);
}
function getImportMetaEnvKeyRe(marker) {
	let re = importMetaEnvKeyReCache.get(marker);
	if (!re) {
		re = new RegExp(`${marker}\\..+?\\b`, "g");
		importMetaEnvKeyReCache.set(marker, re);
	}
	return re;
}

//#endregion
//#region src/node/plugins/worker.ts
var import_picocolors$9 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const workerOrSharedWorkerRE = /(?:\?|&)(worker|sharedworker)(?:&|$)/;
const workerFileRE = /(?:\?|&)worker_file&type=(\w+)(?:&|$)/;
const inlineRE$1 = /[?&]inline\b/;
const WORKER_FILE_ID = "worker_file";
const workerCache = /* @__PURE__ */ new WeakMap();
function saveEmitWorkerAsset(config$2, asset) {
	const workerMap = workerCache.get(config$2.mainConfig || config$2);
	const duplicateAsset = workerMap.assets.get(asset.fileName);
	if (duplicateAsset) {
		if (!isSameContent(duplicateAsset.source, asset.source)) config$2.logger.warn(`\n` + import_picocolors$9.default.yellow(`The emitted file ${JSON.stringify(asset.fileName)} overwrites a previously emitted file of the same name.`));
	}
	workerMap.assets.set(asset.fileName, asset);
}
async function bundleWorkerEntry(config$2, id) {
	const input = cleanUrl(id);
	const newBundleChain = [...config$2.bundleChain, input];
	if (config$2.bundleChain.includes(input)) throw new Error(`Circular worker imports detected. Vite does not support it. Import chain: ${newBundleChain.map((id$1) => prettifyUrl(id$1, config$2.root)).join(" -> ")}`);
	const { rollup } = await import("rollup");
	const { plugins: plugins$1, rollupOptions, format: format$3 } = config$2.worker;
	const workerEnvironment = new BuildEnvironment("client", await plugins$1(newBundleChain));
	await workerEnvironment.init();
	const bundle = await rollup({
		...rollupOptions,
		input,
		plugins: workerEnvironment.plugins.map((p) => injectEnvironmentToHooks(workerEnvironment, p)),
		onLog(level, log$4) {
			onRollupLog(level, log$4, workerEnvironment);
		},
		preserveEntrySignatures: false
	});
	let chunk;
	try {
		const workerOutputConfig = config$2.worker.rollupOptions.output;
		const workerConfig = workerOutputConfig ? Array.isArray(workerOutputConfig) ? workerOutputConfig[0] || {} : workerOutputConfig : {};
		const { output: [outputChunk, ...outputChunks] } = await bundle.generate({
			entryFileNames: path.posix.join(config$2.build.assetsDir, "[name]-[hash].js"),
			chunkFileNames: path.posix.join(config$2.build.assetsDir, "[name]-[hash].js"),
			assetFileNames: path.posix.join(config$2.build.assetsDir, "[name]-[hash].[ext]"),
			...workerConfig,
			format: format$3,
			sourcemap: config$2.build.sourcemap
		});
		chunk = outputChunk;
		outputChunks.forEach((outputChunk$1) => {
			if (outputChunk$1.type === "asset") saveEmitWorkerAsset(config$2, outputChunk$1);
			else if (outputChunk$1.type === "chunk") saveEmitWorkerAsset(config$2, {
				fileName: outputChunk$1.fileName,
				originalFileName: null,
				originalFileNames: [],
				source: outputChunk$1.code
			});
		});
	} catch (e$1) {
		if (e$1 instanceof Error && e$1.name === "RollupError" && e$1.code === "INVALID_OPTION" && e$1.message.includes("\"output.format\"")) e$1.message = e$1.message.replace("output.format", "worker.format");
		throw e$1;
	} finally {
		await bundle.close();
	}
	return emitSourcemapForWorkerEntry(config$2, chunk);
}
function emitSourcemapForWorkerEntry(config$2, chunk) {
	const { map: sourcemap } = chunk;
	if (sourcemap) {
		if (config$2.build.sourcemap === "hidden" || config$2.build.sourcemap === true) {
			const data = sourcemap.toString();
			saveEmitWorkerAsset(config$2, {
				fileName: chunk.fileName + ".map",
				originalFileName: null,
				originalFileNames: [],
				source: data
			});
		}
	}
	return chunk;
}
const workerAssetUrlRE = /__VITE_WORKER_ASSET__([a-z\d]{8})__/g;
function encodeWorkerAssetFileName(fileName, workerCache$1) {
	const { fileNameHash } = workerCache$1;
	const hash$1 = getHash(fileName);
	if (!fileNameHash.get(hash$1)) fileNameHash.set(hash$1, fileName);
	return `__VITE_WORKER_ASSET__${hash$1}__`;
}
async function workerFileToUrl(config$2, id) {
	const workerMap = workerCache.get(config$2.mainConfig || config$2);
	let fileName = workerMap.bundle.get(id);
	if (!fileName) {
		const outputChunk = await bundleWorkerEntry(config$2, id);
		fileName = outputChunk.fileName;
		saveEmitWorkerAsset(config$2, {
			fileName,
			originalFileName: null,
			originalFileNames: [],
			source: outputChunk.code
		});
		workerMap.bundle.set(id, fileName);
	}
	return encodeWorkerAssetFileName(fileName, workerMap);
}
function webWorkerPostPlugin() {
	return {
		name: "vite:worker-post",
		resolveImportMeta(property, { format: format$3 }) {
			if (format$3 === "iife") {
				if (!property) return `{
            url: self.location.href
          }`;
				if (property === "url") return "self.location.href";
			}
			return null;
		}
	};
}
function webWorkerPlugin(config$2) {
	const isBuild = config$2.command === "build";
	const isWorker = config$2.isWorker;
	return {
		name: "vite:worker",
		buildStart() {
			if (isWorker) return;
			workerCache.set(config$2, {
				assets: /* @__PURE__ */ new Map(),
				bundle: /* @__PURE__ */ new Map(),
				fileNameHash: /* @__PURE__ */ new Map()
			});
		},
		load: {
			filter: { id: workerOrSharedWorkerRE },
			async handler(id) {
				const workerMatch = workerOrSharedWorkerRE.exec(id);
				if (!workerMatch) return;
				const { format: format$3 } = config$2.worker;
				const workerConstructor = workerMatch[1] === "sharedworker" ? "SharedWorker" : "Worker";
				const workerType = isBuild ? format$3 === "es" ? "module" : "classic" : "module";
				const workerTypeOption = `{
          ${workerType === "module" ? `type: "module",` : ""}
          name: options?.name
        }`;
				let urlCode;
				if (isBuild) if (isWorker && config$2.bundleChain.at(-1) === cleanUrl(id)) urlCode = "self.location.href";
				else if (inlineRE$1.test(id)) {
					const chunk = await bundleWorkerEntry(config$2, id);
					const jsContent = `const jsContent = ${JSON.stringify(chunk.code)};`;
					return {
						code: workerConstructor === "Worker" ? `${jsContent}
            const blob = typeof self !== "undefined" && self.Blob && new Blob([${workerType === "classic" ? `'(self.URL || self.webkitURL).revokeObjectURL(self.location.href);',` : `'URL.revokeObjectURL(import.meta.url);',`}jsContent], { type: "text/javascript;charset=utf-8" });
            export default function WorkerWrapper(options) {
              let objURL;
              try {
                objURL = blob && (self.URL || self.webkitURL).createObjectURL(blob);
                if (!objURL) throw ''
                const worker = new ${workerConstructor}(objURL, ${workerTypeOption});
                worker.addEventListener("error", () => {
                  (self.URL || self.webkitURL).revokeObjectURL(objURL);
                });
                return worker;
              } catch(e) {
                return new ${workerConstructor}(
                  'data:text/javascript;charset=utf-8,' + encodeURIComponent(jsContent),
                  ${workerTypeOption}
                );
              }
            }` : `${jsContent}
            export default function WorkerWrapper(options) {
              return new ${workerConstructor}(
                'data:text/javascript;charset=utf-8,' + encodeURIComponent(jsContent),
                ${workerTypeOption}
              );
            }
            `,
						map: { mappings: "" }
					};
				} else urlCode = JSON.stringify(await workerFileToUrl(config$2, id));
				else {
					let url$3 = await fileToUrl$1(this, cleanUrl(id));
					url$3 = injectQuery(url$3, `${WORKER_FILE_ID}&type=${workerType}`);
					urlCode = JSON.stringify(url$3);
				}
				if (urlRE.test(id)) return {
					code: `export default ${urlCode}`,
					map: { mappings: "" }
				};
				return {
					code: `export default function WorkerWrapper(options) {
            return new ${workerConstructor}(
              ${urlCode},
              ${workerTypeOption}
            );
          }`,
					map: { mappings: "" }
				};
			}
		},
		shouldTransformCachedModule({ id }) {
			if (isBuild && config$2.build.watch && workerOrSharedWorkerRE.test(id)) return true;
		},
		transform: {
			filter: { id: workerFileRE },
			async handler(raw, id) {
				const workerFileMatch = workerFileRE.exec(id);
				if (workerFileMatch) {
					const workerType = workerFileMatch[1];
					let injectEnv = "";
					const scriptPath = JSON.stringify(path.posix.join(config$2.base, ENV_PUBLIC_PATH));
					if (workerType === "classic") injectEnv = `importScripts(${scriptPath})\n`;
					else if (workerType === "module") injectEnv = `import ${scriptPath}\n`;
					else if (workerType === "ignore") if (isBuild) injectEnv = "";
					else {
						const environment = this.environment;
						injectEnv = ((environment.mode === "dev" ? environment.moduleGraph : void 0)?.getModuleById(ENV_ENTRY))?.transformResult?.code || "";
					}
					if (injectEnv) {
						const s$2 = new MagicString(raw);
						s$2.prepend(injectEnv + ";\n");
						return {
							code: s$2.toString(),
							map: s$2.generateMap({ hires: "boundary" })
						};
					}
				}
			}
		},
		renderChunk(code, chunk, outputOptions) {
			let s$2;
			const result = () => {
				return s$2 && {
					code: s$2.toString(),
					map: this.environment.config.build.sourcemap ? s$2.generateMap({ hires: "boundary" }) : null
				};
			};
			workerAssetUrlRE.lastIndex = 0;
			if (workerAssetUrlRE.test(code)) {
				const toRelativeRuntime = createToImportMetaURLBasedRelativeRuntime(outputOptions.format, this.environment.config.isWorker);
				let match;
				s$2 = new MagicString(code);
				workerAssetUrlRE.lastIndex = 0;
				const { fileNameHash } = workerCache.get(config$2.mainConfig || config$2);
				while (match = workerAssetUrlRE.exec(code)) {
					const [full, hash$1] = match;
					const filename = fileNameHash.get(hash$1);
					const replacement = toOutputFilePathInJS(this.environment, filename, "asset", chunk.fileName, "js", toRelativeRuntime);
					const replacementString = typeof replacement === "string" ? JSON.stringify(encodeURIPath(replacement)).slice(1, -1) : `"+${replacement.runtime}+"`;
					s$2.update(match.index, match.index + full.length, replacementString);
				}
			}
			return result();
		},
		generateBundle(opts, bundle) {
			if (opts.__vite_skip_asset_emit__ || isWorker) return;
			const workerMap = workerCache.get(config$2);
			workerMap.assets.forEach((asset) => {
				const duplicateAsset = bundle[asset.fileName];
				if (duplicateAsset) {
					if (isSameContent(duplicateAsset.type === "asset" ? duplicateAsset.source : duplicateAsset.code, asset.source)) return;
				}
				this.emitFile({
					type: "asset",
					fileName: asset.fileName,
					source: asset.source
				});
			});
			workerMap.assets.clear();
		}
	};
}
function isSameContent(a, b) {
	if (typeof a === "string") {
		if (typeof b === "string") return a === b;
		return Buffer.from(a).equals(b);
	}
	return Buffer.from(b).equals(a);
}

//#endregion
//#region src/node/plugins/preAlias.ts
/**
* A plugin to avoid an aliased AND optimized dep from being aliased in src
*/
function preAliasPlugin(config$2) {
	const findPatterns = getAliasPatterns(config$2.resolve.alias);
	return {
		name: "vite:pre-alias",
		applyToEnvironment(environment) {
			return !isDepOptimizationDisabled(environment.config.optimizeDeps);
		},
		async resolveId(id, importer, options$1) {
			const environment = this.environment;
			const ssr = environment.config.consumer === "server";
			const depsOptimizer = environment.depsOptimizer;
			if (importer && depsOptimizer && bareImportRE.test(id) && !options$1.scan && id !== "@vite/client" && id !== "@vite/env") {
				if (findPatterns.find((pattern) => matches(pattern, id))) {
					const optimizedId = await tryOptimizedResolve(depsOptimizer, id, importer, config$2.resolve.preserveSymlinks, config$2.packageCache);
					if (optimizedId) return optimizedId;
					if (depsOptimizer.options.noDiscovery) return;
					const resolved = await this.resolve(id, importer, options$1);
					if (resolved && !depsOptimizer.isOptimizedDepFile(resolved.id)) {
						const optimizeDeps$1 = depsOptimizer.options;
						const resolvedId = cleanUrl(resolved.id);
						if (!(resolvedId === id || resolvedId.includes("\0")) && fs.existsSync(resolvedId) && !moduleListContains(optimizeDeps$1.exclude, id) && path.isAbsolute(resolvedId) && (isInNodeModules(resolvedId) || optimizeDeps$1.include?.includes(id)) && isOptimizable(resolvedId, optimizeDeps$1) && (!ssr || optimizeAliasReplacementForSSR(resolvedId, optimizeDeps$1))) {
							const optimizedInfo = depsOptimizer.registerMissingImport(id, resolvedId);
							return { id: depsOptimizer.getOptimizedDepId(optimizedInfo) };
						}
					}
					return resolved;
				}
			}
		}
	};
}
function optimizeAliasReplacementForSSR(id, optimizeDeps$1) {
	if (optimizeDeps$1.include?.includes(id)) return true;
	return false;
}
function matches(pattern, importee) {
	if (pattern instanceof RegExp) return pattern.test(importee);
	if (importee.length < pattern.length) return false;
	if (importee === pattern) return true;
	return importee.startsWith(withTrailingSlash(pattern));
}
function getAliasPatterns(entries) {
	if (Array.isArray(entries)) return entries.map((entry) => entry.find);
	return Object.entries(entries).map(([find$1]) => find$1);
}
function getAliasPatternMatcher(entries) {
	const patterns = getAliasPatterns(entries);
	return (importee) => patterns.some((pattern) => matches(pattern, importee));
}

//#endregion
//#region src/node/plugins/importAnalysis.ts
var import_picocolors$8 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const debug$2 = createDebugger("vite:import-analysis");
const clientDir = normalizePath(CLIENT_DIR);
const skipRE = /\.(?:map|json)(?:$|\?)/;
const canSkipImportAnalysis = (id) => skipRE.test(id) || isDirectCSSRequest(id);
const optimizedDepChunkRE = /\/chunk-[A-Z\d]{8}\.js/;
const optimizedDepDynamicRE = /-[A-Z\d]{8}\.js/;
const hasViteIgnoreRE = /\/\*\s*@vite-ignore\s*\*\//;
const urlIsStringRE = /^(?:'.*'|".*"|`.*`)$/;
const templateLiteralRE = /^\s*`(.*)`\s*$/;
function isExplicitImportRequired(url$3) {
	return !isJSRequest(url$3) && !isCSSRequest(url$3);
}
function normalizeResolvedIdToUrl(environment, url$3, resolved) {
	const root = environment.config.root;
	const depsOptimizer = environment.depsOptimizer;
	if (resolved.id.startsWith(withTrailingSlash(root))) url$3 = resolved.id.slice(root.length);
	else if (depsOptimizer?.isOptimizedDepFile(resolved.id) || resolved.id !== "/@react-refresh" && path.isAbsolute(resolved.id) && fs.existsSync(cleanUrl(resolved.id))) url$3 = path.posix.join(FS_PREFIX, resolved.id);
	else url$3 = resolved.id;
	if (url$3[0] !== "." && url$3[0] !== "/") url$3 = wrapId(resolved.id);
	return url$3;
}
function extractImportedBindings(id, source, importSpec, importedBindings) {
	let bindings = importedBindings.get(id);
	if (!bindings) {
		bindings = /* @__PURE__ */ new Set();
		importedBindings.set(id, bindings);
	}
	if (importSpec.d > -1 || importSpec.d === -2) {
		bindings.add("*");
		return;
	}
	const exp = source.slice(importSpec.ss, importSpec.se);
	ESM_STATIC_IMPORT_RE.lastIndex = 0;
	const match = ESM_STATIC_IMPORT_RE.exec(exp);
	if (!match) return;
	const parsed = parseStaticImport({
		type: "static",
		code: match[0],
		start: match.index,
		end: match.index + match[0].length,
		imports: match.groups.imports,
		specifier: match.groups.specifier
	});
	if (parsed.namespacedImport) bindings.add("*");
	if (parsed.defaultImport) bindings.add("default");
	if (parsed.namedImports) for (const name of Object.keys(parsed.namedImports)) bindings.add(name);
}
/**
* Dev-only plugin that lexes, resolves, rewrites and analyzes url imports.
*
* - Imports are resolved to ensure they exist on disk
*
* - Lexes HMR accept calls and updates import relationships in the module graph
*
* - Bare module imports are resolved (by @rollup-plugin/node-resolve) to
* absolute file paths, e.g.
*
*     ```js
*     import 'foo'
*     ```
*     is rewritten to
*     ```js
*     import '/@fs//project/node_modules/foo/dist/foo.js'
*     ```
*
* - CSS imports are appended with `.js` since both the js module and the actual
* css (referenced via `<link>`) may go through the transform pipeline:
*
*     ```js
*     import './style.css'
*     ```
*     is rewritten to
*     ```js
*     import './style.css.js'
*     ```
*/
function importAnalysisPlugin(config$2) {
	const { root, base } = config$2;
	const clientPublicPath = path.posix.join(base, CLIENT_PUBLIC_PATH);
	const enablePartialAccept = config$2.experimental.hmrPartialAccept;
	const matchAlias = getAliasPatternMatcher(config$2.resolve.alias);
	let _env;
	let _ssrEnv;
	function getEnv(ssr) {
		if (!_ssrEnv || !_env) {
			const importMetaEnvKeys = {};
			const userDefineEnv = {};
			for (const key in config$2.env) importMetaEnvKeys[key] = JSON.stringify(config$2.env[key]);
			for (const key in config$2.define) if (key.startsWith("import.meta.env.")) userDefineEnv[key.slice(16)] = config$2.define[key];
			const env$1 = `import.meta.env = ${serializeDefine({
				...importMetaEnvKeys,
				SSR: "__vite_ssr__",
				...userDefineEnv
			})};`;
			_ssrEnv = env$1.replace("__vite_ssr__", "true");
			_env = env$1.replace("__vite_ssr__", "false");
		}
		return ssr ? _ssrEnv : _env;
	}
	return {
		name: "vite:import-analysis",
		async transform(source, importer) {
			const environment = this.environment;
			const ssr = environment.config.consumer === "server";
			const moduleGraph = environment.moduleGraph;
			if (canSkipImportAnalysis(importer)) {
				debug$2?.(import_picocolors$8.default.dim(`[skipped] ${prettifyUrl(importer, root)}`));
				return null;
			}
			const msAtStart = debug$2 ? performance$1.now() : 0;
			await init;
			let imports;
			let exports$1;
			source = stripBomTag(source);
			try {
				[imports, exports$1] = parse(source);
			} catch (_e) {
				const e$1 = _e;
				const { message, showCodeFrame } = createParseErrorInfo(importer, source);
				this.error(message, showCodeFrame ? e$1.idx : void 0);
			}
			const depsOptimizer = environment.depsOptimizer;
			const importerModule = moduleGraph.getModuleById(importer);
			if (!importerModule) throwOutdatedRequest(importer);
			if (!imports.length && !this._addedImports) {
				importerModule.isSelfAccepting = false;
				debug$2?.(`${timeFrom(msAtStart)} ${import_picocolors$8.default.dim(`[no imports] ${prettifyUrl(importer, root)}`)}`);
				return source;
			}
			let hasHMR = false;
			let isSelfAccepting = false;
			let hasEnv = false;
			let needQueryInjectHelper = false;
			let s$2;
			const str = () => s$2 || (s$2 = new MagicString(source));
			let isPartiallySelfAccepting = false;
			const importedBindings = enablePartialAccept ? /* @__PURE__ */ new Map() : null;
			const toAbsoluteUrl = (url$3) => path.posix.resolve(path.posix.dirname(importerModule.url), url$3);
			const normalizeUrl = async (url$3, pos, forceSkipImportAnalysis = false) => {
				url$3 = stripBase(url$3, base);
				let importerFile = importer;
				if (depsOptimizer && moduleListContains(depsOptimizer.options.exclude, url$3)) {
					await depsOptimizer.scanProcessing;
					for (const optimizedModule of depsOptimizer.metadata.depInfoList) {
						if (!optimizedModule.src) continue;
						if (optimizedModule.file === importerModule.file) importerFile = optimizedModule.src;
					}
				}
				const resolved = await this.resolve(url$3, importerFile).catch((e$1) => {
					if (e$1 instanceof Error) e$1.pos ??= pos;
					throw e$1;
				});
				if (!resolved || resolved.meta?.["vite:alias"]?.noResolved) {
					if (ssr) return [url$3, null];
					importerModule.isSelfAccepting = false;
					moduleGraph._hasResolveFailedErrorModules.add(importerModule);
					return this.error(`Failed to resolve import "${url$3}" from "${normalizePath(path.relative(process.cwd(), importerFile))}". Does the file exist?`, pos);
				}
				if (isExternalUrl(resolved.id)) return [resolved.id, resolved.id];
				url$3 = normalizeResolvedIdToUrl(environment, url$3, resolved);
				try {
					const depModule = await moduleGraph._ensureEntryFromUrl(unwrapId(url$3), canSkipImportAnalysis(url$3) || forceSkipImportAnalysis, resolved);
					if (environment.config.consumer === "client" && depModule.lastHMRTimestamp > 0) url$3 = injectQuery(url$3, `t=${depModule.lastHMRTimestamp}`);
				} catch (e$1) {
					e$1.pos = pos;
					throw e$1;
				}
				if (environment.config.consumer === "client") {
					const isRelative$1 = url$3[0] === ".";
					const isSelfImport = !isRelative$1 && cleanUrl(url$3) === cleanUrl(importer);
					if (isExplicitImportRequired(url$3)) url$3 = injectQuery(url$3, "import");
					else if ((isRelative$1 || isSelfImport) && !DEP_VERSION_RE.test(url$3)) {
						const versionMatch = DEP_VERSION_RE.exec(importer);
						if (versionMatch) url$3 = injectQuery(url$3, versionMatch[1]);
					}
				}
				if (!ssr) url$3 = joinUrlSegments(base, url$3);
				return [url$3, resolved.id];
			};
			const orderedImportedUrls = new Array(imports.length);
			const orderedAcceptedUrls = new Array(imports.length);
			const orderedAcceptedExports = new Array(imports.length);
			await Promise.all(imports.map(async (importSpecifier, index) => {
				const { s: start, e: end, ss: expStart, se: expEnd, d: dynamicIndex, a: attributeIndex } = importSpecifier;
				let specifier = importSpecifier.n;
				const rawUrl = source.slice(start, end);
				if (rawUrl === "import.meta") {
					const prop = source.slice(end, end + 4);
					if (prop === ".hot") {
						hasHMR = true;
						const endHot = end + 4 + (source[end + 4] === "?" ? 1 : 0);
						if (source.slice(endHot, endHot + 7) === ".accept") if (source.slice(endHot, endHot + 14) === ".acceptExports") {
							const importAcceptedExports = orderedAcceptedExports[index] = /* @__PURE__ */ new Set();
							lexAcceptedHmrExports(source, source.indexOf("(", endHot + 14) + 1, importAcceptedExports);
							isPartiallySelfAccepting = true;
						} else {
							const importAcceptedUrls = orderedAcceptedUrls[index] = /* @__PURE__ */ new Set();
							if (lexAcceptedHmrDeps(source, source.indexOf("(", endHot + 7) + 1, importAcceptedUrls)) isSelfAccepting = true;
						}
					} else if (prop === ".env") hasEnv = true;
					return;
				} else if (templateLiteralRE.test(rawUrl)) {
					if (!(rawUrl.includes("${") && rawUrl.includes("}"))) specifier = rawUrl.replace(templateLiteralRE, "$1");
				}
				const isDynamicImport = dynamicIndex > -1;
				if (!isDynamicImport && attributeIndex > -1) str().remove(end + 1, expEnd);
				if (specifier !== void 0) {
					if ((isExternalUrl(specifier) && !specifier.startsWith("file://") || isDataUrl(specifier)) && !matchAlias(specifier)) return;
					if (ssr && !matchAlias(specifier)) {
						if (shouldExternalize(environment, specifier, importer)) return;
						if (isBuiltin(environment.config.resolve.builtins, specifier)) return;
					}
					if (specifier === clientPublicPath) return;
					if (specifier[0] === "/" && !(config$2.assetsInclude(cleanUrl(specifier)) || urlRE.test(specifier)) && checkPublicFile(specifier, config$2)) throw new Error(`Cannot import non-asset file ${specifier} which is inside /public. JS/CSS files inside /public are copied as-is on build and can only be referenced via <script src> or <link href> in html. If you want to get the URL of that file, use ${injectQuery(specifier, "url")} instead.`);
					let [url$3, resolvedId] = await normalizeUrl(specifier, start);
					resolvedId = resolvedId || url$3;
					config$2.safeModulePaths.add(fsPathFromUrl(stripBase(url$3, base)));
					if (url$3 !== specifier) {
						let rewriteDone = false;
						if (depsOptimizer?.isOptimizedDepFile(resolvedId) && !optimizedDepChunkRE.test(resolvedId)) {
							const file = cleanUrl(resolvedId);
							const needsInterop$1 = await optimizedDepNeedsInterop(environment, depsOptimizer.metadata, file);
							if (needsInterop$1 === void 0) {
								if (!optimizedDepDynamicRE.test(file)) config$2.logger.error(import_picocolors$8.default.red(`Vite Error, ${url$3} optimized info should be defined`));
							} else if (needsInterop$1) {
								debug$2?.(`${url$3} needs interop`);
								interopNamedImports(str(), importSpecifier, url$3, index, importer, config$2);
								rewriteDone = true;
							}
						} else if (url$3.includes(browserExternalId) && source.slice(expStart, start).includes("{")) {
							interopNamedImports(str(), importSpecifier, url$3, index, importer, config$2);
							rewriteDone = true;
						}
						if (!rewriteDone) {
							const rewrittenUrl = JSON.stringify(url$3);
							const s$3 = isDynamicImport ? start : start - 1;
							const e$1 = isDynamicImport ? end : end + 1;
							str().overwrite(s$3, e$1, rewrittenUrl, { contentOnly: true });
						}
					}
					const hmrUrl = unwrapId(stripBase(url$3, base));
					const isLocalImport = !isExternalUrl(hmrUrl) && !isDataUrl(hmrUrl);
					if (isLocalImport) orderedImportedUrls[index] = hmrUrl;
					if (enablePartialAccept && importedBindings) extractImportedBindings(resolvedId, source, importSpecifier, importedBindings);
					if (!isDynamicImport && isLocalImport && environment.config.dev.preTransformRequests) {
						const url$4 = removeImportQuery(hmrUrl);
						environment.warmupRequest(url$4);
					}
				} else if (!importer.startsWith(withTrailingSlash(clientDir))) {
					if (!isInNodeModules(importer)) {
						if (!hasViteIgnoreRE.test(source.slice(dynamicIndex + 1, end))) this.warn(`\n` + import_picocolors$8.default.cyan(importerModule.file) + `\n` + import_picocolors$8.default.reset(generateCodeFrame(source, start, end)) + import_picocolors$8.default.yellow(`\nThe above dynamic import cannot be analyzed by Vite.\nSee ${import_picocolors$8.default.blue(`https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#limitations`)} for supported dynamic import formats. If this is intended to be left as-is, you can use the /* @vite-ignore */ comment inside the import() call to suppress this warning.\n`));
					}
					if (!ssr) {
						if (!urlIsStringRE.test(rawUrl) || isExplicitImportRequired(rawUrl.slice(1, -1))) {
							needQueryInjectHelper = true;
							str().overwrite(start, end, `__vite__injectQuery(${rawUrl}, 'import')`, { contentOnly: true });
						}
					}
				}
			}));
			const _orderedImportedUrls = orderedImportedUrls.filter(isDefined);
			const importedUrls = new Set(_orderedImportedUrls);
			const staticImportedUrls = new Set(_orderedImportedUrls.map((url$3) => removeTimestampQuery(url$3)));
			const acceptedUrls = mergeAcceptedUrls(orderedAcceptedUrls);
			const acceptedExports = mergeAcceptedUrls(orderedAcceptedExports);
			const isClassicWorker = importer.includes(WORKER_FILE_ID) && importer.includes("type=classic");
			if (hasEnv && !isClassicWorker) str().prepend(getEnv(ssr));
			if (hasHMR && !ssr && !isClassicWorker) {
				debugHmr?.(`${isSelfAccepting ? `[self-accepts]` : isPartiallySelfAccepting ? `[accepts-exports]` : acceptedUrls.size ? `[accepts-deps]` : `[detected api usage]`} ${prettifyUrl(importer, root)}`);
				str().prepend(`import { createHotContext as __vite__createHotContext } from "${clientPublicPath}";import.meta.hot = __vite__createHotContext(${JSON.stringify(normalizeHmrUrl(importerModule.url))});`);
			}
			if (needQueryInjectHelper) if (isClassicWorker) str().append("\n" + __vite__injectQuery.toString());
			else str().prepend(`import { injectQuery as __vite__injectQuery } from "${clientPublicPath}";`);
			const normalizedAcceptedUrls = /* @__PURE__ */ new Set();
			for (const { url: url$3, start, end } of acceptedUrls) {
				let [normalized, resolvedId] = await normalizeUrl(url$3, start).catch(() => []);
				if (resolvedId) {
					const mod = moduleGraph.getModuleById(resolvedId);
					if (!mod) {
						this.error(`module was not found for ${JSON.stringify(resolvedId)}`, start);
						return;
					}
					normalized = mod.url;
				} else try {
					const [resolved] = await moduleGraph.resolveUrl(toAbsoluteUrl(url$3));
					normalized = resolved;
					if (resolved) this.warn({
						message: `Failed to resolve ${JSON.stringify(url$3)} from ${importer}. An id should be written. Did you pass a URL?`,
						pos: start
					});
				} catch {
					this.error(`Failed to resolve ${JSON.stringify(url$3)}`, start);
					return;
				}
				normalizedAcceptedUrls.add(normalized);
				const hmrAccept = normalizeHmrUrl(normalized);
				str().overwrite(start, end, JSON.stringify(hmrAccept), { contentOnly: true });
			}
			if (!isCSSRequest(importer) || SPECIAL_QUERY_RE.test(importer)) {
				const pluginImports = this._addedImports;
				if (pluginImports) (await Promise.all([...pluginImports].map((id) => normalizeUrl(id, 0, true)))).forEach(([url$3]) => importedUrls.add(stripBase(url$3, base)));
				if (ssr && importerModule.isSelfAccepting) isSelfAccepting = true;
				if (!isSelfAccepting && isPartiallySelfAccepting && acceptedExports.size >= exports$1.length && exports$1.every((e$1) => acceptedExports.has(e$1.n))) isSelfAccepting = true;
				const prunedImports = await moduleGraph.updateModuleInfo(importerModule, importedUrls, importedBindings, normalizedAcceptedUrls, isPartiallySelfAccepting ? acceptedExports : null, isSelfAccepting, staticImportedUrls);
				if (prunedImports) handlePrunedModules(prunedImports, environment);
			}
			debug$2?.(`${timeFrom(msAtStart)} ${import_picocolors$8.default.dim(`[${importedUrls.size} imports rewritten] ${prettifyUrl(importer, root)}`)}`);
			if (s$2) return transformStableResult(s$2, importer, config$2);
			else return source;
		}
	};
}
function mergeAcceptedUrls(orderedUrls) {
	const acceptedUrls = /* @__PURE__ */ new Set();
	for (const urls of orderedUrls) {
		if (!urls) continue;
		for (const url$3 of urls) acceptedUrls.add(url$3);
	}
	return acceptedUrls;
}
function createParseErrorInfo(importer, source) {
	const isVue = importer.endsWith(".vue");
	const isJsx = importer.endsWith(".jsx") || importer.endsWith(".tsx");
	const maybeJSX = !isVue && isJSRequest(importer);
	const probablyBinary = source.includes("�");
	return {
		message: "Failed to parse source for import analysis because the content contains invalid JS syntax. " + (isVue ? `Install @vitejs/plugin-vue to handle .vue files.` : maybeJSX ? isJsx ? `If you use tsconfig.json, make sure to not set jsx to preserve.` : `If you are using JSX, make sure to name the file with the .jsx or .tsx extension.` : `You may need to install appropriate plugins to handle the ${path.extname(importer)} file format, or if it's an asset, add "**/*${path.extname(importer)}" to \`assetsInclude\` in your configuration.`),
		showCodeFrame: !probablyBinary
	};
}
const interopHelper = (m$2) => m$2?.__esModule ? m$2 : {
	...typeof m$2 === "object" && !Array.isArray(m$2) || typeof m$2 === "function" ? m$2 : {},
	default: m$2
};
const interopHelperStr = interopHelper.toString().replaceAll("\n", "");
function interopNamedImports(str, importSpecifier, rewrittenUrl, importIndex, importer, config$2) {
	const source = str.original;
	const { s: start, e: end, ss: expStart, se: expEnd, d: dynamicIndex } = importSpecifier;
	const exp = source.slice(expStart, expEnd);
	if (dynamicIndex > -1) str.overwrite(expStart, expEnd, `import('${rewrittenUrl}').then(m => (${interopHelperStr})(m.default))` + getLineBreaks(exp), { contentOnly: true });
	else {
		const rewritten = transformCjsImport(exp, rewrittenUrl, source.slice(start, end), importIndex, importer, config$2);
		if (rewritten) str.overwrite(expStart, expEnd, rewritten + getLineBreaks(exp), { contentOnly: true });
		else str.overwrite(start, end, rewrittenUrl + getLineBreaks(source.slice(start, end)), { contentOnly: true });
	}
}
function getLineBreaks(str) {
	return str.includes("\n") ? "\n".repeat(str.split("\n").length - 1) : "";
}
/**
* Detect import statements to a known optimized CJS dependency and provide
* ES named imports interop. We do this by rewriting named imports to a variable
* assignment to the corresponding property on the `module.exports` of the cjs
* module. Note this doesn't support dynamic re-assignments from within the cjs
* module.
*
* Note that es-module-lexer treats `export * from '...'` as an import as well,
* so, we may encounter ExportAllDeclaration here, in which case `undefined`
* will be returned.
*
* Credits \@csr632 via #837
*/
function transformCjsImport(importExp, url$3, rawUrl, importIndex, importer, config$2) {
	const node = parseAst(importExp).body[0];
	if (config$2.command === "serve" && node.type === "ExportAllDeclaration" && !node.exported) config$2.logger.warn(import_picocolors$8.default.yellow(`\nUnable to interop \`${importExp}\` in ${importer}, this may lose module exports. Please export "${rawUrl}" as ESM or use named exports instead, e.g. \`export { A, B } from "${rawUrl}"\``));
	else if (node.type === "ImportDeclaration" || node.type === "ExportNamedDeclaration") {
		if (!node.specifiers.length) return `import "${url$3}"`;
		const importNames = [];
		const exportNames = [];
		let defaultExports = "";
		for (const spec of node.specifiers) if (spec.type === "ImportSpecifier") {
			const importedName = getIdentifierNameOrLiteralValue(spec.imported);
			importNames.push({
				importedName,
				localName: spec.local.name
			});
		} else if (spec.type === "ImportDefaultSpecifier") importNames.push({
			importedName: "default",
			localName: spec.local.name
		});
		else if (spec.type === "ImportNamespaceSpecifier") importNames.push({
			importedName: "*",
			localName: spec.local.name
		});
		else if (spec.type === "ExportSpecifier") {
			const importedName = getIdentifierNameOrLiteralValue(spec.local);
			const exportedName = getIdentifierNameOrLiteralValue(spec.exported);
			if (exportedName === "default") {
				defaultExports = makeLegalIdentifier(`__vite__cjsExportDefault_${importIndex}`);
				importNames.push({
					importedName,
					localName: defaultExports
				});
			} else {
				const localName = `__vite__cjsExport${spec.exported.type === "Literal" ? `L_${getHash(spec.exported.value)}` : "I_" + spec.exported.name}`;
				importNames.push({
					importedName,
					localName
				});
				exportNames.push(`${localName} as ${spec.exported.type === "Literal" ? JSON.stringify(exportedName) : exportedName}`);
			}
		}
		const cjsModuleName = makeLegalIdentifier(`__vite__cjsImport${importIndex}_${rawUrl}`);
		const lines = [`import ${cjsModuleName} from "${url$3}"`];
		importNames.forEach(({ importedName, localName }) => {
			if (importedName === "*") lines.push(`const ${localName} = (${interopHelperStr})(${cjsModuleName})`);
			else if (importedName === "default") lines.push(`const ${localName} = ${cjsModuleName}.__esModule ? ${cjsModuleName}.default : ${cjsModuleName}`);
			else lines.push(`const ${localName} = ${cjsModuleName}["${importedName}"]`);
		});
		if (defaultExports) lines.push(`export default ${defaultExports}`);
		if (exportNames.length) lines.push(`export { ${exportNames.join(", ")} }`);
		return lines.join("; ");
	}
}
function getIdentifierNameOrLiteralValue(node) {
	return node.type === "Identifier" ? node.name : node.value;
}
function __vite__injectQuery(url$3, queryToInject) {
	if (url$3[0] !== "." && url$3[0] !== "/") return url$3;
	const pathname = url$3.replace(/[?#].*$/, "");
	const { search, hash: hash$1 } = new URL(url$3, "http://vite.dev");
	return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ""}${hash$1 || ""}`;
}

//#endregion
//#region src/node/plugins/clientInjections.ts
const normalizedClientEntry = normalizePath(CLIENT_ENTRY);
const normalizedEnvEntry = normalizePath(ENV_ENTRY);
/**
* some values used by the client needs to be dynamically injected by the server
* @server-only
*/
function clientInjectionsPlugin(config$2) {
	let injectConfigValues;
	const getDefineReplacer = perEnvironmentState((environment) => {
		const userDefine = {};
		for (const key in environment.config.define) if (!key.startsWith("import.meta.env.")) userDefine[key] = environment.config.define[key];
		const serializedDefines = serializeDefine(userDefine);
		const definesReplacement = () => serializedDefines;
		return (code) => code.replace(`__DEFINES__`, definesReplacement);
	});
	return {
		name: "vite:client-inject",
		async buildStart() {
			const resolvedServerHostname = (await resolveHostname(config$2.server.host)).name;
			const resolvedServerPort = config$2.server.port;
			const devBase = config$2.base;
			const serverHost = `${resolvedServerHostname}:${resolvedServerPort}${devBase}`;
			let hmrConfig = config$2.server.hmr;
			hmrConfig = isObject(hmrConfig) ? hmrConfig : void 0;
			const host = hmrConfig?.host || null;
			const protocol = hmrConfig?.protocol || null;
			const timeout$1 = hmrConfig?.timeout || 3e4;
			const overlay = hmrConfig?.overlay !== false;
			const isHmrServerSpecified = !!hmrConfig?.server;
			const hmrConfigName = path.basename(config$2.configFile || "vite.config.js");
			let port = hmrConfig?.clientPort || hmrConfig?.port || null;
			if (config$2.server.middlewareMode && !isHmrServerSpecified) port ||= 24678;
			let directTarget = hmrConfig?.host || resolvedServerHostname;
			directTarget += `:${hmrConfig?.port || resolvedServerPort}`;
			directTarget += devBase;
			let hmrBase = devBase;
			if (hmrConfig?.path) hmrBase = path.posix.join(hmrBase, hmrConfig.path);
			const modeReplacement = escapeReplacement(config$2.mode);
			const baseReplacement = escapeReplacement(devBase);
			const serverHostReplacement = escapeReplacement(serverHost);
			const hmrProtocolReplacement = escapeReplacement(protocol);
			const hmrHostnameReplacement = escapeReplacement(host);
			const hmrPortReplacement = escapeReplacement(port);
			const hmrDirectTargetReplacement = escapeReplacement(directTarget);
			const hmrBaseReplacement = escapeReplacement(hmrBase);
			const hmrTimeoutReplacement = escapeReplacement(timeout$1);
			const hmrEnableOverlayReplacement = escapeReplacement(overlay);
			const hmrConfigNameReplacement = escapeReplacement(hmrConfigName);
			const wsTokenReplacement = escapeReplacement(config$2.webSocketToken);
			injectConfigValues = (code) => {
				return code.replace(`__MODE__`, modeReplacement).replace(/__BASE__/g, baseReplacement).replace(`__SERVER_HOST__`, serverHostReplacement).replace(`__HMR_PROTOCOL__`, hmrProtocolReplacement).replace(`__HMR_HOSTNAME__`, hmrHostnameReplacement).replace(`__HMR_PORT__`, hmrPortReplacement).replace(`__HMR_DIRECT_TARGET__`, hmrDirectTargetReplacement).replace(`__HMR_BASE__`, hmrBaseReplacement).replace(`__HMR_TIMEOUT__`, hmrTimeoutReplacement).replace(`__HMR_ENABLE_OVERLAY__`, hmrEnableOverlayReplacement).replace(`__HMR_CONFIG_NAME__`, hmrConfigNameReplacement).replace(`__WS_TOKEN__`, wsTokenReplacement);
			};
		},
		async transform(code, id) {
			const ssr = this.environment.config.consumer === "server";
			if (id === normalizedClientEntry || id === normalizedEnvEntry) return getDefineReplacer(this)(injectConfigValues(code));
			else if (!ssr && code.includes("process.env.NODE_ENV")) {
				const nodeEnv = this.environment.config.define?.["process.env.NODE_ENV"] || JSON.stringify(process.env.NODE_ENV || config$2.mode);
				return await replaceDefine(this.environment, code, id, {
					"process.env.NODE_ENV": nodeEnv,
					"global.process.env.NODE_ENV": nodeEnv,
					"globalThis.process.env.NODE_ENV": nodeEnv
				});
			}
		}
	};
}
function escapeReplacement(value$1) {
	const jsonValue = JSON.stringify(value$1);
	return () => jsonValue;
}

//#endregion
//#region src/node/plugins/wasm.ts
const wasmHelperId = "\0vite/wasm-helper.js";
const wasmInitRE = /(?<![?#].*)\.wasm\?init/;
const wasmHelper = async (opts = {}, url$3) => {
	let result;
	if (url$3.startsWith("data:")) {
		const urlContent = url$3.replace(/^data:.*?base64,/, "");
		let bytes;
		if (typeof Buffer === "function" && typeof Buffer.from === "function") bytes = Buffer.from(urlContent, "base64");
		else if (typeof atob === "function") {
			const binaryString = atob(urlContent);
			bytes = new Uint8Array(binaryString.length);
			for (let i$1 = 0; i$1 < binaryString.length; i$1++) bytes[i$1] = binaryString.charCodeAt(i$1);
		} else throw new Error("Failed to decode base64-encoded data URL, Buffer and atob are not supported");
		result = await WebAssembly.instantiate(bytes, opts);
	} else {
		const response = await fetch(url$3);
		const contentType = response.headers.get("Content-Type") || "";
		if ("instantiateStreaming" in WebAssembly && contentType.startsWith("application/wasm")) result = await WebAssembly.instantiateStreaming(response, opts);
		else {
			const buffer = await response.arrayBuffer();
			result = await WebAssembly.instantiate(buffer, opts);
		}
	}
	return result.instance;
};
const wasmHelperCode = wasmHelper.toString();
const wasmHelperPlugin = () => {
	return {
		name: "vite:wasm-helper",
		resolveId: {
			filter: { id: exactRegex(wasmHelperId) },
			handler(id) {
				return id;
			}
		},
		load: {
			filter: { id: [exactRegex(wasmHelperId), wasmInitRE] },
			async handler(id) {
				if (id === wasmHelperId) return `export default ${wasmHelperCode}`;
				const url$3 = await fileToUrl$1(this, id);
				return `
  import initWasm from "${wasmHelperId}"
  export default opts => initWasm(opts, ${JSON.stringify(url$3)})
  `;
			}
		}
	};
};
const wasmFallbackPlugin = () => {
	return {
		name: "vite:wasm-fallback",
		load: {
			filter: { id: /\.wasm$/ },
			handler(_id) {
				throw new Error("\"ESM integration proposal for Wasm\" is not supported currently. Use vite-plugin-wasm or other community plugins to handle this. Alternatively, you can use `.wasm?init` or `.wasm?url`. See https://vite.dev/guide/features.html#webassembly for more details.");
			}
		}
	};
};

//#endregion
//#region src/node/plugins/workerImportMetaUrl.ts
function err(e$1, pos) {
	const error$1 = new Error(e$1);
	error$1.pos = pos;
	return error$1;
}
function findClosingParen(input, fromIndex) {
	let count = 1;
	for (let i$1 = fromIndex; i$1 < input.length; i$1++) {
		if (input[i$1] === "(") count++;
		if (input[i$1] === ")") count--;
		if (count === 0) return i$1;
	}
	return -1;
}
function extractWorkerTypeFromAst(expression, optsStartIndex) {
	if (expression.type !== "ObjectExpression") return;
	let lastSpreadElementIndex = -1;
	let typeProperty = null;
	let typePropertyIndex = -1;
	for (let i$1 = 0; i$1 < expression.properties.length; i$1++) {
		const property = expression.properties[i$1];
		if (property.type === "SpreadElement") {
			lastSpreadElementIndex = i$1;
			continue;
		}
		if (property.type === "Property" && (property.key.type === "Identifier" && property.key.name === "type" || property.key.type === "Literal" && property.key.value === "type")) {
			typeProperty = property;
			typePropertyIndex = i$1;
		}
	}
	if (typePropertyIndex === -1 && lastSpreadElementIndex === -1) return "classic";
	if (typePropertyIndex < lastSpreadElementIndex) throw err("Expected object spread to be used before the definition of the type property. Vite needs a static value for the type property to correctly infer it.", optsStartIndex);
	if (typeProperty?.value.type !== "Literal") throw err("Expected worker options type property to be a literal value.", optsStartIndex);
	return typeProperty?.value.value === "module" ? "module" : "classic";
}
async function parseWorkerOptions(rawOpts, optsStartIndex) {
	let opts = {};
	try {
		opts = evalValue(rawOpts);
	} catch {
		const optsNode = (await parseAstAsync(`(${rawOpts})`)).body[0].expression;
		const type = extractWorkerTypeFromAst(optsNode, optsStartIndex);
		if (type) return { type };
		throw err("Vite is unable to parse the worker options as the value is not static. To ignore this error, please use /* @vite-ignore */ in the worker options.", optsStartIndex);
	}
	if (opts == null) return {};
	if (typeof opts !== "object") throw err(`Expected worker options to be an object, got ${typeof opts}`, optsStartIndex);
	return opts;
}
async function getWorkerType(raw, clean, i$1) {
	const commaIndex = clean.indexOf(",", i$1);
	if (commaIndex === -1) return "classic";
	const endIndex = findClosingParen(clean, i$1);
	if (commaIndex > endIndex) return "classic";
	let workerOptString = raw.substring(commaIndex + 1, endIndex);
	if (hasViteIgnoreRE.test(workerOptString)) return "ignore";
	const cleanWorkerOptString = clean.substring(commaIndex + 1, endIndex);
	const trimmedCleanWorkerOptString = cleanWorkerOptString.trim();
	if (!trimmedCleanWorkerOptString.length) return "classic";
	if (trimmedCleanWorkerOptString.endsWith(",")) workerOptString = workerOptString.slice(0, cleanWorkerOptString.lastIndexOf(","));
	const workerOpts = await parseWorkerOptions(workerOptString, commaIndex + 1);
	if (workerOpts.type && (workerOpts.type === "module" || workerOpts.type === "classic")) return workerOpts.type;
	return "classic";
}
const workerImportMetaUrlRE = /new\s+(?:Worker|SharedWorker)\s*\(\s*new\s+URL.+?import\.meta\.url/s;
function workerImportMetaUrlPlugin(config$2) {
	const isBuild = config$2.command === "build";
	let workerResolver;
	const fsResolveOptions = {
		...config$2.resolve,
		root: config$2.root,
		isProduction: config$2.isProduction,
		isBuild: config$2.command === "build",
		packageCache: config$2.packageCache,
		asSrc: true
	};
	return {
		name: "vite:worker-import-meta-url",
		applyToEnvironment(environment) {
			return environment.config.consumer === "client";
		},
		shouldTransformCachedModule({ code }) {
			if (isBuild && config$2.build.watch && workerImportMetaUrlRE.test(code)) return true;
		},
		transform: {
			filter: { code: workerImportMetaUrlRE },
			async handler(code, id) {
				let s$2;
				const cleanString = stripLiteral(code);
				const workerImportMetaUrlRE$1 = /\bnew\s+(?:Worker|SharedWorker)\s*\(\s*(new\s+URL\s*\(\s*('[^']+'|"[^"]+"|`[^`]+`)\s*,\s*import\.meta\.url\s*\))/dg;
				let match;
				while (match = workerImportMetaUrlRE$1.exec(cleanString)) {
					const [[, endIndex], [expStart, expEnd], [urlStart, urlEnd]] = match.indices;
					const rawUrl = code.slice(urlStart, urlEnd);
					if (rawUrl[0] === "`" && rawUrl.includes("${")) this.error(`\`new URL(url, import.meta.url)\` is not supported in dynamic template string.`, expStart);
					s$2 ||= new MagicString(code);
					const workerType = await getWorkerType(code, cleanString, endIndex);
					const url$3 = rawUrl.slice(1, -1);
					let file;
					if (url$3[0] === ".") {
						file = path.resolve(path.dirname(id), url$3);
						file = slash(tryFsResolve(file, fsResolveOptions) ?? file);
					} else {
						workerResolver ??= createBackCompatIdResolver(config$2, {
							extensions: [],
							tryIndex: false,
							preferRelative: true
						});
						file = await workerResolver(this.environment, url$3, id);
						file ??= url$3[0] === "/" ? slash(path.join(config$2.publicDir, url$3)) : slash(path.resolve(path.dirname(id), url$3));
					}
					if (isBuild && config$2.isWorker && config$2.bundleChain.at(-1) === cleanUrl(file)) s$2.update(expStart, expEnd, "self.location.href");
					else {
						let builtUrl;
						if (isBuild) builtUrl = await workerFileToUrl(config$2, file);
						else {
							builtUrl = await fileToUrl$1(this, cleanUrl(file));
							builtUrl = injectQuery(builtUrl, `${WORKER_FILE_ID}&type=${workerType}`);
						}
						s$2.update(expStart, expEnd, `new URL(/* @vite-ignore */ ${JSON.stringify(builtUrl)}, import.meta.url)`);
					}
				}
				if (s$2) return transformStableResult(s$2, id, config$2);
				return null;
			}
		}
	};
}

//#endregion
//#region src/node/plugins/assetImportMetaUrl.ts
/**
* Convert `new URL('./foo.png', import.meta.url)` to its resolved built URL
*
* Supports template string with dynamic segments:
* ```
* new URL(`./dir/${name}.png`, import.meta.url)
* // transformed to
* import.meta.glob('./dir/**.png', { eager: true, import: 'default' })[`./dir/${name}.png`]
* ```
*/
function assetImportMetaUrlPlugin(config$2) {
	const { publicDir } = config$2;
	let assetResolver;
	const fsResolveOptions = {
		...config$2.resolve,
		root: config$2.root,
		isProduction: config$2.isProduction,
		isBuild: config$2.command === "build",
		packageCache: config$2.packageCache,
		asSrc: true
	};
	return {
		name: "vite:asset-import-meta-url",
		applyToEnvironment(environment) {
			return environment.config.consumer === "client";
		},
		transform: {
			filter: {
				id: { exclude: [exactRegex(preloadHelperId), exactRegex(CLIENT_ENTRY)] },
				code: /new\s+URL.+import\.meta\.url/s
			},
			async handler(code, id) {
				let s$2;
				const assetImportMetaUrlRE = /\bnew\s+URL\s*\(\s*('[^']+'|"[^"]+"|`[^`]+`)\s*,\s*import\.meta\.url\s*(?:,\s*)?\)/dg;
				const cleanString = stripLiteral(code);
				let match;
				while (match = assetImportMetaUrlRE.exec(cleanString)) {
					const [[startIndex, endIndex], [urlStart, urlEnd]] = match.indices;
					if (hasViteIgnoreRE.test(code.slice(startIndex, urlStart))) continue;
					const rawUrl = code.slice(urlStart, urlEnd);
					if (!s$2) s$2 = new MagicString(code);
					if (rawUrl[0] === "`" && rawUrl.includes("${")) {
						const queryDelimiterIndex = getQueryDelimiterIndex(rawUrl);
						const hasQueryDelimiter = queryDelimiterIndex !== -1;
						const pureUrl = hasQueryDelimiter ? rawUrl.slice(0, queryDelimiterIndex) + "`" : rawUrl;
						const queryString = hasQueryDelimiter ? rawUrl.slice(queryDelimiterIndex, -1) : "";
						const templateLiteral = this.parse(pureUrl).body[0].expression;
						if (templateLiteral.expressions.length) {
							const pattern = buildGlobPattern(templateLiteral);
							if (pattern[0] === "*") continue;
							const globOptions = {
								eager: true,
								import: "default",
								query: injectQuery(queryString, "url")
							};
							s$2.update(startIndex, endIndex, `new URL((import.meta.glob(${JSON.stringify(pattern)}, ${JSON.stringify(globOptions)}))[${pureUrl}], import.meta.url)`);
							continue;
						}
					}
					const url$3 = rawUrl.slice(1, -1);
					if (isDataUrl(url$3)) continue;
					let file;
					if (url$3[0] === ".") {
						file = slash(path.resolve(path.dirname(id), url$3));
						file = tryFsResolve(file, fsResolveOptions) ?? file;
					} else {
						assetResolver ??= createBackCompatIdResolver(config$2, {
							extensions: [],
							mainFields: [],
							tryIndex: false,
							preferRelative: true
						});
						file = await assetResolver(this.environment, url$3, id);
						file ??= url$3[0] === "/" ? slash(path.join(publicDir, url$3)) : slash(path.resolve(path.dirname(id), url$3));
					}
					let builtUrl;
					if (file) try {
						if (publicDir && isParentDirectory(publicDir, file)) {
							const publicPath = "/" + path.posix.relative(publicDir, file);
							builtUrl = await fileToUrl$1(this, publicPath);
						} else {
							builtUrl = await fileToUrl$1(this, file);
							if (tryStatSync(file)?.isFile()) this.addWatchFile(file);
						}
					} catch {}
					if (!builtUrl) {
						const rawExp = code.slice(startIndex, endIndex);
						config$2.logger.warnOnce(`\n${rawExp} doesn't exist at build time, it will remain unchanged to be resolved at runtime. If this is intended, you can use the /* @vite-ignore */ comment to suppress this warning.`);
						builtUrl = url$3;
					}
					s$2.update(startIndex, endIndex, `new URL(${JSON.stringify(builtUrl)}, import.meta.url)`);
				}
				if (s$2) return transformStableResult(s$2, id, config$2);
			}
		}
	};
}
function buildGlobPattern(ast) {
	let pattern = "";
	let lastIsGlob = false;
	for (let i$1 = 0; i$1 < ast.quasis.length; i$1++) {
		const str = ast.quasis[i$1].value.raw;
		if (str) {
			pattern += str;
			lastIsGlob = false;
		}
		if (ast.expressions[i$1] && !lastIsGlob) {
			pattern += "*";
			lastIsGlob = true;
		}
	}
	return pattern;
}
function getQueryDelimiterIndex(rawUrl) {
	let bracketsStack = 0;
	for (let i$1 = 0; i$1 < rawUrl.length; i$1++) if (rawUrl[i$1] === "{") bracketsStack++;
	else if (rawUrl[i$1] === "}") bracketsStack--;
	else if (rawUrl[i$1] === "?" && bracketsStack === 0) return i$1;
	return -1;
}

//#endregion
//#region src/node/plugins/metadata.ts
/**
* Prepares the rendered chunks to contain additional metadata during build.
*/
function metadataPlugin() {
	return {
		name: "vite:build-metadata",
		async renderChunk(_code, chunk) {
			chunk.viteMetadata = {
				importedAssets: /* @__PURE__ */ new Set(),
				importedCss: /* @__PURE__ */ new Set()
			};
			return null;
		}
	};
}

//#endregion
//#region ../../node_modules/.pnpm/@rollup+plugin-dynamic-import-vars@2.1.4_rollup@4.43.0/node_modules/@rollup/plugin-dynamic-import-vars/dist/es/index.js
var VariableDynamicImportError = class extends Error {};
const example = "For example: import(`./foo/${bar}.js`).";
function sanitizeString(str) {
	if (str === "") return str;
	if (str.includes("*")) throw new VariableDynamicImportError("A dynamic import cannot contain * characters.");
	return escapePath(str);
}
function templateLiteralToGlob(node) {
	let glob$1 = "";
	for (let i$1 = 0; i$1 < node.quasis.length; i$1 += 1) {
		glob$1 += sanitizeString(node.quasis[i$1].value.raw);
		if (node.expressions[i$1]) glob$1 += expressionToGlob(node.expressions[i$1]);
	}
	return glob$1;
}
function callExpressionToGlob(node) {
	const { callee } = node;
	if (callee.type === "MemberExpression" && callee.property.type === "Identifier" && callee.property.name === "concat") return `${expressionToGlob(callee.object)}${node.arguments.map(expressionToGlob).join("")}`;
	return "*";
}
function binaryExpressionToGlob(node) {
	if (node.operator !== "+") throw new VariableDynamicImportError(`${node.operator} operator is not supported.`);
	return `${expressionToGlob(node.left)}${expressionToGlob(node.right)}`;
}
function expressionToGlob(node) {
	switch (node.type) {
		case "TemplateLiteral": return templateLiteralToGlob(node);
		case "CallExpression": return callExpressionToGlob(node);
		case "BinaryExpression": return binaryExpressionToGlob(node);
		case "Literal": return sanitizeString(node.value);
		default: return "*";
	}
}
const defaultProtocol = "file:";
const ignoredProtocols = [
	"data:",
	"http:",
	"https:"
];
function shouldIgnore(glob$1) {
	const containsAsterisk = glob$1.includes("*");
	const globURL = new URL(glob$1, defaultProtocol);
	const containsIgnoredProtocol = ignoredProtocols.some((ignoredProtocol) => ignoredProtocol === globURL.protocol);
	return !containsAsterisk || containsIgnoredProtocol;
}
function dynamicImportToGlob(node, sourceString) {
	let glob$1 = expressionToGlob(node);
	if (shouldIgnore(glob$1)) return null;
	glob$1 = glob$1.replace(/\*\*/g, "*");
	if (glob$1.startsWith("*")) throw new VariableDynamicImportError(`invalid import "${sourceString}". It cannot be statically analyzed. Variable dynamic imports must start with ./ and be limited to a specific directory. ${example}`);
	if (glob$1.startsWith("/")) throw new VariableDynamicImportError(`invalid import "${sourceString}". Variable absolute imports are not supported, imports must start with ./ in the static part of the import. ${example}`);
	if (!glob$1.startsWith("./") && !glob$1.startsWith("../")) throw new VariableDynamicImportError(`invalid import "${sourceString}". Variable bare imports are not supported, imports must start with ./ in the static part of the import. ${example}`);
	if (/^\.\/\*\.\w+$/.test(glob$1)) throw new VariableDynamicImportError(`${`invalid import "${sourceString}". Variable imports cannot import their own directory, place imports in a separate directory or make the import filename more specific. `}${example}`);
	if (path$1.extname(glob$1) === "") throw new VariableDynamicImportError(`invalid import "${sourceString}". A file extension must be included in the static part of the import. ${example}`);
	return glob$1;
}

//#endregion
//#region src/node/plugins/dynamicImportVars.ts
const dynamicImportHelperId = "\0vite/dynamic-import-helper.js";
const relativePathRE = /^\.{1,2}\//;
const hasDynamicImportRE = /\bimport\s*[(/]/;
const dynamicImportHelper = (glob$1, path$13, segs) => {
	const v = glob$1[path$13];
	if (v) return typeof v === "function" ? v() : Promise.resolve(v);
	return new Promise((_, reject) => {
		(typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(reject.bind(null, /* @__PURE__ */ new Error("Unknown variable dynamic import: " + path$13 + (path$13.split("/").length !== segs ? ". Note that variables only represent file names one level deep." : ""))));
	});
};
function parseDynamicImportPattern(strings) {
	const filename = strings.slice(1, -1);
	const ast = parseAst(strings).body[0].expression;
	const userPatternQuery = dynamicImportToGlob(ast, filename);
	if (!userPatternQuery) return null;
	const [userPattern] = userPatternQuery.split(requestQueryMaybeEscapedSplitRE, 2);
	let [rawPattern, search] = filename.split(requestQuerySplitRE, 2);
	let globParams = null;
	if (search) {
		search = "?" + search;
		if (workerOrSharedWorkerRE.test(search) || urlRE.test(search) || rawRE.test(search)) globParams = {
			query: search,
			import: "*"
		};
		else globParams = { query: search };
	}
	return {
		globParams,
		userPattern,
		rawPattern
	};
}
async function transformDynamicImport(importSource, importer, resolve$4, root) {
	if (importSource[1] !== "." && importSource[1] !== "/") {
		const resolvedFileName = await resolve$4(importSource.slice(1, -1), importer);
		if (!resolvedFileName) return null;
		const relativeFileName = normalizePath(posix.relative(posix.dirname(normalizePath(importer)), normalizePath(resolvedFileName)));
		importSource = "`" + (relativeFileName[0] === "." ? "" : "./") + relativeFileName + "`";
	}
	const dynamicImportPattern = parseDynamicImportPattern(importSource);
	if (!dynamicImportPattern) return null;
	const { globParams, rawPattern, userPattern } = dynamicImportPattern;
	const params = globParams ? `, ${JSON.stringify(globParams)}` : "";
	const dir = importer ? posix.dirname(importer) : root;
	const normalized = rawPattern[0] === "/" ? posix.join(root, rawPattern.slice(1)) : posix.join(dir, rawPattern);
	let newRawPattern = posix.relative(posix.dirname(importer), normalized);
	if (!relativePathRE.test(newRawPattern)) newRawPattern = `./${newRawPattern}`;
	const exp = `(import.meta.glob(${JSON.stringify(userPattern)}${params}))`;
	return {
		rawPattern: newRawPattern,
		pattern: userPattern,
		glob: exp
	};
}
function dynamicImportVarsPlugin(config$2) {
	const resolve$4 = createBackCompatIdResolver(config$2, {
		preferRelative: true,
		tryIndex: false,
		extensions: []
	});
	const getFilter = perEnvironmentState((environment) => {
		const { include, exclude } = environment.config.build.dynamicImportVarsOptions;
		return createFilter(include, exclude);
	});
	return {
		name: "vite:dynamic-import-vars",
		resolveId: {
			filter: { id: exactRegex(dynamicImportHelperId) },
			handler(id) {
				return id;
			}
		},
		load: {
			filter: { id: exactRegex(dynamicImportHelperId) },
			handler(_id) {
				return `export default ${dynamicImportHelper.toString()}`;
			}
		},
		transform: {
			filter: {
				id: { exclude: exactRegex(CLIENT_ENTRY) },
				code: hasDynamicImportRE
			},
			async handler(source, importer) {
				const { environment } = this;
				if (!getFilter(this)(importer)) return;
				await init;
				let imports = [];
				try {
					imports = parse(source)[0];
				} catch {
					return null;
				}
				if (!imports.length) return null;
				let s$2;
				let needDynamicImportHelper = false;
				for (let index = 0; index < imports.length; index++) {
					const { s: start, e: end, ss: expStart, se: expEnd, d: dynamicIndex } = imports[index];
					if (dynamicIndex === -1 || source[start] !== "`") continue;
					if (hasViteIgnoreRE.test(source.slice(expStart, expEnd))) continue;
					s$2 ||= new MagicString(source);
					let result;
					try {
						result = await transformDynamicImport(source.slice(start, end), importer, (id, importer$1) => resolve$4(environment, id, importer$1), config$2.root);
					} catch (error$1) {
						if (environment.config.build.dynamicImportVarsOptions.warnOnError) this.warn(error$1);
						else this.error(error$1);
					}
					if (!result) continue;
					const { rawPattern, glob: glob$1 } = result;
					needDynamicImportHelper = true;
					s$2.overwrite(expStart, expEnd, `__variableDynamicImportRuntimeHelper(${glob$1}, \`${rawPattern}\`, ${rawPattern.split("/").length})`);
				}
				if (s$2) {
					if (needDynamicImportHelper) s$2.prepend(`import __variableDynamicImportRuntimeHelper from "${dynamicImportHelperId}";`);
					return transformStableResult(s$2, importer, config$2);
				}
			}
		}
	};
}

//#endregion
//#region src/node/plugins/pluginFilter.ts
function getMatcherString(glob$1, cwd) {
	if (glob$1.startsWith("**") || path.isAbsolute(glob$1)) return slash(glob$1);
	return slash(path.join(cwd, glob$1));
}
function patternToIdFilter(pattern, cwd) {
	if (pattern instanceof RegExp) return (id) => {
		const normalizedId = slash(id);
		const result = pattern.test(normalizedId);
		pattern.lastIndex = 0;
		return result;
	};
	const matcher = picomatch(getMatcherString(pattern, cwd), { dot: true });
	return (id) => {
		return matcher(slash(id));
	};
}
function patternToCodeFilter(pattern) {
	if (pattern instanceof RegExp) return (code) => {
		const result = pattern.test(code);
		pattern.lastIndex = 0;
		return result;
	};
	return (code) => code.includes(pattern);
}
function createFilter$1(exclude, include) {
	if (!exclude && !include) return;
	return (input) => {
		if (exclude?.some((filter$1) => filter$1(input))) return false;
		if (include?.some((filter$1) => filter$1(input))) return true;
		return !(include && include.length > 0);
	};
}
function normalizeFilter(filter$1) {
	if (typeof filter$1 === "string" || filter$1 instanceof RegExp) return { include: [filter$1] };
	if (Array.isArray(filter$1)) return { include: filter$1 };
	return {
		include: filter$1.include ? arraify(filter$1.include) : void 0,
		exclude: filter$1.exclude ? arraify(filter$1.exclude) : void 0
	};
}
function createIdFilter(filter$1, cwd = process.cwd()) {
	if (!filter$1) return;
	const { exclude, include } = normalizeFilter(filter$1);
	const excludeFilter = exclude?.map((p) => patternToIdFilter(p, cwd));
	const includeFilter = include?.map((p) => patternToIdFilter(p, cwd));
	return createFilter$1(excludeFilter, includeFilter);
}
function createCodeFilter(filter$1) {
	if (!filter$1) return;
	const { exclude, include } = normalizeFilter(filter$1);
	const excludeFilter = exclude?.map(patternToCodeFilter);
	const includeFilter = include?.map(patternToCodeFilter);
	return createFilter$1(excludeFilter, includeFilter);
}
function createFilterForTransform(idFilter, codeFilter, cwd) {
	if (!idFilter && !codeFilter) return;
	const idFilterFn = createIdFilter(idFilter, cwd);
	const codeFilterFn = createCodeFilter(codeFilter);
	return (id, code) => {
		let fallback = true;
		if (idFilterFn) fallback &&= idFilterFn(id);
		if (!fallback) return false;
		if (codeFilterFn) fallback &&= codeFilterFn(code);
		return fallback;
	};
}

//#endregion
//#region src/node/plugins/index.ts
async function resolvePlugins(config$2, prePlugins, normalPlugins, postPlugins) {
	const isBuild = config$2.command === "build";
	const isWorker = config$2.isWorker;
	const buildPlugins = isBuild ? await (await import("./build.js")).resolveBuildPlugins(config$2) : {
		pre: [],
		post: []
	};
	const { modulePreload } = config$2.build;
	return [
		!isBuild ? optimizedDepsPlugin() : null,
		isBuild ? metadataPlugin() : null,
		!isWorker ? watchPackageDataPlugin(config$2.packageCache) : null,
		!isBuild ? preAliasPlugin(config$2) : null,
		alias({
			entries: config$2.resolve.alias,
			customResolver: viteAliasCustomResolver
		}),
		...prePlugins,
		modulePreload !== false && modulePreload.polyfill ? modulePreloadPolyfillPlugin(config$2) : null,
		resolvePlugin({
			root: config$2.root,
			isProduction: config$2.isProduction,
			isBuild,
			packageCache: config$2.packageCache,
			asSrc: true,
			optimizeDeps: true,
			externalize: true
		}),
		htmlInlineProxyPlugin(config$2),
		cssPlugin(config$2),
		config$2.esbuild !== false ? esbuildPlugin(config$2) : null,
		jsonPlugin(config$2.json, isBuild),
		wasmHelperPlugin(),
		webWorkerPlugin(config$2),
		assetPlugin(config$2),
		...normalPlugins,
		wasmFallbackPlugin(),
		definePlugin(config$2),
		cssPostPlugin(config$2),
		isBuild && buildHtmlPlugin(config$2),
		workerImportMetaUrlPlugin(config$2),
		assetImportMetaUrlPlugin(config$2),
		...buildPlugins.pre,
		dynamicImportVarsPlugin(config$2),
		importGlobPlugin(config$2),
		...postPlugins,
		...buildPlugins.post,
		...isBuild ? [] : [
			clientInjectionsPlugin(config$2),
			cssAnalysisPlugin(config$2),
			importAnalysisPlugin(config$2)
		]
	].filter(Boolean);
}
function createPluginHookUtils(plugins$1) {
	const sortedPluginsCache = /* @__PURE__ */ new Map();
	function getSortedPlugins(hookName) {
		if (sortedPluginsCache.has(hookName)) return sortedPluginsCache.get(hookName);
		const sorted = getSortedPluginsByHook(hookName, plugins$1);
		sortedPluginsCache.set(hookName, sorted);
		return sorted;
	}
	function getSortedPluginHooks(hookName) {
		return getSortedPlugins(hookName).map((p) => getHookHandler(p[hookName])).filter(Boolean);
	}
	return {
		getSortedPlugins,
		getSortedPluginHooks
	};
}
function getSortedPluginsByHook(hookName, plugins$1) {
	const sortedPlugins = [];
	let pre = 0, normal = 0, post = 0;
	for (const plugin of plugins$1) {
		const hook = plugin[hookName];
		if (hook) {
			if (typeof hook === "object") {
				if (hook.order === "pre") {
					sortedPlugins.splice(pre++, 0, plugin);
					continue;
				}
				if (hook.order === "post") {
					sortedPlugins.splice(pre + normal + post++, 0, plugin);
					continue;
				}
			}
			sortedPlugins.splice(pre + normal++, 0, plugin);
		}
	}
	return sortedPlugins;
}
function getHookHandler(hook) {
	return typeof hook === "object" ? hook.handler : hook;
}
const filterForPlugin = /* @__PURE__ */ new WeakMap();
function getCachedFilterForPlugin(plugin, hookName) {
	let filters = filterForPlugin.get(plugin);
	if (filters && hookName in filters) return filters[hookName];
	if (!filters) {
		filters = {};
		filterForPlugin.set(plugin, filters);
	}
	let filter$1;
	switch (hookName) {
		case "resolveId": {
			const rawFilter = extractFilter(plugin.resolveId)?.id;
			filters.resolveId = createIdFilter(rawFilter);
			filter$1 = filters.resolveId;
			break;
		}
		case "load": {
			const rawFilter = extractFilter(plugin.load)?.id;
			filters.load = createIdFilter(rawFilter);
			filter$1 = filters.load;
			break;
		}
		case "transform": {
			const rawFilters = extractFilter(plugin.transform);
			filters.transform = createFilterForTransform(rawFilters?.id, rawFilters?.code);
			filter$1 = filters.transform;
			break;
		}
	}
	return filter$1;
}
function extractFilter(hook) {
	return hook && "filter" in hook && hook.filter ? hook.filter : void 0;
}
const viteAliasCustomResolver = async function(id, importer, options$1) {
	return await this.resolve(id, importer, options$1) || {
		id,
		meta: { "vite:alias": { noResolved: true } }
	};
};

//#endregion
//#region src/node/server/pluginContainer.ts
var import_picocolors$7 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const EMPTY_OBJECT = Object.freeze({});
const debugSourcemapCombineFilter = process.env.DEBUG_VITE_SOURCEMAP_COMBINE_FILTER;
const debugSourcemapCombine = createDebugger("vite:sourcemap-combine", { onlyWhenFocused: true });
const debugResolve = createDebugger("vite:resolve");
const debugPluginResolve = createDebugger("vite:plugin-resolve", { onlyWhenFocused: "vite:plugin" });
const debugPluginTransform = createDebugger("vite:plugin-transform", { onlyWhenFocused: "vite:plugin" });
const debugPluginContainerContext = createDebugger("vite:plugin-container-context");
const ERR_CLOSED_SERVER = "ERR_CLOSED_SERVER";
function throwClosedServerError() {
	const err$2 = /* @__PURE__ */ new Error("The server is being restarted or closed. Request is outdated");
	err$2.code = ERR_CLOSED_SERVER;
	throw err$2;
}
/**
* Create a plugin container with a set of plugins. We pass them as a parameter
* instead of using environment.plugins to allow the creation of different
* pipelines working with the same environment (used for createIdResolver).
*/
async function createEnvironmentPluginContainer(environment, plugins$1, watcher, autoStart = true) {
	const container = new EnvironmentPluginContainer(environment, plugins$1, watcher, autoStart);
	await container.resolveRollupOptions();
	return container;
}
var EnvironmentPluginContainer = class {
	_pluginContextMap = /* @__PURE__ */ new Map();
	_resolvedRollupOptions;
	_processesing = /* @__PURE__ */ new Set();
	_seenResolves = {};
	_moduleNodeToLoadAddedImports = /* @__PURE__ */ new WeakMap();
	getSortedPluginHooks;
	getSortedPlugins;
	moduleGraph;
	watchFiles = /* @__PURE__ */ new Set();
	minimalContext;
	_started = false;
	_buildStartPromise;
	_closed = false;
	/**
	* @internal use `createEnvironmentPluginContainer` instead
	*/
	constructor(environment, plugins$1, watcher, autoStart = true) {
		this.environment = environment;
		this.plugins = plugins$1;
		this.watcher = watcher;
		this._started = !autoStart;
		this.minimalContext = new MinimalPluginContext({
			...basePluginContextMeta,
			watchMode: true
		}, environment);
		const utils$3 = createPluginHookUtils(plugins$1);
		this.getSortedPlugins = utils$3.getSortedPlugins;
		this.getSortedPluginHooks = utils$3.getSortedPluginHooks;
		this.moduleGraph = environment.mode === "dev" ? environment.moduleGraph : void 0;
	}
	_updateModuleLoadAddedImports(id, addedImports) {
		const module$1 = this.moduleGraph?.getModuleById(id);
		if (module$1) this._moduleNodeToLoadAddedImports.set(module$1, addedImports);
	}
	_getAddedImports(id) {
		const module$1 = this.moduleGraph?.getModuleById(id);
		return module$1 ? this._moduleNodeToLoadAddedImports.get(module$1) || null : null;
	}
	getModuleInfo(id) {
		const module$1 = this.moduleGraph?.getModuleById(id);
		if (!module$1) return null;
		if (!module$1.info) module$1.info = new Proxy({
			id,
			meta: module$1.meta || EMPTY_OBJECT
		}, { get(info, key) {
			if (key in info) return info[key];
			if (key === "then") return;
			throw Error(`[vite] The "${key}" property of ModuleInfo is not supported.`);
		} });
		return module$1.info ?? null;
	}
	handleHookPromise(maybePromise) {
		if (!maybePromise?.then) return maybePromise;
		const promise = maybePromise;
		this._processesing.add(promise);
		return promise.finally(() => this._processesing.delete(promise));
	}
	get options() {
		return this._resolvedRollupOptions;
	}
	async resolveRollupOptions() {
		if (!this._resolvedRollupOptions) {
			let options$1 = this.environment.config.build.rollupOptions;
			for (const optionsHook of this.getSortedPluginHooks("options")) {
				if (this._closed) throwClosedServerError();
				options$1 = await this.handleHookPromise(optionsHook.call(this.minimalContext, options$1)) || options$1;
			}
			this._resolvedRollupOptions = options$1;
		}
		return this._resolvedRollupOptions;
	}
	_getPluginContext(plugin) {
		if (!this._pluginContextMap.has(plugin)) this._pluginContextMap.set(plugin, new PluginContext(plugin, this));
		return this._pluginContextMap.get(plugin);
	}
	async hookParallel(hookName, context, args, condition) {
		const parallelPromises = [];
		for (const plugin of this.getSortedPlugins(hookName)) {
			if (condition && !condition(plugin)) continue;
			const hook = plugin[hookName];
			const handler = getHookHandler(hook);
			if (hook.sequential) {
				await Promise.all(parallelPromises);
				parallelPromises.length = 0;
				await handler.apply(context(plugin), args(plugin));
			} else parallelPromises.push(handler.apply(context(plugin), args(plugin)));
		}
		await Promise.all(parallelPromises);
	}
	async buildStart(_options) {
		if (this._started) {
			if (this._buildStartPromise) await this._buildStartPromise;
			return;
		}
		this._started = true;
		const config$2 = this.environment.getTopLevelConfig();
		this._buildStartPromise = this.handleHookPromise(this.hookParallel("buildStart", (plugin) => this._getPluginContext(plugin), () => [this.options], (plugin) => this.environment.name === "client" || config$2.server.perEnvironmentStartEndDuringDev || plugin.perEnvironmentStartEndDuringDev));
		await this._buildStartPromise;
		this._buildStartPromise = void 0;
	}
	async resolveId(rawId, importer = join(this.environment.config.root, "index.html"), options$1) {
		if (!this._started) {
			this.buildStart();
			await this._buildStartPromise;
		}
		const skip = options$1?.skip;
		const skipCalls = options$1?.skipCalls;
		const scan = !!options$1?.scan;
		const ssr = this.environment.config.consumer === "server";
		const ctx = new ResolveIdContext(this, skip, skipCalls, scan);
		const topLevelConfig = this.environment.getTopLevelConfig();
		const mergedSkip = new Set(skip);
		for (const call$1 of skipCalls ?? []) if (call$1.called || call$1.id === rawId && call$1.importer === importer) mergedSkip.add(call$1.plugin);
		const resolveStart = debugResolve ? performance$1.now() : 0;
		let id = null;
		const partial = {};
		for (const plugin of this.getSortedPlugins("resolveId")) {
			if (this._closed && this.environment.config.dev.recoverable) throwClosedServerError();
			if (mergedSkip?.has(plugin)) continue;
			const filter$1 = getCachedFilterForPlugin(plugin, "resolveId");
			if (filter$1 && !filter$1(rawId)) continue;
			ctx._plugin = plugin;
			const normalizedOptions = {
				attributes: options$1?.attributes ?? {},
				custom: options$1?.custom,
				isEntry: !!options$1?.isEntry,
				ssr,
				scan
			};
			if (isFutureDeprecationEnabled(topLevelConfig, "removePluginHookSsrArgument")) {
				let ssrTemp = ssr;
				Object.defineProperty(normalizedOptions, "ssr", {
					get() {
						warnFutureDeprecation(topLevelConfig, "removePluginHookSsrArgument", `Used in plugin "${plugin.name}".`);
						return ssrTemp;
					},
					set(v) {
						ssrTemp = v;
					}
				});
			}
			const pluginResolveStart = debugPluginResolve ? performance$1.now() : 0;
			const handler = getHookHandler(plugin.resolveId);
			const result = await this.handleHookPromise(handler.call(ctx, rawId, importer, normalizedOptions));
			if (!result) continue;
			if (typeof result === "string") id = result;
			else {
				id = result.id;
				Object.assign(partial, result);
			}
			debugPluginResolve?.(timeFrom(pluginResolveStart), plugin.name, prettifyUrl(id, this.environment.config.root));
			break;
		}
		if (debugResolve && rawId !== id && !rawId.startsWith(FS_PREFIX)) {
			const key = rawId + id;
			if (!this._seenResolves[key]) {
				this._seenResolves[key] = true;
				debugResolve(`${timeFrom(resolveStart)} ${import_picocolors$7.default.cyan(rawId)} -> ${import_picocolors$7.default.dim(id)}`);
			}
		}
		if (id) {
			partial.id = isExternalUrl(id) || id[0] === "\0" ? id : normalizePath(id);
			return partial;
		} else return null;
	}
	async load(id) {
		let ssr = this.environment.config.consumer === "server";
		const topLevelConfig = this.environment.getTopLevelConfig();
		const options$1 = { ssr };
		const ctx = new LoadPluginContext(this);
		for (const plugin of this.getSortedPlugins("load")) {
			if (this._closed && this.environment.config.dev.recoverable) throwClosedServerError();
			const filter$1 = getCachedFilterForPlugin(plugin, "load");
			if (filter$1 && !filter$1(id)) continue;
			ctx._plugin = plugin;
			if (isFutureDeprecationEnabled(topLevelConfig, "removePluginHookSsrArgument")) Object.defineProperty(options$1, "ssr", {
				get() {
					warnFutureDeprecation(topLevelConfig, "removePluginHookSsrArgument", `Used in plugin "${plugin.name}".`);
					return ssr;
				},
				set(v) {
					ssr = v;
				}
			});
			const handler = getHookHandler(plugin.load);
			const result = await this.handleHookPromise(handler.call(ctx, id, options$1));
			if (result != null) {
				if (isObject(result)) ctx._updateModuleInfo(id, result);
				this._updateModuleLoadAddedImports(id, ctx._addedImports);
				return result;
			}
		}
		this._updateModuleLoadAddedImports(id, ctx._addedImports);
		return null;
	}
	async transform(code, id, options$1) {
		let ssr = this.environment.config.consumer === "server";
		const topLevelConfig = this.environment.getTopLevelConfig();
		const optionsWithSSR = options$1 ? {
			...options$1,
			ssr
		} : { ssr };
		const inMap = options$1?.inMap;
		const ctx = new TransformPluginContext(this, id, code, inMap);
		ctx._addedImports = this._getAddedImports(id);
		for (const plugin of this.getSortedPlugins("transform")) {
			if (this._closed && this.environment.config.dev.recoverable) throwClosedServerError();
			const filter$1 = getCachedFilterForPlugin(plugin, "transform");
			if (filter$1 && !filter$1(id, code)) continue;
			if (isFutureDeprecationEnabled(topLevelConfig, "removePluginHookSsrArgument")) Object.defineProperty(optionsWithSSR, "ssr", {
				get() {
					warnFutureDeprecation(topLevelConfig, "removePluginHookSsrArgument", `Used in plugin "${plugin.name}".`);
					return ssr;
				},
				set(v) {
					ssr = v;
				}
			});
			ctx._updateActiveInfo(plugin, id, code);
			const start = debugPluginTransform ? performance$1.now() : 0;
			let result;
			const handler = getHookHandler(plugin.transform);
			try {
				result = await this.handleHookPromise(handler.call(ctx, code, id, optionsWithSSR));
			} catch (e$1) {
				ctx.error(e$1);
			}
			if (!result) continue;
			debugPluginTransform?.(timeFrom(start), plugin.name, prettifyUrl(id, this.environment.config.root));
			if (isObject(result)) {
				if (result.code !== void 0) {
					code = result.code;
					if (result.map) {
						if (debugSourcemapCombine) result.map.name = plugin.name;
						ctx.sourcemapChain.push(result.map);
					}
				}
				ctx._updateModuleInfo(id, result);
			} else code = result;
		}
		return {
			code,
			map: ctx._getCombinedSourcemap()
		};
	}
	async watchChange(id, change) {
		await this.hookParallel("watchChange", (plugin) => this._getPluginContext(plugin), () => [id, change]);
	}
	async close() {
		if (this._closed) return;
		this._closed = true;
		await Promise.allSettled(Array.from(this._processesing));
		const config$2 = this.environment.getTopLevelConfig();
		await this.hookParallel("buildEnd", (plugin) => this._getPluginContext(plugin), () => [], (plugin) => this.environment.name === "client" || config$2.server.perEnvironmentStartEndDuringDev || plugin.perEnvironmentStartEndDuringDev);
		await this.hookParallel("closeBundle", (plugin) => this._getPluginContext(plugin), () => []);
	}
};
const basePluginContextMeta = {
	viteVersion: VERSION,
	rollupVersion
};
var BasicMinimalPluginContext = class {
	constructor(meta, _logger) {
		this.meta = meta;
		this._logger = _logger;
	}
	debug(rawLog) {
		const log$4 = this._normalizeRawLog(rawLog);
		const msg = buildErrorMessage(log$4, [`debug: ${log$4.message}`], false);
		debugPluginContainerContext?.(msg);
	}
	info(rawLog) {
		const log$4 = this._normalizeRawLog(rawLog);
		const msg = buildErrorMessage(log$4, [`info: ${log$4.message}`], false);
		this._logger.info(msg, {
			clear: true,
			timestamp: true
		});
	}
	warn(rawLog) {
		const log$4 = this._normalizeRawLog(rawLog);
		const msg = buildErrorMessage(log$4, [import_picocolors$7.default.yellow(`warning: ${log$4.message}`)], false);
		this._logger.warn(msg, {
			clear: true,
			timestamp: true
		});
	}
	error(e$1) {
		throw typeof e$1 === "string" ? new Error(e$1) : e$1;
	}
	_normalizeRawLog(rawLog) {
		const logValue = typeof rawLog === "function" ? rawLog() : rawLog;
		return typeof logValue === "string" ? new Error(logValue) : logValue;
	}
};
var MinimalPluginContext = class extends BasicMinimalPluginContext {
	environment;
	constructor(meta, environment) {
		super(meta, environment.logger);
		this.environment = environment;
	}
};
const fsModule = {
	appendFile: fsp.appendFile,
	copyFile: fsp.copyFile,
	mkdir: fsp.mkdir,
	mkdtemp: fsp.mkdtemp,
	readdir: fsp.readdir,
	readFile: fsp.readFile,
	realpath: fsp.realpath,
	rename: fsp.rename,
	rmdir: fsp.rmdir,
	stat: fsp.stat,
	lstat: fsp.lstat,
	unlink: fsp.unlink,
	writeFile: fsp.writeFile
};
var PluginContext = class extends MinimalPluginContext {
	ssr = false;
	_scan = false;
	_activeId = null;
	_activeCode = null;
	_resolveSkips;
	_resolveSkipCalls;
	constructor(_plugin, _container) {
		super(_container.minimalContext.meta, _container.environment);
		this._plugin = _plugin;
		this._container = _container;
	}
	fs = fsModule;
	parse(code, opts) {
		return parseAst(code, opts);
	}
	async resolve(id, importer, options$1) {
		let skipCalls;
		if (options$1?.skipSelf === false) skipCalls = this._resolveSkipCalls;
		else if (this._resolveSkipCalls) {
			const skipCallsTemp = [...this._resolveSkipCalls];
			const sameCallIndex = this._resolveSkipCalls.findIndex((c) => c.id === id && c.importer === importer && c.plugin === this._plugin);
			if (sameCallIndex !== -1) skipCallsTemp[sameCallIndex] = {
				...skipCallsTemp[sameCallIndex],
				called: true
			};
			else skipCallsTemp.push({
				id,
				importer,
				plugin: this._plugin
			});
			skipCalls = skipCallsTemp;
		} else skipCalls = [{
			id,
			importer,
			plugin: this._plugin
		}];
		let out = await this._container.resolveId(id, importer, {
			attributes: options$1?.attributes,
			custom: options$1?.custom,
			isEntry: !!options$1?.isEntry,
			skip: this._resolveSkips,
			skipCalls,
			scan: this._scan
		});
		if (typeof out === "string") out = { id: out };
		return out;
	}
	async load(options$1) {
		await this._container.moduleGraph?.ensureEntryFromUrl(unwrapId(options$1.id));
		this._updateModuleInfo(options$1.id, options$1);
		const loadResult = await this._container.load(options$1.id);
		const code = typeof loadResult === "object" ? loadResult?.code : loadResult;
		if (code != null) await this._container.transform(code, options$1.id);
		const moduleInfo = this.getModuleInfo(options$1.id);
		if (!moduleInfo) throw Error(`Failed to load module with id ${options$1.id}`);
		return moduleInfo;
	}
	getModuleInfo(id) {
		return this._container.getModuleInfo(id);
	}
	_updateModuleInfo(id, { meta }) {
		if (meta) {
			const moduleInfo = this.getModuleInfo(id);
			if (moduleInfo) moduleInfo.meta = {
				...moduleInfo.meta,
				...meta
			};
		}
	}
	getModuleIds() {
		return this._container.moduleGraph ? this._container.moduleGraph.idToModuleMap.keys() : Array.prototype[Symbol.iterator]();
	}
	addWatchFile(id) {
		this._container.watchFiles.add(id);
		if (this._container.watcher) ensureWatchedFile(this._container.watcher, id, this.environment.config.root);
	}
	getWatchFiles() {
		return [...this._container.watchFiles];
	}
	emitFile(_assetOrFile) {
		this._warnIncompatibleMethod(`emitFile`);
		return "";
	}
	setAssetSource() {
		this._warnIncompatibleMethod(`setAssetSource`);
	}
	getFileName() {
		this._warnIncompatibleMethod(`getFileName`);
		return "";
	}
	debug(log$4) {
		const err$2 = this._formatLog(typeof log$4 === "function" ? log$4() : log$4);
		super.debug(err$2);
	}
	info(log$4) {
		const err$2 = this._formatLog(typeof log$4 === "function" ? log$4() : log$4);
		super.info(err$2);
	}
	warn(log$4, position) {
		const err$2 = this._formatLog(typeof log$4 === "function" ? log$4() : log$4, position);
		super.warn(err$2);
	}
	error(e$1, position) {
		throw this._formatLog(e$1, position);
	}
	_formatLog(e$1, position) {
		const err$2 = typeof e$1 === "string" ? new Error(e$1) : e$1;
		if (err$2.pluginCode) return err$2;
		err$2.plugin = this._plugin.name;
		if (this._activeId && !err$2.id) err$2.id = this._activeId;
		if (this._activeCode) {
			err$2.pluginCode = this._activeCode;
			const pos = position ?? err$2.pos ?? err$2.position;
			if (pos != null) {
				let errLocation;
				try {
					errLocation = numberToPos(this._activeCode, pos);
				} catch (err2) {
					this.environment.logger.error(import_picocolors$7.default.red(`Error in error handler:\n${err2.stack || err2.message}\n`), { error: err2 });
					throw err$2;
				}
				err$2.loc = err$2.loc || {
					file: err$2.id,
					...errLocation
				};
				err$2.frame = err$2.frame || generateCodeFrame(this._activeCode, pos);
			} else if (err$2.loc) {
				if (!err$2.frame) {
					let code = this._activeCode;
					if (err$2.loc.file) {
						err$2.id = normalizePath(err$2.loc.file);
						try {
							code = fs.readFileSync(err$2.loc.file, "utf-8");
						} catch {}
					}
					err$2.frame = generateCodeFrame(code, err$2.loc);
				}
			} else if (err$2.line && err$2.column) {
				err$2.loc = {
					file: err$2.id,
					line: err$2.line,
					column: err$2.column
				};
				err$2.frame = err$2.frame || generateCodeFrame(this._activeCode, err$2.loc);
			}
			if (this instanceof TransformPluginContext && typeof err$2.loc?.line === "number" && typeof err$2.loc.column === "number") {
				const rawSourceMap = this._getCombinedSourcemap();
				if (rawSourceMap && "version" in rawSourceMap) {
					const { source, line, column } = originalPositionFor(new TraceMap(rawSourceMap), {
						line: Number(err$2.loc.line),
						column: Number(err$2.loc.column)
					});
					if (source) err$2.loc = {
						file: source,
						line,
						column
					};
				}
			}
		} else if (err$2.loc) {
			if (!err$2.frame) {
				let code = err$2.pluginCode;
				if (err$2.loc.file) {
					err$2.id = normalizePath(err$2.loc.file);
					if (!code) try {
						code = fs.readFileSync(err$2.loc.file, "utf-8");
					} catch {}
				}
				if (code) err$2.frame = generateCodeFrame(`${code}`, err$2.loc);
			}
		}
		if (typeof err$2.loc?.column !== "number" && typeof err$2.loc?.line !== "number" && !err$2.loc?.file) delete err$2.loc;
		return err$2;
	}
	_warnIncompatibleMethod(method) {
		this.environment.logger.warn(import_picocolors$7.default.cyan(`[plugin:${this._plugin.name}] `) + import_picocolors$7.default.yellow(`context method ${import_picocolors$7.default.bold(`${method}()`)} is not supported in serve mode. This plugin is likely not vite-compatible.`));
	}
};
var ResolveIdContext = class extends PluginContext {
	constructor(container, skip, skipCalls, scan) {
		super(null, container);
		this._resolveSkips = skip;
		this._resolveSkipCalls = skipCalls;
		this._scan = scan;
	}
};
var LoadPluginContext = class extends PluginContext {
	_addedImports = null;
	constructor(container) {
		super(null, container);
	}
	addWatchFile(id) {
		if (!this._addedImports) this._addedImports = /* @__PURE__ */ new Set();
		this._addedImports.add(id);
		super.addWatchFile(id);
	}
};
var TransformPluginContext = class extends LoadPluginContext {
	filename;
	originalCode;
	originalSourcemap = null;
	sourcemapChain = [];
	combinedMap = null;
	constructor(container, id, code, inMap) {
		super(container);
		this.filename = id;
		this.originalCode = code;
		if (inMap) {
			if (debugSourcemapCombine) inMap.name = "$inMap";
			this.sourcemapChain.push(inMap);
		}
	}
	_getCombinedSourcemap() {
		if (debugSourcemapCombine && debugSourcemapCombineFilter && this.filename.includes(debugSourcemapCombineFilter)) {
			debugSourcemapCombine("----------", this.filename);
			debugSourcemapCombine(this.combinedMap);
			debugSourcemapCombine(this.sourcemapChain);
			debugSourcemapCombine("----------");
		}
		let combinedMap = this.combinedMap;
		if (combinedMap && !("version" in combinedMap) && combinedMap.mappings === "") {
			this.sourcemapChain.length = 0;
			return combinedMap;
		}
		for (let m$2 of this.sourcemapChain) {
			if (typeof m$2 === "string") m$2 = JSON.parse(m$2);
			if (!("version" in m$2)) {
				if (m$2.mappings === "") {
					combinedMap = { mappings: "" };
					break;
				}
				combinedMap = null;
				break;
			}
			if (!combinedMap) {
				const sm = m$2;
				if (sm.sources.length === 1 && !sm.sources[0]) combinedMap = {
					...sm,
					sources: [this.filename],
					sourcesContent: [this.originalCode]
				};
				else combinedMap = sm;
			} else combinedMap = combineSourcemaps(cleanUrl(this.filename), [m$2, combinedMap]);
		}
		if (combinedMap !== this.combinedMap) {
			this.combinedMap = combinedMap;
			this.sourcemapChain.length = 0;
		}
		return this.combinedMap;
	}
	getCombinedSourcemap() {
		const map$1 = this._getCombinedSourcemap();
		if (!map$1 || !("version" in map$1) && map$1.mappings === "") return new MagicString(this.originalCode).generateMap({
			includeContent: true,
			hires: "boundary",
			source: cleanUrl(this.filename)
		});
		return map$1;
	}
	_updateActiveInfo(plugin, id, code) {
		this._plugin = plugin;
		this._activeId = id;
		this._activeCode = code;
	}
};
var PluginContainer = class {
	constructor(environments) {
		this.environments = environments;
	}
	_getEnvironment(options$1) {
		return options$1?.environment ? options$1.environment : this.environments[options$1?.ssr ? "ssr" : "client"];
	}
	_getPluginContainer(options$1) {
		return this._getEnvironment(options$1).pluginContainer;
	}
	getModuleInfo(id) {
		const clientModuleInfo = this.environments.client.pluginContainer.getModuleInfo(id);
		const ssrModuleInfo = this.environments.ssr.pluginContainer.getModuleInfo(id);
		if (clientModuleInfo == null && ssrModuleInfo == null) return null;
		return new Proxy({}, { get: (_, key) => {
			if (key === "meta") {
				const meta = {};
				if (ssrModuleInfo) Object.assign(meta, ssrModuleInfo.meta);
				if (clientModuleInfo) Object.assign(meta, clientModuleInfo.meta);
				return meta;
			}
			if (clientModuleInfo) {
				if (key in clientModuleInfo) return clientModuleInfo[key];
			}
			if (ssrModuleInfo) {
				if (key in ssrModuleInfo) return ssrModuleInfo[key];
			}
		} });
	}
	get options() {
		return this.environments.client.pluginContainer.options;
	}
	async buildStart(_options) {
		return this.environments.client.pluginContainer.buildStart(_options);
	}
	async watchChange(id, change) {
		return this.environments.client.pluginContainer.watchChange(id, change);
	}
	async resolveId(rawId, importer, options$1) {
		return this._getPluginContainer(options$1).resolveId(rawId, importer, options$1);
	}
	async load(id, options$1) {
		return this._getPluginContainer(options$1).load(id);
	}
	async transform(code, id, options$1) {
		return this._getPluginContainer(options$1).transform(code, id, options$1);
	}
	async close() {}
};
/**
* server.pluginContainer compatibility
*
* The default environment is in buildStart, buildEnd, watchChange, and closeBundle hooks,
* which are called once for all environments, or when no environment is passed in other hooks.
* The ssrEnvironment is needed for backward compatibility when the ssr flag is passed without
* an environment. The defaultEnvironment in the main pluginContainer in the server should be
* the client environment for backward compatibility.
**/
function createPluginContainer(environments) {
	return new PluginContainer(environments);
}

//#endregion
//#region src/node/idResolver.ts
/**
* Some projects like Astro were overriding config.createResolver to add a custom
* alias plugin. For the client and ssr environments, we root through it to avoid
* breaking changes for now.
*/
function createBackCompatIdResolver(config$2, options$1) {
	const compatResolve = config$2.createResolver(options$1);
	let resolve$4;
	return async (environment, id, importer, aliasOnly) => {
		if (environment.name === "client" || environment.name === "ssr") return compatResolve(id, importer, aliasOnly, environment.name === "ssr");
		resolve$4 ??= createIdResolver(config$2, options$1);
		return resolve$4(environment, id, importer, aliasOnly);
	};
}
/**
* Create an internal resolver to be used in special scenarios, e.g.
* optimizer and handling css @imports
*/
function createIdResolver(config$2, options$1) {
	const scan = options$1?.scan;
	const pluginContainerMap = /* @__PURE__ */ new Map();
	async function resolve$4(environment, id, importer) {
		let pluginContainer = pluginContainerMap.get(environment);
		if (!pluginContainer) {
			pluginContainer = await createEnvironmentPluginContainer(environment, [alias({ entries: environment.config.resolve.alias }), resolvePlugin({
				root: config$2.root,
				isProduction: config$2.isProduction,
				isBuild: config$2.command === "build",
				asSrc: true,
				preferRelative: false,
				tryIndex: true,
				...options$1,
				idOnly: true
			})], void 0, false);
			pluginContainerMap.set(environment, pluginContainer);
		}
		return await pluginContainer.resolveId(id, importer, { scan });
	}
	const aliasOnlyPluginContainerMap = /* @__PURE__ */ new Map();
	async function resolveAlias(environment, id, importer) {
		let pluginContainer = aliasOnlyPluginContainerMap.get(environment);
		if (!pluginContainer) {
			pluginContainer = await createEnvironmentPluginContainer(environment, [alias({ entries: environment.config.resolve.alias })], void 0, false);
			aliasOnlyPluginContainerMap.set(environment, pluginContainer);
		}
		return await pluginContainer.resolveId(id, importer, { scan });
	}
	return async (environment, id, importer, aliasOnly) => {
		return (await (aliasOnly ? resolveAlias : resolve$4)(environment, id, importer))?.id;
	};
}

//#endregion
//#region src/node/plugins/css.ts
var import_src = /* @__PURE__ */ __toESM(require_src(), 1);
var import_picocolors$6 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const decoder = new TextDecoder();
const cssConfigDefaults = Object.freeze({
	transformer: "postcss",
	preprocessorMaxWorkers: true,
	devSourcemap: false
});
function resolveCSSOptions(options$1) {
	const resolved = mergeWithDefaults(cssConfigDefaults, options$1 ?? {});
	if (resolved.transformer === "lightningcss") {
		resolved.lightningcss ??= {};
		resolved.lightningcss.targets ??= convertTargets(ESBUILD_BASELINE_WIDELY_AVAILABLE_TARGET);
	}
	return resolved;
}
const cssModuleRE = /* @__PURE__ */ new RegExp(`\\.module${CSS_LANGS_RE.source}`);
const directRequestRE = /[?&]direct\b/;
const htmlProxyRE = /[?&]html-proxy\b/;
const htmlProxyIndexRE = /&index=(\d+)/;
const commonjsProxyRE = /[?&]commonjs-proxy/;
const inlineRE = /[?&]inline\b/;
const inlineCSSRE = /[?&]inline-css\b/;
const styleAttrRE = /[?&]style-attr\b/;
const functionCallRE = /^[A-Z_][.\w-]*\(/i;
const transformOnlyRE = /[?&]transform-only\b/;
const nonEscapedDoubleQuoteRe = /(?<!\\)"/g;
const defaultCssBundleName = "style.css";
var PreprocessLang = /* @__PURE__ */ function(PreprocessLang$1) {
	PreprocessLang$1["less"] = "less";
	PreprocessLang$1["sass"] = "sass";
	PreprocessLang$1["scss"] = "scss";
	PreprocessLang$1["styl"] = "styl";
	PreprocessLang$1["stylus"] = "stylus";
	return PreprocessLang$1;
}(PreprocessLang || {});
var PostCssDialectLang = /* @__PURE__ */ function(PostCssDialectLang$1) {
	PostCssDialectLang$1["sss"] = "sugarss";
	return PostCssDialectLang$1;
}(PostCssDialectLang || {});
const isModuleCSSRequest = (request) => cssModuleRE.test(request);
const isDirectCSSRequest = (request) => CSS_LANGS_RE.test(request) && directRequestRE.test(request);
const isDirectRequest = (request) => directRequestRE.test(request);
const cssModulesCache = /* @__PURE__ */ new WeakMap();
const removedPureCssFilesCache = /* @__PURE__ */ new WeakMap();
const cssBundleNameCache = /* @__PURE__ */ new WeakMap();
const postcssConfigCache = /* @__PURE__ */ new WeakMap();
function encodePublicUrlsInCSS(config$2) {
	return config$2.command === "build";
}
const cssUrlAssetRE = /__VITE_CSS_URL__([\da-f]+)__/g;
/**
* Plugin applied before user plugins
*/
function cssPlugin(config$2) {
	const isBuild = config$2.command === "build";
	let moduleCache;
	const idResolver = createBackCompatIdResolver(config$2, {
		preferRelative: true,
		tryIndex: false,
		extensions: []
	});
	let preprocessorWorkerController;
	if (config$2.css.transformer !== "lightningcss") resolvePostcssConfig(config$2).catch(() => {});
	return {
		name: "vite:css",
		buildStart() {
			moduleCache = /* @__PURE__ */ new Map();
			cssModulesCache.set(config$2, moduleCache);
			removedPureCssFilesCache.set(config$2, /* @__PURE__ */ new Map());
			preprocessorWorkerController = createPreprocessorWorkerController(normalizeMaxWorkers(config$2.css.preprocessorMaxWorkers));
			preprocessorWorkerControllerCache.set(config$2, preprocessorWorkerController);
		},
		buildEnd() {
			preprocessorWorkerController?.close();
		},
		load: {
			filter: { id: CSS_LANGS_RE },
			async handler(id) {
				if (urlRE.test(id)) {
					if (isModuleCSSRequest(id)) throw new Error(`?url is not supported with CSS modules. (tried to import ${JSON.stringify(id)})`);
					if (isBuild) {
						id = injectQuery(removeUrlQuery(id), "transform-only");
						return `import ${JSON.stringify(id)};export default "__VITE_CSS_URL__${Buffer.from(id).toString("hex")}__"`;
					}
				}
			}
		},
		transform: {
			filter: { id: {
				include: CSS_LANGS_RE,
				exclude: [commonjsProxyRE, SPECIAL_QUERY_RE]
			} },
			async handler(raw, id) {
				const { environment } = this;
				const resolveUrl$1 = (url$3, importer) => idResolver(environment, url$3, importer);
				const urlResolver = async (url$3, importer) => {
					const decodedUrl = decodeURI(url$3);
					if (checkPublicFile(decodedUrl, config$2)) if (encodePublicUrlsInCSS(config$2)) return [publicFileToBuiltUrl(decodedUrl, config$2), void 0];
					else return [joinUrlSegments(config$2.base, decodedUrl), void 0];
					const [id$1, fragment] = decodedUrl.split("#");
					let resolved = await resolveUrl$1(id$1, importer);
					if (resolved) {
						if (fragment) resolved += "#" + fragment;
						let url$4 = await fileToUrl$1(this, resolved);
						if (!url$4.startsWith("data:") && this.environment.mode === "dev") {
							const mod = [...this.environment.moduleGraph.getModulesByFile(resolved) ?? []].find((mod$1) => mod$1.type === "asset");
							if (mod?.lastHMRTimestamp) url$4 = injectQuery(url$4, `t=${mod.lastHMRTimestamp}`);
						}
						return [url$4, resolved];
					}
					if (config$2.command === "build") {
						if (!(config$2.build.rollupOptions.external ? resolveUserExternal(config$2.build.rollupOptions.external, decodedUrl, id$1, false) : false)) config$2.logger.warnOnce(`\n${decodedUrl} referenced in ${id$1} didn't resolve at build time, it will remain unchanged to be resolved at runtime`);
					}
					return [url$3, void 0];
				};
				const { code: css, modules, deps, map: map$1 } = await compileCSS(environment, id, raw, preprocessorWorkerController, urlResolver);
				if (modules) moduleCache.set(id, modules);
				if (deps) for (const file of deps) this.addWatchFile(file);
				return {
					code: css,
					map: map$1
				};
			}
		}
	};
}
/**
* Plugin applied after user plugins
*/
function cssPostPlugin(config$2) {
	const styles = /* @__PURE__ */ new Map();
	let codeSplitEmitQueue = createSerialPromiseQueue();
	const urlEmitQueue = createSerialPromiseQueue();
	let pureCssChunks;
	let hasEmitted = false;
	let chunkCSSMap;
	const rollupOptionsOutput = config$2.build.rollupOptions.output;
	const assetFileNames = (Array.isArray(rollupOptionsOutput) ? rollupOptionsOutput[0] : rollupOptionsOutput)?.assetFileNames;
	const getCssAssetDirname = (cssAssetName) => {
		const cssAssetNameDir = path.dirname(cssAssetName);
		if (!assetFileNames) return path.join(config$2.build.assetsDir, cssAssetNameDir);
		else if (typeof assetFileNames === "string") return path.join(path.dirname(assetFileNames), cssAssetNameDir);
		else return path.dirname(assetFileNames({
			type: "asset",
			name: cssAssetName,
			names: [cssAssetName],
			originalFileName: null,
			originalFileNames: [],
			source: "/* vite internal call, ignore */"
		}));
	};
	function getCssBundleName() {
		const cached = cssBundleNameCache.get(config$2);
		if (cached) return cached;
		const cssBundleName = config$2.build.lib ? resolveLibCssFilename(config$2.build.lib, config$2.root, config$2.packageCache) : defaultCssBundleName;
		cssBundleNameCache.set(config$2, cssBundleName);
		return cssBundleName;
	}
	return {
		name: "vite:css-post",
		renderStart() {
			pureCssChunks = /* @__PURE__ */ new Set();
			hasEmitted = false;
			chunkCSSMap = /* @__PURE__ */ new Map();
			codeSplitEmitQueue = createSerialPromiseQueue();
		},
		transform: {
			filter: { id: {
				include: CSS_LANGS_RE,
				exclude: [commonjsProxyRE, SPECIAL_QUERY_RE]
			} },
			async handler(css, id) {
				css = stripBomTag(css);
				const inlineCSS = inlineCSSRE.test(id);
				const isHTMLProxy$1 = htmlProxyRE.test(id);
				if (inlineCSS && isHTMLProxy$1) {
					if (styleAttrRE.test(id)) css = css.replace(/"/g, "&quot;");
					const index = htmlProxyIndexRE.exec(id)?.[1];
					if (index == null) throw new Error(`HTML proxy index in "${id}" not found`);
					addToHTMLProxyTransformResult(`${getHash(cleanUrl(id))}_${Number.parseInt(index)}`, css);
					return `export default ''`;
				}
				const inlined = inlineRE.test(id);
				const modules = cssModulesCache.get(config$2).get(id);
				const modulesCode = modules && !inlined && dataToEsm(modules, {
					namedExports: true,
					preferConst: true
				});
				if (config$2.command === "serve") {
					const getContentWithSourcemap = async (content) => {
						if (config$2.css.devSourcemap) {
							const sourcemap = this.getCombinedSourcemap();
							if (sourcemap.mappings) await injectSourcesContent(sourcemap, cleanUrl(id), config$2.logger);
							return getCodeWithSourcemap("css", content, sourcemap);
						}
						return content;
					};
					if (isDirectCSSRequest(id)) return null;
					if (inlined) return `export default ${JSON.stringify(css)}`;
					if (this.environment.config.consumer === "server") return modulesCode || "export {}";
					const cssContent = await getContentWithSourcemap(css);
					return {
						code: [
							`import { updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle } from ${JSON.stringify(path.posix.join(config$2.base, CLIENT_PUBLIC_PATH))}`,
							`const __vite__id = ${JSON.stringify(id)}`,
							`const __vite__css = ${JSON.stringify(cssContent)}`,
							`__vite__updateStyle(__vite__id, __vite__css)`,
							`${modulesCode || "import.meta.hot.accept()"}`,
							`import.meta.hot.prune(() => __vite__removeStyle(__vite__id))`
						].join("\n"),
						map: { mappings: "" }
					};
				}
				if (!inlined) styles.set(id, css);
				let code;
				if (modulesCode) code = modulesCode;
				else if (inlined) {
					let content = css;
					if (config$2.build.cssMinify) content = await minifyCSS(content, config$2, true);
					code = `export default ${JSON.stringify(content)}`;
				} else code = "";
				return {
					code,
					map: { mappings: "" },
					moduleSideEffects: modulesCode || inlined ? false : "no-treeshake"
				};
			}
		},
		async renderChunk(code, chunk, opts, meta) {
			let chunkCSS;
			const renderedModules = new Proxy({}, { get(_target, p) {
				for (const name in meta.chunks) {
					const module$1 = meta.chunks[name].modules[p];
					if (module$1) return module$1;
				}
			} });
			const isJsChunkEmpty = code === "" && !chunk.isEntry;
			let isPureCssChunk = chunk.exports.length === 0;
			const ids = Object.keys(chunk.modules);
			for (const id of ids) if (styles.has(id)) {
				if (transformOnlyRE.test(id)) continue;
				const cssScopeTo = this.getModuleInfo(id)?.meta?.vite?.cssScopeTo;
				if (cssScopeTo && !isCssScopeToRendered(cssScopeTo, renderedModules)) continue;
				if (cssModuleRE.test(id)) isPureCssChunk = false;
				chunkCSS = (chunkCSS || "") + styles.get(id);
			} else if (!isJsChunkEmpty) isPureCssChunk = false;
			const publicAssetUrlMap = publicAssetUrlCache.get(config$2);
			const resolveAssetUrlsInCss = (chunkCSS$1, cssAssetName) => {
				const encodedPublicUrls = encodePublicUrlsInCSS(config$2);
				const cssAssetDirname = encodedPublicUrls || config$2.base === "./" || config$2.base === "" ? slash(getCssAssetDirname(cssAssetName)) : void 0;
				const toRelative = (filename) => {
					const relativePath = normalizePath(path.relative(cssAssetDirname, filename));
					return relativePath[0] === "." ? relativePath : "./" + relativePath;
				};
				chunkCSS$1 = chunkCSS$1.replace(assetUrlRE, (_, fileHash, postfix = "") => {
					const filename = this.getFileName(fileHash) + postfix;
					chunk.viteMetadata.importedAssets.add(cleanUrl(filename));
					return encodeURIPath(toOutputFilePathInCss(filename, "asset", cssAssetName, "css", config$2, toRelative));
				});
				if (encodedPublicUrls) {
					const relativePathToPublicFromCSS = normalizePath(path.relative(cssAssetDirname, ""));
					chunkCSS$1 = chunkCSS$1.replace(publicAssetUrlRE, (_, hash$1) => {
						const publicUrl = publicAssetUrlMap.get(hash$1).slice(1);
						return encodeURIPath(toOutputFilePathInCss(publicUrl, "public", cssAssetName, "css", config$2, () => `${relativePathToPublicFromCSS}/${publicUrl}`));
					});
				}
				return chunkCSS$1;
			};
			function ensureFileExt(name, ext) {
				return normalizePath(path.format({
					...path.parse(name),
					base: void 0,
					ext
				}));
			}
			let s$2;
			const urlEmitTasks = [];
			if (code.includes("__VITE_CSS_URL__")) {
				let match;
				cssUrlAssetRE.lastIndex = 0;
				while (match = cssUrlAssetRE.exec(code)) {
					const [full, idHex] = match;
					const id = Buffer.from(idHex, "hex").toString();
					const originalFileName = cleanUrl(id);
					const cssAssetName = ensureFileExt(path.basename(originalFileName), ".css");
					if (!styles.has(id)) throw new Error(`css content for ${JSON.stringify(id)} was not found`);
					let cssContent = styles.get(id);
					cssContent = resolveAssetUrlsInCss(cssContent, cssAssetName);
					urlEmitTasks.push({
						cssAssetName,
						originalFileName,
						content: cssContent,
						start: match.index,
						end: match.index + full.length
					});
				}
			}
			await urlEmitQueue.run(async () => Promise.all(urlEmitTasks.map(async (info) => {
				info.content = await finalizeCss(info.content, config$2);
			})));
			if (urlEmitTasks.length > 0) {
				const toRelativeRuntime = createToImportMetaURLBasedRelativeRuntime(opts.format, config$2.isWorker);
				s$2 ||= new MagicString(code);
				for (const { cssAssetName, originalFileName, content, start, end } of urlEmitTasks) {
					const referenceId = this.emitFile({
						type: "asset",
						name: cssAssetName,
						originalFileName,
						source: content
					});
					const filename = this.getFileName(referenceId);
					chunk.viteMetadata.importedAssets.add(cleanUrl(filename));
					const replacement = toOutputFilePathInJS(this.environment, filename, "asset", chunk.fileName, "js", toRelativeRuntime);
					const replacementString = typeof replacement === "string" ? JSON.stringify(encodeURIPath(replacement)).slice(1, -1) : `"+${replacement.runtime}+"`;
					s$2.update(start, end, replacementString);
				}
			}
			if (chunkCSS !== void 0) {
				if (isPureCssChunk && (opts.format === "es" || opts.format === "cjs")) pureCssChunks.add(chunk);
				if (this.environment.config.build.cssCodeSplit) {
					if (opts.format === "es" || opts.format === "cjs") {
						const isEntry = chunk.isEntry && isPureCssChunk;
						const cssFullAssetName = ensureFileExt(chunk.name, ".css");
						const cssAssetName = chunk.isEntry && (!chunk.facadeModuleId || !isCSSRequest(chunk.facadeModuleId)) ? path.basename(cssFullAssetName) : cssFullAssetName;
						const originalFileName = getChunkOriginalFileName(chunk, config$2.root, opts.format);
						chunkCSS = resolveAssetUrlsInCss(chunkCSS, cssAssetName);
						chunkCSS = await codeSplitEmitQueue.run(async () => {
							return finalizeCss(chunkCSS, config$2);
						});
						const referenceId = this.emitFile({
							type: "asset",
							name: cssAssetName,
							originalFileName,
							source: chunkCSS
						});
						if (isEntry) cssEntriesMap.get(this.environment).add(referenceId);
						chunk.viteMetadata.importedCss.add(this.getFileName(referenceId));
					} else if (this.environment.config.consumer === "client") {
						chunkCSS = await finalizeCss(chunkCSS, config$2);
						let cssString = JSON.stringify(chunkCSS);
						cssString = renderAssetUrlInJS(this, chunk, opts, cssString)?.toString() || cssString;
						const style = `__vite_style__`;
						const injectCode = `var ${style} = document.createElement('style');${style}.textContent = ${cssString};document.head.appendChild(${style});`;
						let injectionPoint;
						const wrapIdx = code.indexOf("System.register");
						const singleQuoteUseStrict = `'use strict';`;
						const doubleQuoteUseStrict = `"use strict";`;
						if (wrapIdx >= 0) {
							const executeFnStart = code.indexOf("execute:", wrapIdx);
							injectionPoint = code.indexOf("{", executeFnStart) + 1;
						} else if (code.includes(singleQuoteUseStrict)) injectionPoint = code.indexOf(singleQuoteUseStrict) + singleQuoteUseStrict.length;
						else if (code.includes(doubleQuoteUseStrict)) injectionPoint = code.indexOf(doubleQuoteUseStrict) + doubleQuoteUseStrict.length;
						else throw new Error("Injection point for inlined CSS not found");
						s$2 ||= new MagicString(code);
						s$2.appendRight(injectionPoint, injectCode);
					}
				} else {
					chunkCSS = resolveAssetUrlsInCss(chunkCSS, getCssBundleName());
					chunkCSSMap.set(chunk.fileName, chunkCSS);
				}
			}
			if (s$2) if (config$2.build.sourcemap) return {
				code: s$2.toString(),
				map: s$2.generateMap({ hires: "boundary" })
			};
			else return { code: s$2.toString() };
			return null;
		},
		augmentChunkHash(chunk) {
			if (chunk.viteMetadata?.importedCss.size) {
				let hash$1 = "";
				for (const id of chunk.viteMetadata.importedCss) hash$1 += id;
				return hash$1;
			}
		},
		async generateBundle(opts, bundle) {
			if (opts.__vite_skip_asset_emit__) return;
			if ((config$2.command !== "build" || this.environment.config.build.emitAssets) && !this.environment.config.build.cssCodeSplit && !hasEmitted) {
				let extractedCss = "";
				const collected = /* @__PURE__ */ new Set();
				const dynamicImports = /* @__PURE__ */ new Set();
				function collect(chunk) {
					if (!chunk || chunk.type !== "chunk" || collected.has(chunk)) return;
					collected.add(chunk);
					chunk.imports.forEach((importName) => collect(bundle[importName]));
					chunk.dynamicImports.forEach((importName) => dynamicImports.add(importName));
					extractedCss += chunkCSSMap.get(chunk.preliminaryFileName) ?? "";
				}
				for (const chunk of Object.values(bundle)) if (chunk.type === "chunk" && chunk.isEntry) collect(chunk);
				for (const chunkName of dynamicImports) collect(bundle[chunkName]);
				if (extractedCss) {
					hasEmitted = true;
					extractedCss = await finalizeCss(extractedCss, config$2);
					this.emitFile({
						name: getCssBundleName(),
						type: "asset",
						source: extractedCss,
						originalFileName: "style.css"
					});
				}
			}
			if (pureCssChunks.size) {
				const prelimaryNameToChunkMap = Object.fromEntries(Object.values(bundle).filter((chunk) => chunk.type === "chunk").map((chunk) => [chunk.preliminaryFileName, chunk.fileName]));
				const pureCssChunkNames = [...pureCssChunks].map((pureCssChunk) => prelimaryNameToChunkMap[pureCssChunk.fileName]).filter(Boolean);
				const replaceEmptyChunk = getEmptyChunkReplacer(pureCssChunkNames, opts.format);
				for (const file in bundle) {
					const chunk = bundle[file];
					if (chunk.type === "chunk") {
						let chunkImportsPureCssChunk = false;
						chunk.imports = chunk.imports.filter((file$1) => {
							if (pureCssChunkNames.includes(file$1)) {
								const { importedCss, importedAssets } = bundle[file$1].viteMetadata;
								importedCss.forEach((file$2) => chunk.viteMetadata.importedCss.add(file$2));
								importedAssets.forEach((file$2) => chunk.viteMetadata.importedAssets.add(file$2));
								chunkImportsPureCssChunk = true;
								return false;
							}
							return true;
						});
						if (chunkImportsPureCssChunk) chunk.code = replaceEmptyChunk(chunk.code);
					}
				}
				const removedPureCssFiles = removedPureCssFilesCache.get(config$2);
				pureCssChunkNames.forEach((fileName) => {
					removedPureCssFiles.set(fileName, bundle[fileName]);
					delete bundle[fileName];
					delete bundle[`${fileName}.map`];
				});
			}
			const cssAssets = Object.values(bundle).filter((asset) => asset.type === "asset" && asset.fileName.endsWith(".css"));
			for (const cssAsset of cssAssets) if (typeof cssAsset.source === "string") cssAsset.source = cssAsset.source.replace(viteHashUpdateMarkerRE, "");
		}
	};
}
function cssAnalysisPlugin(config$2) {
	return {
		name: "vite:css-analysis",
		transform: {
			filter: { id: {
				include: CSS_LANGS_RE,
				exclude: [commonjsProxyRE, SPECIAL_QUERY_RE]
			} },
			async handler(_, id) {
				const { moduleGraph } = this.environment;
				const thisModule = moduleGraph.getModuleById(id);
				if (thisModule) {
					const isSelfAccepting = !cssModulesCache.get(config$2)?.get(id) && !inlineRE.test(id) && !htmlProxyRE.test(id);
					const pluginImports = this._addedImports;
					if (pluginImports) {
						const depModules = /* @__PURE__ */ new Set();
						for (const file of pluginImports) depModules.add(moduleGraph.createFileOnlyEntry(file));
						moduleGraph.updateModuleInfo(thisModule, depModules, null, /* @__PURE__ */ new Set(), null, isSelfAccepting);
					} else thisModule.isSelfAccepting = isSelfAccepting;
				}
			}
		}
	};
}
function isCssScopeToRendered(cssScopeTo, renderedModules) {
	const [importerId, exp] = cssScopeTo;
	const importer = renderedModules[importerId];
	return importer && (exp === void 0 || importer.renderedExports.includes(exp));
}
/**
* Create a replacer function that takes code and replaces given pure CSS chunk imports
* @param pureCssChunkNames The chunks that only contain pure CSS and should be replaced
* @param outputFormat The module output format to decide whether to replace `import` or `require`
*/
function getEmptyChunkReplacer(pureCssChunkNames, outputFormat) {
	const emptyChunkFiles = pureCssChunkNames.map((file) => escapeRegex(path.basename(file))).join("|");
	const emptyChunkRE = new RegExp(outputFormat === "es" ? `\\bimport\\s*["'][^"']*(?:${emptyChunkFiles})["'];` : `(\\b|,\\s*)require\\(\\s*["'][^"']*(?:${emptyChunkFiles})["']\\)(;|,)`, "g");
	return (code) => code.replace(emptyChunkRE, (m$2, p1, p2) => {
		if (outputFormat === "es") return `/* empty css ${"".padEnd(m$2.length - 15)}*/`;
		if (p2 === ";") return `${p2}/* empty css ${"".padEnd(m$2.length - 16)}*/`;
		return `${p1}/* empty css ${"".padEnd(m$2.length - 15 - p1.length)}*/`;
	});
}
const fileURLWithWindowsDriveRE = /^file:\/\/\/[a-zA-Z]:\//;
function createCSSResolvers(config$2) {
	let cssResolve;
	let sassResolve;
	let lessResolve;
	return {
		get css() {
			return cssResolve ??= createBackCompatIdResolver(config$2, {
				extensions: [".css"],
				mainFields: ["style"],
				conditions: ["style", DEV_PROD_CONDITION],
				tryIndex: false,
				preferRelative: true
			});
		},
		get sass() {
			if (!sassResolve) {
				const resolver$1 = createBackCompatIdResolver(config$2, {
					extensions: [
						".scss",
						".sass",
						".css"
					],
					mainFields: ["sass", "style"],
					conditions: [
						"sass",
						"style",
						DEV_PROD_CONDITION
					],
					tryIndex: true,
					tryPrefix: "_",
					preferRelative: true
				});
				sassResolve = async (...args) => {
					if (args[1].startsWith("file://")) args[1] = fileURLToPath(args[1], { windows: isWindows && !fileURLWithWindowsDriveRE.test(args[1]) ? false : void 0 });
					return resolver$1(...args);
				};
			}
			return sassResolve;
		},
		get less() {
			return lessResolve ??= createBackCompatIdResolver(config$2, {
				extensions: [".less", ".css"],
				mainFields: ["less", "style"],
				conditions: [
					"less",
					"style",
					DEV_PROD_CONDITION
				],
				tryIndex: false,
				preferRelative: true
			});
		}
	};
}
function getCssResolversKeys(resolvers) {
	return Object.keys(resolvers);
}
async function compileCSSPreprocessors(environment, id, lang, code, workerController) {
	const { config: config$2 } = environment;
	const { preprocessorOptions, devSourcemap } = config$2.css;
	const atImportResolvers = getAtImportResolvers(environment.getTopLevelConfig());
	const opts = {
		...preprocessorOptions && preprocessorOptions[lang] || {},
		filename: cleanUrl(id),
		enableSourcemap: devSourcemap ?? false
	};
	const preProcessor = workerController[lang];
	const preprocessResult = await preProcessor(environment, code, config$2.root, opts, atImportResolvers);
	if (preprocessResult.error) throw preprocessResult.error;
	let deps;
	if (preprocessResult.deps.length > 0) {
		const normalizedFilename = normalizePath(opts.filename);
		deps = new Set([...preprocessResult.deps].filter((dep) => normalizePath(dep) !== normalizedFilename));
	}
	return {
		code: preprocessResult.code,
		map: combineSourcemapsIfExists(opts.filename, preprocessResult.map, preprocessResult.additionalMap),
		deps
	};
}
const configToAtImportResolvers = /* @__PURE__ */ new WeakMap();
function getAtImportResolvers(config$2) {
	let atImportResolvers = configToAtImportResolvers.get(config$2);
	if (!atImportResolvers) {
		atImportResolvers = createCSSResolvers(config$2);
		configToAtImportResolvers.set(config$2, atImportResolvers);
	}
	return atImportResolvers;
}
async function compileCSS(environment, id, code, workerController, urlResolver) {
	const { config: config$2 } = environment;
	const lang = CSS_LANGS_RE.exec(id)?.[1];
	const deps = /* @__PURE__ */ new Set();
	let preprocessorMap;
	if (isPreProcessor(lang)) {
		const preprocessorResult = await compileCSSPreprocessors(environment, id, lang, code, workerController);
		code = preprocessorResult.code;
		preprocessorMap = preprocessorResult.map;
		preprocessorResult.deps?.forEach((dep) => deps.add(dep));
	} else if (lang === "sss" && config$2.css.transformer === "lightningcss") {
		const sssResult = await transformSugarSS(environment, id, code);
		code = sssResult.code;
		preprocessorMap = sssResult.map;
	}
	const transformResult = await (config$2.css.transformer === "lightningcss" ? compileLightningCSS(environment, id, code, deps, workerController, urlResolver) : compilePostCSS(environment, id, code, deps, lang, workerController, urlResolver));
	if (!transformResult) return {
		code,
		map: config$2.css.devSourcemap ? preprocessorMap : { mappings: "" },
		deps
	};
	return {
		...transformResult,
		map: config$2.css.devSourcemap ? combineSourcemapsIfExists(cleanUrl(id), typeof transformResult.map === "string" ? JSON.parse(transformResult.map) : transformResult.map, preprocessorMap) : { mappings: "" },
		deps
	};
}
async function compilePostCSS(environment, id, code, deps, lang, workerController, urlResolver) {
	const { config: config$2 } = environment;
	const { modules: modulesOptions, devSourcemap } = config$2.css;
	const isModule = modulesOptions !== false && cssModuleRE.test(id);
	const needInlineImport = code.includes("@import");
	const hasUrl = cssUrlRE.test(code) || cssImageSetRE.test(code);
	const postcssConfig = await resolvePostcssConfig(environment.getTopLevelConfig());
	if (lang !== "sss" && !postcssConfig && !isModule && !needInlineImport && !hasUrl) return;
	const atImportResolvers = getAtImportResolvers(environment.getTopLevelConfig());
	const postcssPlugins = postcssConfig?.plugins.slice() ?? [];
	if (needInlineImport) postcssPlugins.unshift((await importPostcssImport()).default({
		async resolve(id$1, basedir) {
			const publicFile = checkPublicFile(id$1, environment.getTopLevelConfig());
			if (publicFile) return publicFile;
			const resolved = await atImportResolvers.css(environment, id$1, path.join(basedir, "*"));
			if (resolved) return path.resolve(resolved);
			if (!path.isAbsolute(id$1)) environment.logger.error(import_picocolors$6.default.red(`Unable to resolve \`@import "${id$1}"\` from ${basedir}`));
			return id$1;
		},
		async load(id$1) {
			const code$1 = await fs.promises.readFile(id$1, "utf-8");
			const lang$1 = CSS_LANGS_RE.exec(id$1)?.[1];
			if (isPreProcessor(lang$1)) {
				const result = await compileCSSPreprocessors(environment, id$1, lang$1, code$1, workerController);
				result.deps?.forEach((dep) => deps.add(dep));
				return result.code;
			}
			return code$1;
		},
		nameLayer(index) {
			return `vite--anon-layer-${getHash(id)}-${index}`;
		}
	}));
	if (urlResolver && (postcssPlugins.length > 0 || isModule || hasUrl)) postcssPlugins.push(UrlRewritePostcssPlugin({
		resolver: urlResolver,
		deps,
		logger: environment.logger
	}));
	let modules;
	if (isModule) postcssPlugins.unshift((await importPostcssModules()).default({
		...modulesOptions,
		localsConvention: modulesOptions?.localsConvention,
		getJSON(cssFileName, _modules, outputFileName) {
			modules = _modules;
			if (modulesOptions && typeof modulesOptions.getJSON === "function") modulesOptions.getJSON(cssFileName, _modules, outputFileName);
		},
		async resolve(id$1, importer) {
			for (const key of getCssResolversKeys(atImportResolvers)) {
				const resolved = await atImportResolvers[key](environment, id$1, importer);
				if (resolved) return path.resolve(resolved);
			}
			return id$1;
		}
	}));
	const postcssOptions = postcssConfig?.options ?? {};
	const postcssParser = lang === "sss" ? loadSss(config$2.root) : postcssOptions.parser;
	if (!postcssPlugins.length && !postcssParser) return;
	return {
		...await runPostCSS(id, code, postcssPlugins, {
			...postcssOptions,
			parser: postcssParser
		}, deps, environment.logger, devSourcemap),
		modules
	};
}
async function transformSugarSS(environment, id, code) {
	const { config: config$2 } = environment;
	const { devSourcemap } = config$2.css;
	return await runPostCSS(id, code, [], { parser: loadSss(config$2.root) }, void 0, environment.logger, devSourcemap);
}
async function runPostCSS(id, code, plugins$1, options$1, deps, logger, enableSourcemap) {
	let postcssResult;
	try {
		const source = removeDirectQuery(id);
		postcssResult = await (await importPostcss()).default(plugins$1).process(code, {
			...options$1,
			to: source,
			from: source,
			...enableSourcemap ? { map: {
				inline: false,
				annotation: false,
				sourcesContent: true
			} } : {}
		});
		for (const message of postcssResult.messages) if (message.type === "dependency") deps?.add(normalizePath(message.file));
		else if (message.type === "dir-dependency") {
			const { dir, glob: globPattern = "**" } = message;
			const files = globSync(globPattern, {
				absolute: true,
				cwd: path.resolve(path.dirname(id), dir),
				expandDirectories: false,
				ignore: ["**/node_modules/**"]
			});
			for (let i$1 = 0; i$1 < files.length; i$1++) deps?.add(files[i$1]);
		} else if (message.type === "warning") {
			const warning = message;
			let msg = `[vite:css][postcss] ${warning.text}`;
			msg += `\n${generateCodeFrame(code, {
				line: warning.line,
				column: warning.column - 1
			}, warning.endLine !== void 0 && warning.endColumn !== void 0 ? {
				line: warning.endLine,
				column: warning.endColumn - 1
			} : void 0)}`;
			logger.warn(import_picocolors$6.default.yellow(msg));
		}
	} catch (e$1) {
		e$1.message = `[postcss] ${e$1.message}`;
		e$1.code = code;
		e$1.loc = {
			file: e$1.file,
			line: e$1.line,
			column: e$1.column - 1
		};
		throw e$1;
	}
	if (!enableSourcemap) return {
		code: postcssResult.css,
		map: { mappings: "" }
	};
	const postcssMap = await formatPostcssSourceMap(postcssResult.map.toJSON(), cleanUrl(id));
	return {
		code: postcssResult.css,
		map: postcssMap
	};
}
function createCachedImport(imp) {
	let cached;
	return () => {
		if (!cached) cached = imp().then((module$1) => {
			cached = module$1;
			return module$1;
		});
		return cached;
	};
}
const importPostcssImport = createCachedImport(() => import("./postcss-import.js").then(__toDynamicImportESM(1)));
const importPostcssModules = createCachedImport(() => import("./build2.js").then(__toDynamicImportESM(1)));
const importPostcss = createCachedImport(() => import("postcss"));
const preprocessorWorkerControllerCache = /* @__PURE__ */ new WeakMap();
let alwaysFakeWorkerWorkerControllerCache;
/**
* @experimental
*/
async function preprocessCSS(code, filename, config$2) {
	let workerController = preprocessorWorkerControllerCache.get(config$2);
	if (!workerController) {
		alwaysFakeWorkerWorkerControllerCache ||= createPreprocessorWorkerController(0);
		workerController = alwaysFakeWorkerWorkerControllerCache;
	}
	return await compileCSS(new PartialEnvironment("client", config$2), filename, code, workerController);
}
async function formatPostcssSourceMap(rawMap, file) {
	const inputFileDir = path.dirname(file);
	const sources = rawMap.sources.map((source) => {
		const cleanSource = cleanUrl(decodeURIComponent(source));
		if (cleanSource[0] === "<" && cleanSource.endsWith(">")) return `\0${cleanSource}`;
		return normalizePath(path.resolve(inputFileDir, cleanSource));
	});
	return {
		file,
		mappings: rawMap.mappings,
		names: rawMap.names,
		sources,
		sourcesContent: rawMap.sourcesContent,
		version: rawMap.version
	};
}
function combineSourcemapsIfExists(filename, map1, map2) {
	if (!map1 || !map2) return map1;
	if (map1.mappings === "" || map2.mappings === "") return { mappings: "" };
	return combineSourcemaps(filename, [map1, map2]);
}
const viteHashUpdateMarker = "/*$vite$:1*/";
const viteHashUpdateMarkerRE = /\/\*\$vite\$:\d+\*\//;
async function finalizeCss(css, config$2) {
	if (css.includes("@import") || css.includes("@charset")) css = await hoistAtRules(css);
	if (config$2.build.cssMinify) css = await minifyCSS(css, config$2, false);
	css += viteHashUpdateMarker;
	return css;
}
async function resolvePostcssConfig(config$2) {
	let result = postcssConfigCache.get(config$2);
	if (result !== void 0) return await result;
	const inlineOptions = config$2.css.postcss;
	if (isObject(inlineOptions)) {
		const options$1 = { ...inlineOptions };
		delete options$1.plugins;
		result = {
			options: options$1,
			plugins: inlineOptions.plugins || []
		};
	} else {
		const searchPath = typeof inlineOptions === "string" ? inlineOptions : config$2.root;
		result = (0, import_src.default)({}, searchPath, { stopDir: searchForWorkspaceRoot(config$2.root) }).catch((e$1) => {
			if (!e$1.message.includes("No PostCSS Config found")) if (e$1 instanceof Error) {
				const { name, message, stack } = e$1;
				e$1.name = "Failed to load PostCSS config";
				e$1.message = `Failed to load PostCSS config (searchPath: ${searchPath}): [${name}] ${message}\n${stack}`;
				e$1.stack = "";
				throw e$1;
			} else throw new Error(`Failed to load PostCSS config: ${e$1}`);
			return null;
		});
		result.then((resolved) => {
			postcssConfigCache.set(config$2, resolved);
		}, () => {});
	}
	postcssConfigCache.set(config$2, result);
	return result;
}
const cssUrlRE = /(?<!@import\s+)(?<=^|[^\w\-\u0080-\uffff])url\((\s*('[^']+'|"[^"]+")\s*|(?:\\.|[^'")\\])+)\)/;
const cssDataUriRE = /(?<=^|[^\w\-\u0080-\uffff])data-uri\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/;
const importCssRE = /@import\s+(?:url\()?('[^']+\.css'|"[^"]+\.css"|[^'"\s)]+\.css)/;
const cssImageSetRE = /(?<=image-set\()((?:[\w-]{1,256}\([^)]*\)|[^)])*)(?=\))/;
const UrlRewritePostcssPlugin = (opts) => {
	if (!opts) throw new Error("base or replace is required");
	return {
		postcssPlugin: "vite-url-rewrite",
		Once(root) {
			const promises$2 = [];
			root.walkDecls((declaration) => {
				const importer = declaration.source?.input.file;
				if (!importer) opts.logger.warnOnce("\nA PostCSS plugin did not pass the `from` option to `postcss.parse`. This may cause imported assets to be incorrectly transformed. If you've recently added a PostCSS plugin that raised this warning, please contact the package author to fix the issue.");
				const isCssUrl = cssUrlRE.test(declaration.value);
				const isCssImageSet = cssImageSetRE.test(declaration.value);
				if (isCssUrl || isCssImageSet) {
					const replacerForDeclaration = async (rawUrl) => {
						const [newUrl, resolvedId] = await opts.resolver(rawUrl, importer);
						if (resolvedId) opts.deps.add(resolvedId);
						return newUrl;
					};
					if (isCssUrl && isCssImageSet) promises$2.push(rewriteCssUrls(declaration.value, replacerForDeclaration).then((url$3) => rewriteCssImageSet(url$3, replacerForDeclaration)).then((url$3) => {
						declaration.value = url$3;
					}));
					else promises$2.push((isCssImageSet ? rewriteCssImageSet : rewriteCssUrls)(declaration.value, replacerForDeclaration).then((url$3) => {
						declaration.value = url$3;
					}));
				}
			});
			if (promises$2.length) return Promise.all(promises$2);
		}
	};
};
UrlRewritePostcssPlugin.postcss = true;
function rewriteCssUrls(css, replacer) {
	return asyncReplace(css, cssUrlRE, async (match) => {
		const [matched, rawUrl] = match;
		return await doUrlReplace(rawUrl.trim(), matched, replacer);
	});
}
function rewriteCssDataUris(css, replacer) {
	return asyncReplace(css, cssDataUriRE, async (match) => {
		const [matched, rawUrl] = match;
		return await doUrlReplace(rawUrl.trim(), matched, replacer, "data-uri");
	});
}
function rewriteImportCss(css, replacer) {
	return asyncReplace(css, importCssRE, async (match) => {
		const [matched, rawUrl] = match;
		return await doImportCSSReplace(rawUrl, matched, replacer);
	});
}
const cssNotProcessedRE = /(?:gradient|element|cross-fade|image)\(/;
async function rewriteCssImageSet(css, replacer) {
	return await asyncReplace(css, cssImageSetRE, async (match) => {
		const [, rawUrl] = match;
		return await processSrcSet(rawUrl, async ({ url: url$3 }) => {
			if (cssUrlRE.test(url$3)) return await rewriteCssUrls(url$3, replacer);
			if (!cssNotProcessedRE.test(url$3)) return await doUrlReplace(url$3, url$3, replacer);
			return url$3;
		});
	});
}
function skipUrlReplacer(unquotedUrl) {
	return isExternalUrl(unquotedUrl) || isDataUrl(unquotedUrl) || unquotedUrl[0] === "#" || functionCallRE.test(unquotedUrl) || unquotedUrl.startsWith("__VITE_ASSET__") || unquotedUrl.startsWith("__VITE_PUBLIC_ASSET__");
}
async function doUrlReplace(rawUrl, matched, replacer, funcName = "url") {
	let wrap$1 = "";
	const first$2 = rawUrl[0];
	let unquotedUrl = rawUrl;
	if (first$2 === `"` || first$2 === `'`) {
		wrap$1 = first$2;
		unquotedUrl = rawUrl.slice(1, -1);
	}
	if (skipUrlReplacer(unquotedUrl)) return matched;
	unquotedUrl = unquotedUrl.replace(/\\(\W)/g, "$1");
	let newUrl = await replacer(unquotedUrl, rawUrl);
	if (newUrl === false) return matched;
	if (wrap$1 === "" && (newUrl !== encodeURI(newUrl) || newUrl.includes(")"))) wrap$1 = "\"";
	if (wrap$1 === "'" && newUrl.includes("'")) wrap$1 = "\"";
	if (wrap$1 === "\"" && newUrl.includes("\"")) newUrl = newUrl.replace(nonEscapedDoubleQuoteRe, "\\\"");
	return `${funcName}(${wrap$1}${newUrl}${wrap$1})`;
}
async function doImportCSSReplace(rawUrl, matched, replacer) {
	let wrap$1 = "";
	const first$2 = rawUrl[0];
	let unquotedUrl = rawUrl;
	if (first$2 === `"` || first$2 === `'`) {
		wrap$1 = first$2;
		unquotedUrl = rawUrl.slice(1, -1);
	}
	if (skipUrlReplacer(unquotedUrl)) return matched;
	const newUrl = await replacer(unquotedUrl, rawUrl);
	if (newUrl === false) return matched;
	return `@import ${matched.includes("url(") ? "url(" : ""}${wrap$1}${newUrl}${wrap$1}`;
}
async function minifyCSS(css, config$2, inlined) {
	if (config$2.build.cssMinify === "lightningcss") try {
		const { code, warnings } = (await importLightningCSS()).transform({
			...config$2.css.lightningcss,
			targets: convertTargets(config$2.build.cssTarget),
			cssModules: void 0,
			filename: defaultCssBundleName,
			code: Buffer.from(css),
			minify: true
		});
		for (const warning of warnings) {
			let msg = `[lightningcss minify] ${warning.message}`;
			msg += `\n${generateCodeFrame(css, {
				line: warning.loc.line,
				column: warning.loc.column - 1
			})}`;
			config$2.logger.warn(import_picocolors$6.default.yellow(msg));
		}
		return decoder.decode(code) + (inlined ? "" : "\n");
	} catch (e$1) {
		e$1.message = `[lightningcss minify] ${e$1.message}`;
		const friendlyMessage = getLightningCssErrorMessageForIeSyntaxes(css);
		if (friendlyMessage) e$1.message += friendlyMessage;
		if (e$1.loc) {
			e$1.loc = {
				line: e$1.loc.line,
				column: e$1.loc.column - 1
			};
			e$1.frame = generateCodeFrame(css, e$1.loc);
		}
		throw e$1;
	}
	try {
		const { code, warnings } = await transform(css, {
			loader: "css",
			target: config$2.build.cssTarget || void 0,
			...resolveMinifyCssEsbuildOptions(config$2.esbuild || {})
		});
		if (warnings.length) {
			const msgs = await formatMessages(warnings, { kind: "warning" });
			config$2.logger.warn(import_picocolors$6.default.yellow(`[esbuild css minify]\n${msgs.join("\n")}`));
		}
		return inlined ? code.trimEnd() : code;
	} catch (e$1) {
		if (e$1.errors) {
			e$1.message = "[esbuild css minify] " + e$1.message;
			e$1.frame = "\n" + (await formatMessages(e$1.errors, { kind: "error" })).join("\n");
			e$1.loc = e$1.errors[0].location;
		}
		throw e$1;
	}
}
function resolveMinifyCssEsbuildOptions(options$1) {
	const base = {
		charset: options$1.charset ?? "utf8",
		logLevel: options$1.logLevel,
		logLimit: options$1.logLimit,
		logOverride: options$1.logOverride,
		legalComments: options$1.legalComments
	};
	if (options$1.minifyIdentifiers != null || options$1.minifySyntax != null || options$1.minifyWhitespace != null) return {
		...base,
		minifyIdentifiers: options$1.minifyIdentifiers ?? true,
		minifySyntax: options$1.minifySyntax ?? true,
		minifyWhitespace: options$1.minifyWhitespace ?? true
	};
	else return {
		...base,
		minify: true
	};
}
const atImportRE = /@import(?:\s*(?:url\([^)]*\)|"(?:[^"]|(?<=\\)")*"|'(?:[^']|(?<=\\)')*').*?|[^;]*);/g;
const atCharsetRE = /@charset(?:\s*(?:"(?:[^"]|(?<=\\)")*"|'(?:[^']|(?<=\\)')*').*?|[^;]*);/g;
async function hoistAtRules(css) {
	const s$2 = new MagicString(css);
	const cleanCss = emptyCssComments(css);
	let match;
	atImportRE.lastIndex = 0;
	while (match = atImportRE.exec(cleanCss)) {
		s$2.remove(match.index, match.index + match[0].length);
		s$2.appendLeft(0, match[0]);
	}
	atCharsetRE.lastIndex = 0;
	let foundCharset = false;
	while (match = atCharsetRE.exec(cleanCss)) {
		s$2.remove(match.index, match.index + match[0].length);
		if (!foundCharset) {
			s$2.prepend(match[0]);
			foundCharset = true;
		}
	}
	return s$2.toString();
}
const loadedPreprocessorPath = {};
function loadPreprocessorPath(lang, root) {
	const cached = loadedPreprocessorPath[lang];
	if (cached) return cached;
	try {
		return loadedPreprocessorPath[lang] = requireResolveFromRootWithFallback(root, lang);
	} catch (e$1) {
		if (e$1.code === "MODULE_NOT_FOUND") {
			const installCommand = getPackageManagerCommand("install");
			throw new Error(`Preprocessor dependency "${lang}" not found. Did you install it? Try \`${installCommand} -D ${lang}\`.`);
		} else {
			const message = /* @__PURE__ */ new Error(`Preprocessor dependency "${lang}" failed to load:\n${e$1.message}`);
			message.stack = e$1.stack + "\n" + message.stack;
			throw message;
		}
	}
}
function loadSassPackage(root) {
	try {
		return {
			name: "sass-embedded",
			path: loadPreprocessorPath("sass-embedded", root)
		};
	} catch (e1) {
		try {
			return {
				name: "sass",
				path: loadPreprocessorPath(PreprocessLang.sass, root)
			};
		} catch {
			throw e1;
		}
	}
}
let cachedSss;
function loadSss(root) {
	if (cachedSss) return cachedSss;
	const sssPath = loadPreprocessorPath(PostCssDialectLang.sss, root);
	cachedSss = createRequire(
		/** #__KEEP__ */
		import.meta.url
	)(sssPath);
	return cachedSss;
}
function cleanScssBugUrl(url$3) {
	if (typeof window !== "undefined" && typeof location !== "undefined" && typeof location.href === "string") {
		const prefix = location.href.replace(/\/$/, "");
		return url$3.replace(prefix, "");
	} else return url$3;
}
const makeScssWorker = (environment, resolvers, _maxWorkers) => {
	let compilerPromise;
	return {
		async run(sassPath, data, options$1) {
			const sass = (await import(pathToFileURL(sassPath).href)).default;
			compilerPromise ??= sass.initAsyncCompiler();
			const compiler = await compilerPromise;
			const sassOptions = { ...options$1 };
			sassOptions.url = pathToFileURL(options$1.filename);
			sassOptions.sourceMap = options$1.enableSourcemap;
			const skipRebaseUrls = (unquotedUrl, rawUrl) => {
				if (!(rawUrl[0] === "\"" || rawUrl[0] === "'") && unquotedUrl[0] === "$") return true;
				return unquotedUrl.startsWith("#{");
			};
			const internalImporter = {
				async canonicalize(url$3, context) {
					const importer = context.containingUrl ? fileURLToPath(context.containingUrl) : options$1.filename;
					const resolved = await resolvers.sass(environment, url$3, cleanScssBugUrl(importer));
					if (resolved && (resolved.endsWith(".css") || resolved.endsWith(".scss") || resolved.endsWith(".sass"))) return pathToFileURL(resolved);
					return null;
				},
				async load(canonicalUrl) {
					const ext = path.extname(canonicalUrl.pathname);
					let syntax = "scss";
					if (ext === ".sass") syntax = "indented";
					else if (ext === ".css") syntax = "css";
					const result$1 = await rebaseUrls(environment, fileURLToPath(canonicalUrl), options$1.filename, resolvers.sass, skipRebaseUrls);
					return {
						contents: result$1.contents ?? await fsp.readFile(result$1.file, "utf-8"),
						syntax,
						sourceMapUrl: canonicalUrl
					};
				}
			};
			sassOptions.importers = [...sassOptions.importers ?? [], internalImporter];
			sassOptions.importer ??= internalImporter;
			const result = await compiler.compileStringAsync(data, sassOptions);
			return {
				css: result.css,
				map: result.sourceMap ? JSON.stringify(result.sourceMap) : void 0,
				stats: { includedFiles: result.loadedUrls.filter((url$3) => url$3.protocol === "file:").map((url$3) => fileURLToPath(url$3)) }
			};
		},
		async stop() {
			await (await compilerPromise)?.dispose();
			compilerPromise = void 0;
		}
	};
};
const scssProcessor = (maxWorkers) => {
	let worker;
	return {
		close() {
			worker?.stop();
		},
		async process(environment, source, root, options$1, resolvers) {
			const sassPackage = loadSassPackage(root);
			worker ??= makeScssWorker(environment, resolvers, maxWorkers);
			const { content: data, map: additionalMap } = await getSource(source, options$1.filename, options$1.additionalData, options$1.enableSourcemap);
			const optionsWithoutAdditionalData = {
				...options$1,
				additionalData: void 0
			};
			try {
				const result = await worker.run(sassPackage.path, data, optionsWithoutAdditionalData);
				const deps = result.stats.includedFiles.map((f$1) => cleanScssBugUrl(f$1));
				const map$1 = result.map ? JSON.parse(result.map.toString()) : void 0;
				if (map$1) map$1.sources = map$1.sources.map((url$3) => url$3.startsWith("file://") ? normalizePath(fileURLToPath(url$3)) : url$3);
				return {
					code: result.css.toString(),
					map: map$1,
					additionalMap,
					deps
				};
			} catch (e$1) {
				e$1.message = `[sass] ${e$1.message}`;
				e$1.id = e$1.file;
				e$1.frame = e$1.formatted;
				if (e$1.span?.start) {
					e$1.line = e$1.span.start.line + 1;
					e$1.column = e$1.span.start.column + 1;
					e$1.frame = e$1.message;
				}
				return {
					code: "",
					error: e$1,
					deps: []
				};
			}
		}
	};
};
/**
* relative url() inside \@imported sass and less files must be rebased to use
* root file as base.
*/
async function rebaseUrls(environment, file, rootFile, resolver$1, ignoreUrl) {
	file = path.resolve(file);
	const fileDir = path.dirname(file);
	const rootDir = path.dirname(rootFile);
	if (fileDir === rootDir) return { file };
	const content = await fsp.readFile(file, "utf-8");
	const hasUrls = cssUrlRE.test(content);
	const hasDataUris = cssDataUriRE.test(content);
	const hasImportCss = importCssRE.test(content);
	if (!hasUrls && !hasDataUris && !hasImportCss) return { file };
	let rebased;
	const rebaseFn = async (unquotedUrl, rawUrl) => {
		if (ignoreUrl?.(unquotedUrl, rawUrl)) return false;
		if (unquotedUrl[0] === "/") return unquotedUrl;
		const absolute = await resolver$1(environment, unquotedUrl, file) || path.resolve(fileDir, unquotedUrl);
		return normalizePath(path.relative(rootDir, absolute));
	};
	if (hasImportCss) rebased = await rewriteImportCss(content, rebaseFn);
	if (hasUrls) rebased = await rewriteCssUrls(rebased || content, rebaseFn);
	if (hasDataUris) rebased = await rewriteCssDataUris(rebased || content, rebaseFn);
	return {
		file,
		contents: rebased
	};
}
const makeLessWorker = (environment, resolvers, maxWorkers) => {
	const skipRebaseUrls = (unquotedUrl, _rawUrl) => {
		return unquotedUrl[0] === "@";
	};
	const viteLessResolve = async (filename, dir, rootFile, mime) => {
		const resolved = await resolvers.less(environment, filename, path.join(dir, "*"));
		if (!resolved) return void 0;
		if (mime === "application/javascript") return { resolved: path.resolve(resolved) };
		const result = await rebaseUrls(environment, resolved, rootFile, resolvers.less, skipRebaseUrls);
		return {
			resolved,
			contents: "contents" in result ? result.contents : void 0
		};
	};
	return new WorkerWithFallback(async () => {
		const [fsp$1, path$13] = await Promise.all([import("node:fs/promises"), import("node:path")]);
		let ViteLessManager;
		const createViteLessPlugin = (less, rootFile) => {
			const { FileManager } = less;
			ViteLessManager ??= class ViteManager extends FileManager {
				rootFile;
				constructor(rootFile$1) {
					super();
					this.rootFile = rootFile$1;
				}
				supports(filename) {
					return !/^(?:https?:)?\/\//.test(filename);
				}
				supportsSync() {
					return false;
				}
				async loadFile(filename, dir, opts, env$1) {
					const result = await viteLessResolve(filename, dir, this.rootFile, opts.mime);
					if (result) return {
						filename: path$13.resolve(result.resolved),
						contents: result.contents ?? await fsp$1.readFile(result.resolved, "utf-8")
					};
					else return super.loadFile(filename, dir, opts, env$1);
				}
			};
			return {
				install(_, pluginManager) {
					pluginManager.addFileManager(new ViteLessManager(rootFile));
				},
				minVersion: [
					3,
					0,
					0
				]
			};
		};
		return async (lessPath, content, options$1) => {
			const nodeLess = (await import(lessPath)).default;
			const viteResolverPlugin = createViteLessPlugin(nodeLess, options$1.filename);
			return await nodeLess.render(content, {
				paths: ["node_modules"],
				...options$1,
				plugins: [viteResolverPlugin, ...options$1.plugins || []],
				...options$1.enableSourcemap ? { sourceMap: {
					outputSourceFiles: true,
					sourceMapFileInline: false
				} } : {}
			});
		};
	}, {
		parentFunctions: { viteLessResolve },
		shouldUseFake(_lessPath, _content, options$1) {
			return !!options$1.plugins && options$1.plugins.length > 0;
		},
		max: maxWorkers
	});
};
const lessProcessor = (maxWorkers) => {
	let worker;
	return {
		close() {
			worker?.stop();
		},
		async process(environment, source, root, options$1, resolvers) {
			const lessPath = pathToFileURL(loadPreprocessorPath(PreprocessLang.less, root)).href;
			worker ??= makeLessWorker(environment, resolvers, maxWorkers);
			const { content, map: additionalMap } = await getSource(source, options$1.filename, options$1.additionalData, options$1.enableSourcemap);
			let result;
			const optionsWithoutAdditionalData = {
				...options$1,
				additionalData: void 0
			};
			try {
				result = await worker.run(lessPath, content, optionsWithoutAdditionalData);
			} catch (e$1) {
				const error$1 = e$1;
				const normalizedError = /* @__PURE__ */ new Error(`[less] ${error$1.message || error$1.type}`);
				normalizedError.loc = {
					file: error$1.filename || options$1.filename,
					line: error$1.line,
					column: error$1.column
				};
				return {
					code: "",
					error: normalizedError,
					deps: []
				};
			}
			const map$1 = result.map && JSON.parse(result.map);
			if (map$1) delete map$1.sourcesContent;
			return {
				code: result.css.toString(),
				map: map$1,
				additionalMap,
				deps: result.imports
			};
		}
	};
};
const makeStylWorker = (maxWorkers) => {
	return new WorkerWithFallback(() => {
		return async (stylusPath, content, root, options$1) => {
			const nodeStylus = (await import(stylusPath)).default;
			const ref = nodeStylus(content, {
				paths: ["node_modules"],
				...options$1
			});
			if (options$1.define) for (const key in options$1.define) ref.define(key, options$1.define[key]);
			if (options$1.enableSourcemap) ref.set("sourcemap", {
				comment: false,
				inline: false,
				basePath: root
			});
			return {
				code: ref.render(),
				map: ref.sourcemap,
				deps: ref.deps()
			};
		};
	}, {
		shouldUseFake(_stylusPath, _content, _root, options$1) {
			return !!(options$1.define && Object.values(options$1.define).some((d$2) => typeof d$2 === "function"));
		},
		max: maxWorkers
	});
};
const stylProcessor = (maxWorkers) => {
	let worker;
	return {
		close() {
			worker?.stop();
		},
		async process(_environment, source, root, options$1, _resolvers) {
			const stylusPath = pathToFileURL(loadPreprocessorPath(PreprocessLang.stylus, root)).href;
			worker ??= makeStylWorker(maxWorkers);
			const { content, map: additionalMap } = await getSource(source, options$1.filename, options$1.additionalData, options$1.enableSourcemap, "\n");
			const importsDeps = (options$1.imports ?? []).map((dep) => path.resolve(dep));
			const optionsWithoutAdditionalData = {
				...options$1,
				additionalData: void 0
			};
			try {
				const { code, map: map$1, deps } = await worker.run(stylusPath, content, root, optionsWithoutAdditionalData);
				return {
					code,
					map: formatStylusSourceMap(map$1, root),
					additionalMap,
					deps: [...deps, ...importsDeps]
				};
			} catch (e$1) {
				const wrapped = /* @__PURE__ */ new Error(`[stylus] ${e$1.message}`);
				wrapped.name = e$1.name;
				wrapped.stack = e$1.stack;
				return {
					code: "",
					error: wrapped,
					deps: []
				};
			}
		}
	};
};
function formatStylusSourceMap(mapBefore, root) {
	if (!mapBefore) return void 0;
	const map$1 = { ...mapBefore };
	const resolveFromRoot = (p) => normalizePath(path.resolve(root, p));
	if (map$1.file) map$1.file = resolveFromRoot(map$1.file);
	map$1.sources = map$1.sources.map(resolveFromRoot);
	return map$1;
}
async function getSource(source, filename, additionalData, enableSourcemap, sep$3 = "") {
	if (!additionalData) return { content: source };
	if (typeof additionalData === "function") {
		const newContent = await additionalData(source, filename);
		if (typeof newContent === "string") return { content: newContent };
		return newContent;
	}
	if (!enableSourcemap) return { content: additionalData + sep$3 + source };
	const ms = new MagicString(source);
	ms.appendLeft(0, sep$3);
	ms.appendLeft(0, additionalData);
	const map$1 = ms.generateMap({ hires: "boundary" });
	map$1.file = filename;
	map$1.sources = [filename];
	return {
		content: ms.toString(),
		map: map$1
	};
}
const createPreprocessorWorkerController = (maxWorkers) => {
	const scss = scssProcessor(maxWorkers);
	const less = lessProcessor(maxWorkers);
	const styl = stylProcessor(maxWorkers);
	const sassProcess = (environment, source, root, options$1, resolvers) => {
		const opts = { ...options$1 };
		opts.syntax = "indented";
		return scss.process(environment, source, root, opts, resolvers);
	};
	const close$1 = () => {
		less.close();
		scss.close();
		styl.close();
	};
	return {
		[PreprocessLang.less]: less.process,
		[PreprocessLang.scss]: scss.process,
		[PreprocessLang.sass]: sassProcess,
		[PreprocessLang.styl]: styl.process,
		[PreprocessLang.stylus]: styl.process,
		close: close$1
	};
};
const normalizeMaxWorkers = (maxWorker) => {
	if (maxWorker === void 0) return 0;
	if (maxWorker === true) return void 0;
	return maxWorker;
};
const preprocessorSet = new Set([
	PreprocessLang.less,
	PreprocessLang.sass,
	PreprocessLang.scss,
	PreprocessLang.styl,
	PreprocessLang.stylus
]);
function isPreProcessor(lang) {
	return lang && preprocessorSet.has(lang);
}
const importLightningCSS = createCachedImport(() => import("lightningcss"));
async function compileLightningCSS(environment, id, src, deps, workerController, urlResolver) {
	const { config: config$2 } = environment;
	const filename = removeDirectQuery(id).replace("\0", NULL_BYTE_PLACEHOLDER);
	let res;
	try {
		res = styleAttrRE.test(id) ? (await importLightningCSS()).transformStyleAttribute({
			filename,
			code: Buffer.from(src),
			targets: config$2.css.lightningcss?.targets,
			minify: config$2.isProduction && !!config$2.build.cssMinify,
			analyzeDependencies: true
		}) : await (await importLightningCSS()).bundleAsync({
			...config$2.css.lightningcss,
			filename,
			projectRoot: config$2.root,
			resolver: {
				async read(filePath) {
					if (filePath === filename) return src;
					const code = fs.readFileSync(filePath, "utf-8");
					const lang = CSS_LANGS_RE.exec(filePath)?.[1];
					if (isPreProcessor(lang)) {
						const result = await compileCSSPreprocessors(environment, id, lang, code, workerController);
						result.deps?.forEach((dep) => deps.add(dep));
						return result.code;
					} else if (lang === "sss") return (await transformSugarSS(environment, id, code)).code;
					return code;
				},
				async resolve(id$1, from) {
					const publicFile = checkPublicFile(id$1, environment.getTopLevelConfig());
					if (publicFile) return publicFile;
					const atImportResolvers = getAtImportResolvers(environment.getTopLevelConfig());
					const lang = CSS_LANGS_RE.exec(from)?.[1];
					let resolver$1;
					switch (lang) {
						case "css":
						case "sss":
						case "styl":
						case "stylus":
						case void 0:
							resolver$1 = atImportResolvers.css;
							break;
						case "sass":
						case "scss":
							resolver$1 = atImportResolvers.sass;
							break;
						case "less":
							resolver$1 = atImportResolvers.less;
							break;
						default: throw new Error(`Unknown lang: ${lang}`);
					}
					const resolved = await resolver$1(environment, id$1, from);
					if (resolved) {
						deps.add(resolved);
						return resolved;
					}
					return id$1;
				}
			},
			minify: config$2.isProduction && !!config$2.build.cssMinify,
			sourceMap: config$2.command === "build" ? !!config$2.build.sourcemap : config$2.css.devSourcemap,
			analyzeDependencies: true,
			cssModules: cssModuleRE.test(id) ? config$2.css.lightningcss?.cssModules ?? true : void 0
		});
	} catch (e$1) {
		e$1.message = `[lightningcss] ${e$1.message}`;
		if (e$1.loc) {
			e$1.loc = {
				file: e$1.fileName.replace(NULL_BYTE_PLACEHOLDER, "\0"),
				line: e$1.loc.line,
				column: e$1.loc.column - 1
			};
			try {
				const friendlyMessage = getLightningCssErrorMessageForIeSyntaxes(fs.readFileSync(e$1.fileName, "utf-8"));
				if (friendlyMessage) e$1.message += friendlyMessage;
			} catch {}
		}
		throw e$1;
	}
	for (const warning of res.warnings) {
		let msg = `[vite:css][lightningcss] ${warning.message}`;
		msg += `\n${generateCodeFrame(src, {
			line: warning.loc.line,
			column: warning.loc.column - 1
		})}`;
		environment.logger.warn(import_picocolors$6.default.yellow(msg));
	}
	let css = decoder.decode(res.code);
	for (const dep of res.dependencies) switch (dep.type) {
		case "url": {
			let replaceUrl;
			if (skipUrlReplacer(dep.url)) replaceUrl = dep.url;
			else if (urlResolver) {
				const [newUrl, resolvedId] = await urlResolver(dep.url, dep.loc.filePath.replace(NULL_BYTE_PLACEHOLDER, "\0"));
				if (resolvedId) deps.add(resolvedId);
				replaceUrl = newUrl;
			} else replaceUrl = dep.url;
			css = css.replace(dep.placeholder, () => replaceUrl.replaceAll("\"", "\\\""));
			break;
		}
		default: throw new Error(`Unsupported dependency type: ${dep.type}`);
	}
	let modules;
	if ("exports" in res && res.exports) {
		modules = {};
		const sortedEntries = Object.entries(res.exports).sort((a, b) => a[0].localeCompare(b[0]));
		for (const [key, value$1] of sortedEntries) {
			modules[key] = value$1.name;
			for (const c of value$1.composes) modules[key] += " " + c.name;
		}
	}
	return {
		code: css,
		map: "map" in res ? res.map?.toString() : void 0,
		modules
	};
}
function getLightningCssErrorMessageForIeSyntaxes(code) {
	const commonIeMessage = ", which was used in the past to support old Internet Explorer versions. This is not a valid CSS syntax and will be ignored by modern browsers. \nWhile this is not supported by LightningCSS, you can set `css.lightningcss.errorRecovery: true` to strip these codes.";
	if (/[\s;{]\*[a-zA-Z-][\w-]+\s*:/.test(code)) return ".\nThis file contains star property hack (e.g. `*zoom`)" + commonIeMessage;
	if (/min-width:\s*0\\0/.test(code)) return ".\nThis file contains @media zero hack (e.g. `@media (min-width: 0\\0)`)" + commonIeMessage;
}
const map = {
	chrome: "chrome",
	edge: "edge",
	firefox: "firefox",
	hermes: false,
	ie: "ie",
	ios: "ios_saf",
	node: false,
	opera: "opera",
	rhino: false,
	safari: "safari"
};
const esMap = {
	2015: [
		"chrome49",
		"edge13",
		"safari10",
		"firefox44",
		"opera36"
	],
	2016: [
		"chrome50",
		"edge13",
		"safari10",
		"firefox43",
		"opera37"
	],
	2017: [
		"chrome58",
		"edge15",
		"safari11",
		"firefox52",
		"opera45"
	],
	2018: [
		"chrome63",
		"edge79",
		"safari12",
		"firefox58",
		"opera50"
	],
	2019: [
		"chrome73",
		"edge79",
		"safari12.1",
		"firefox64",
		"opera60"
	],
	2020: [
		"chrome80",
		"edge80",
		"safari14.1",
		"firefox80",
		"opera67"
	],
	2021: [
		"chrome85",
		"edge85",
		"safari14.1",
		"firefox80",
		"opera71"
	],
	2022: [
		"chrome94",
		"edge94",
		"safari16.4",
		"firefox93",
		"opera80"
	],
	2023: [
		"chrome110",
		"edge110",
		"safari16.4",
		"opera96"
	]
};
const esRE = /es(\d{4})/;
const versionRE = /\d/;
const convertTargetsCache = /* @__PURE__ */ new Map();
const convertTargets = (esbuildTarget) => {
	if (!esbuildTarget) return {};
	const cached = convertTargetsCache.get(esbuildTarget);
	if (cached) return cached;
	const targets = {};
	const entriesWithoutES = arraify(esbuildTarget).flatMap((e$1) => {
		const match = esRE.exec(e$1);
		if (!match) return e$1;
		const year = Number(match[1]);
		if (!esMap[year]) throw new Error(`Unsupported target "${e$1}"`);
		return esMap[year];
	});
	for (const entry of entriesWithoutES) {
		if (entry === "esnext") continue;
		const index = entry.search(versionRE);
		if (index >= 0) {
			const browser = map[entry.slice(0, index)];
			if (browser === false) continue;
			if (browser) {
				const [major, minor = 0] = entry.slice(index).split(".").map((v) => parseInt(v, 10));
				if (!isNaN(major) && !isNaN(minor)) {
					const version$2 = major << 16 | minor << 8;
					if (!targets[browser] || version$2 < targets[browser]) targets[browser] = version$2;
					continue;
				}
			}
		}
		throw new Error(`Unsupported target "${entry}"`);
	}
	convertTargetsCache.set(esbuildTarget, targets);
	return targets;
};
function resolveLibCssFilename(libOptions, root, packageCache) {
	if (typeof libOptions.cssFileName === "string") return `${libOptions.cssFileName}.css`;
	else if (typeof libOptions.fileName === "string") return `${libOptions.fileName}.css`;
	const packageJson = findNearestMainPackageData(root, packageCache)?.data;
	const name = packageJson ? getPkgName(packageJson.name) : void 0;
	if (!name) throw new Error("Name in package.json is required if option \"build.lib.cssFileName\" is not provided.");
	return `${name}.css`;
}

//#endregion
//#region src/node/plugins/importAnalysisBuild.ts
var import_convert_source_map = /* @__PURE__ */ __toESM(require_convert_source_map(), 1);
/**
* A flag for injected helpers. This flag will be set to `false` if the output
* target is not native es - so that injected helper logic can be conditionally
* dropped.
*/
const isModernFlag = `__VITE_IS_MODERN__`;
const preloadMethod = `__vitePreload`;
const preloadMarker = `__VITE_PRELOAD__`;
const preloadHelperId = "\0vite/preload-helper.js";
const preloadMarkerRE = new RegExp(preloadMarker, "g");
const dynamicImportPrefixRE = /import\s*\(/;
const dynamicImportTreeshakenRE = /((?:\bconst\s+|\blet\s+|\bvar\s+|,\s*)(\{[^{}.=]+\})\s*=\s*await\s+import\([^)]+\))(?=\s*(?:$|[^[.]))|(\(\s*await\s+import\([^)]+\)\s*\)(\??\.[\w$]+))|\bimport\([^)]+\)(\s*\.then\(\s*(?:function\s*)?\(\s*\{([^{}.=]+)\}\))/g;
function toRelativePath(filename, importer) {
	const relPath = path.posix.relative(path.posix.dirname(importer), filename);
	return relPath[0] === "." ? relPath : `./${relPath}`;
}
function indexOfMatchInSlice(str, reg, pos = 0) {
	reg.lastIndex = pos;
	return reg.exec(str)?.index ?? -1;
}
/**
* Helper for preloading CSS and direct imports of async chunks in parallel to
* the async chunk itself.
*/
function detectScriptRel() {
	const relList = typeof document !== "undefined" && document.createElement("link").relList;
	return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}
function preload(baseModule, deps, importerUrl) {
	let promise = Promise.resolve();
	if (__VITE_IS_MODERN__ && deps && deps.length > 0) {
		const links = document.getElementsByTagName("link");
		const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
		const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
		function allSettled(promises$2) {
			return Promise.all(promises$2.map((p) => Promise.resolve(p).then((value$1) => ({
				status: "fulfilled",
				value: value$1
			}), (reason) => ({
				status: "rejected",
				reason
			}))));
		}
		promise = allSettled(deps.map((dep) => {
			dep = assetsURL(dep, importerUrl);
			if (dep in seen) return;
			seen[dep] = true;
			const isCss = dep.endsWith(".css");
			const cssSelector = isCss ? "[rel=\"stylesheet\"]" : "";
			if (!!importerUrl) for (let i$1 = links.length - 1; i$1 >= 0; i$1--) {
				const link$1 = links[i$1];
				if (link$1.href === dep && (!isCss || link$1.rel === "stylesheet")) return;
			}
			else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
			const link = document.createElement("link");
			link.rel = isCss ? "stylesheet" : scriptRel;
			if (!isCss) link.as = "script";
			link.crossOrigin = "";
			link.href = dep;
			if (cspNonce) link.setAttribute("nonce", cspNonce);
			document.head.appendChild(link);
			if (isCss) return new Promise((res, rej) => {
				link.addEventListener("load", res);
				link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
			});
		}));
	}
	function handlePreloadError(err$2) {
		const e$1 = new Event("vite:preloadError", { cancelable: true });
		e$1.payload = err$2;
		window.dispatchEvent(e$1);
		if (!e$1.defaultPrevented) throw err$2;
	}
	return promise.then((res) => {
		for (const item of res || []) {
			if (item.status !== "rejected") continue;
			handlePreloadError(item.reason);
		}
		return baseModule().catch(handlePreloadError);
	});
}
function getPreloadCode(environment, renderBuiltUrlBoolean, isRelativeBase) {
	const { modulePreload } = environment.config.build;
	return `const scriptRel = ${modulePreload && modulePreload.polyfill ? `'modulepreload'` : `/* @__PURE__ */ (${detectScriptRel.toString()})()`};const assetsURL = ${renderBuiltUrlBoolean || isRelativeBase ? `function(dep, importerUrl) { return new URL(dep, importerUrl).href }` : `function(dep) { return ${JSON.stringify(environment.config.base)}+dep }`};const seen = {};export const ${preloadMethod} = ${preload.toString()}`;
}
/**
* Build only. During serve this is performed as part of ./importAnalysis.
*/
function buildImportAnalysisPlugin(config$2) {
	const getInsertPreload = (environment) => environment.config.consumer === "client" && !config$2.isWorker && !config$2.build.lib;
	const renderBuiltUrl = config$2.experimental.renderBuiltUrl;
	const isRelativeBase = config$2.base === "./" || config$2.base === "";
	return {
		name: "vite:build-import-analysis",
		resolveId: {
			filter: { id: exactRegex(preloadHelperId) },
			handler(id) {
				return id;
			}
		},
		load: {
			filter: { id: exactRegex(preloadHelperId) },
			handler(_id) {
				return {
					code: getPreloadCode(this.environment, !!renderBuiltUrl, isRelativeBase),
					moduleSideEffects: false
				};
			}
		},
		transform: {
			filter: { code: dynamicImportPrefixRE },
			async handler(source, importer) {
				await init;
				let imports = [];
				try {
					imports = parse(source)[0];
				} catch (_e) {
					const e$1 = _e;
					const { message, showCodeFrame } = createParseErrorInfo(importer, source);
					this.error(message, showCodeFrame ? e$1.idx : void 0);
				}
				if (!imports.length) return null;
				const insertPreload = getInsertPreload(this.environment);
				const dynamicImports = {};
				if (insertPreload) {
					let match;
					while (match = dynamicImportTreeshakenRE.exec(source)) {
						if (match[1]) {
							dynamicImports[dynamicImportTreeshakenRE.lastIndex] = {
								declaration: `const ${match[2]}`,
								names: match[2]?.trim()
							};
							continue;
						}
						if (match[3]) {
							let names$1 = /\.([^.?]+)/.exec(match[4])?.[1] || "";
							if (names$1 === "default") names$1 = "default: __vite_default__";
							dynamicImports[dynamicImportTreeshakenRE.lastIndex - match[4]?.length - 1] = {
								declaration: `const {${names$1}}`,
								names: `{ ${names$1} }`
							};
							continue;
						}
						const names = match[6]?.trim();
						dynamicImports[dynamicImportTreeshakenRE.lastIndex - match[5]?.length] = {
							declaration: `const {${names}}`,
							names: `{ ${names} }`
						};
					}
				}
				let s$2;
				const str = () => s$2 || (s$2 = new MagicString(source));
				let needPreloadHelper = false;
				for (let index = 0; index < imports.length; index++) {
					const { s: start, e: end, ss: expStart, se: expEnd, d: dynamicIndex, a: attributeIndex } = imports[index];
					const isDynamicImport = dynamicIndex > -1;
					if (!isDynamicImport && attributeIndex > -1) str().remove(end + 1, expEnd);
					if (isDynamicImport && insertPreload && (source[start] === "\"" || source[start] === "'" || source[start] === "`")) {
						needPreloadHelper = true;
						const { declaration, names } = dynamicImports[expEnd] || {};
						if (names) {
							str().prependLeft(expStart, `${preloadMethod}(async () => { ${declaration} = await `);
							str().appendRight(expEnd, `;return ${names}}`);
						} else str().prependLeft(expStart, `${preloadMethod}(() => `);
						str().appendRight(expEnd, `,${isModernFlag}?${preloadMarker}:void 0${renderBuiltUrl || isRelativeBase ? ",import.meta.url" : ""})`);
					}
				}
				if (needPreloadHelper && insertPreload && !source.includes(`const ${preloadMethod} =`)) str().prepend(`import { ${preloadMethod} } from "${preloadHelperId}";`);
				if (s$2) return {
					code: s$2.toString(),
					map: this.environment.config.build.sourcemap ? s$2.generateMap({ hires: "boundary" }) : null
				};
			}
		},
		renderChunk(code, _, { format: format$3 }) {
			if (code.indexOf(isModernFlag) > -1) {
				const re = new RegExp(isModernFlag, "g");
				const isModern = String(format$3 === "es");
				const isModernWithPadding = isModern + " ".repeat(isModernFlag.length - isModern.length);
				return {
					code: code.replace(re, isModernWithPadding),
					map: null
				};
			}
			return null;
		},
		generateBundle({ format: format$3 }, bundle) {
			if (format$3 !== "es") return;
			if (!getInsertPreload(this.environment)) {
				const removedPureCssFiles = removedPureCssFilesCache.get(config$2);
				if (removedPureCssFiles && removedPureCssFiles.size > 0) for (const file in bundle) {
					const chunk = bundle[file];
					if (chunk.type === "chunk" && chunk.code.includes("import")) {
						const code = chunk.code;
						let imports;
						try {
							imports = parse(code)[0].filter((i$1) => i$1.d > -1);
						} catch (e$1) {
							const loc = numberToPos(code, e$1.idx);
							this.error({
								name: e$1.name,
								message: e$1.message,
								stack: e$1.stack,
								cause: e$1.cause,
								pos: e$1.idx,
								loc: {
									...loc,
									file: chunk.fileName
								},
								frame: generateCodeFrame(code, loc)
							});
						}
						for (const imp of imports) {
							const { n: name, s: start, e: end, ss: expStart, se: expEnd } = imp;
							let url$3 = name;
							if (!url$3) {
								const rawUrl = code.slice(start, end);
								if (rawUrl[0] === `"` && rawUrl.endsWith(`"`)) url$3 = rawUrl.slice(1, -1);
							}
							if (!url$3) continue;
							const normalizedFile = path.posix.join(path.posix.dirname(chunk.fileName), url$3);
							if (removedPureCssFiles.has(normalizedFile)) chunk.code = chunk.code.slice(0, expStart) + `Promise.resolve({${"".padEnd(expEnd - expStart - 19, " ")}})` + chunk.code.slice(expEnd);
						}
					}
				}
				return;
			}
			const buildSourcemap = this.environment.config.build.sourcemap;
			const { modulePreload } = this.environment.config.build;
			for (const file in bundle) {
				const chunk = bundle[file];
				if (chunk.type === "chunk" && chunk.code.indexOf(preloadMarker) > -1) {
					const code = chunk.code;
					let imports;
					try {
						imports = parse(code)[0].filter((i$1) => i$1.d > -1);
					} catch (e$1) {
						const loc = numberToPos(code, e$1.idx);
						this.error({
							name: e$1.name,
							message: e$1.message,
							stack: e$1.stack,
							cause: e$1.cause,
							pos: e$1.idx,
							loc: {
								...loc,
								file: chunk.fileName
							},
							frame: generateCodeFrame(code, loc)
						});
					}
					const s$2 = new MagicString(code);
					const rewroteMarkerStartPos = /* @__PURE__ */ new Set();
					const fileDeps = [];
					const addFileDep = (url$3, runtime = false) => {
						const index = fileDeps.findIndex((dep) => dep.url === url$3);
						if (index === -1) return fileDeps.push({
							url: url$3,
							runtime
						}) - 1;
						else return index;
					};
					if (imports.length) for (let index = 0; index < imports.length; index++) {
						const { n: name, s: start, e: end, ss: expStart, se: expEnd } = imports[index];
						let url$3 = name;
						if (!url$3) {
							const rawUrl = code.slice(start, end);
							if (rawUrl[0] === `"` && rawUrl.endsWith(`"`)) url$3 = rawUrl.slice(1, -1);
						}
						const deps = /* @__PURE__ */ new Set();
						let hasRemovedPureCssChunk = false;
						let normalizedFile = void 0;
						if (url$3) {
							normalizedFile = path.posix.join(path.posix.dirname(chunk.fileName), url$3);
							const ownerFilename = chunk.fileName;
							const analyzed = /* @__PURE__ */ new Set();
							const addDeps = (filename) => {
								if (filename === ownerFilename) return;
								if (analyzed.has(filename)) return;
								analyzed.add(filename);
								const chunk$1 = bundle[filename];
								if (chunk$1) {
									deps.add(chunk$1.fileName);
									if (chunk$1.type === "chunk") {
										chunk$1.imports.forEach(addDeps);
										chunk$1.viteMetadata.importedCss.forEach((file$1) => {
											deps.add(file$1);
										});
									}
								} else {
									const chunk$2 = removedPureCssFilesCache.get(config$2).get(filename);
									if (chunk$2) {
										if (chunk$2.viteMetadata.importedCss.size) {
											chunk$2.viteMetadata.importedCss.forEach((file$1) => {
												deps.add(file$1);
											});
											hasRemovedPureCssChunk = true;
										}
										s$2.update(expStart, expEnd, "Promise.resolve({})");
									}
								}
							};
							addDeps(normalizedFile);
						}
						let markerStartPos$1 = indexOfMatchInSlice(code, preloadMarkerRE, end);
						if (markerStartPos$1 === -1 && imports.length === 1) markerStartPos$1 = indexOfMatchInSlice(code, preloadMarkerRE);
						if (markerStartPos$1 > 0) {
							let depsArray = deps.size > 1 || hasRemovedPureCssChunk && deps.size > 0 ? modulePreload === false ? [...deps].filter((d$2) => d$2.endsWith(".css")) : [...deps] : [];
							const resolveDependencies = modulePreload ? modulePreload.resolveDependencies : void 0;
							if (resolveDependencies && normalizedFile) {
								const cssDeps = [];
								const otherDeps = [];
								for (const dep of depsArray) (dep.endsWith(".css") ? cssDeps : otherDeps).push(dep);
								depsArray = [...resolveDependencies(normalizedFile, otherDeps, {
									hostId: file,
									hostType: "js"
								}), ...cssDeps];
							}
							let renderedDeps;
							if (renderBuiltUrl) renderedDeps = depsArray.map((dep) => {
								const replacement = toOutputFilePathInJS(this.environment, dep, "asset", chunk.fileName, "js", toRelativePath);
								if (typeof replacement === "string") return addFileDep(replacement);
								return addFileDep(replacement.runtime, true);
							});
							else renderedDeps = depsArray.map((d$2) => isRelativeBase ? addFileDep(toRelativePath(d$2, file)) : addFileDep(d$2));
							s$2.update(markerStartPos$1, markerStartPos$1 + preloadMarker.length, renderedDeps.length > 0 ? `__vite__mapDeps([${renderedDeps.join(",")}])` : `[]`);
							rewroteMarkerStartPos.add(markerStartPos$1);
						}
					}
					if (fileDeps.length > 0) {
						const mapDepsCode = `const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=${`[${fileDeps.map((fileDep) => fileDep.runtime ? fileDep.url : JSON.stringify(fileDep.url)).join(",")}]`})))=>i.map(i=>d[i]);\n`;
						if (code.startsWith("#!")) s$2.prependLeft(code.indexOf("\n") + 1, mapDepsCode);
						else s$2.prepend(mapDepsCode);
					}
					let markerStartPos = indexOfMatchInSlice(code, preloadMarkerRE);
					while (markerStartPos >= 0) {
						if (!rewroteMarkerStartPos.has(markerStartPos)) s$2.update(markerStartPos, markerStartPos + preloadMarker.length, "void 0");
						markerStartPos = indexOfMatchInSlice(code, preloadMarkerRE, markerStartPos + preloadMarker.length);
					}
					if (s$2.hasChanged()) {
						chunk.code = s$2.toString();
						if (buildSourcemap && chunk.map) {
							const nextMap = s$2.generateMap({
								source: chunk.fileName,
								hires: "boundary"
							});
							const originalFile = chunk.map.file;
							const map$1 = combineSourcemaps(chunk.fileName, [nextMap, chunk.map]);
							map$1.toUrl = () => genSourceMapUrl(map$1);
							if (originalFile) map$1.file = originalFile;
							const originalDebugId = chunk.map.debugId;
							chunk.map = map$1;
							if (buildSourcemap === "inline") {
								chunk.code = chunk.code.replace(import_convert_source_map.default.mapFileCommentRegex, "");
								chunk.code += `\n//# sourceMappingURL=${genSourceMapUrl(map$1)}`;
							} else {
								if (originalDebugId) map$1.debugId = originalDebugId;
								const mapAsset = bundle[chunk.fileName + ".map"];
								if (mapAsset && mapAsset.type === "asset") mapAsset.source = map$1.toString();
							}
						}
					}
				}
			}
		}
	};
}

//#endregion
//#region src/node/ssr/ssrManifestPlugin.ts
function ssrManifestPlugin() {
	const getSsrManifest = perEnvironmentState(() => {
		return {};
	});
	return {
		name: "vite:ssr-manifest",
		applyToEnvironment(environment) {
			return !!environment.config.build.ssrManifest;
		},
		generateBundle(_options, bundle) {
			const config$2 = this.environment.config;
			const ssrManifest = getSsrManifest(this);
			const { base } = config$2;
			for (const file in bundle) {
				const chunk = bundle[file];
				if (chunk.type === "chunk") {
					for (const id in chunk.modules) {
						const normalizedId = normalizePath(relative(config$2.root, id));
						const mappedChunks = ssrManifest[normalizedId] ?? (ssrManifest[normalizedId] = []);
						if (!chunk.isEntry) {
							mappedChunks.push(joinUrlSegments(base, chunk.fileName));
							chunk.viteMetadata.importedCss.forEach((file$1) => {
								mappedChunks.push(joinUrlSegments(base, file$1));
							});
						}
						chunk.viteMetadata.importedAssets.forEach((file$1) => {
							mappedChunks.push(joinUrlSegments(base, file$1));
						});
					}
					if (chunk.code.includes(preloadMethod)) {
						const code = chunk.code;
						let imports = [];
						try {
							imports = parse(code)[0].filter((i$1) => i$1.n && i$1.d > -1);
						} catch (_e) {
							const e$1 = _e;
							const loc = numberToPos(code, e$1.idx);
							this.error({
								name: e$1.name,
								message: e$1.message,
								stack: e$1.stack,
								cause: e$1.cause,
								pos: e$1.idx,
								loc: {
									...loc,
									file: chunk.fileName
								},
								frame: generateCodeFrame(code, loc)
							});
						}
						if (imports.length) for (let index = 0; index < imports.length; index++) {
							const { s: start, e: end, n: name } = imports[index];
							const url$3 = code.slice(start, end);
							const deps = [];
							const ownerFilename = chunk.fileName;
							const analyzed = /* @__PURE__ */ new Set();
							const addDeps = (filename) => {
								if (filename === ownerFilename) return;
								if (analyzed.has(filename)) return;
								analyzed.add(filename);
								const chunk$1 = bundle[filename];
								if (chunk$1) {
									chunk$1.viteMetadata.importedCss.forEach((file$1) => {
										deps.push(joinUrlSegments(base, file$1));
									});
									chunk$1.imports.forEach(addDeps);
								}
							};
							addDeps(normalizePath(join(dirname(chunk.fileName), url$3.slice(1, -1))));
							ssrManifest[basename(name)] = deps;
						}
					}
				}
			}
			this.emitFile({
				fileName: typeof config$2.build.ssrManifest === "string" ? config$2.build.ssrManifest : ".vite/ssr-manifest.json",
				type: "asset",
				source: JSON.stringify(sortObjectKeys(ssrManifest), void 0, 2)
			});
		}
	};
}

//#endregion
//#region src/node/plugins/loadFallback.ts
/**
* A plugin to provide build load fallback for arbitrary request with queries.
*/
function buildLoadFallbackPlugin() {
	return {
		name: "vite:load-fallback",
		load: { async handler(id) {
			try {
				const cleanedId = cleanUrl(id);
				const content = await fsp.readFile(cleanedId, "utf-8");
				this.addWatchFile(cleanedId);
				return content;
			} catch {
				const content = await fsp.readFile(id, "utf-8");
				this.addWatchFile(id);
				return content;
			}
		} }
	};
}

//#endregion
//#region src/node/plugins/completeSystemWrap.ts
/**
* make sure systemjs register wrap to had complete parameters in system format
*/
function completeSystemWrapPlugin() {
	const SystemJSWrapRE = /System.register\(.*?(\(exports\)|\(\))/g;
	return {
		name: "vite:force-systemjs-wrap-complete",
		renderChunk(code, _chunk, opts) {
			if (opts.format === "system") return {
				code: code.replace(SystemJSWrapRE, (s$2, s1) => s$2.replace(s1, "(exports, module)")),
				map: null
			};
		}
	};
}

//#endregion
//#region src/node/plugins/prepareOutDir.ts
var import_picocolors$5 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
function prepareOutDirPlugin() {
	const rendered = /* @__PURE__ */ new Set();
	return {
		name: "vite:prepare-out-dir",
		options() {
			rendered.delete(this.environment);
		},
		renderStart: {
			order: "pre",
			handler() {
				if (rendered.has(this.environment)) return;
				rendered.add(this.environment);
				const { config: config$2 } = this.environment;
				if (config$2.build.write) {
					const { root, build: options$1 } = config$2;
					const resolvedOutDirs = getResolvedOutDirs(root, options$1.outDir, options$1.rollupOptions.output);
					prepareOutDir(resolvedOutDirs, resolveEmptyOutDir(options$1.emptyOutDir, root, resolvedOutDirs, this.environment.logger), this.environment);
				}
			}
		}
	};
}
function prepareOutDir(outDirs, emptyOutDir, environment) {
	const { publicDir } = environment.config;
	const outDirsArray = [...outDirs];
	for (const outDir of outDirs) {
		if (emptyOutDir !== false && fs.existsSync(outDir)) emptyDir(outDir, [...outDirsArray.map((dir) => {
			const relative$3 = path.relative(outDir, dir);
			if (relative$3 && !relative$3.startsWith("..") && !path.isAbsolute(relative$3)) return relative$3;
			return "";
		}).filter(Boolean), ".git"]);
		if (environment.config.build.copyPublicDir && publicDir && fs.existsSync(publicDir)) {
			if (!areSeparateFolders(outDir, publicDir)) environment.logger.warn(import_picocolors$5.default.yellow(`\n${import_picocolors$5.default.bold(`(!)`)} The public directory feature may not work correctly. outDir ${import_picocolors$5.default.white(import_picocolors$5.default.dim(outDir))} and publicDir ${import_picocolors$5.default.white(import_picocolors$5.default.dim(publicDir))} are not separate folders.\n`));
			copyDir(publicDir, outDir);
		}
	}
}
function areSeparateFolders(a, b) {
	const na = normalizePath(a);
	const nb = normalizePath(b);
	return na !== nb && !na.startsWith(withTrailingSlash(nb)) && !nb.startsWith(withTrailingSlash(na));
}

//#endregion
//#region src/node/build.ts
var import_picocolors$4 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const buildEnvironmentOptionsDefaults = Object.freeze({
	target: "baseline-widely-available",
	polyfillModulePreload: true,
	modulePreload: true,
	outDir: "dist",
	assetsDir: "assets",
	assetsInlineLimit: DEFAULT_ASSETS_INLINE_LIMIT,
	sourcemap: false,
	terserOptions: {},
	rollupOptions: {},
	commonjsOptions: {
		include: [/node_modules/],
		extensions: [".js", ".cjs"]
	},
	dynamicImportVarsOptions: {
		warnOnError: true,
		exclude: [/node_modules/]
	},
	write: true,
	emptyOutDir: null,
	copyPublicDir: true,
	manifest: false,
	lib: false,
	ssrManifest: false,
	ssrEmitAssets: false,
	reportCompressedSize: true,
	chunkSizeWarningLimit: 500,
	watch: null
});
function resolveBuildEnvironmentOptions(raw, logger, consumer) {
	const deprecatedPolyfillModulePreload = raw.polyfillModulePreload;
	const { polyfillModulePreload,...rest } = raw;
	raw = rest;
	if (deprecatedPolyfillModulePreload !== void 0) logger.warn("polyfillModulePreload is deprecated. Use modulePreload.polyfill instead.");
	if (deprecatedPolyfillModulePreload === false && raw.modulePreload === void 0) raw.modulePreload = { polyfill: false };
	const merged = mergeWithDefaults({
		...buildEnvironmentOptionsDefaults,
		cssCodeSplit: !raw.lib,
		minify: consumer === "server" ? false : "esbuild",
		ssr: consumer === "server",
		emitAssets: consumer === "client",
		createEnvironment: (name, config$2) => new BuildEnvironment(name, config$2)
	}, raw);
	if (merged.target === "baseline-widely-available") merged.target = ESBUILD_BASELINE_WIDELY_AVAILABLE_TARGET;
	if (merged.minify === "false") merged.minify = false;
	else if (merged.minify === true) merged.minify = "esbuild";
	const defaultModulePreload = { polyfill: true };
	return {
		...merged,
		cssTarget: merged.cssTarget ?? merged.target,
		cssMinify: merged.cssMinify ?? (consumer === "server" ? "esbuild" : !!merged.minify),
		modulePreload: merged.modulePreload === false ? false : merged.modulePreload === true ? defaultModulePreload : {
			...defaultModulePreload,
			...merged.modulePreload
		}
	};
}
async function resolveBuildPlugins(config$2) {
	return {
		pre: [
			completeSystemWrapPlugin(),
			...!config$2.isWorker ? [prepareOutDirPlugin()] : [],
			perEnvironmentPlugin("commonjs", (environment) => {
				const { commonjsOptions } = environment.config.build;
				return !Array.isArray(commonjsOptions.include) || commonjsOptions.include.length !== 0 ? commonjs(commonjsOptions) : false;
			}),
			dataURIPlugin(),
			perEnvironmentPlugin("vite:rollup-options-plugins", async (environment) => (await asyncFlatten(arraify(environment.config.build.rollupOptions.plugins))).filter(Boolean)),
			...config$2.isWorker ? [webWorkerPostPlugin()] : []
		],
		post: [
			buildImportAnalysisPlugin(config$2),
			buildEsbuildPlugin(),
			terserPlugin(config$2),
			...!config$2.isWorker ? [
				manifestPlugin(),
				ssrManifestPlugin(),
				buildReporterPlugin(config$2)
			] : [],
			buildLoadFallbackPlugin()
		]
	};
}
/**
* Bundles a single environment for production.
* Returns a Promise containing the build result.
*/
async function build$1(inlineConfig = {}) {
	const builder = await createBuilder(inlineConfig, true);
	const environment = Object.values(builder.environments)[0];
	if (!environment) throw new Error("No environment found");
	return builder.build(environment);
}
function resolveConfigToBuild(inlineConfig = {}, patchConfig, patchPlugins) {
	return resolveConfig(inlineConfig, "build", "production", "production", false, patchConfig, patchPlugins);
}
function resolveRollupOptions(environment) {
	const { root, packageCache, build: options$1 } = environment.config;
	const libOptions = options$1.lib;
	const { logger } = environment;
	const ssr = environment.config.consumer === "server";
	const resolve$4 = (p) => path.resolve(root, p);
	const input = libOptions ? options$1.rollupOptions.input || (typeof libOptions.entry === "string" ? resolve$4(libOptions.entry) : Array.isArray(libOptions.entry) ? libOptions.entry.map(resolve$4) : Object.fromEntries(Object.entries(libOptions.entry).map(([alias$2, file]) => [alias$2, resolve$4(file)]))) : typeof options$1.ssr === "string" ? resolve$4(options$1.ssr) : options$1.rollupOptions.input || resolve$4("index.html");
	if (ssr && typeof input === "string" && input.endsWith(".html")) throw new Error("rollupOptions.input should not be an html file when building for SSR. Please specify a dedicated SSR entry.");
	if (options$1.cssCodeSplit === false) {
		if ((typeof input === "string" ? [input] : Array.isArray(input) ? input : Object.values(input)).some((input$1) => input$1.endsWith(".css"))) throw new Error(`When "build.cssCodeSplit: false" is set, "rollupOptions.input" should not include CSS files.`);
	}
	const outDir = resolve$4(options$1.outDir);
	const plugins$1 = environment.plugins.map((p) => injectEnvironmentToHooks(environment, p));
	const rollupOptions = {
		preserveEntrySignatures: ssr ? "allow-extension" : libOptions ? "strict" : false,
		cache: options$1.watch ? void 0 : false,
		...options$1.rollupOptions,
		output: options$1.rollupOptions.output,
		input,
		plugins: plugins$1,
		external: options$1.rollupOptions.external,
		onLog(level, log$4) {
			onRollupLog(level, log$4, environment);
		}
	};
	const isSsrTargetWebworkerEnvironment = environment.name === "ssr" && environment.getTopLevelConfig().ssr?.target === "webworker";
	const buildOutputOptions = (output = {}) => {
		if (output.output) logger.warn("You've set \"rollupOptions.output.output\" in your config. This is deprecated and will override all Vite.js default output options. Please use \"rollupOptions.output\" instead.");
		if (output.file) throw new Error("Vite does not support \"rollupOptions.output.file\". Please use \"rollupOptions.output.dir\" and \"rollupOptions.output.entryFileNames\" instead.");
		if (output.sourcemap) logger.warnOnce(import_picocolors$4.default.yellow("Vite does not support \"rollupOptions.output.sourcemap\". Please use \"build.sourcemap\" instead."));
		const format$3 = output.format || "es";
		const jsExt = ssr && !isSsrTargetWebworkerEnvironment || libOptions ? resolveOutputJsExtension(format$3, findNearestPackageData(root, packageCache)?.data.type) : "js";
		return {
			dir: outDir,
			format: format$3,
			exports: "auto",
			sourcemap: options$1.sourcemap,
			name: libOptions ? libOptions.name : void 0,
			hoistTransitiveImports: libOptions ? false : void 0,
			generatedCode: "es2015",
			entryFileNames: ssr ? `[name].${jsExt}` : libOptions ? ({ name }) => resolveLibFilename(libOptions, format$3, name, root, jsExt, packageCache) : path.posix.join(options$1.assetsDir, `[name]-[hash].${jsExt}`),
			chunkFileNames: libOptions ? `[name]-[hash].${jsExt}` : path.posix.join(options$1.assetsDir, `[name]-[hash].${jsExt}`),
			assetFileNames: libOptions ? `[name].[ext]` : path.posix.join(options$1.assetsDir, `[name]-[hash].[ext]`),
			inlineDynamicImports: output.format === "umd" || output.format === "iife" || isSsrTargetWebworkerEnvironment && (typeof input === "string" || Object.keys(input).length === 1),
			...output
		};
	};
	const outputs = resolveBuildOutputs(options$1.rollupOptions.output, libOptions, logger);
	if (Array.isArray(outputs)) rollupOptions.output = outputs.map(buildOutputOptions);
	else rollupOptions.output = buildOutputOptions(outputs);
	return rollupOptions;
}
/**
* Build an App environment, or a App library (if libraryOptions is provided)
**/
async function buildEnvironment(environment) {
	const { logger, config: config$2 } = environment;
	const { root, build: options$1 } = config$2;
	logger.info(import_picocolors$4.default.cyan(`vite v${VERSION} ${import_picocolors$4.default.green(`building ${config$2.consumer === "server" ? `SSR bundle ` : ``}for ${environment.config.mode}...`)}`));
	let bundle;
	let startTime;
	try {
		const rollupOptions = resolveRollupOptions(environment);
		if (options$1.watch) {
			logger.info(import_picocolors$4.default.cyan(`\nwatching for file changes...`));
			const resolvedOutDirs = getResolvedOutDirs(root, options$1.outDir, options$1.rollupOptions.output);
			const emptyOutDir = resolveEmptyOutDir(options$1.emptyOutDir, root, resolvedOutDirs, logger);
			const resolvedChokidarOptions = resolveChokidarOptions({
				...(rollupOptions.watch || {}).chokidar,
				...options$1.watch.chokidar
			}, resolvedOutDirs, emptyOutDir, environment.config.cacheDir);
			const { watch: watch$1 } = await import("rollup");
			const watcher = watch$1({
				...rollupOptions,
				watch: {
					...rollupOptions.watch,
					...options$1.watch,
					chokidar: resolvedChokidarOptions
				}
			});
			watcher.on("event", (event) => {
				if (event.code === "BUNDLE_START") logger.info(import_picocolors$4.default.cyan(`\nbuild started...`));
				else if (event.code === "BUNDLE_END") {
					event.result.close();
					logger.info(import_picocolors$4.default.cyan(`built in ${event.duration}ms.`));
				} else if (event.code === "ERROR") {
					const e$1 = event.error;
					enhanceRollupError(e$1);
					clearLine();
					logger.error(e$1.message, { error: e$1 });
				}
			});
			return watcher;
		}
		const { rollup } = await import("rollup");
		startTime = Date.now();
		bundle = await rollup(rollupOptions);
		const res = [];
		for (const output of arraify(rollupOptions.output)) res.push(await bundle[options$1.write ? "write" : "generate"](output));
		logger.info(`${import_picocolors$4.default.green(`✓ built in ${displayTime(Date.now() - startTime)}`)}`);
		return Array.isArray(rollupOptions.output) ? res : res[0];
	} catch (e$1) {
		enhanceRollupError(e$1);
		clearLine();
		if (startTime) {
			logger.error(`${import_picocolors$4.default.red("✗")} Build failed in ${displayTime(Date.now() - startTime)}`);
			startTime = void 0;
		}
		throw e$1;
	} finally {
		if (bundle) await bundle.close();
	}
}
function enhanceRollupError(e$1) {
	const stackOnly = extractStack(e$1);
	let msg = import_picocolors$4.default.red((e$1.plugin ? `[${e$1.plugin}] ` : "") + e$1.message);
	if (e$1.loc && e$1.loc.file && e$1.loc.file !== e$1.id) msg += `\nfile: ${import_picocolors$4.default.cyan(`${e$1.loc.file}:${e$1.loc.line}:${e$1.loc.column}` + (e$1.id ? ` (${e$1.id})` : ""))}`;
	else if (e$1.id) msg += `\nfile: ${import_picocolors$4.default.cyan(e$1.id + (e$1.loc ? `:${e$1.loc.line}:${e$1.loc.column}` : ""))}`;
	if (e$1.frame) msg += `\n` + import_picocolors$4.default.yellow(normalizeCodeFrame(e$1.frame));
	e$1.message = msg;
	if (stackOnly !== void 0) e$1.stack = `${e$1.message}\n${stackOnly}`;
}
/**
* The stack string usually contains a copy of the message at the start of the stack.
* If the stack starts with the message, we remove it and just return the stack trace
* portion. Otherwise the original stack trace is used.
*/
function extractStack(e$1) {
	const { stack, name = "Error", message } = e$1;
	if (!stack) return stack;
	const expectedPrefix = `${name}: ${message}\n`;
	if (stack.startsWith(expectedPrefix)) return stack.slice(expectedPrefix.length);
	return stack;
}
/**
* Esbuild code frames have newlines at the start and end of the frame, rollup doesn't
* This function normalizes the frame to match the esbuild format which has more pleasing padding
*/
function normalizeCodeFrame(frame) {
	return `\n${frame.replace(/^\n|\n$/g, "")}\n`;
}
function resolveOutputJsExtension(format$3, type = "commonjs") {
	if (type === "module") return format$3 === "cjs" || format$3 === "umd" ? "cjs" : "js";
	else return format$3 === "es" ? "mjs" : "js";
}
function resolveLibFilename(libOptions, format$3, entryName, root, extension$1, packageCache) {
	if (typeof libOptions.fileName === "function") return libOptions.fileName(format$3, entryName);
	const packageJson = findNearestMainPackageData(root, packageCache)?.data;
	const name = libOptions.fileName || (packageJson && typeof libOptions.entry === "string" ? getPkgName(packageJson.name) : entryName);
	if (!name) throw new Error("Name in package.json is required if option \"build.lib.fileName\" is not provided.");
	extension$1 ??= resolveOutputJsExtension(format$3, packageJson?.type);
	if (format$3 === "cjs" || format$3 === "es") return `${name}.${extension$1}`;
	return `${name}.${format$3}.${extension$1}`;
}
function resolveBuildOutputs(outputs, libOptions, logger) {
	if (libOptions) {
		const libHasMultipleEntries = typeof libOptions.entry !== "string" && Object.values(libOptions.entry).length > 1;
		const libFormats = libOptions.formats || (libHasMultipleEntries ? ["es", "cjs"] : ["es", "umd"]);
		if (!Array.isArray(outputs)) {
			if (libFormats.includes("umd") || libFormats.includes("iife")) {
				if (libHasMultipleEntries) throw new Error("Multiple entry points are not supported when output formats include \"umd\" or \"iife\".");
				if (!libOptions.name) throw new Error("Option \"build.lib.name\" is required when output formats include \"umd\" or \"iife\".");
			}
			return libFormats.map((format$3) => ({
				...outputs,
				format: format$3
			}));
		}
		if (libOptions.formats) logger.warn(import_picocolors$4.default.yellow("\"build.lib.formats\" will be ignored because \"build.rollupOptions.output\" is already an array format."));
		outputs.forEach((output) => {
			if ((output.format === "umd" || output.format === "iife") && !output.name) throw new Error("Entries in \"build.rollupOptions.output\" must specify \"name\" when the format is \"umd\" or \"iife\".");
		});
	}
	return outputs;
}
const warningIgnoreList = [`CIRCULAR_DEPENDENCY`, `THIS_IS_UNDEFINED`];
const dynamicImportWarningIgnoreList = [`Unsupported expression`, `statically analyzed`];
function clearLine() {
	if (process.stdout.isTTY && !process.env.CI) {
		process.stdout.clearLine(0);
		process.stdout.cursorTo(0);
	}
}
function onRollupLog(level, log$4, environment) {
	const debugLogger = createDebugger("vite:build");
	const viteLog = (logLeveling, rawLogging) => {
		const logging = typeof rawLogging === "object" ? rawLogging : { message: rawLogging };
		if (logging.code === "UNRESOLVED_IMPORT") {
			const id = logging.id;
			const exporter = logging.exporter;
			if (!id || !id.endsWith("?commonjs-external")) throw new Error(`[vite]: Rollup failed to resolve import "${exporter}" from "${id}".\nThis is most likely unintended because it can break your application at runtime.\nIf you do want to externalize this module explicitly add it to\n\`build.rollupOptions.external\``);
		}
		if (logLeveling === "warn") {
			if (logging.plugin === "rollup-plugin-dynamic-import-variables" && dynamicImportWarningIgnoreList.some((msg) => logging.message.includes(msg))) return;
			if (warningIgnoreList.includes(logging.code)) return;
		}
		switch (logLeveling) {
			case "info":
				environment.logger.info(logging.message);
				return;
			case "warn":
				environment.logger.warn(import_picocolors$4.default.yellow(logging.message));
				return;
			case "error":
				environment.logger.error(import_picocolors$4.default.red(logging.message));
				return;
			case "debug":
				debugLogger?.(logging.message);
				return;
			default:
				environment.logger.info(logging.message);
				return;
		}
	};
	clearLine();
	const userOnLog = environment.config.build.rollupOptions?.onLog;
	const userOnWarn = environment.config.build.rollupOptions?.onwarn;
	if (userOnLog) if (userOnWarn) userOnLog(level, log$4, normalizeUserOnWarn(userOnWarn, viteLog));
	else userOnLog(level, log$4, viteLog);
	else if (userOnWarn) normalizeUserOnWarn(userOnWarn, viteLog)(level, log$4);
	else viteLog(level, log$4);
}
function normalizeUserOnWarn(userOnWarn, defaultHandler) {
	return (logLevel, logging) => {
		if (logLevel === "warn") userOnWarn(normalizeLog(logging), (log$4) => defaultHandler("warn", typeof log$4 === "function" ? log$4() : log$4));
		else defaultHandler(logLevel, logging);
	};
}
const normalizeLog = (log$4) => typeof log$4 === "string" ? { message: log$4 } : log$4;
function resolveUserExternal(user, id, parentId, isResolved) {
	if (typeof user === "function") return user(id, parentId, isResolved);
	else if (Array.isArray(user)) return user.some((test) => isExternal(id, test));
	else return isExternal(id, user);
}
function isExternal(id, test) {
	if (typeof test === "string") return id === test;
	else return test.test(id);
}
function injectEnvironmentToHooks(environment, plugin) {
	const { resolveId, load: load$3, transform: transform$2 } = plugin;
	const clone$1 = { ...plugin };
	for (const hook of Object.keys(clone$1)) switch (hook) {
		case "resolveId":
			clone$1[hook] = wrapEnvironmentResolveId(environment, resolveId, plugin.name);
			break;
		case "load":
			clone$1[hook] = wrapEnvironmentLoad(environment, load$3, plugin.name);
			break;
		case "transform":
			clone$1[hook] = wrapEnvironmentTransform(environment, transform$2, plugin.name);
			break;
		default:
			if (ROLLUP_HOOKS.includes(hook)) clone$1[hook] = wrapEnvironmentHook(environment, clone$1[hook]);
			break;
	}
	return clone$1;
}
function wrapEnvironmentResolveId(environment, hook, pluginName) {
	if (!hook) return;
	const fn = getHookHandler(hook);
	const handler = function(id, importer, options$1) {
		return fn.call(injectEnvironmentInContext(this, environment), id, importer, injectSsrFlag(options$1, environment, pluginName));
	};
	if ("handler" in hook) return {
		...hook,
		handler
	};
	else return handler;
}
function wrapEnvironmentLoad(environment, hook, pluginName) {
	if (!hook) return;
	const fn = getHookHandler(hook);
	const handler = function(id, ...args) {
		return fn.call(injectEnvironmentInContext(this, environment), id, injectSsrFlag(args[0], environment, pluginName));
	};
	if ("handler" in hook) return {
		...hook,
		handler
	};
	else return handler;
}
function wrapEnvironmentTransform(environment, hook, pluginName) {
	if (!hook) return;
	const fn = getHookHandler(hook);
	const handler = function(code, importer, ...args) {
		return fn.call(injectEnvironmentInContext(this, environment), code, importer, injectSsrFlag(args[0], environment, pluginName));
	};
	if ("handler" in hook) return {
		...hook,
		handler
	};
	else return handler;
}
function wrapEnvironmentHook(environment, hook) {
	if (!hook) return;
	const fn = getHookHandler(hook);
	if (typeof fn !== "function") return hook;
	const handler = function(...args) {
		return fn.call(injectEnvironmentInContext(this, environment), ...args);
	};
	if ("handler" in hook) return {
		...hook,
		handler
	};
	else return handler;
}
function injectEnvironmentInContext(context, environment) {
	context.meta.viteVersion ??= VERSION;
	context.environment ??= environment;
	return context;
}
function injectSsrFlag(options$1, environment, pluginName) {
	let ssr = environment.config.consumer === "server";
	const newOptions = {
		...options$1 ?? {},
		ssr
	};
	if (isFutureDeprecationEnabled(environment?.getTopLevelConfig(), "removePluginHookSsrArgument")) Object.defineProperty(newOptions, "ssr", {
		get() {
			warnFutureDeprecation(environment?.getTopLevelConfig(), "removePluginHookSsrArgument", `Used in plugin "${pluginName}".`);
			return ssr;
		},
		set(v) {
			ssr = v;
		}
	});
	return newOptions;
}
const needsEscapeRegEx = /[\n\r'\\\u2028\u2029]/;
const quoteNewlineRegEx = /([\n\r'\u2028\u2029])/g;
const backSlashRegEx = /\\/g;
function escapeId(id) {
	if (!needsEscapeRegEx.test(id)) return id;
	return id.replace(backSlashRegEx, "\\\\").replace(quoteNewlineRegEx, "\\$1");
}
const getResolveUrl = (path$13, URL$4 = "URL") => `new ${URL$4}(${path$13}).href`;
const getRelativeUrlFromDocument = (relativePath, umd = false) => getResolveUrl(`'${escapeId(partialEncodeURIPath(relativePath))}', ${umd ? `typeof document === 'undefined' ? location.href : ` : ""}document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT' && document.currentScript.src || document.baseURI`);
const getFileUrlFromFullPath = (path$13) => `require('u' + 'rl').pathToFileURL(${path$13}).href`;
const getFileUrlFromRelativePath = (path$13) => getFileUrlFromFullPath(`__dirname + '/${escapeId(path$13)}'`);
const customRelativeUrlMechanisms = {
	amd: (relativePath) => {
		if (relativePath[0] !== ".") relativePath = "./" + relativePath;
		return getResolveUrl(`require.toUrl('${escapeId(relativePath)}'), document.baseURI`);
	},
	cjs: (relativePath) => `(typeof document === 'undefined' ? ${getFileUrlFromRelativePath(relativePath)} : ${getRelativeUrlFromDocument(relativePath)})`,
	es: (relativePath) => getResolveUrl(`'${escapeId(partialEncodeURIPath(relativePath))}', import.meta.url`),
	iife: (relativePath) => getRelativeUrlFromDocument(relativePath),
	system: (relativePath) => getResolveUrl(`'${escapeId(partialEncodeURIPath(relativePath))}', module.meta.url`),
	umd: (relativePath) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getFileUrlFromRelativePath(relativePath)} : ${getRelativeUrlFromDocument(relativePath, true)})`,
	"worker-iife": (relativePath) => getResolveUrl(`'${escapeId(partialEncodeURIPath(relativePath))}', self.location.href`)
};
function toOutputFilePathInJS(environment, filename, type, hostId, hostType, toRelative) {
	const { experimental, base, decodedBase } = environment.config;
	const ssr = environment.config.consumer === "server";
	const { renderBuiltUrl } = experimental;
	let relative$3 = base === "" || base === "./";
	if (renderBuiltUrl) {
		const result = renderBuiltUrl(filename, {
			hostId,
			hostType,
			type,
			ssr
		});
		if (typeof result === "object") {
			if (result.runtime) return { runtime: result.runtime };
			if (typeof result.relative === "boolean") relative$3 = result.relative;
		} else if (result) return result;
	}
	if (relative$3 && !ssr) return toRelative(filename, hostId);
	return joinUrlSegments(decodedBase, filename);
}
function createToImportMetaURLBasedRelativeRuntime(format$3, isWorker) {
	const toRelativePath$1 = customRelativeUrlMechanisms[isWorker && format$3 === "iife" ? "worker-iife" : format$3];
	return (filename, importer) => ({ runtime: toRelativePath$1(path.posix.relative(path.dirname(importer), filename)) });
}
function toOutputFilePathWithoutRuntime(filename, type, hostId, hostType, config$2, toRelative) {
	const { renderBuiltUrl } = config$2.experimental;
	let relative$3 = config$2.base === "" || config$2.base === "./";
	if (renderBuiltUrl) {
		const result = renderBuiltUrl(filename, {
			hostId,
			hostType,
			type,
			ssr: !!config$2.build.ssr
		});
		if (typeof result === "object") {
			if (result.runtime) throw new Error(`{ runtime: "${result.runtime}" } is not supported for assets in ${hostType} files: ${filename}`);
			if (typeof result.relative === "boolean") relative$3 = result.relative;
		} else if (result) return result;
	}
	if (relative$3 && !config$2.build.ssr) return toRelative(filename, hostId);
	else return joinUrlSegments(config$2.decodedBase, filename);
}
const toOutputFilePathInCss = toOutputFilePathWithoutRuntime;
const toOutputFilePathInHtml = toOutputFilePathWithoutRuntime;
var BuildEnvironment = class extends BaseEnvironment {
	mode = "build";
	isBuilt = false;
	constructor(name, config$2, setup$1) {
		let options$1 = config$2.environments[name];
		if (!options$1) throw new Error(`Environment "${name}" is not defined in the config.`);
		if (setup$1?.options) options$1 = mergeConfig(options$1, setup$1.options);
		super(name, config$2, options$1);
	}
	async init() {
		if (this._initiated) return;
		this._initiated = true;
	}
};
const builderOptionsDefaults = Object.freeze({
	sharedConfigBuild: false,
	sharedPlugins: false
});
function resolveBuilderOptions(options$1) {
	if (!options$1) return;
	return mergeWithDefaults({
		...builderOptionsDefaults,
		buildApp: async () => {}
	}, options$1);
}
/**
* Creates a ViteBuilder to orchestrate building multiple environments.
* @experimental
*/
async function createBuilder(inlineConfig = {}, useLegacyBuilder = false) {
	const patchConfig = (resolved) => {
		if (!(useLegacyBuilder ?? !resolved.builder)) return;
		resolved.build = { ...resolved.environments[resolved.build.ssr ? "ssr" : "client"].build };
	};
	const config$2 = await resolveConfigToBuild(inlineConfig, patchConfig);
	useLegacyBuilder ??= !config$2.builder;
	const configBuilder = config$2.builder ?? resolveBuilderOptions({});
	const environments = {};
	const builder = {
		environments,
		config: config$2,
		async buildApp() {
			const pluginContext = new BasicMinimalPluginContext({
				...basePluginContextMeta,
				watchMode: false
			}, config$2.logger);
			let configBuilderBuildAppCalled = false;
			for (const p of config$2.getSortedPlugins("buildApp")) {
				const hook = p.buildApp;
				if (!configBuilderBuildAppCalled && typeof hook === "object" && hook.order === "post") {
					configBuilderBuildAppCalled = true;
					await configBuilder.buildApp(builder);
				}
				await getHookHandler(hook).call(pluginContext, builder);
			}
			if (!configBuilderBuildAppCalled) await configBuilder.buildApp(builder);
			if (Object.values(builder.environments).every((environment) => !environment.isBuilt)) for (const environment of Object.values(builder.environments)) await builder.build(environment);
		},
		async build(environment) {
			const output = await buildEnvironment(environment);
			environment.isBuilt = true;
			return output;
		}
	};
	async function setupEnvironment(name, config$3) {
		const environment = await config$3.build.createEnvironment(name, config$3);
		await environment.init();
		environments[name] = environment;
	}
	if (useLegacyBuilder) await setupEnvironment(config$2.build.ssr ? "ssr" : "client", config$2);
	else for (const environmentName of Object.keys(config$2.environments)) {
		let environmentConfig = config$2;
		if (!configBuilder.sharedConfigBuild) {
			const patchConfig$1 = (resolved) => {
				resolved.build = { ...resolved.environments[environmentName].build };
			};
			const patchPlugins = (resolvedPlugins) => {
				let j = 0;
				for (let i$1 = 0; i$1 < resolvedPlugins.length; i$1++) {
					const environmentPlugin = resolvedPlugins[i$1];
					if (configBuilder.sharedPlugins || environmentPlugin.sharedDuringBuild) {
						for (let k = j; k < config$2.plugins.length; k++) if (environmentPlugin.name === config$2.plugins[k].name) {
							resolvedPlugins[i$1] = config$2.plugins[k];
							j = k + 1;
							break;
						}
					}
				}
			};
			environmentConfig = await resolveConfigToBuild(inlineConfig, patchConfig$1, patchPlugins);
		}
		await setupEnvironment(environmentName, environmentConfig);
	}
	return builder;
}

//#endregion
//#region src/node/ssr/fetchModule.ts
/**
* Fetch module information for Vite runner.
* @experimental
*/
async function fetchModule(environment, url$3, importer, options$1 = {}) {
	if (url$3.startsWith("data:") || isBuiltin(environment.config.resolve.builtins, url$3)) return {
		externalize: url$3,
		type: "builtin"
	};
	const isFileUrl$1 = url$3.startsWith("file://");
	if (isExternalUrl(url$3) && !isFileUrl$1) return {
		externalize: url$3,
		type: "network"
	};
	if (!isFileUrl$1 && importer && url$3[0] !== "." && url$3[0] !== "/") {
		const { isProduction, root } = environment.config;
		const { externalConditions, dedupe, preserveSymlinks } = environment.config.resolve;
		const resolved = tryNodeResolve(url$3, importer, {
			mainFields: ["main"],
			conditions: externalConditions,
			externalConditions,
			external: [],
			noExternal: [],
			extensions: [
				".js",
				".cjs",
				".json"
			],
			dedupe,
			preserveSymlinks,
			isBuild: false,
			isProduction,
			root,
			packageCache: environment.config.packageCache,
			builtins: environment.config.resolve.builtins
		});
		if (!resolved) {
			const err$2 = /* @__PURE__ */ new Error(`Cannot find module '${url$3}' imported from '${importer}'`);
			err$2.code = "ERR_MODULE_NOT_FOUND";
			throw err$2;
		}
		return {
			externalize: pathToFileURL(resolved.id).toString(),
			type: isFilePathESM(resolved.id, environment.config.packageCache) ? "module" : "commonjs"
		};
	}
	url$3 = unwrapId(url$3);
	const mod = await environment.moduleGraph.ensureEntryFromUrl(url$3);
	const cached = !!mod.transformResult;
	if (options$1.cached && cached) return { cache: true };
	let result = await environment.transformRequest(url$3);
	if (!result) throw new Error(`[vite] transform failed for module '${url$3}'${importer ? ` imported from '${importer}'` : ""}.`);
	if (options$1.inlineSourceMap !== false) result = inlineSourceMap(mod, result, options$1.startOffset);
	if (result.code[0] === "#") result.code = result.code.replace(/^#!.*/, (s$2) => " ".repeat(s$2.length));
	return {
		code: result.code,
		file: mod.file,
		id: mod.id,
		url: mod.url,
		invalidate: !cached
	};
}
const OTHER_SOURCE_MAP_REGEXP = new RegExp(`//# ${SOURCEMAPPING_URL}=data:application/json[^,]+base64,([A-Za-z0-9+/=]+)$`, "gm");
function inlineSourceMap(mod, result, startOffset) {
	const map$1 = result.map;
	let code = result.code;
	if (!map$1 || !("version" in map$1) || code.includes(MODULE_RUNNER_SOURCEMAPPING_SOURCE)) return result;
	OTHER_SOURCE_MAP_REGEXP.lastIndex = 0;
	if (OTHER_SOURCE_MAP_REGEXP.test(code)) code = code.replace(OTHER_SOURCE_MAP_REGEXP, "");
	const sourceMap = startOffset ? Object.assign({}, map$1, { mappings: ";".repeat(startOffset) + map$1.mappings }) : map$1;
	result.code = `${code.trimEnd()}\n//# sourceURL=${mod.id}\n${MODULE_RUNNER_SOURCEMAPPING_SOURCE}\n//# ${SOURCEMAPPING_URL}=${genSourceMapUrl(sourceMap)}\n`;
	return result;
}

//#endregion
//#region src/node/optimizer/optimizer.ts
var import_picocolors$3 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const debug$1 = createDebugger("vite:deps");
/**
* The amount to wait for requests to register newly found dependencies before triggering
* a re-bundle + page reload
*/
const debounceMs = 100;
function createDepsOptimizer(environment) {
	const { logger } = environment;
	const sessionTimestamp = Date.now().toString();
	let debounceProcessingHandle;
	let closed = false;
	const options$1 = environment.config.optimizeDeps;
	const { noDiscovery, holdUntilCrawlEnd } = options$1;
	let metadata = initDepsOptimizerMetadata(environment, sessionTimestamp);
	const depsOptimizer = {
		init: init$3,
		metadata,
		registerMissingImport,
		run: () => debouncedProcessing(0),
		isOptimizedDepFile: createIsOptimizedDepFile(environment),
		isOptimizedDepUrl: createIsOptimizedDepUrl(environment),
		getOptimizedDepId: (depInfo) => `${depInfo.file}?v=${depInfo.browserHash}`,
		close: close$1,
		options: options$1
	};
	let newDepsDiscovered = false;
	let newDepsToLog = [];
	let newDepsToLogHandle;
	const logNewlyDiscoveredDeps = () => {
		if (newDepsToLog.length) {
			logger.info(import_picocolors$3.default.green(`✨ new dependencies optimized: ${depsLogString(newDepsToLog)}`), { timestamp: true });
			newDepsToLog = [];
		}
	};
	let discoveredDepsWhileScanning = [];
	const logDiscoveredDepsWhileScanning = () => {
		if (discoveredDepsWhileScanning.length) {
			logger.info(import_picocolors$3.default.green(`✨ discovered while scanning: ${depsLogString(discoveredDepsWhileScanning)}`), { timestamp: true });
			discoveredDepsWhileScanning = [];
		}
	};
	let depOptimizationProcessing = promiseWithResolvers();
	let depOptimizationProcessingQueue = [];
	const resolveEnqueuedProcessingPromises = () => {
		for (const processing of depOptimizationProcessingQueue) processing.resolve();
		depOptimizationProcessingQueue = [];
	};
	let enqueuedRerun;
	let currentlyProcessing = false;
	let firstRunCalled = false;
	let warnAboutMissedDependencies = false;
	let waitingForCrawlEnd = false;
	let optimizationResult;
	let discover;
	async function close$1() {
		closed = true;
		await Promise.allSettled([
			discover?.cancel(),
			depsOptimizer.scanProcessing,
			optimizationResult?.cancel()
		]);
	}
	let inited = false;
	async function init$3() {
		if (inited) return;
		inited = true;
		const cachedMetadata = await loadCachedDepOptimizationMetadata(environment);
		firstRunCalled = !!cachedMetadata;
		metadata = depsOptimizer.metadata = cachedMetadata || initDepsOptimizerMetadata(environment, sessionTimestamp);
		if (!cachedMetadata) {
			waitingForCrawlEnd = true;
			currentlyProcessing = true;
			const manuallyIncludedDeps = {};
			await addManuallyIncludedOptimizeDeps(environment, manuallyIncludedDeps);
			const manuallyIncludedDepsInfo = toDiscoveredDependencies(environment, manuallyIncludedDeps, sessionTimestamp);
			for (const depInfo of Object.values(manuallyIncludedDepsInfo)) {
				addOptimizedDepInfo(metadata, "discovered", {
					...depInfo,
					processing: depOptimizationProcessing.promise
				});
				newDepsDiscovered = true;
			}
			environment.waitForRequestsIdle().then(onCrawlEnd);
			if (noDiscovery) runOptimizer();
			else depsOptimizer.scanProcessing = new Promise((resolve$4) => {
				(async () => {
					try {
						debug$1?.(import_picocolors$3.default.green(`scanning for dependencies...`));
						let deps;
						try {
							discover = discoverProjectDependencies(devToScanEnvironment(environment));
							deps = await discover.result;
							discover = void 0;
						} catch (e$1) {
							environment.logger.error(import_picocolors$3.default.red("(!) Failed to run dependency scan. Skipping dependency pre-bundling. " + e$1.stack));
							return;
						}
						const manuallyIncluded = Object.keys(manuallyIncludedDepsInfo);
						discoveredDepsWhileScanning.push(...Object.keys(metadata.discovered).filter((dep) => !deps[dep] && !manuallyIncluded.includes(dep)));
						for (const id of Object.keys(deps)) if (!metadata.discovered[id]) addMissingDep(id, deps[id]);
						const knownDeps = prepareKnownDeps();
						startNextDiscoveredBatch();
						optimizationResult = runOptimizeDeps(environment, knownDeps);
						if (!holdUntilCrawlEnd) optimizationResult.result.then((result) => {
							if (!waitingForCrawlEnd) return;
							optimizationResult = void 0;
							runOptimizer(result);
						});
					} catch (e$1) {
						logger.error(e$1.stack || e$1.message);
					} finally {
						resolve$4();
						depsOptimizer.scanProcessing = void 0;
					}
				})();
			});
		}
	}
	function startNextDiscoveredBatch() {
		newDepsDiscovered = false;
		depOptimizationProcessingQueue.push(depOptimizationProcessing);
		depOptimizationProcessing = promiseWithResolvers();
	}
	function prepareKnownDeps() {
		const knownDeps = {};
		const metadata$1 = depsOptimizer.metadata;
		for (const dep of Object.keys(metadata$1.optimized)) knownDeps[dep] = { ...metadata$1.optimized[dep] };
		for (const dep of Object.keys(metadata$1.discovered)) {
			const { processing,...info } = metadata$1.discovered[dep];
			knownDeps[dep] = info;
		}
		return knownDeps;
	}
	async function runOptimizer(preRunResult) {
		const isRerun = firstRunCalled;
		firstRunCalled = true;
		enqueuedRerun = void 0;
		if (debounceProcessingHandle) clearTimeout(debounceProcessingHandle);
		if (closed) {
			currentlyProcessing = false;
			depOptimizationProcessing.resolve();
			resolveEnqueuedProcessingPromises();
			return;
		}
		currentlyProcessing = true;
		try {
			let processingResult;
			if (preRunResult) processingResult = preRunResult;
			else {
				const knownDeps = prepareKnownDeps();
				startNextDiscoveredBatch();
				optimizationResult = runOptimizeDeps(environment, knownDeps);
				processingResult = await optimizationResult.result;
				optimizationResult = void 0;
			}
			if (closed) {
				currentlyProcessing = false;
				processingResult.cancel();
				resolveEnqueuedProcessingPromises();
				return;
			}
			const newData = processingResult.metadata;
			const needsInteropMismatch = findInteropMismatches(metadata.discovered, newData.optimized);
			const needsReload = needsInteropMismatch.length > 0 || metadata.hash !== newData.hash || Object.keys(metadata.optimized).some((dep) => {
				return metadata.optimized[dep].fileHash !== newData.optimized[dep].fileHash;
			});
			const commitProcessing = async () => {
				await processingResult.commit();
				for (const id in metadata.discovered) if (!newData.optimized[id]) addOptimizedDepInfo(newData, "discovered", metadata.discovered[id]);
				if (!needsReload) {
					newData.browserHash = metadata.browserHash;
					for (const dep in newData.chunks) newData.chunks[dep].browserHash = metadata.browserHash;
					for (const dep in newData.optimized) newData.optimized[dep].browserHash = (metadata.optimized[dep] || metadata.discovered[dep]).browserHash;
				}
				for (const o$1 in newData.optimized) {
					const discovered = metadata.discovered[o$1];
					if (discovered) {
						const optimized = newData.optimized[o$1];
						discovered.browserHash = optimized.browserHash;
						discovered.fileHash = optimized.fileHash;
						discovered.needsInterop = optimized.needsInterop;
						discovered.processing = void 0;
					}
				}
				if (isRerun) newDepsToLog.push(...Object.keys(newData.optimized).filter((dep) => !metadata.optimized[dep]));
				metadata = depsOptimizer.metadata = newData;
				resolveEnqueuedProcessingPromises();
			};
			if (!needsReload) {
				await commitProcessing();
				if (!debug$1) {
					if (newDepsToLogHandle) clearTimeout(newDepsToLogHandle);
					newDepsToLogHandle = setTimeout(() => {
						newDepsToLogHandle = void 0;
						logNewlyDiscoveredDeps();
						if (warnAboutMissedDependencies) {
							logDiscoveredDepsWhileScanning();
							logger.info(import_picocolors$3.default.magenta(`❗ add these dependencies to optimizeDeps.include to speed up cold start`), { timestamp: true });
							warnAboutMissedDependencies = false;
						}
					}, 2 * debounceMs);
				} else debug$1(import_picocolors$3.default.green(`✨ ${!isRerun ? `dependencies optimized` : `optimized dependencies unchanged`}`));
			} else if (newDepsDiscovered) {
				processingResult.cancel();
				debug$1?.(import_picocolors$3.default.green(`✨ delaying reload as new dependencies have been found...`));
			} else {
				await commitProcessing();
				if (!debug$1) {
					if (newDepsToLogHandle) clearTimeout(newDepsToLogHandle);
					newDepsToLogHandle = void 0;
					logNewlyDiscoveredDeps();
					if (warnAboutMissedDependencies) {
						logDiscoveredDepsWhileScanning();
						logger.info(import_picocolors$3.default.magenta(`❗ add these dependencies to optimizeDeps.include to avoid a full page reload during cold start`), { timestamp: true });
						warnAboutMissedDependencies = false;
					}
				}
				logger.info(import_picocolors$3.default.green(`✨ optimized dependencies changed. reloading`), { timestamp: true });
				if (needsInteropMismatch.length > 0) logger.warn(`Mixed ESM and CJS detected in ${import_picocolors$3.default.yellow(needsInteropMismatch.join(", "))}, add ${needsInteropMismatch.length === 1 ? "it" : "them"} to optimizeDeps.needsInterop to speed up cold start`, { timestamp: true });
				fullReload();
			}
		} catch (e$1) {
			logger.error(import_picocolors$3.default.red(`error while updating dependencies:\n${e$1.stack}`), {
				timestamp: true,
				error: e$1
			});
			resolveEnqueuedProcessingPromises();
			metadata.discovered = {};
		}
		currentlyProcessing = false;
		enqueuedRerun?.();
	}
	function fullReload() {
		environment.moduleGraph.invalidateAll();
		environment.hot.send({
			type: "full-reload",
			path: "*"
		});
	}
	async function rerun() {
		const depsString = depsLogString(Object.keys(metadata.discovered));
		debug$1?.(import_picocolors$3.default.green(`new dependencies found: ${depsString}`));
		runOptimizer();
	}
	function getDiscoveredBrowserHash(hash$1, deps, missing) {
		return getHash(hash$1 + JSON.stringify(deps) + JSON.stringify(missing) + sessionTimestamp);
	}
	function registerMissingImport(id, resolved) {
		const optimized = metadata.optimized[id];
		if (optimized) return optimized;
		const chunk = metadata.chunks[id];
		if (chunk) return chunk;
		let missing = metadata.discovered[id];
		if (missing) return missing;
		missing = addMissingDep(id, resolved);
		if (!waitingForCrawlEnd) debouncedProcessing();
		return missing;
	}
	function addMissingDep(id, resolved) {
		newDepsDiscovered = true;
		return addOptimizedDepInfo(metadata, "discovered", {
			id,
			file: getOptimizedDepPath(environment, id),
			src: resolved,
			browserHash: getDiscoveredBrowserHash(metadata.hash, depsFromOptimizedDepInfo(metadata.optimized), depsFromOptimizedDepInfo(metadata.discovered)),
			processing: depOptimizationProcessing.promise,
			exportsData: extractExportsData(environment, resolved)
		});
	}
	function debouncedProcessing(timeout$1 = debounceMs) {
		enqueuedRerun = void 0;
		if (debounceProcessingHandle) clearTimeout(debounceProcessingHandle);
		if (newDepsToLogHandle) clearTimeout(newDepsToLogHandle);
		newDepsToLogHandle = void 0;
		debounceProcessingHandle = setTimeout(() => {
			debounceProcessingHandle = void 0;
			enqueuedRerun = rerun;
			if (!currentlyProcessing) enqueuedRerun();
		}, timeout$1);
	}
	async function onCrawlEnd() {
		waitingForCrawlEnd = false;
		debug$1?.(import_picocolors$3.default.green(`✨ static imports crawl ended`));
		if (closed) return;
		await depsOptimizer.scanProcessing;
		if (optimizationResult && !options$1.noDiscovery) {
			const afterScanResult = optimizationResult.result;
			optimizationResult = void 0;
			const result = await afterScanResult;
			currentlyProcessing = false;
			const crawlDeps = Object.keys(metadata.discovered);
			const scanDeps = Object.keys(result.metadata.optimized);
			if (scanDeps.length === 0 && crawlDeps.length === 0) {
				debug$1?.(import_picocolors$3.default.green(`✨ no dependencies found by the scanner or crawling static imports`));
				startNextDiscoveredBatch();
				runOptimizer(result);
				return;
			}
			const needsInteropMismatch = findInteropMismatches(metadata.discovered, result.metadata.optimized);
			const scannerMissedDeps = crawlDeps.some((dep) => !scanDeps.includes(dep));
			if (needsInteropMismatch.length > 0 || scannerMissedDeps) {
				result.cancel();
				for (const dep of scanDeps) if (!crawlDeps.includes(dep)) addMissingDep(dep, result.metadata.optimized[dep].src);
				if (scannerMissedDeps) debug$1?.(import_picocolors$3.default.yellow(`✨ new dependencies were found while crawling that weren't detected by the scanner`));
				debug$1?.(import_picocolors$3.default.green(`✨ re-running optimizer`));
				debouncedProcessing(0);
			} else {
				debug$1?.(import_picocolors$3.default.green(`✨ using post-scan optimizer result, the scanner found every used dependency`));
				startNextDiscoveredBatch();
				runOptimizer(result);
			}
		} else if (!holdUntilCrawlEnd) {
			if (newDepsDiscovered) {
				debug$1?.(import_picocolors$3.default.green(`✨ new dependencies were found while crawling static imports, re-running optimizer`));
				warnAboutMissedDependencies = true;
				debouncedProcessing(0);
			}
		} else {
			const crawlDeps = Object.keys(metadata.discovered);
			currentlyProcessing = false;
			if (crawlDeps.length === 0) {
				debug$1?.(import_picocolors$3.default.green(`✨ no dependencies found while crawling the static imports`));
				firstRunCalled = true;
			}
			debouncedProcessing(0);
		}
	}
	return depsOptimizer;
}
function createExplicitDepsOptimizer(environment) {
	const depsOptimizer = {
		metadata: initDepsOptimizerMetadata(environment),
		isOptimizedDepFile: createIsOptimizedDepFile(environment),
		isOptimizedDepUrl: createIsOptimizedDepUrl(environment),
		getOptimizedDepId: (depInfo) => `${depInfo.file}?v=${depInfo.browserHash}`,
		registerMissingImport: () => {
			throw new Error(`Vite Internal Error: registerMissingImport is not supported in dev ${environment.name}`);
		},
		init: init$3,
		run: () => {},
		close: async () => {},
		options: environment.config.optimizeDeps
	};
	let inited = false;
	async function init$3() {
		if (inited) return;
		inited = true;
		depsOptimizer.metadata = await optimizeExplicitEnvironmentDeps(environment);
	}
	return depsOptimizer;
}
function findInteropMismatches(discovered, optimized) {
	const needsInteropMismatch = [];
	for (const dep in discovered) {
		const discoveredDepInfo = discovered[dep];
		if (discoveredDepInfo.needsInterop === void 0) continue;
		const depInfo = optimized[dep];
		if (!depInfo) continue;
		if (depInfo.needsInterop !== discoveredDepInfo.needsInterop) {
			needsInteropMismatch.push(dep);
			debug$1?.(import_picocolors$3.default.cyan(`✨ needsInterop mismatch detected for ${dep}`));
		}
	}
	return needsInteropMismatch;
}

//#endregion
//#region src/node/server/moduleGraph.ts
var EnvironmentModuleNode = class {
	environment;
	/**
	* Public served url path, starts with /
	*/
	url;
	/**
	* Resolved file system path + query
	*/
	id = null;
	file = null;
	type;
	info;
	meta;
	importers = /* @__PURE__ */ new Set();
	importedModules = /* @__PURE__ */ new Set();
	acceptedHmrDeps = /* @__PURE__ */ new Set();
	acceptedHmrExports = null;
	importedBindings = null;
	isSelfAccepting;
	transformResult = null;
	ssrModule = null;
	ssrError = null;
	lastHMRTimestamp = 0;
	/**
	* `import.meta.hot.invalidate` is called by the client.
	* If there's multiple clients, multiple `invalidate` request is received.
	* This property is used to dedupe those request to avoid multiple updates happening.
	* @internal
	*/
	lastHMRInvalidationReceived = false;
	lastInvalidationTimestamp = 0;
	/**
	* If the module only needs to update its imports timestamp (e.g. within an HMR chain),
	* it is considered soft-invalidated. In this state, its `transformResult` should exist,
	* and the next `transformRequest` for this module will replace the timestamps.
	*
	* By default the value is `undefined` if it's not soft/hard-invalidated. If it gets
	* soft-invalidated, this will contain the previous `transformResult` value. If it gets
	* hard-invalidated, this will be set to `'HARD_INVALIDATED'`.
	* @internal
	*/
	invalidationState;
	/**
	* The module urls that are statically imported in the code. This information is separated
	* out from `importedModules` as only importers that statically import the module can be
	* soft invalidated. Other imports (e.g. watched files) needs the importer to be hard invalidated.
	* @internal
	*/
	staticImportedUrls;
	/**
	* @param setIsSelfAccepting - set `false` to set `isSelfAccepting` later. e.g. #7870
	*/
	constructor(url$3, environment, setIsSelfAccepting = true) {
		this.environment = environment;
		this.url = url$3;
		this.type = isDirectCSSRequest(url$3) ? "css" : "js";
		if (setIsSelfAccepting) this.isSelfAccepting = false;
	}
};
var EnvironmentModuleGraph = class {
	environment;
	urlToModuleMap = /* @__PURE__ */ new Map();
	idToModuleMap = /* @__PURE__ */ new Map();
	etagToModuleMap = /* @__PURE__ */ new Map();
	fileToModulesMap = /* @__PURE__ */ new Map();
	/**
	* @internal
	*/
	_unresolvedUrlToModuleMap = /* @__PURE__ */ new Map();
	/**
	* @internal
	*/
	_resolveId;
	/** @internal */
	_hasResolveFailedErrorModules = /* @__PURE__ */ new Set();
	constructor(environment, resolveId) {
		this.environment = environment;
		this._resolveId = resolveId;
	}
	async getModuleByUrl(rawUrl) {
		rawUrl = removeImportQuery(removeTimestampQuery(rawUrl));
		const mod = this._getUnresolvedUrlToModule(rawUrl);
		if (mod) return mod;
		const [url$3] = await this._resolveUrl(rawUrl);
		return this.urlToModuleMap.get(url$3);
	}
	getModuleById(id) {
		return this.idToModuleMap.get(removeTimestampQuery(id));
	}
	getModulesByFile(file) {
		return this.fileToModulesMap.get(file);
	}
	onFileChange(file) {
		const mods = this.getModulesByFile(file);
		if (mods) {
			const seen$1 = /* @__PURE__ */ new Set();
			mods.forEach((mod) => {
				this.invalidateModule(mod, seen$1);
			});
		}
	}
	onFileDelete(file) {
		const mods = this.getModulesByFile(file);
		if (mods) mods.forEach((mod) => {
			mod.importedModules.forEach((importedMod) => {
				importedMod.importers.delete(mod);
			});
		});
	}
	invalidateModule(mod, seen$1 = /* @__PURE__ */ new Set(), timestamp = monotonicDateNow(), isHmr = false, softInvalidate = false) {
		const prevInvalidationState = mod.invalidationState;
		if (softInvalidate) mod.invalidationState ??= mod.transformResult ?? "HARD_INVALIDATED";
		else mod.invalidationState = "HARD_INVALIDATED";
		if (seen$1.has(mod) && prevInvalidationState === mod.invalidationState) return;
		seen$1.add(mod);
		if (isHmr) {
			mod.lastHMRTimestamp = timestamp;
			mod.lastHMRInvalidationReceived = false;
		} else mod.lastInvalidationTimestamp = timestamp;
		const etag$1 = mod.transformResult?.etag;
		if (etag$1) this.etagToModuleMap.delete(etag$1);
		mod.transformResult = null;
		mod.ssrModule = null;
		mod.ssrError = null;
		mod.importers.forEach((importer) => {
			if (!importer.acceptedHmrDeps.has(mod)) {
				const shouldSoftInvalidateImporter = (importer.staticImportedUrls?.has(mod.url) || softInvalidate) && importer.type === "js";
				this.invalidateModule(importer, seen$1, timestamp, isHmr, shouldSoftInvalidateImporter);
			}
		});
		this._hasResolveFailedErrorModules.delete(mod);
	}
	invalidateAll() {
		const timestamp = monotonicDateNow();
		const seen$1 = /* @__PURE__ */ new Set();
		this.idToModuleMap.forEach((mod) => {
			this.invalidateModule(mod, seen$1, timestamp);
		});
	}
	/**
	* Update the module graph based on a module's updated imports information
	* If there are dependencies that no longer have any importers, they are
	* returned as a Set.
	*
	* @param staticImportedUrls Subset of `importedModules` where they're statically imported in code.
	*   This is only used for soft invalidations so `undefined` is fine but may cause more runtime processing.
	*/
	async updateModuleInfo(mod, importedModules, importedBindings, acceptedModules, acceptedExports, isSelfAccepting, staticImportedUrls) {
		mod.isSelfAccepting = isSelfAccepting;
		const prevImports = mod.importedModules;
		let noLongerImported;
		let resolvePromises = [];
		let resolveResults = new Array(importedModules.size);
		let index = 0;
		for (const imported of importedModules) {
			const nextIndex = index++;
			if (typeof imported === "string") resolvePromises.push(this.ensureEntryFromUrl(imported).then((dep) => {
				dep.importers.add(mod);
				resolveResults[nextIndex] = dep;
			}));
			else {
				imported.importers.add(mod);
				resolveResults[nextIndex] = imported;
			}
		}
		if (resolvePromises.length) await Promise.all(resolvePromises);
		mod.importedModules = new Set(resolveResults);
		prevImports.forEach((dep) => {
			if (!mod.importedModules.has(dep)) {
				dep.importers.delete(mod);
				if (!dep.importers.size) (noLongerImported || (noLongerImported = /* @__PURE__ */ new Set())).add(dep);
			}
		});
		resolvePromises = [];
		resolveResults = new Array(acceptedModules.size);
		index = 0;
		for (const accepted of acceptedModules) {
			const nextIndex = index++;
			if (typeof accepted === "string") resolvePromises.push(this.ensureEntryFromUrl(accepted).then((dep) => {
				resolveResults[nextIndex] = dep;
			}));
			else resolveResults[nextIndex] = accepted;
		}
		if (resolvePromises.length) await Promise.all(resolvePromises);
		mod.acceptedHmrDeps = new Set(resolveResults);
		mod.staticImportedUrls = staticImportedUrls;
		mod.acceptedHmrExports = acceptedExports;
		mod.importedBindings = importedBindings;
		return noLongerImported;
	}
	async ensureEntryFromUrl(rawUrl, setIsSelfAccepting = true) {
		return this._ensureEntryFromUrl(rawUrl, setIsSelfAccepting);
	}
	/**
	* @internal
	*/
	async _ensureEntryFromUrl(rawUrl, setIsSelfAccepting = true, resolved) {
		rawUrl = removeImportQuery(removeTimestampQuery(rawUrl));
		let mod = this._getUnresolvedUrlToModule(rawUrl);
		if (mod) return mod;
		const modPromise = (async () => {
			const [url$3, resolvedId, meta] = await this._resolveUrl(rawUrl, resolved);
			mod = this.idToModuleMap.get(resolvedId);
			if (!mod) {
				mod = new EnvironmentModuleNode(url$3, this.environment, setIsSelfAccepting);
				if (meta) mod.meta = meta;
				this.urlToModuleMap.set(url$3, mod);
				mod.id = resolvedId;
				this.idToModuleMap.set(resolvedId, mod);
				const file = mod.file = cleanUrl(resolvedId);
				let fileMappedModules = this.fileToModulesMap.get(file);
				if (!fileMappedModules) {
					fileMappedModules = /* @__PURE__ */ new Set();
					this.fileToModulesMap.set(file, fileMappedModules);
				}
				fileMappedModules.add(mod);
			} else if (!this.urlToModuleMap.has(url$3)) this.urlToModuleMap.set(url$3, mod);
			this._setUnresolvedUrlToModule(rawUrl, mod);
			return mod;
		})();
		this._setUnresolvedUrlToModule(rawUrl, modPromise);
		return modPromise;
	}
	createFileOnlyEntry(file) {
		file = normalizePath(file);
		let fileMappedModules = this.fileToModulesMap.get(file);
		if (!fileMappedModules) {
			fileMappedModules = /* @__PURE__ */ new Set();
			this.fileToModulesMap.set(file, fileMappedModules);
		}
		const url$3 = `${FS_PREFIX}${file}`;
		for (const m$2 of fileMappedModules) if ((m$2.url === url$3 || m$2.id === file) && m$2.type === "asset") return m$2;
		const mod = new EnvironmentModuleNode(url$3, this.environment);
		mod.type = "asset";
		mod.file = file;
		fileMappedModules.add(mod);
		return mod;
	}
	async resolveUrl(url$3) {
		url$3 = removeImportQuery(removeTimestampQuery(url$3));
		const mod = await this._getUnresolvedUrlToModule(url$3);
		if (mod?.id) return [
			mod.url,
			mod.id,
			mod.meta
		];
		return this._resolveUrl(url$3);
	}
	updateModuleTransformResult(mod, result) {
		if (this.environment === "client") {
			const prevEtag = mod.transformResult?.etag;
			if (prevEtag) this.etagToModuleMap.delete(prevEtag);
			if (result?.etag) this.etagToModuleMap.set(result.etag, mod);
		}
		mod.transformResult = result;
	}
	getModuleByEtag(etag$1) {
		return this.etagToModuleMap.get(etag$1);
	}
	/**
	* @internal
	*/
	_getUnresolvedUrlToModule(url$3) {
		return this._unresolvedUrlToModuleMap.get(url$3);
	}
	/**
	* @internal
	*/
	_setUnresolvedUrlToModule(url$3, mod) {
		this._unresolvedUrlToModuleMap.set(url$3, mod);
	}
	/**
	* @internal
	*/
	async _resolveUrl(url$3, alreadyResolved) {
		const resolved = alreadyResolved ?? await this._resolveId(url$3);
		const resolvedId = resolved?.id || url$3;
		if (url$3 !== resolvedId && !url$3.includes("\0") && !url$3.startsWith(`virtual:`)) {
			const ext = extname(cleanUrl(resolvedId));
			if (ext) {
				const pathname = cleanUrl(url$3);
				if (!pathname.endsWith(ext)) url$3 = pathname + ext + url$3.slice(pathname.length);
			}
		}
		return [
			url$3,
			resolvedId,
			resolved?.meta
		];
	}
};

//#endregion
//#region src/node/server/warmup.ts
var import_picocolors$2 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
function warmupFiles(server, environment) {
	const { root } = server.config;
	mapFiles(environment.config.dev.warmup, root).then((files) => {
		for (const file of files) warmupFile(server, environment, file);
	});
}
async function warmupFile(server, environment, file) {
	if (file.endsWith(".html")) {
		const url$3 = htmlFileToUrl(file, server.config.root);
		if (url$3) try {
			const html = await fsp.readFile(file, "utf-8");
			await server.transformIndexHtml(url$3, html);
		} catch (e$1) {
			environment.logger.error(`Pre-transform error (${import_picocolors$2.default.cyan(file)}): ${e$1.message}`, {
				error: e$1,
				timestamp: true
			});
		}
	} else {
		const url$3 = fileToUrl(file, server.config.root);
		await environment.warmupRequest(url$3);
	}
}
function htmlFileToUrl(file, root) {
	const url$3 = path.relative(root, file);
	if (url$3[0] === ".") return;
	return "/" + normalizePath(url$3);
}
function fileToUrl(file, root) {
	const url$3 = path.relative(root, file);
	if (url$3[0] === ".") return path.posix.join(FS_PREFIX, normalizePath(file));
	return "/" + normalizePath(url$3);
}
async function mapFiles(files, root) {
	if (!files.length) return [];
	const result = [];
	const globs = [];
	for (const file of files) if (isDynamicPattern(file)) globs.push(file);
	else if (path.isAbsolute(file)) result.push(file);
	else result.push(path.resolve(root, file));
	if (globs.length) result.push(...await glob(globs, {
		absolute: true,
		cwd: root,
		expandDirectories: false,
		ignore: ["**/.git/**", "**/node_modules/**"]
	}));
	return result;
}

//#endregion
//#region src/node/server/environment.ts
var import_picocolors$1 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
var DevEnvironment = class extends BaseEnvironment {
	mode = "dev";
	moduleGraph;
	depsOptimizer;
	/**
	* @internal
	*/
	_remoteRunnerOptions;
	get pluginContainer() {
		if (!this._pluginContainer) throw new Error(`${this.name} environment.pluginContainer called before initialized`);
		return this._pluginContainer;
	}
	/**
	* @internal
	*/
	_pluginContainer;
	/**
	* @internal
	*/
	_closing = false;
	/**
	* @internal
	*/
	_pendingRequests;
	/**
	* @internal
	*/
	_crawlEndFinder;
	/**
	* Hot channel for this environment. If not provided or disabled,
	* it will be a noop channel that does nothing.
	*
	* @example
	* environment.hot.send({ type: 'full-reload' })
	*/
	hot;
	constructor(name, config$2, context) {
		let options$1 = config$2.environments[name];
		if (!options$1) throw new Error(`Environment "${name}" is not defined in the config.`);
		if (context.options) options$1 = mergeConfig(options$1, context.options);
		super(name, config$2, options$1);
		this._pendingRequests = /* @__PURE__ */ new Map();
		this.moduleGraph = new EnvironmentModuleGraph(name, (url$3) => this.pluginContainer.resolveId(url$3, void 0));
		this._crawlEndFinder = setupOnCrawlEnd();
		this._remoteRunnerOptions = context.remoteRunner ?? {};
		this.hot = context.transport ? isWebSocketServer in context.transport ? context.transport : normalizeHotChannel(context.transport, context.hot) : normalizeHotChannel({}, context.hot);
		this.hot.setInvokeHandler({ fetchModule: (id, importer, options$2) => {
			return this.fetchModule(id, importer, options$2);
		} });
		this.hot.on("vite:invalidate", async ({ path: path$13, message, firstInvalidatedBy }) => {
			invalidateModule(this, {
				path: path$13,
				message,
				firstInvalidatedBy
			});
		});
		const { optimizeDeps: optimizeDeps$1 } = this.config;
		if (context.depsOptimizer) this.depsOptimizer = context.depsOptimizer;
		else if (isDepOptimizationDisabled(optimizeDeps$1)) this.depsOptimizer = void 0;
		else this.depsOptimizer = (optimizeDeps$1.noDiscovery ? createExplicitDepsOptimizer : createDepsOptimizer)(this);
	}
	async init(options$1) {
		if (this._initiated) return;
		this._initiated = true;
		this._pluginContainer = await createEnvironmentPluginContainer(this, this.config.plugins, options$1?.watcher);
	}
	/**
	* When the dev server is restarted, the methods are called in the following order:
	* - new instance `init`
	* - previous instance `close`
	* - new instance `listen`
	*/
	async listen(server) {
		this.hot.listen();
		await this.depsOptimizer?.init();
		warmupFiles(server, this);
	}
	fetchModule(id, importer, options$1) {
		return fetchModule(this, id, importer, {
			...this._remoteRunnerOptions,
			...options$1
		});
	}
	async reloadModule(module$1) {
		if (this.config.server.hmr !== false && module$1.file) updateModules(this, module$1.file, [module$1], monotonicDateNow());
	}
	transformRequest(url$3, options$1) {
		return transformRequest(this, url$3, options$1);
	}
	async warmupRequest(url$3) {
		try {
			await this.transformRequest(url$3);
		} catch (e$1) {
			if (e$1?.code === ERR_OUTDATED_OPTIMIZED_DEP || e$1?.code === ERR_CLOSED_SERVER) return;
			this.logger.error(buildErrorMessage(e$1, [`Pre-transform error: ${e$1.message}`], false), {
				error: e$1,
				timestamp: true
			});
		}
	}
	async close() {
		this._closing = true;
		this._crawlEndFinder.cancel();
		await Promise.allSettled([
			this.pluginContainer.close(),
			this.depsOptimizer?.close(),
			isWebSocketServer in this.hot ? Promise.resolve() : this.hot.close(),
			(async () => {
				while (this._pendingRequests.size > 0) await Promise.allSettled([...this._pendingRequests.values()].map((pending) => pending.request));
			})()
		]);
	}
	/**
	* Calling `await environment.waitForRequestsIdle(id)` will wait until all static imports
	* are processed after the first transformRequest call. If called from a load or transform
	* plugin hook, the id needs to be passed as a parameter to avoid deadlocks.
	* Calling this function after the first static imports section of the module graph has been
	* processed will resolve immediately.
	* @experimental
	*/
	waitForRequestsIdle(ignoredId) {
		return this._crawlEndFinder.waitForRequestsIdle(ignoredId);
	}
	/**
	* @internal
	*/
	_registerRequestProcessing(id, done) {
		this._crawlEndFinder.registerRequestProcessing(id, done);
	}
};
function invalidateModule(environment, m$2) {
	const mod = environment.moduleGraph.urlToModuleMap.get(m$2.path);
	if (mod && mod.isSelfAccepting && mod.lastHMRTimestamp > 0 && !mod.lastHMRInvalidationReceived) {
		mod.lastHMRInvalidationReceived = true;
		environment.logger.info(import_picocolors$1.default.yellow(`hmr invalidate `) + import_picocolors$1.default.dim(m$2.path) + (m$2.message ? ` ${m$2.message}` : ""), { timestamp: true });
		updateModules(environment, getShortName(mod.file, environment.config.root), [...mod.importers], mod.lastHMRTimestamp, m$2.firstInvalidatedBy);
	}
}
const callCrawlEndIfIdleAfterMs = 50;
function setupOnCrawlEnd() {
	const registeredIds = /* @__PURE__ */ new Set();
	const seenIds = /* @__PURE__ */ new Set();
	const onCrawlEndPromiseWithResolvers = promiseWithResolvers();
	let timeoutHandle;
	let cancelled = false;
	function cancel() {
		cancelled = true;
	}
	function registerRequestProcessing(id, done) {
		if (!seenIds.has(id)) {
			seenIds.add(id);
			registeredIds.add(id);
			done().catch(() => {}).finally(() => markIdAsDone(id));
		}
	}
	function waitForRequestsIdle(ignoredId) {
		if (ignoredId) {
			seenIds.add(ignoredId);
			markIdAsDone(ignoredId);
		} else checkIfCrawlEndAfterTimeout();
		return onCrawlEndPromiseWithResolvers.promise;
	}
	function markIdAsDone(id) {
		registeredIds.delete(id);
		checkIfCrawlEndAfterTimeout();
	}
	function checkIfCrawlEndAfterTimeout() {
		if (cancelled || registeredIds.size > 0) return;
		if (timeoutHandle) clearTimeout(timeoutHandle);
		timeoutHandle = setTimeout(callOnCrawlEndWhenIdle, callCrawlEndIfIdleAfterMs);
	}
	async function callOnCrawlEndWhenIdle() {
		if (cancelled || registeredIds.size > 0) return;
		onCrawlEndPromiseWithResolvers.resolve();
	}
	return {
		registerRequestProcessing,
		waitForRequestsIdle,
		cancel
	};
}

//#endregion
//#region src/node/server/environments/runnableEnvironment.ts
function createRunnableDevEnvironment(name, config$2, context = {}) {
	if (context.transport == null) context.transport = createServerHotChannel();
	if (context.hot == null) context.hot = true;
	return new RunnableDevEnvironment(name, config$2, context);
}
function isRunnableDevEnvironment(environment) {
	return environment instanceof RunnableDevEnvironment;
}
var RunnableDevEnvironment = class extends DevEnvironment {
	_runner;
	_runnerFactory;
	_runnerOptions;
	constructor(name, config$2, context) {
		super(name, config$2, context);
		this._runnerFactory = context.runner;
		this._runnerOptions = context.runnerOptions;
	}
	get runner() {
		if (this._runner) return this._runner;
		this._runner = (this._runnerFactory || createServerModuleRunner)(this, this._runnerOptions);
		return this._runner;
	}
	async close() {
		await super.close();
		if (this._runner) await this._runner.close();
	}
};

//#endregion
//#region ../../node_modules/.pnpm/@polka+compression@1.0.0-next.25/node_modules/@polka/compression/build.mjs
const NOOP = () => {};
const MIMES = /text|javascript|\/json|xml/i;
/**
* @param {any} chunk
* @param {BufferEncoding} enc
* @returns {number}
*/
function getChunkSize(chunk, enc) {
	return chunk ? Buffer.byteLength(chunk, enc) : 0;
}
/**
* @param {import('./index.d.mts').Options} [options]
* @returns {import('./index.d.mts').Middleware}
*/
function build_default$1({ threshold = 1024, level = -1, brotli = false, gzip: gzip$1 = true, mimes: mimes$1 = MIMES } = {}) {
	const brotliOpts = typeof brotli === "object" && brotli || {};
	const gzipOpts = typeof gzip$1 === "object" && gzip$1 || {};
	if (!zlib.createBrotliCompress) brotli = false;
	return (req$4, res, next = NOOP) => {
		const accept = req$4.headers["accept-encoding"] + "";
		const encoding = (brotli && accept.match(/\bbr\b/) || gzip$1 && accept.match(/\bgzip\b/) || [])[0];
		if (req$4.method === "HEAD" || !encoding) return next();
		/** @type {zlib.Gzip | zlib.BrotliCompress} */
		let compress;
		/** @type {Array<[string, function]>?} */
		let pendingListeners = [];
		let pendingStatus = 0;
		let started = false;
		let size = 0;
		function start() {
			started = true;
			size = res.getHeader("Content-Length") | 0 || size;
			const compressible = mimes$1.test(String(res.getHeader("Content-Type") || "text/plain"));
			const cleartext = !res.getHeader("Content-Encoding");
			const listeners = pendingListeners || [];
			if (compressible && cleartext && size >= threshold) {
				res.setHeader("Content-Encoding", encoding);
				res.removeHeader("Content-Length");
				if (encoding === "br") compress = zlib.createBrotliCompress({ params: Object.assign({
					[zlib.constants.BROTLI_PARAM_QUALITY]: level,
					[zlib.constants.BROTLI_PARAM_SIZE_HINT]: size
				}, brotliOpts) });
				else compress = zlib.createGzip(Object.assign({ level }, gzipOpts));
				compress.on("data", (chunk) => write.call(res, chunk) || compress.pause());
				on.call(res, "drain", () => compress.resume());
				compress.on("end", () => end.call(res));
				listeners.forEach((p) => compress.on.apply(compress, p));
			} else {
				pendingListeners = null;
				listeners.forEach((p) => on.apply(res, p));
			}
			writeHead.call(res, pendingStatus || res.statusCode);
		}
		const { end, write, on, writeHead } = res;
		res.writeHead = function(status$1, reason, headers) {
			if (typeof reason !== "string") [headers, reason] = [reason, headers];
			if (headers) for (let k in headers) res.setHeader(k, headers[k]);
			pendingStatus = status$1;
			return this;
		};
		res.write = function(chunk, enc) {
			size += getChunkSize(chunk, enc);
			if (!started) start();
			if (!compress) return write.apply(this, arguments);
			return compress.write.apply(compress, arguments);
		};
		res.end = function(chunk, enc) {
			if (arguments.length > 0 && typeof chunk !== "function") size += getChunkSize(chunk, enc);
			if (!started) start();
			if (!compress) return end.apply(this, arguments);
			return compress.end.apply(compress, arguments);
		};
		res.on = function(type, listener$1) {
			if (!pendingListeners) on.call(this, type, listener$1);
			else if (compress) compress.on(type, listener$1);
			else pendingListeners.push([type, listener$1]);
			return this;
		};
		next();
	};
}

//#endregion
//#region src/node/preview.ts
var import_connect = /* @__PURE__ */ __toESM(require_connect(), 1);
var import_lib = /* @__PURE__ */ __toESM(require_lib$1(), 1);
function resolvePreviewOptions(preview$1, server) {
	return {
		port: preview$1?.port ?? DEFAULT_PREVIEW_PORT,
		strictPort: preview$1?.strictPort ?? server.strictPort,
		host: preview$1?.host ?? server.host,
		allowedHosts: preview$1?.allowedHosts ?? server.allowedHosts,
		https: preview$1?.https ?? server.https,
		open: preview$1?.open ?? server.open,
		proxy: preview$1?.proxy ?? server.proxy,
		cors: preview$1?.cors ?? server.cors,
		headers: preview$1?.headers ?? server.headers
	};
}
/**
* Starts the Vite server in preview mode, to simulate a production deployment
*/
async function preview(inlineConfig = {}) {
	const config$2 = await resolveConfig(inlineConfig, "serve", "production", "production", true);
	const clientOutDir = config$2.environments.client.build.outDir;
	const distDir = path.resolve(config$2.root, clientOutDir);
	if (!fs.existsSync(distDir) && config$2.plugins.every((plugin) => !plugin.configurePreviewServer) && process.argv[1]?.endsWith(path.normalize("bin/vite.js")) && process.argv[2] === "preview") throw new Error(`The directory "${clientOutDir}" does not exist. Did you build your project?`);
	const httpsOptions = await resolveHttpsConfig(config$2.preview.https);
	const app = (0, import_connect.default)();
	const httpServer = await resolveHttpServer(config$2.preview, app, httpsOptions);
	setClientErrorHandler(httpServer, config$2.logger);
	const options$1 = config$2.preview;
	const logger = config$2.logger;
	const closeHttpServer = createServerCloseFn(httpServer);
	let closeServerPromise;
	const closeServer = async () => {
		teardownSIGTERMListener(closeServerAndExit);
		await closeHttpServer();
		server.resolvedUrls = null;
	};
	const server = {
		config: config$2,
		middlewares: app,
		httpServer,
		async close() {
			if (!closeServerPromise) closeServerPromise = closeServer();
			return closeServerPromise;
		},
		resolvedUrls: null,
		printUrls() {
			if (server.resolvedUrls) printServerUrls(server.resolvedUrls, options$1.host, logger.info);
			else throw new Error("cannot print server URLs before server is listening.");
		},
		bindCLIShortcuts(options$2) {
			bindCLIShortcuts(server, options$2);
		}
	};
	const closeServerAndExit = async (_, exitCode) => {
		try {
			await server.close();
		} finally {
			process.exitCode ??= exitCode ? 128 + exitCode : void 0;
			process.exit();
		}
	};
	setupSIGTERMListener(closeServerAndExit);
	const { cors } = config$2.preview;
	if (cors !== false) app.use((0, import_lib.default)(typeof cors === "boolean" ? {} : cors));
	const { allowedHosts } = config$2.preview;
	if (allowedHosts !== true && !config$2.preview.https) app.use(hostValidationMiddleware(allowedHosts, true));
	const configurePreviewServerContext = new BasicMinimalPluginContext({
		...basePluginContextMeta,
		watchMode: false
	}, config$2.logger);
	const postHooks = [];
	for (const hook of config$2.getSortedPluginHooks("configurePreviewServer")) postHooks.push(await hook.call(configurePreviewServerContext, server));
	const { proxy } = config$2.preview;
	if (proxy) app.use(proxyMiddleware(httpServer, proxy, config$2));
	app.use(build_default$1());
	if (config$2.base !== "/") app.use(baseMiddleware(config$2.rawBase, false));
	const headers = config$2.preview.headers;
	const viteAssetMiddleware = (...args) => build_default(distDir, {
		etag: true,
		dev: true,
		extensions: [],
		ignores: false,
		setHeaders(res) {
			if (headers) for (const name in headers) res.setHeader(name, headers[name]);
		},
		shouldServe(filePath) {
			return shouldServeFile(filePath, distDir);
		}
	})(...args);
	app.use(viteAssetMiddleware);
	if (config$2.appType === "spa" || config$2.appType === "mpa") app.use(htmlFallbackMiddleware(distDir, config$2.appType === "spa"));
	postHooks.forEach((fn) => fn && fn());
	if (config$2.appType === "spa" || config$2.appType === "mpa") {
		const normalizedDistDir = normalizePath(distDir);
		app.use(indexHtmlMiddleware(normalizedDistDir, server));
		app.use(notFoundMiddleware());
	}
	const hostname = await resolveHostname(options$1.host);
	await httpServerStart(httpServer, {
		port: options$1.port,
		strictPort: options$1.strictPort,
		host: hostname.host,
		logger
	});
	server.resolvedUrls = resolveServerUrls(httpServer, config$2.preview, hostname, httpsOptions, config$2);
	if (options$1.open) {
		const url$3 = getServerUrlByHost(server.resolvedUrls, options$1.host);
		if (url$3) openBrowser(typeof options$1.open === "string" ? new URL(options$1.open, url$3).href : url$3, true, logger);
	}
	return server;
}

//#endregion
//#region src/node/ssr/index.ts
const ssrConfigDefaults = Object.freeze({
	target: "node",
	optimizeDeps: {}
});
function resolveSSROptions(ssr, preserveSymlinks) {
	return mergeWithDefaults(mergeWithDefaults(ssrConfigDefaults, { optimizeDeps: { esbuildOptions: { preserveSymlinks } } }), ssr ?? {});
}

//#endregion
//#region src/node/ssr/runnerImport.ts
/**
* Import any file using the default Vite environment.
* @experimental
*/
async function runnerImport(moduleId, inlineConfig) {
	const isModuleSyncConditionEnabled = (await import("#module-sync-enabled")).default;
	const environment = createRunnableDevEnvironment("inline", await resolveConfig(mergeConfig(inlineConfig || {}, {
		configFile: false,
		envDir: false,
		cacheDir: process.cwd(),
		environments: { inline: {
			consumer: "server",
			dev: { moduleRunnerTransform: true },
			resolve: {
				external: true,
				mainFields: [],
				conditions: ["node", ...isModuleSyncConditionEnabled ? ["module-sync"] : []]
			}
		} }
	}), "serve"), {
		runnerOptions: { hmr: { logger: false } },
		hot: false
	});
	await environment.init();
	try {
		const module$1 = await environment.runner.import(moduleId);
		return {
			module: module$1,
			dependencies: [...environment.runner.evaluatedModules.urlToIdModuleMap.values()].filter((m$2) => {
				if (!m$2.meta || "externalize" in m$2.meta) return false;
				return m$2.exports !== module$1;
			}).map((m$2) => m$2.file)
		};
	} finally {
		await environment.close();
	}
}

//#endregion
//#region src/node/config.ts
var import_picocolors = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const debug = createDebugger("vite:config", { depth: 10 });
const promisifiedRealpath = promisify(fs.realpath);
const SYMBOL_RESOLVED_CONFIG = Symbol("vite:resolved-config");
function defineConfig(config$2) {
	return config$2;
}
function defaultCreateClientDevEnvironment(name, config$2, context) {
	return new DevEnvironment(name, config$2, {
		hot: true,
		transport: context.ws
	});
}
function defaultCreateDevEnvironment(name, config$2) {
	return createRunnableDevEnvironment(name, config$2);
}
const configDefaults = Object.freeze({
	define: {},
	dev: {
		warmup: [],
		sourcemap: { js: true },
		sourcemapIgnoreList: void 0
	},
	build: buildEnvironmentOptionsDefaults,
	resolve: {
		externalConditions: [...DEFAULT_EXTERNAL_CONDITIONS],
		extensions: [
			".mjs",
			".js",
			".mts",
			".ts",
			".jsx",
			".tsx",
			".json"
		],
		dedupe: [],
		noExternal: [],
		external: [],
		preserveSymlinks: false,
		alias: []
	},
	base: "/",
	publicDir: "public",
	plugins: [],
	html: { cspNonce: void 0 },
	css: cssConfigDefaults,
	json: {
		namedExports: true,
		stringify: "auto"
	},
	assetsInclude: void 0,
	builder: builderOptionsDefaults,
	server: serverConfigDefaults,
	preview: { port: DEFAULT_PREVIEW_PORT },
	experimental: {
		importGlobRestoreExtension: false,
		renderBuiltUrl: void 0,
		hmrPartialAccept: false
	},
	future: {
		removePluginHookHandleHotUpdate: void 0,
		removePluginHookSsrArgument: void 0,
		removeServerModuleGraph: void 0,
		removeServerHot: void 0,
		removeServerTransformRequest: void 0,
		removeServerWarmupRequest: void 0,
		removeSsrLoadModule: void 0
	},
	legacy: { skipWebSocketTokenCheck: false },
	logLevel: "info",
	customLogger: void 0,
	clearScreen: true,
	envDir: void 0,
	envPrefix: "VITE_",
	worker: {
		format: "iife",
		plugins: () => []
	},
	optimizeDeps: {
		include: [],
		exclude: [],
		needsInterop: [],
		extensions: [],
		disabled: "build",
		holdUntilCrawlEnd: true,
		force: false
	},
	ssr: ssrConfigDefaults,
	environments: {},
	appType: "spa"
});
function resolveDevEnvironmentOptions(dev, environmentName, consumer, preTransformRequest$1) {
	const resolved = mergeWithDefaults({
		...configDefaults.dev,
		sourcemapIgnoreList: isInNodeModules,
		preTransformRequests: preTransformRequest$1 ?? consumer === "client",
		createEnvironment: environmentName === "client" ? defaultCreateClientDevEnvironment : defaultCreateDevEnvironment,
		recoverable: consumer === "client",
		moduleRunnerTransform: consumer === "server"
	}, dev ?? {});
	return {
		...resolved,
		sourcemapIgnoreList: resolved.sourcemapIgnoreList === false ? () => false : resolved.sourcemapIgnoreList
	};
}
function resolveEnvironmentOptions(options$1, alias$2, preserveSymlinks, forceOptimizeDeps, logger, environmentName, isSsrTargetWebworkerSet, preTransformRequests) {
	const consumer = options$1.consumer ?? (environmentName === "client" ? "client" : "server");
	const isSsrTargetWebworkerEnvironment = isSsrTargetWebworkerSet && environmentName === "ssr";
	if (options$1.define?.["process.env"]) {
		const processEnvDefine = options$1.define["process.env"];
		if (typeof processEnvDefine === "object") {
			const pathKey$1 = Object.entries(processEnvDefine).find(([key, value$1]) => key.toLowerCase() === "path" && !!value$1)?.[0];
			if (pathKey$1) logger.warnOnce(import_picocolors.default.yellow(`The \`define\` option contains an object with ${JSON.stringify(pathKey$1)} for "process.env" key. It looks like you may have passed the entire \`process.env\` object to \`define\`, which can unintentionally expose all environment variables. This poses a security risk and is discouraged.`));
		}
	}
	const resolve$4 = resolveEnvironmentResolveOptions(options$1.resolve, alias$2, preserveSymlinks, logger, consumer, isSsrTargetWebworkerEnvironment);
	return {
		define: options$1.define,
		resolve: resolve$4,
		keepProcessEnv: options$1.keepProcessEnv ?? (isSsrTargetWebworkerEnvironment ? false : consumer === "server"),
		consumer,
		optimizeDeps: resolveDepOptimizationOptions(options$1.optimizeDeps, resolve$4.preserveSymlinks, forceOptimizeDeps, consumer),
		dev: resolveDevEnvironmentOptions(options$1.dev, environmentName, consumer, preTransformRequests),
		build: resolveBuildEnvironmentOptions(options$1.build ?? {}, logger, consumer),
		plugins: void 0
	};
}
function getDefaultEnvironmentOptions(config$2) {
	return {
		define: config$2.define,
		resolve: {
			...config$2.resolve,
			mainFields: void 0,
			conditions: void 0
		},
		dev: config$2.dev,
		build: config$2.build
	};
}
/**
* Check and warn if `path` includes characters that don't work well in Vite,
* such as `#` and `?` and `*`.
*/
function checkBadCharactersInPath(name, path$13, logger) {
	const badChars = [];
	if (path$13.includes("#")) badChars.push("#");
	if (path$13.includes("?")) badChars.push("?");
	if (path$13.includes("*")) badChars.push("*");
	if (badChars.length > 0) {
		const charString = badChars.map((c) => `"${c}"`).join(" and ");
		logger.warn(import_picocolors.default.yellow(`${name} contains the ${charString} ${badChars.length > 1 ? "characters" : "character"} (${import_picocolors.default.cyan(path$13)}), which may not work when running Vite. Consider renaming the directory / file to remove the characters.`));
	}
}
const clientAlias = [{
	find: /^\/?@vite\/env/,
	replacement: path.posix.join(FS_PREFIX, normalizePath(ENV_ENTRY))
}, {
	find: /^\/?@vite\/client/,
	replacement: path.posix.join(FS_PREFIX, normalizePath(CLIENT_ENTRY))
}];
/**
* alias and preserveSymlinks are not per-environment options, but they are
* included in the resolved environment options for convenience.
*/
function resolveEnvironmentResolveOptions(resolve$4, alias$2, preserveSymlinks, logger, consumer, isSsrTargetWebworkerEnvironment) {
	const resolvedResolve = mergeWithDefaults({
		...configDefaults.resolve,
		mainFields: consumer === void 0 || consumer === "client" || isSsrTargetWebworkerEnvironment ? DEFAULT_CLIENT_MAIN_FIELDS : DEFAULT_SERVER_MAIN_FIELDS,
		conditions: consumer === void 0 || consumer === "client" || isSsrTargetWebworkerEnvironment ? DEFAULT_CLIENT_CONDITIONS : DEFAULT_SERVER_CONDITIONS.filter((c) => c !== "browser"),
		builtins: resolve$4?.builtins ?? (consumer === "server" ? isSsrTargetWebworkerEnvironment && resolve$4?.noExternal === true ? [] : nodeLikeBuiltins : [])
	}, resolve$4 ?? {});
	resolvedResolve.preserveSymlinks = preserveSymlinks;
	resolvedResolve.alias = alias$2;
	if (resolve$4?.browserField === false && resolvedResolve.mainFields.includes("browser")) logger.warn(import_picocolors.default.yellow("`resolve.browserField` is set to false, but the option is removed in favour of the 'browser' string in `resolve.mainFields`. You may want to update `resolve.mainFields` to remove the 'browser' string and preserve the previous browser behaviour."));
	return resolvedResolve;
}
function resolveResolveOptions(resolve$4, logger) {
	const alias$2 = normalizeAlias(mergeAlias(clientAlias, resolve$4?.alias || configDefaults.resolve.alias));
	const preserveSymlinks = resolve$4?.preserveSymlinks ?? configDefaults.resolve.preserveSymlinks;
	if (alias$2.some((a) => a.find === "/")) logger.warn(import_picocolors.default.yellow("`resolve.alias` contains an alias that maps `/`. This is not recommended as it can cause unexpected behavior when resolving paths."));
	return resolveEnvironmentResolveOptions(resolve$4, alias$2, preserveSymlinks, logger, void 0);
}
function resolveDepOptimizationOptions(optimizeDeps$1, preserveSymlinks, forceOptimizeDeps, consumer) {
	return mergeWithDefaults({
		...configDefaults.optimizeDeps,
		disabled: void 0,
		noDiscovery: consumer !== "client",
		esbuildOptions: { preserveSymlinks },
		force: forceOptimizeDeps ?? configDefaults.optimizeDeps.force
	}, optimizeDeps$1 ?? {});
}
function isResolvedConfig(inlineConfig) {
	return SYMBOL_RESOLVED_CONFIG in inlineConfig && inlineConfig[SYMBOL_RESOLVED_CONFIG];
}
async function resolveConfig(inlineConfig, command, defaultMode = "development", defaultNodeEnv = "development", isPreview = false, patchConfig = void 0, patchPlugins = void 0) {
	let config$2 = inlineConfig;
	let configFileDependencies = [];
	let mode = inlineConfig.mode || defaultMode;
	const isNodeEnvSet = !!process.env.NODE_ENV;
	const packageCache = /* @__PURE__ */ new Map();
	if (!isNodeEnvSet) process.env.NODE_ENV = defaultNodeEnv;
	const configEnv = {
		mode,
		command,
		isSsrBuild: command === "build" && !!config$2.build?.ssr,
		isPreview
	};
	let { configFile } = config$2;
	if (configFile !== false) {
		const loadResult = await loadConfigFromFile(configEnv, configFile, config$2.root, config$2.logLevel, config$2.customLogger, config$2.configLoader);
		if (loadResult) {
			config$2 = mergeConfig(loadResult.config, config$2);
			configFile = loadResult.path;
			configFileDependencies = loadResult.dependencies;
		}
	}
	mode = inlineConfig.mode || config$2.mode || mode;
	configEnv.mode = mode;
	const filterPlugin = (p) => {
		if (!p) return false;
		else if (!p.apply) return true;
		else if (typeof p.apply === "function") return p.apply({
			...config$2,
			mode
		}, configEnv);
		else return p.apply === command;
	};
	const [prePlugins, normalPlugins, postPlugins] = sortUserPlugins((await asyncFlatten(config$2.plugins || [])).filter(filterPlugin));
	const isBuild = command === "build";
	const userPlugins = [
		...prePlugins,
		...normalPlugins,
		...postPlugins
	];
	config$2 = await runConfigHook(config$2, userPlugins, configEnv);
	config$2.environments ??= {};
	if (!config$2.environments.ssr && (!isBuild || config$2.ssr || config$2.build?.ssr)) config$2.environments = {
		ssr: {},
		...config$2.environments
	};
	if (!config$2.environments.client) config$2.environments = {
		client: {},
		...config$2.environments
	};
	const logger = createLogger(config$2.logLevel, {
		allowClearScreen: config$2.clearScreen,
		customLogger: config$2.customLogger
	});
	const resolvedRoot = normalizePath(config$2.root ? path.resolve(config$2.root) : process.cwd());
	checkBadCharactersInPath("The project root", resolvedRoot, logger);
	const configEnvironmentsClient = config$2.environments.client;
	configEnvironmentsClient.dev ??= {};
	const deprecatedSsrOptimizeDepsConfig = config$2.ssr?.optimizeDeps ?? {};
	let configEnvironmentsSsr = config$2.environments.ssr;
	const warmupOptions = config$2.server?.warmup;
	if (warmupOptions?.clientFiles) configEnvironmentsClient.dev.warmup = warmupOptions.clientFiles;
	if (warmupOptions?.ssrFiles) {
		configEnvironmentsSsr ??= {};
		configEnvironmentsSsr.dev ??= {};
		configEnvironmentsSsr.dev.warmup = warmupOptions.ssrFiles;
	}
	if (configEnvironmentsSsr) {
		configEnvironmentsSsr.optimizeDeps = mergeConfig(deprecatedSsrOptimizeDepsConfig, configEnvironmentsSsr.optimizeDeps ?? {});
		configEnvironmentsSsr.resolve = mergeConfig({ resolve: {
			conditions: config$2.ssr?.resolve?.conditions,
			externalConditions: config$2.ssr?.resolve?.externalConditions,
			mainFields: config$2.ssr?.resolve?.mainFields,
			external: config$2.ssr?.external,
			noExternal: config$2.ssr?.noExternal
		} }, { resolve: configEnvironmentsSsr.resolve ?? {} }).resolve;
	}
	if (config$2.build?.ssrEmitAssets !== void 0) {
		configEnvironmentsSsr ??= {};
		configEnvironmentsSsr.build ??= {};
		configEnvironmentsSsr.build.emitAssets = config$2.build.ssrEmitAssets;
	}
	if (!config$2.environments.client || !config$2.environments.ssr && !isBuild) throw new Error("Required environments configuration were stripped out in the config hook");
	const defaultEnvironmentOptions = getDefaultEnvironmentOptions(config$2);
	const defaultClientEnvironmentOptions = {
		...defaultEnvironmentOptions,
		resolve: config$2.resolve,
		optimizeDeps: config$2.optimizeDeps
	};
	const defaultNonClientEnvironmentOptions = {
		...defaultEnvironmentOptions,
		dev: {
			...defaultEnvironmentOptions.dev,
			createEnvironment: void 0,
			warmup: void 0
		},
		build: {
			...defaultEnvironmentOptions.build,
			createEnvironment: void 0
		}
	};
	for (const name of Object.keys(config$2.environments)) config$2.environments[name] = mergeConfig(name === "client" ? defaultClientEnvironmentOptions : defaultNonClientEnvironmentOptions, config$2.environments[name]);
	await runConfigEnvironmentHook(config$2.environments, userPlugins, logger, configEnv, config$2.ssr?.target === "webworker");
	config$2.resolve ??= {};
	config$2.resolve.conditions = config$2.environments.client.resolve?.conditions;
	config$2.resolve.mainFields = config$2.environments.client.resolve?.mainFields;
	const resolvedDefaultResolve = resolveResolveOptions(config$2.resolve, logger);
	const resolvedEnvironments = {};
	for (const environmentName of Object.keys(config$2.environments)) resolvedEnvironments[environmentName] = resolveEnvironmentOptions(config$2.environments[environmentName], resolvedDefaultResolve.alias, resolvedDefaultResolve.preserveSymlinks, inlineConfig.forceOptimizeDeps, logger, environmentName, config$2.ssr?.target === "webworker", config$2.server?.preTransformRequests);
	const backwardCompatibleOptimizeDeps = resolvedEnvironments.client.optimizeDeps;
	const resolvedDevEnvironmentOptions = resolveDevEnvironmentOptions(config$2.dev, void 0, void 0);
	const resolvedBuildOptions = resolveBuildEnvironmentOptions(config$2.build ?? {}, logger, void 0);
	const ssr = resolveSSROptions({
		...config$2.ssr,
		external: resolvedEnvironments.ssr?.resolve.external,
		noExternal: resolvedEnvironments.ssr?.resolve.noExternal,
		optimizeDeps: resolvedEnvironments.ssr?.optimizeDeps,
		resolve: {
			...config$2.ssr?.resolve,
			conditions: resolvedEnvironments.ssr?.resolve.conditions,
			externalConditions: resolvedEnvironments.ssr?.resolve.externalConditions
		}
	}, resolvedDefaultResolve.preserveSymlinks);
	let envDir = config$2.envFile === false ? false : config$2.envDir;
	if (envDir !== false) envDir = config$2.envDir ? normalizePath(path.resolve(resolvedRoot, config$2.envDir)) : resolvedRoot;
	const userEnv = loadEnv(mode, envDir, resolveEnvPrefix(config$2));
	const userNodeEnv = process.env.VITE_USER_NODE_ENV;
	if (!isNodeEnvSet && userNodeEnv) if (userNodeEnv === "development") process.env.NODE_ENV = "development";
	else logger.warn(`NODE_ENV=${userNodeEnv} is not supported in the .env file. Only NODE_ENV=development is supported to create a development build of your project. If you need to set process.env.NODE_ENV, you can set it in the Vite config instead.`);
	const isProduction = process.env.NODE_ENV === "production";
	const resolvedBase = config$2.base === "" || config$2.base === "./" ? !isBuild || config$2.build?.ssr ? "/" : "./" : resolveBaseUrl(config$2.base, isBuild, logger);
	const pkgDir = findNearestPackageData(resolvedRoot, packageCache)?.dir;
	const cacheDir = normalizePath(config$2.cacheDir ? path.resolve(resolvedRoot, config$2.cacheDir) : pkgDir ? path.join(pkgDir, `node_modules/.vite`) : path.join(resolvedRoot, `.vite`));
	const assetsFilter = config$2.assetsInclude && (!Array.isArray(config$2.assetsInclude) || config$2.assetsInclude.length) ? createFilter(config$2.assetsInclude) : () => false;
	const { publicDir } = config$2;
	const resolvedPublicDir = publicDir !== false && publicDir !== "" ? normalizePath(path.resolve(resolvedRoot, typeof publicDir === "string" ? publicDir : configDefaults.publicDir)) : "";
	const server = resolveServerOptions(resolvedRoot, config$2.server, logger);
	const builder = resolveBuilderOptions(config$2.builder);
	const BASE_URL = resolvedBase;
	const resolvedConfigContext = new BasicMinimalPluginContext({
		...basePluginContextMeta,
		watchMode: command === "serve" && !isPreview || command === "build" && !!resolvedBuildOptions.watch
	}, logger);
	let resolved;
	let createUserWorkerPlugins = config$2.worker?.plugins;
	if (Array.isArray(createUserWorkerPlugins)) {
		createUserWorkerPlugins = () => config$2.worker?.plugins;
		logger.warn(import_picocolors.default.yellow("worker.plugins is now a function that returns an array of plugins. Please update your Vite config accordingly.\n"));
	}
	const createWorkerPlugins = async function(bundleChain) {
		const rawWorkerUserPlugins = (await asyncFlatten(createUserWorkerPlugins?.() || [])).filter(filterPlugin);
		let workerConfig = mergeConfig({}, config$2);
		const [workerPrePlugins, workerNormalPlugins, workerPostPlugins] = sortUserPlugins(rawWorkerUserPlugins);
		const workerUserPlugins = [
			...workerPrePlugins,
			...workerNormalPlugins,
			...workerPostPlugins
		];
		workerConfig = await runConfigHook(workerConfig, workerUserPlugins, configEnv);
		const workerResolved = {
			...workerConfig,
			...resolved,
			isWorker: true,
			mainConfig: resolved,
			bundleChain
		};
		workerResolved.plugins = await resolvePlugins(workerResolved, workerPrePlugins, workerNormalPlugins, workerPostPlugins);
		await Promise.all(createPluginHookUtils(workerResolved.plugins).getSortedPluginHooks("configResolved").map((hook) => hook.call(resolvedConfigContext, workerResolved)));
		workerResolved.environments = {
			...workerResolved.environments,
			client: {
				...workerResolved.environments.client,
				plugins: await resolveEnvironmentPlugins(new PartialEnvironment("client", workerResolved))
			}
		};
		return workerResolved;
	};
	const resolvedWorkerOptions = {
		format: config$2.worker?.format || "iife",
		plugins: createWorkerPlugins,
		rollupOptions: config$2.worker?.rollupOptions || {}
	};
	const base = withTrailingSlash(resolvedBase);
	const preview$1 = resolvePreviewOptions(config$2.preview, server);
	const additionalAllowedHosts = getAdditionalAllowedHosts(server, preview$1);
	if (Array.isArray(server.allowedHosts)) server.allowedHosts.push(...additionalAllowedHosts);
	if (Array.isArray(preview$1.allowedHosts)) preview$1.allowedHosts.push(...additionalAllowedHosts);
	resolved = {
		configFile: configFile ? normalizePath(configFile) : void 0,
		configFileDependencies: configFileDependencies.map((name) => normalizePath(path.resolve(name))),
		inlineConfig,
		root: resolvedRoot,
		base,
		decodedBase: decodeBase(base),
		rawBase: resolvedBase,
		publicDir: resolvedPublicDir,
		cacheDir,
		command,
		mode,
		isWorker: false,
		mainConfig: null,
		bundleChain: [],
		isProduction,
		plugins: userPlugins,
		css: resolveCSSOptions(config$2.css),
		json: mergeWithDefaults(configDefaults.json, config$2.json ?? {}),
		esbuild: config$2.esbuild === false ? false : {
			jsxDev: !isProduction,
			...config$2.esbuild
		},
		server,
		builder,
		preview: preview$1,
		envDir,
		env: {
			...userEnv,
			BASE_URL,
			MODE: mode,
			DEV: !isProduction,
			PROD: isProduction
		},
		assetsInclude(file) {
			return DEFAULT_ASSETS_RE.test(file) || assetsFilter(file);
		},
		logger,
		packageCache,
		worker: resolvedWorkerOptions,
		appType: config$2.appType ?? "spa",
		experimental: mergeWithDefaults(configDefaults.experimental, config$2.experimental ?? {}),
		future: config$2.future === "warn" ? {
			removePluginHookHandleHotUpdate: "warn",
			removePluginHookSsrArgument: "warn",
			removeServerModuleGraph: "warn",
			removeServerReloadModule: "warn",
			removeServerPluginContainer: "warn",
			removeServerHot: "warn",
			removeServerTransformRequest: "warn",
			removeServerWarmupRequest: "warn",
			removeSsrLoadModule: "warn"
		} : config$2.future,
		ssr,
		optimizeDeps: backwardCompatibleOptimizeDeps,
		resolve: resolvedDefaultResolve,
		dev: resolvedDevEnvironmentOptions,
		build: resolvedBuildOptions,
		environments: resolvedEnvironments,
		webSocketToken: Buffer.from(crypto.getRandomValues(new Uint8Array(9))).toString("base64url"),
		getSortedPlugins: void 0,
		getSortedPluginHooks: void 0,
		createResolver(options$1) {
			const resolve$4 = createIdResolver(this, options$1);
			const clientEnvironment = new PartialEnvironment("client", this);
			let ssrEnvironment;
			return async (id, importer, aliasOnly, ssr$1) => {
				if (ssr$1) ssrEnvironment ??= new PartialEnvironment("ssr", this);
				return await resolve$4(ssr$1 ? ssrEnvironment : clientEnvironment, id, importer, aliasOnly);
			};
		},
		fsDenyGlob: picomatch(server.fs.deny.map((pattern) => pattern.includes("/") ? pattern : `**/${pattern}`), {
			matchBase: false,
			nocase: true,
			dot: true
		}),
		safeModulePaths: /* @__PURE__ */ new Set(),
		[SYMBOL_RESOLVED_CONFIG]: true
	};
	resolved = {
		...config$2,
		...resolved
	};
	patchConfig?.(resolved);
	const resolvedPlugins = await resolvePlugins(resolved, prePlugins, normalPlugins, postPlugins);
	patchPlugins?.(resolvedPlugins);
	resolved.plugins = resolvedPlugins;
	Object.assign(resolved, createPluginHookUtils(resolved.plugins));
	await Promise.all(resolved.getSortedPluginHooks("configResolved").map((hook) => hook.call(resolvedConfigContext, resolved)));
	for (const name of Object.keys(resolved.environments)) resolved.environments[name].plugins = await resolveEnvironmentPlugins(new PartialEnvironment(name, resolved));
	optimizeDepsDisabledBackwardCompatibility(resolved, resolved.optimizeDeps);
	optimizeDepsDisabledBackwardCompatibility(resolved, resolved.ssr.optimizeDeps, "ssr.");
	if (!resolved.builder?.sharedConfigBuild && resolved.environments.ssr) resolved.environments.ssr.build.emitAssets = resolved.build.ssrEmitAssets || resolved.build.emitAssets;
	debug?.(`using resolved config: %O`, {
		...resolved,
		plugins: resolved.plugins.map((p) => p.name),
		worker: {
			...resolved.worker,
			plugins: `() => plugins`
		}
	});
	const outputOption = config$2.build?.rollupOptions?.output ?? [];
	if (Array.isArray(outputOption)) {
		const assetFileNamesList = outputOption.map((output) => output.assetFileNames);
		if (assetFileNamesList.length > 1) {
			const firstAssetFileNames = assetFileNamesList[0];
			if (assetFileNamesList.some((assetFileNames) => assetFileNames !== firstAssetFileNames)) resolved.logger.warn(import_picocolors.default.yellow(`
assetFileNames isn't equal for every build.rollupOptions.output. A single pattern across all outputs is supported by Vite.
`));
		}
	}
	if (config$2.legacy?.buildSsrCjsExternalHeuristics || config$2.ssr?.format === "cjs") resolved.logger.warn(import_picocolors.default.yellow(`
(!) Experimental legacy.buildSsrCjsExternalHeuristics and ssr.format were be removed in Vite 5.
    The only SSR Output format is ESM. Find more information at https://github.com/vitejs/vite/discussions/13816.
`));
	const resolvedBuildOutDir = normalizePath(path.resolve(resolved.root, resolved.build.outDir));
	if (isParentDirectory(resolvedBuildOutDir, resolved.root) || resolvedBuildOutDir === resolved.root) resolved.logger.warn(import_picocolors.default.yellow(`
(!) build.outDir must not be the same directory of root or a parent directory of root as this could cause Vite to overwriting source files with build outputs.
`));
	return resolved;
}
/**
* Resolve base url. Note that some users use Vite to build for non-web targets like
* electron or expects to deploy
*/
function resolveBaseUrl(base = configDefaults.base, isBuild, logger) {
	if (base[0] === ".") {
		logger.warn(import_picocolors.default.yellow(import_picocolors.default.bold(`(!) invalid "base" option: "${base}". The value can only be an absolute URL, "./", or an empty string.`)));
		return "/";
	}
	const isExternal$1 = isExternalUrl(base);
	if (!isExternal$1 && base[0] !== "/") logger.warn(import_picocolors.default.yellow(import_picocolors.default.bold(`(!) "base" option should start with a slash.`)));
	if (!isBuild || !isExternal$1) {
		base = new URL(base, "http://vite.dev").pathname;
		if (base[0] !== "/") base = "/" + base;
	}
	return base;
}
function decodeBase(base) {
	try {
		return decodeURI(base);
	} catch {
		throw new Error("The value passed to \"base\" option was malformed. It should be a valid URL.");
	}
}
function sortUserPlugins(plugins$1) {
	const prePlugins = [];
	const postPlugins = [];
	const normalPlugins = [];
	if (plugins$1) plugins$1.flat().forEach((p) => {
		if (p.enforce === "pre") prePlugins.push(p);
		else if (p.enforce === "post") postPlugins.push(p);
		else normalPlugins.push(p);
	});
	return [
		prePlugins,
		normalPlugins,
		postPlugins
	];
}
async function loadConfigFromFile(configEnv, configFile, configRoot = process.cwd(), logLevel, customLogger, configLoader = "bundle") {
	if (configLoader !== "bundle" && configLoader !== "runner" && configLoader !== "native") throw new Error(`Unsupported configLoader: ${configLoader}. Accepted values are 'bundle', 'runner', and 'native'.`);
	const start = performance$1.now();
	const getTime = () => `${(performance$1.now() - start).toFixed(2)}ms`;
	let resolvedPath;
	if (configFile) resolvedPath = path.resolve(configFile);
	else for (const filename of DEFAULT_CONFIG_FILES) {
		const filePath = path.resolve(configRoot, filename);
		if (!fs.existsSync(filePath)) continue;
		resolvedPath = filePath;
		break;
	}
	if (!resolvedPath) {
		debug?.("no config file found.");
		return null;
	}
	try {
		const { configExport, dependencies } = await (configLoader === "bundle" ? bundleAndLoadConfigFile : configLoader === "runner" ? runnerImportConfigFile : nativeImportConfigFile)(resolvedPath);
		debug?.(`config file loaded in ${getTime()}`);
		const config$2 = await (typeof configExport === "function" ? configExport(configEnv) : configExport);
		if (!isObject(config$2)) throw new Error(`config must export or return an object.`);
		return {
			path: normalizePath(resolvedPath),
			config: config$2,
			dependencies
		};
	} catch (e$1) {
		const logger = createLogger(logLevel, { customLogger });
		checkBadCharactersInPath("The config path", resolvedPath, logger);
		logger.error(import_picocolors.default.red(`failed to load config from ${resolvedPath}`), { error: e$1 });
		throw e$1;
	}
}
async function nativeImportConfigFile(resolvedPath) {
	return {
		configExport: (await import(pathToFileURL(resolvedPath).href + "?t=" + Date.now())).default,
		dependencies: []
	};
}
async function runnerImportConfigFile(resolvedPath) {
	const { module: module$1, dependencies } = await runnerImport(resolvedPath);
	return {
		configExport: module$1.default,
		dependencies
	};
}
async function bundleAndLoadConfigFile(resolvedPath) {
	const isESM = typeof process.versions.deno === "string" || isFilePathESM(resolvedPath);
	const bundled = await bundleConfigFile(resolvedPath, isESM);
	return {
		configExport: await loadConfigFromBundledFile(resolvedPath, bundled.code, isESM),
		dependencies: bundled.dependencies
	};
}
async function bundleConfigFile(fileName, isESM) {
	const isModuleSyncConditionEnabled = (await import("#module-sync-enabled")).default;
	const dirnameVarName = "__vite_injected_original_dirname";
	const filenameVarName = "__vite_injected_original_filename";
	const importMetaUrlVarName = "__vite_injected_original_import_meta_url";
	const result = await build({
		absWorkingDir: process.cwd(),
		entryPoints: [fileName],
		write: false,
		target: [`node${process.versions.node}`],
		platform: "node",
		bundle: true,
		format: isESM ? "esm" : "cjs",
		mainFields: ["main"],
		sourcemap: "inline",
		sourceRoot: pathToFileURL(path.dirname(fileName)).href + "/",
		metafile: true,
		define: {
			__dirname: dirnameVarName,
			__filename: filenameVarName,
			"import.meta.url": importMetaUrlVarName,
			"import.meta.dirname": dirnameVarName,
			"import.meta.filename": filenameVarName,
			"import.meta.main": "false"
		},
		plugins: [{
			name: "externalize-deps",
			setup(build$3) {
				const packageCache = /* @__PURE__ */ new Map();
				const resolveByViteResolver = (id, importer, isRequire$1) => {
					return tryNodeResolve(id, importer, {
						root: path.dirname(fileName),
						isBuild: true,
						isProduction: true,
						preferRelative: false,
						tryIndex: true,
						mainFields: [],
						conditions: ["node", ...isModuleSyncConditionEnabled ? ["module-sync"] : []],
						externalConditions: [],
						external: [],
						noExternal: [],
						dedupe: [],
						extensions: configDefaults.resolve.extensions,
						preserveSymlinks: false,
						packageCache,
						isRequire: isRequire$1,
						builtins: nodeLikeBuiltins
					})?.id;
				};
				build$3.onResolve({ filter: /^[^.#].*/ }, async ({ path: id, importer, kind }) => {
					if (kind === "entry-point" || path.isAbsolute(id) || isNodeBuiltin(id)) return;
					if (isNodeLikeBuiltin(id) || id.startsWith("npm:")) return { external: true };
					const isImport = isESM || kind === "dynamic-import";
					let idFsPath;
					try {
						idFsPath = resolveByViteResolver(id, importer, !isImport);
					} catch (e$1) {
						if (!isImport) {
							let canResolveWithImport = false;
							try {
								canResolveWithImport = !!resolveByViteResolver(id, importer, false);
							} catch {}
							if (canResolveWithImport) throw new Error(`Failed to resolve ${JSON.stringify(id)}. This package is ESM only but it was tried to load by \`require\`. See https://vite.dev/guide/troubleshooting.html#this-package-is-esm-only for more details.`);
						}
						throw e$1;
					}
					if (idFsPath && isImport) idFsPath = pathToFileURL(idFsPath).href;
					return {
						path: idFsPath,
						external: true
					};
				});
			}
		}, {
			name: "inject-file-scope-variables",
			setup(build$3) {
				build$3.onLoad({ filter: /\.[cm]?[jt]s$/ }, async (args) => {
					const contents = await fsp.readFile(args.path, "utf-8");
					const injectValues = `const ${dirnameVarName} = ${JSON.stringify(path.dirname(args.path))};const ${filenameVarName} = ${JSON.stringify(args.path)};const ${importMetaUrlVarName} = ${JSON.stringify(pathToFileURL(args.path).href)};`;
					return {
						loader: args.path.endsWith("ts") ? "ts" : "js",
						contents: injectValues + contents
					};
				});
			}
		}]
	});
	const { text } = result.outputFiles[0];
	return {
		code: text,
		dependencies: Object.keys(result.metafile.inputs)
	};
}
const _require = createRequire(
	/** #__KEEP__ */
	import.meta.url
);
async function loadConfigFromBundledFile(fileName, bundledCode, isESM) {
	if (isESM) {
		let nodeModulesDir = typeof process.versions.deno === "string" ? void 0 : findNearestNodeModules(path.dirname(fileName));
		if (nodeModulesDir) try {
			await fsp.mkdir(path.resolve(nodeModulesDir, ".vite-temp/"), { recursive: true });
		} catch (e$1) {
			if (e$1.code === "EACCES") nodeModulesDir = void 0;
			else throw e$1;
		}
		const hash$1 = `timestamp-${Date.now()}-${Math.random().toString(16).slice(2)}`;
		const tempFileName = nodeModulesDir ? path.resolve(nodeModulesDir, `.vite-temp/${path.basename(fileName)}.${hash$1}.mjs`) : `${fileName}.${hash$1}.mjs`;
		await fsp.writeFile(tempFileName, bundledCode);
		try {
			return (await import(pathToFileURL(tempFileName).href)).default;
		} finally {
			fs.unlink(tempFileName, () => {});
		}
	} else {
		const extension$1 = path.extname(fileName);
		const realFileName = await promisifiedRealpath(fileName);
		const loaderExt = extension$1 in _require.extensions ? extension$1 : ".js";
		const defaultLoader = _require.extensions[loaderExt];
		_require.extensions[loaderExt] = (module$1, filename) => {
			if (filename === realFileName) module$1._compile(bundledCode, filename);
			else defaultLoader(module$1, filename);
		};
		delete _require.cache[_require.resolve(fileName)];
		const raw = _require(fileName);
		_require.extensions[loaderExt] = defaultLoader;
		return raw.__esModule ? raw.default : raw;
	}
}
async function runConfigHook(config$2, plugins$1, configEnv) {
	let conf = config$2;
	const context = new BasicMinimalPluginContext(basePluginContextMeta, createLogger(config$2.logLevel, {
		allowClearScreen: config$2.clearScreen,
		customLogger: config$2.customLogger
	}));
	for (const p of getSortedPluginsByHook("config", plugins$1)) {
		const hook = p.config;
		const res = await getHookHandler(hook).call(context, conf, configEnv);
		if (res && res !== conf) conf = mergeConfig(conf, res);
	}
	return conf;
}
async function runConfigEnvironmentHook(environments, plugins$1, logger, configEnv, isSsrTargetWebworkerSet) {
	const context = new BasicMinimalPluginContext(basePluginContextMeta, logger);
	const environmentNames = Object.keys(environments);
	for (const p of getSortedPluginsByHook("configEnvironment", plugins$1)) {
		const hook = p.configEnvironment;
		const handler = getHookHandler(hook);
		for (const name of environmentNames) {
			const res = await handler.call(context, name, environments[name], {
				...configEnv,
				isSsrTargetWebworker: isSsrTargetWebworkerSet && name === "ssr"
			});
			if (res) environments[name] = mergeConfig(environments[name], res);
		}
	}
}
function optimizeDepsDisabledBackwardCompatibility(resolved, optimizeDeps$1, optimizeDepsPath = "") {
	const optimizeDepsDisabled = optimizeDeps$1.disabled;
	if (optimizeDepsDisabled !== void 0) {
		if (optimizeDepsDisabled === true || optimizeDepsDisabled === "dev") {
			const commonjsOptionsInclude = resolved.build.commonjsOptions.include;
			const commonjsPluginDisabled = Array.isArray(commonjsOptionsInclude) && commonjsOptionsInclude.length === 0;
			optimizeDeps$1.noDiscovery = true;
			optimizeDeps$1.include = void 0;
			if (commonjsPluginDisabled) resolved.build.commonjsOptions.include = void 0;
			resolved.logger.warn(import_picocolors.default.yellow(`(!) Experimental ${optimizeDepsPath}optimizeDeps.disabled and deps pre-bundling during build were removed in Vite 5.1.
    To disable the deps optimizer, set ${optimizeDepsPath}optimizeDeps.noDiscovery to true and ${optimizeDepsPath}optimizeDeps.include as undefined or empty.
    Please remove ${optimizeDepsPath}optimizeDeps.disabled from your config.
    ${commonjsPluginDisabled ? "Empty config.build.commonjsOptions.include will be ignored to support CJS during build. This config should also be removed." : ""}
  `));
		} else if (optimizeDepsDisabled === false || optimizeDepsDisabled === "build") resolved.logger.warn(import_picocolors.default.yellow(`(!) Experimental ${optimizeDepsPath}optimizeDeps.disabled and deps pre-bundling during build were removed in Vite 5.1.
    Setting it to ${optimizeDepsDisabled} now has no effect.
    Please remove ${optimizeDepsPath}optimizeDeps.disabled from your config.
  `));
	}
}

//#endregion
export { BuildEnvironment, DevEnvironment, _createServer, addManuallyIncludedOptimizeDeps, addOptimizedDepInfo, build$1 as build, buildEnvironmentOptionsDefaults, buildErrorMessage, builderOptionsDefaults, cleanupDepsCacheStaleDirs, configDefaults, createBuilder, createFilter, createIdResolver, createIsOptimizedDepFile, createIsOptimizedDepUrl, createRunnableDevEnvironment, createServer$2 as createServer, createServerCloseFn, createServerHotChannel, createServerModuleRunner, createServerModuleRunnerTransport, createToImportMetaURLBasedRelativeRuntime, defineConfig, depsFromOptimizedDepInfo, depsLogString, discoverProjectDependencies, extractExportsData, fetchModule, formatPostcssSourceMap, getDefaultEnvironmentOptions, getDepsCacheDir, getOptimizedDepPath, initDepsOptimizerMetadata, injectEnvironmentToHooks, isCSSRequest, isDepOptimizationDisabled, isFileLoadingAllowed, isFileServingAllowed, isResolvedConfig, isRunnableDevEnvironment, loadCachedDepOptimizationMetadata, loadConfigFromFile, loadEnv, mergeAlias, mergeConfig, normalizePath, onRollupLog, optimizeDeps, optimizeExplicitEnvironmentDeps, optimizedDepInfoFromFile, optimizedDepInfoFromId, optimizedDepNeedsInterop, perEnvironmentPlugin, perEnvironmentState, preprocessCSS, preview, resolveBaseUrl, resolveBuildEnvironmentOptions, resolveBuildOutputs, resolveBuildPlugins, resolveBuilderOptions, resolveConfig, resolveDevEnvironmentOptions, resolveEnvPrefix, resolveLibFilename, resolvePreviewOptions, resolveServerOptions, resolveUserExternal, restartServerWithUrls, rollupVersion, runOptimizeDeps, runnerImport, searchForWorkspaceRoot, send, serverConfigDefaults, sortUserPlugins, ssrTransform, toDiscoveredDependencies, toOutputFilePathInCss, toOutputFilePathInHtml, toOutputFilePathInJS, toOutputFilePathWithoutRuntime, transformWithEsbuild };

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\vitest\node_modules\vite\types\package.json
============================================================
{
  "//": "this file is here to make typescript happy when moduleResolution=node16+",
  "version": "0.0.0"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\vitest\node_modules\vite\package.json
============================================================
{
  "name": "vite",
  "version": "7.1.11",
  "type": "module",
  "license": "MIT",
  "author": "Evan You",
  "description": "Native-ESM powered web dev build tool",
  "bin": {
    "vite": "bin/vite.js"
  },
  "keywords": [
    "frontend",
    "framework",
    "hmr",
    "dev-server",
    "build-tool",
    "vite"
  ],
  "main": "./dist/node/index.js",
  "types": "./dist/node/index.d.ts",
  "exports": {
    ".": "./dist/node/index.js",
    "./client": {
      "types": "./client.d.ts"
    },
    "./module-runner": "./dist/node/module-runner.js",
    "./dist/client/*": "./dist/client/*",
    "./types/*": {
      "types": "./types/*"
    },
    "./types/internal/*": null,
    "./package.json": "./package.json"
  },
  "typesVersions": {
    "*": {
      "module-runner": [
        "dist/node/module-runner.d.ts"
      ]
    }
  },
  "imports": {
    "#module-sync-enabled": {
      "module-sync": "./misc/true.js",
      "default": "./misc/false.js"
    },
    "#types/*": "./types/*.d.ts",
    "#dep-types/*": "./src/types/*.d.ts"
  },
  "files": [
    "bin",
    "dist",
    "misc/**/*.js",
    "client.d.ts",
    "types"
  ],
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitejs/vite.git",
    "directory": "packages/vite"
  },
  "bugs": {
    "url": "https://github.com/vitejs/vite/issues"
  },
  "homepage": "https://vite.dev",
  "funding": "https://github.com/vitejs/vite?sponsor=1",
  "//": "READ CONTRIBUTING.md to understand what to put under deps vs. devDeps!",
  "dependencies": {
    "esbuild": "^0.25.0",
    "fdir": "^6.5.0",
    "picomatch": "^4.0.3",
    "postcss": "^8.5.6",
    "rollup": "^4.43.0",
    "tinyglobby": "^0.2.15"
  },
  "optionalDependencies": {
    "fsevents": "~2.3.3"
  },
  "devDependencies": {
    "@babel/parser": "^7.28.4",
    "@jridgewell/remapping": "^2.3.5",
    "@jridgewell/trace-mapping": "^0.3.31",
    "@oxc-project/types": "0.90.0",
    "@polka/compression": "^1.0.0-next.25",
    "@rolldown/pluginutils": "^1.0.0-beta.43",
    "@rollup/plugin-alias": "^5.1.1",
    "@rollup/plugin-commonjs": "^28.0.8",
    "@rollup/plugin-dynamic-import-vars": "2.1.4",
    "@rollup/pluginutils": "^5.3.0",
    "@types/escape-html": "^1.0.4",
    "@types/pnpapi": "^0.0.5",
    "artichokie": "^0.4.2",
    "baseline-browser-mapping": "^2.8.18",
    "cac": "^6.7.14",
    "chokidar": "^3.6.0",
    "connect": "^3.7.0",
    "convert-source-map": "^2.0.0",
    "cors": "^2.8.5",
    "cross-spawn": "^7.0.6",
    "debug": "^4.4.3",
    "dotenv": "^17.2.3",
    "dotenv-expand": "^12.0.3",
    "es-module-lexer": "^1.7.0",
    "escape-html": "^1.0.3",
    "estree-walker": "^3.0.3",
    "etag": "^1.8.1",
    "host-validation-middleware": "^0.1.2",
    "http-proxy-3": "^1.22.0",
    "launch-editor-middleware": "^2.11.1",
    "lightningcss": "^1.30.2",
    "magic-string": "^0.30.19",
    "mlly": "^1.8.0",
    "mrmime": "^2.0.1",
    "nanoid": "^5.1.6",
    "open": "^10.2.0",
    "parse5": "^8.0.0",
    "pathe": "^2.0.3",
    "periscopic": "^4.0.2",
    "picocolors": "^1.1.1",
    "postcss-import": "^16.1.1",
    "postcss-load-config": "^6.0.1",
    "postcss-modules": "^6.0.1",
    "premove": "^4.0.0",
    "resolve.exports": "^2.0.3",
    "rolldown": "^1.0.0-beta.43",
    "rolldown-plugin-dts": "^0.16.11",
    "rollup-plugin-license": "^3.6.0",
    "sass": "^1.93.2",
    "sass-embedded": "^1.93.2",
    "sirv": "^3.0.2",
    "strip-literal": "^3.1.0",
    "terser": "^5.44.0",
    "tsconfck": "^3.1.6",
    "ufo": "^1.6.1",
    "ws": "^8.18.3"
  },
  "peerDependencies": {
    "@types/node": "^20.19.0 || >=22.12.0",
    "jiti": ">=1.21.0",
    "less": "^4.0.0",
    "lightningcss": "^1.21.0",
    "sass": "^1.70.0",
    "sass-embedded": "^1.70.0",
    "stylus": ">=0.54.8",
    "sugarss": "^5.0.0",
    "terser": "^5.16.0",
    "tsx": "^4.8.1",
    "yaml": "^2.4.2"
  },
  "peerDependenciesMeta": {
    "@types/node": {
      "optional": true
    },
    "jiti": {
      "optional": true
    },
    "sass": {
      "optional": true
    },
    "sass-embedded": {
      "optional": true
    },
    "stylus": {
      "optional": true
    },
    "less": {
      "optional": true
    },
    "sugarss": {
      "optional": true
    },
    "lightningcss": {
      "optional": true
    },
    "terser": {
      "optional": true
    },
    "tsx": {
      "optional": true
    },
    "yaml": {
      "optional": true
    }
  },
  "scripts": {
    "dev": "premove dist && pnpm build-bundle -w",
    "build": "premove dist && pnpm build-bundle && pnpm build-types",
    "build-bundle": "rolldown --config rolldown.config.ts",
    "build-types": "pnpm build-types-roll && pnpm build-types-check",
    "build-types-roll": "rolldown --config rolldown.dts.config.ts",
    "build-types-check": "tsc --project tsconfig.check.json",
    "typecheck": "tsc && tsc -p src/node",
    "lint": "eslint --cache --ext .ts src/**",
    "format": "prettier --write --cache --parser typescript \"src/**/*.ts\"",
    "generate-target": "tsx scripts/generateTarget.ts"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\vitest\package.json
============================================================
{
  "name": "vitest",
  "type": "module",
  "version": "4.0.1",
  "description": "Next generation testing framework powered by Vite",
  "author": "Anthony Fu <anthonyfu117@hotmail.com>",
  "license": "MIT",
  "funding": "https://opencollective.com/vitest",
  "homepage": "https://vitest.dev",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitest-dev/vitest.git",
    "directory": "packages/vitest"
  },
  "bugs": {
    "url": "https://github.com/vitest-dev/vitest/issues"
  },
  "keywords": [
    "vite",
    "vitest",
    "test",
    "jest"
  ],
  "sideEffects": false,
  "imports": {
    "#module-evaluator": {
      "types": "./dist/module-evaluator.d.ts",
      "default": "./dist/module-evaluator.js"
    }
  },
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      },
      "require": {
        "types": "./index.d.cts",
        "default": "./index.cjs"
      }
    },
    "./browser": {
      "types": "./browser/context.d.ts",
      "default": "./browser/context.js"
    },
    "./package.json": "./package.json",
    "./optional-types.js": {
      "types": "./optional-types.d.ts"
    },
    "./src/*": "./src/*",
    "./globals": {
      "types": "./globals.d.ts"
    },
    "./jsdom": {
      "types": "./jsdom.d.ts"
    },
    "./importMeta": {
      "types": "./importMeta.d.ts"
    },
    "./import-meta": {
      "types": "./import-meta.d.ts"
    },
    "./node": {
      "types": "./dist/node.d.ts",
      "default": "./dist/node.js"
    },
    "./internal/browser": {
      "types": "./dist/browser.d.ts",
      "default": "./dist/browser.js"
    },
    "./internal/module-runner": {
      "types": "./dist/module-runner.d.ts",
      "default": "./dist/module-runner.js"
    },
    "./runners": {
      "types": "./dist/runners.d.ts",
      "default": "./dist/runners.js"
    },
    "./suite": {
      "types": "./dist/suite.d.ts",
      "default": "./dist/suite.js"
    },
    "./environments": {
      "types": "./dist/environments.d.ts",
      "default": "./dist/environments.js"
    },
    "./config": {
      "types": "./config.d.ts",
      "require": "./dist/config.cjs",
      "default": "./dist/config.js"
    },
    "./coverage": {
      "types": "./coverage.d.ts",
      "default": "./dist/coverage.js"
    },
    "./reporters": {
      "types": "./dist/reporters.d.ts",
      "default": "./dist/reporters.js"
    },
    "./snapshot": {
      "types": "./dist/snapshot.d.ts",
      "default": "./dist/snapshot.js"
    },
    "./mocker": {
      "types": "./dist/mocker.d.ts",
      "default": "./dist/mocker.js"
    },
    "./worker": {
      "types": "./worker.d.ts",
      "default": "./dist/worker.js"
    }
  },
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "bin": {
    "vitest": "./vitest.mjs"
  },
  "files": [
    "*.cjs",
    "*.d.cts",
    "*.d.ts",
    "*.mjs",
    "bin",
    "browser",
    "dist"
  ],
  "engines": {
    "node": "^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "peerDependencies": {
    "@edge-runtime/vm": "*",
    "@types/debug": "^4.1.12",
    "@types/node": "^20.0.0 || ^22.0.0 || >=24.0.0",
    "happy-dom": "*",
    "jsdom": "*",
    "@vitest/browser-preview": "4.0.1",
    "@vitest/browser-playwright": "4.0.1",
    "@vitest/browser-webdriverio": "4.0.1",
    "@vitest/ui": "4.0.1"
  },
  "peerDependenciesMeta": {
    "@edge-runtime/vm": {
      "optional": true
    },
    "@types/debug": {
      "optional": true
    },
    "@types/node": {
      "optional": true
    },
    "@vitest/browser-playwright": {
      "optional": true
    },
    "@vitest/browser-preview": {
      "optional": true
    },
    "@vitest/browser-webdriverio": {
      "optional": true
    },
    "@vitest/ui": {
      "optional": true
    },
    "happy-dom": {
      "optional": true
    },
    "jsdom": {
      "optional": true
    }
  },
  "dependencies": {
    "debug": "^4.4.3",
    "es-module-lexer": "^1.7.0",
    "expect-type": "^1.2.2",
    "magic-string": "^0.30.19",
    "pathe": "^2.0.3",
    "picomatch": "^4.0.3",
    "std-env": "^3.9.0",
    "tinybench": "^2.9.0",
    "tinyexec": "^0.3.2",
    "tinyglobby": "^0.2.15",
    "tinyrainbow": "^3.0.3",
    "vite": "^6.0.0 || ^7.0.0",
    "why-is-node-running": "^2.3.0",
    "@vitest/expect": "4.0.1",
    "@vitest/mocker": "4.0.1",
    "@vitest/pretty-format": "4.0.1",
    "@vitest/runner": "4.0.1",
    "@vitest/snapshot": "4.0.1",
    "@vitest/spy": "4.0.1",
    "@vitest/utils": "4.0.1"
  },
  "devDependencies": {
    "@antfu/install-pkg": "^1.1.0",
    "@edge-runtime/vm": "^5.0.0",
    "@jridgewell/trace-mapping": "0.3.31",
    "@sinonjs/fake-timers": "14.0.0",
    "@types/debug": "^4.1.12",
    "@types/estree": "^1.0.8",
    "@types/istanbul-lib-coverage": "^2.0.6",
    "@types/istanbul-reports": "^3.0.4",
    "@types/jsdom": "^21.1.7",
    "@types/node": "^22.18.6",
    "@types/picomatch": "^4.0.2",
    "@types/prompts": "^2.4.9",
    "@types/sinonjs__fake-timers": "^8.1.5",
    "acorn-walk": "^8.3.4",
    "birpc": "^2.5.0",
    "cac": "^6.7.14",
    "empathic": "^2.0.0",
    "flatted": "^3.3.3",
    "happy-dom": "^20.0.0",
    "jsdom": "^26.1.0",
    "local-pkg": "^1.1.2",
    "mime": "^4.1.0",
    "prompts": "^2.4.2",
    "strip-literal": "^3.0.0",
    "ws": "^8.18.3"
  },
  "scripts": {
    "build": "premove dist && rollup -c",
    "dev": "NODE_OPTIONS=\"--max-old-space-size=8192\" rollup -c --watch -m inline"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\void-elements\package.json
============================================================
{
  "name": "void-elements",
  "version": "3.1.0",
  "description": "Array of \"void elements\" defined by the HTML specification.",
  "main": "index.js",
  "scripts": {
    "pretest": "node build.js > test/latest.js",
    "test": "node test",
    "update": "node build.js > index.js"
  },
  "keywords": [
    "html",
    "void",
    "elements"
  ],
  "files": [
    "index.js"
  ],
  "repository": "pugjs/void-elements",
  "author": "hemanth.hm",
  "engines": {
    "node": ">=0.10.0"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/jadejs/void-elements/issues"
  },
  "homepage": "https://github.com/jadejs/void-elements",
  "devDependencies": {
    "jsdom": "^9.9.1",
    "request": "^2.79.0",
    "request-promise": "^4.1.1"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\w3c-xmlserializer\package.json
============================================================
{
  "name": "w3c-xmlserializer",
  "description": "A per-spec XML serializer implementation",
  "keywords": [
    "dom",
    "w3c",
    "xml",
    "xmlserializer"
  ],
  "version": "5.0.0",
  "license": "MIT",
  "dependencies": {
    "xml-name-validator": "^5.0.0"
  },
  "devDependencies": {
    "@domenic/eslint-config": "^3.0.0",
    "eslint": "^8.53.0",
    "jsdom": "^22.1.0"
  },
  "repository": "jsdom/w3c-xmlserializer",
  "files": [
    "lib/"
  ],
  "main": "lib/serialize.js",
  "scripts": {
    "test": "node --test",
    "lint": "eslint ."
  },
  "engines": {
    "node": ">=18"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\walker\package.json
============================================================
{
  "name": "walker",
  "description": "A simple directory tree walker.",
  "version": "1.0.8",
  "homepage": "https://github.com/daaku/nodejs-walker",
  "author": "Naitik Shah <n@daaku.org>",
  "keywords": [
    "utils",
    "fs",
    "filesystem"
  ],
  "main": "lib/walker",
  "repository": {
    "type": "git",
    "url": "https://github.com/daaku/nodejs-walker"
  },
  "scripts": {
    "test": "NODE_PATH=./lib mocha --ui exports"
  },
  "dependencies": {
    "makeerror": "1.0.12"
  },
  "devDependencies": {
    "mocha": "9.1.3"
  },
  "license": "Apache-2.0"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\webidl-conversions\package.json
============================================================
{
  "name": "webidl-conversions",
  "version": "8.0.0",
  "description": "Implements the WebIDL algorithms for converting to and from JavaScript values",
  "main": "lib/index.js",
  "scripts": {
    "lint": "eslint .",
    "test": "node --test",
    "coverage": "c8 node --test --experimental-test-coverage test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jsdom/webidl-conversions.git"
  },
  "keywords": [
    "webidl",
    "web",
    "types"
  ],
  "files": [
    "lib/"
  ],
  "author": "Domenic Denicola <d@domenic.me> (https://domenic.me/)",
  "license": "BSD-2-Clause",
  "devDependencies": {
    "@domenic/eslint-config": "^4.0.1",
    "c8": "^10.1.3",
    "eslint": "^9.35.0",
    "globals": "^16.3.0"
  },
  "engines": {
    "node": ">=20"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\whatwg-encoding\package.json
============================================================
{
  "name": "whatwg-encoding",
  "description": "Decode strings according to the WHATWG Encoding Standard",
  "keywords": [
    "encoding",
    "whatwg"
  ],
  "version": "3.1.1",
  "author": "Domenic Denicola <d@domenic.me> (https://domenic.me/)",
  "license": "MIT",
  "repository": "jsdom/whatwg-encoding",
  "main": "lib/whatwg-encoding.js",
  "files": [
    "lib/"
  ],
  "scripts": {
    "pretest": "npm run prepare",
    "test": "node --test",
    "lint": "eslint .",
    "prepare": "node scripts/update.js"
  },
  "dependencies": {
    "iconv-lite": "0.6.3"
  },
  "devDependencies": {
    "@domenic/eslint-config": "^3.0.0",
    "eslint": "^8.53.0"
  },
  "engines": {
    "node": ">=18"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\whatwg-mimetype\package.json
============================================================
{
  "name": "whatwg-mimetype",
  "description": "Parses, serializes, and manipulates MIME types, according to the WHATWG MIME Sniffing Standard",
  "keywords": [
    "content-type",
    "mime type",
    "mimesniff",
    "http",
    "whatwg"
  ],
  "version": "4.0.0",
  "author": "Domenic Denicola <d@domenic.me> (https://domenic.me/)",
  "license": "MIT",
  "repository": "jsdom/whatwg-mimetype",
  "main": "lib/mime-type.js",
  "files": [
    "lib/"
  ],
  "scripts": {
    "test": "node --test",
    "coverage": "c8 node --test --experimental-test-coverage",
    "lint": "eslint .",
    "pretest": "node scripts/get-latest-platform-tests.js"
  },
  "devDependencies": {
    "@domenic/eslint-config": "^3.0.0",
    "c8": "^8.0.1",
    "eslint": "^8.53.0",
    "printable-string": "^0.3.0",
    "whatwg-encoding": "^3.0.0"
  },
  "engines": {
    "node": ">=18"
  },
  "c8": {
    "reporter": [
      "text",
      "html"
    ],
    "exclude": [
      "scripts/",
      "test/"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\whatwg-url\package.json
============================================================
{
  "name": "whatwg-url",
  "version": "15.1.0",
  "description": "An implementation of the WHATWG URL Standard's URL API and parsing machinery",
  "main": "index.js",
  "files": [
    "index.js",
    "webidl2js-wrapper.js",
    "lib/*.js"
  ],
  "author": "Sebastian Mayr <github@smayr.name>",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jsdom/whatwg-url.git"
  },
  "dependencies": {
    "tr46": "^6.0.0",
    "webidl-conversions": "^8.0.0"
  },
  "devDependencies": {
    "@domenic/eslint-config": "^4.0.1",
    "benchmark": "^2.1.4",
    "c8": "^10.1.3",
    "esbuild": "^0.25.9",
    "eslint": "^9.35.0",
    "globals": "^16.4.0",
    "webidl2js": "^19.0.0"
  },
  "engines": {
    "node": ">=20"
  },
  "scripts": {
    "coverage": "c8 node --test --experimental-test-coverage test/*.js",
    "lint": "eslint",
    "prepare": "node scripts/transform.js",
    "pretest": "node scripts/get-latest-platform-tests.js && node scripts/transform.js",
    "build-live-viewer": "esbuild --bundle --format=esm --sourcemap --outfile=live-viewer/whatwg-url.mjs index.js",
    "test": "node --test test/*.js",
    "bench": "node scripts/benchmark.js"
  },
  "c8": {
    "reporter": [
      "text",
      "html"
    ],
    "exclude": [
      "lib/Function.js",
      "lib/URL.js",
      "lib/URLSearchParams.js",
      "lib/utils.js",
      "scripts/",
      "test/"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\which\package.json
============================================================
{
  "author": "Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me)",
  "name": "which",
  "description": "Like which(1) unix command. Find the first instance of an executable in the PATH.",
  "version": "2.0.2",
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/node-which.git"
  },
  "main": "which.js",
  "bin": {
    "node-which": "./bin/node-which"
  },
  "license": "ISC",
  "dependencies": {
    "isexe": "^2.0.0"
  },
  "devDependencies": {
    "mkdirp": "^0.5.0",
    "rimraf": "^2.6.2",
    "tap": "^14.6.9"
  },
  "scripts": {
    "test": "tap",
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublish": "npm run changelog",
    "prechangelog": "bash gen-changelog.sh",
    "changelog": "git add CHANGELOG.md",
    "postchangelog": "git commit -m 'update changelog - '${npm_package_version}",
    "postpublish": "git push origin --follow-tags"
  },
  "files": [
    "which.js",
    "bin/node-which"
  ],
  "tap": {
    "check-coverage": true
  },
  "engines": {
    "node": ">= 8"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\why-is-node-running\package.json
============================================================
{
  "name": "why-is-node-running",
  "version": "2.3.0",
  "description": "Node is running but you don't know why? why-is-node-running is here to help you.",
  "main": "index.js",
  "dependencies": {
    "siginfo": "^2.0.0",
    "stackback": "0.0.2"
  },
  "bin": {
    "why-is-node-running": "cli.js"
  },
  "engines": {
    "node": ">=8"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mafintosh/why-is-node-running.git"
  },
  "keywords": [
    "debug",
    "devops",
    "test",
    "events",
    "handles"
  ],
  "author": "Mathias Buus (@mafintosh)",
  "contributors": [
    {
      "name": "Jon Peck",
      "email": "jpeck@fluxsauce.com"
    }
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/mafintosh/why-is-node-running/issues"
  },
  "homepage": "https://github.com/mafintosh/why-is-node-running"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\wrap-ansi\node_modules\ansi-styles\package.json
============================================================
{
	"name": "ansi-styles",
	"version": "6.2.3",
	"description": "ANSI escape codes for styling strings in the terminal",
	"license": "MIT",
	"repository": "chalk/ansi-styles",
	"funding": "https://github.com/chalk/ansi-styles?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"type": "module",
	"exports": "./index.js",
	"engines": {
		"node": ">=12"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"screenshot": "svg-term --command='node screenshot' --out=screenshot.svg --padding=3 --width=55 --height=3 --at=1000 --no-cursor"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"devDependencies": {
		"ava": "^6.1.3",
		"svg-term-cli": "^2.1.1",
		"tsd": "^0.31.1",
		"xo": "^0.58.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\wrap-ansi\package.json
============================================================
{
	"name": "wrap-ansi",
	"version": "8.1.0",
	"description": "Wordwrap a string with ANSI escape codes",
	"license": "MIT",
	"repository": "chalk/wrap-ansi",
	"funding": "https://github.com/chalk/wrap-ansi?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"type": "module",
	"exports": {
		"types": "./index.d.ts",
		"default": "./index.js"
	},
	"engines": {
		"node": ">=12"
	},
	"scripts": {
		"test": "xo && nyc ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"wrap",
		"break",
		"wordwrap",
		"wordbreak",
		"linewrap",
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"dependencies": {
		"ansi-styles": "^6.1.0",
		"string-width": "^5.0.1",
		"strip-ansi": "^7.0.1"
	},
	"devDependencies": {
		"ava": "^3.15.0",
		"chalk": "^4.1.2",
		"coveralls": "^3.1.1",
		"has-ansi": "^5.0.1",
		"nyc": "^15.1.0",
		"tsd": "^0.25.0",
		"xo": "^0.44.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\wrap-ansi-cjs\node_modules\emoji-regex\package.json
============================================================
{
  "name": "emoji-regex",
  "version": "8.0.0",
  "description": "A regular expression to match all Emoji-only symbols as per the Unicode Standard.",
  "homepage": "https://mths.be/emoji-regex",
  "main": "index.js",
  "types": "index.d.ts",
  "keywords": [
    "unicode",
    "regex",
    "regexp",
    "regular expressions",
    "code points",
    "symbols",
    "characters",
    "emoji"
  ],
  "license": "MIT",
  "author": {
    "name": "Mathias Bynens",
    "url": "https://mathiasbynens.be/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mathiasbynens/emoji-regex.git"
  },
  "bugs": "https://github.com/mathiasbynens/emoji-regex/issues",
  "files": [
    "LICENSE-MIT.txt",
    "index.js",
    "index.d.ts",
    "text.js",
    "es2015/index.js",
    "es2015/text.js"
  ],
  "scripts": {
    "build": "rm -rf -- es2015; babel src -d .; NODE_ENV=es2015 babel src -d ./es2015; node script/inject-sequences.js",
    "test": "mocha",
    "test:watch": "npm run test -- --watch"
  },
  "devDependencies": {
    "@babel/cli": "^7.2.3",
    "@babel/core": "^7.3.4",
    "@babel/plugin-proposal-unicode-property-regex": "^7.2.0",
    "@babel/preset-env": "^7.3.4",
    "mocha": "^6.0.2",
    "regexgen": "^1.3.0",
    "unicode-12.0.0": "^0.7.9"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\wrap-ansi-cjs\node_modules\string-width\package.json
============================================================
{
	"name": "string-width",
	"version": "4.2.3",
	"description": "Get the visual width of a string - the number of columns required to display it",
	"license": "MIT",
	"repository": "sindresorhus/string-width",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"string",
		"character",
		"unicode",
		"width",
		"visual",
		"column",
		"columns",
		"fullwidth",
		"full-width",
		"full",
		"ansi",
		"escape",
		"codes",
		"cli",
		"command-line",
		"terminal",
		"console",
		"cjk",
		"chinese",
		"japanese",
		"korean",
		"fixed-width"
	],
	"dependencies": {
		"emoji-regex": "^8.0.0",
		"is-fullwidth-code-point": "^3.0.0",
		"strip-ansi": "^6.0.1"
	},
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.1",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\wrap-ansi-cjs\node_modules\strip-ansi\package.json
============================================================
{
	"name": "strip-ansi",
	"version": "6.0.1",
	"description": "Strip ANSI escape codes from a string",
	"license": "MIT",
	"repository": "chalk/strip-ansi",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"strip",
		"trim",
		"remove",
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"dependencies": {
		"ansi-regex": "^5.0.1"
	},
	"devDependencies": {
		"ava": "^2.4.0",
		"tsd": "^0.10.0",
		"xo": "^0.25.3"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\wrap-ansi-cjs\package.json
============================================================
{
	"name": "wrap-ansi",
	"version": "7.0.0",
	"description": "Wordwrap a string with ANSI escape codes",
	"license": "MIT",
	"repository": "chalk/wrap-ansi",
	"funding": "https://github.com/chalk/wrap-ansi?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && nyc ava"
	},
	"files": [
		"index.js"
	],
	"keywords": [
		"wrap",
		"break",
		"wordwrap",
		"wordbreak",
		"linewrap",
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"dependencies": {
		"ansi-styles": "^4.0.0",
		"string-width": "^4.1.0",
		"strip-ansi": "^6.0.0"
	},
	"devDependencies": {
		"ava": "^2.1.0",
		"chalk": "^4.0.0",
		"coveralls": "^3.0.3",
		"has-ansi": "^4.0.0",
		"nyc": "^15.0.1",
		"xo": "^0.29.1"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\wrappy\package.json
============================================================
{
  "name": "wrappy",
  "version": "1.0.2",
  "description": "Callback wrapping utility",
  "main": "wrappy.js",
  "files": [
    "wrappy.js"
  ],
  "directories": {
    "test": "test"
  },
  "dependencies": {},
  "devDependencies": {
    "tap": "^2.3.1"
  },
  "scripts": {
    "test": "tap --coverage test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/npm/wrappy"
  },
  "author": "Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/npm/wrappy/issues"
  },
  "homepage": "https://github.com/npm/wrappy"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\write-file-atomic\package.json
============================================================
{
  "name": "write-file-atomic",
  "version": "5.0.1",
  "description": "Write files in an atomic fashion w/configurable ownership",
  "main": "./lib/index.js",
  "scripts": {
    "test": "tap",
    "posttest": "npm run lint",
    "lint": "eslint \"**/*.js\"",
    "postlint": "template-oss-check",
    "lintfix": "npm run lint -- --fix",
    "snap": "tap",
    "template-oss-apply": "template-oss-apply --force"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/npm/write-file-atomic.git"
  },
  "keywords": [
    "writeFile",
    "atomic"
  ],
  "author": "GitHub Inc.",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/npm/write-file-atomic/issues"
  },
  "homepage": "https://github.com/npm/write-file-atomic",
  "dependencies": {
    "imurmurhash": "^0.1.4",
    "signal-exit": "^4.0.1"
  },
  "devDependencies": {
    "@npmcli/eslint-config": "^4.0.0",
    "@npmcli/template-oss": "4.14.1",
    "tap": "^16.0.1"
  },
  "files": [
    "bin/",
    "lib/"
  ],
  "engines": {
    "node": "^14.17.0 || ^16.13.0 || >=18.0.0"
  },
  "templateOSS": {
    "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
    "windowsCI": false,
    "version": "4.14.1",
    "publish": "true"
  },
  "tap": {
    "nyc-arg": [
      "--exclude",
      "tap-snapshots/**"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\ws\package.json
============================================================
{
  "name": "ws",
  "version": "8.18.3",
  "description": "Simple to use, blazing fast and thoroughly tested websocket client and server for Node.js",
  "keywords": [
    "HyBi",
    "Push",
    "RFC-6455",
    "WebSocket",
    "WebSockets",
    "real-time"
  ],
  "homepage": "https://github.com/websockets/ws",
  "bugs": "https://github.com/websockets/ws/issues",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/websockets/ws.git"
  },
  "author": "Einar Otto Stangvik <einaros@gmail.com> (http://2x.io)",
  "license": "MIT",
  "main": "index.js",
  "exports": {
    ".": {
      "browser": "./browser.js",
      "import": "./wrapper.mjs",
      "require": "./index.js"
    },
    "./package.json": "./package.json"
  },
  "browser": "browser.js",
  "engines": {
    "node": ">=10.0.0"
  },
  "files": [
    "browser.js",
    "index.js",
    "lib/*.js",
    "wrapper.mjs"
  ],
  "scripts": {
    "test": "nyc --reporter=lcov --reporter=text mocha --throw-deprecation test/*.test.js",
    "integration": "mocha --throw-deprecation test/*.integration.js",
    "lint": "eslint . && prettier --check --ignore-path .gitignore \"**/*.{json,md,yaml,yml}\""
  },
  "peerDependencies": {
    "bufferutil": "^4.0.1",
    "utf-8-validate": ">=5.0.2"
  },
  "peerDependenciesMeta": {
    "bufferutil": {
      "optional": true
    },
    "utf-8-validate": {
      "optional": true
    }
  },
  "devDependencies": {
    "benchmark": "^2.1.4",
    "bufferutil": "^4.0.1",
    "eslint": "^9.0.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.0.0",
    "globals": "^16.0.0",
    "mocha": "^8.4.0",
    "nyc": "^15.0.0",
    "prettier": "^3.0.0",
    "utf-8-validate": "^6.0.0"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\xml-name-validator\package.json
============================================================
{
  "name": "xml-name-validator",
  "description": "Validates whether a string matches the production for an XML name or qualified name",
  "keywords": [
    "xml",
    "name",
    "qname"
  ],
  "version": "5.0.0",
  "author": "Domenic Denicola <d@domenic.me> (https://domenic.me/)",
  "license": "Apache-2.0",
  "repository": "jsdom/xml-name-validator",
  "main": "lib/xml-name-validator.js",
  "files": [
    "lib/"
  ],
  "scripts": {
    "test": "node --test",
    "benchmark": "node scripts/benchmark.js",
    "lint": "eslint ."
  },
  "devDependencies": {
    "@domenic/eslint-config": "^3.0.0",
    "benchmark": "^2.1.4",
    "eslint": "^8.53.0"
  },
  "engines": {
    "node": ">=18"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\xmlchars\package.json
============================================================
{
  "name": "xmlchars",
  "version": "2.2.0",
  "description": "Utilities for determining if characters belong to character classes defined by the XML specs.",
  "keywords": [
    "XML",
    "validation"
  ],
  "main": "xmlchars.js",
  "types": "xmlchars.d.ts",
  "repository": "https://github.com/lddubeau/xmlchars.git",
  "author": "Louis-Dominique Dubeau <ldd@lddubeau.com>",
  "license": "MIT",
  "devDependencies": {
    "@commitlint/cli": "^8.1.0",
    "@commitlint/config-angular": "^8.1.0",
    "@types/chai": "^4.2.1",
    "@types/mocha": "^5.2.7",
    "chai": "^4.2.0",
    "conventional-changelog-cli": "^2.0.23",
    "husky": "^3.0.5",
    "mocha": "^6.2.0",
    "ts-node": "^8.3.0",
    "tslint": "^5.19.0",
    "tslint-config-lddubeau": "^4.1.0",
    "typescript": "^3.6.2"
  },
  "scripts": {
    "copy": "cp README.md LICENSE build/dist && sed -e'/\"private\": true/d' package.json > build/dist/package.json",
    "build": "tsc && npm run copy",
    "pretest": "npm run build",
    "test": "mocha",
    "posttest": "tslint -p tsconfig.json && tslint -p test/tsconfig.json",
    "prepack": "node -e 'require(\"assert\")(!require(\"./package.json\").private)'",
    "test-install": "npm run test && (test_dir=build/install_dir; rm -rf $test_dir; mkdir -p $test_dir/node_modules; packname=`npm run xmlchars:pack --silent`; (cd $test_dir; npm install ../$packname); rm -rf $test_dir)",
    "xmlchars:pack": "cd build/dist/ && (packname=`npm pack --silent`; mv $packname ..; echo $packname)",
    "prepublishOnly": "node -e 'require(\"assert\")(!require(\"./package.json\").private)'",
    "xmlchars:publish": "npm run test-install && (cd build/dist && npm publish)",
    "preversion": "npm run test-install",
    "version": "conventional-changelog -p angular -i CHANGELOG.md -s && git add CHANGELOG.md",
    "postversion": "npm run xmlchars:publish",
    "postpublish": "git push origin --follow-tags",
    "clean": "rm -rf build"
  },
  "dependencies": {},
  "husky": {
    "hooks": {
      "commit-msg": "commitlint -e $HUSKY_GIT_PARAMS"
    }
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\y18n\package.json
============================================================
{
  "name": "y18n",
  "version": "5.0.8",
  "description": "the bare-bones internationalization library used by yargs",
  "exports": {
    ".": [
      {
        "import": "./index.mjs",
        "require": "./build/index.cjs"
      },
      "./build/index.cjs"
    ]
  },
  "type": "module",
  "module": "./build/lib/index.js",
  "keywords": [
    "i18n",
    "internationalization",
    "yargs"
  ],
  "homepage": "https://github.com/yargs/y18n",
  "bugs": {
    "url": "https://github.com/yargs/y18n/issues"
  },
  "repository": "yargs/y18n",
  "license": "ISC",
  "author": "Ben Coe <bencoe@gmail.com>",
  "main": "./build/index.cjs",
  "scripts": {
    "check": "standardx **/*.ts **/*.cjs **/*.mjs",
    "fix": "standardx --fix **/*.ts **/*.cjs **/*.mjs",
    "pretest": "rimraf build && tsc -p tsconfig.test.json && cross-env NODE_ENV=test npm run build:cjs",
    "test": "c8 --reporter=text --reporter=html mocha test/*.cjs",
    "test:esm": "c8 --reporter=text --reporter=html mocha test/esm/*.mjs",
    "posttest": "npm run check",
    "coverage": "c8 report --check-coverage",
    "precompile": "rimraf build",
    "compile": "tsc",
    "postcompile": "npm run build:cjs",
    "build:cjs": "rollup -c",
    "prepare": "npm run compile"
  },
  "devDependencies": {
    "@types/node": "^14.6.4",
    "@wessberg/rollup-plugin-ts": "^1.3.1",
    "c8": "^7.3.0",
    "chai": "^4.0.1",
    "cross-env": "^7.0.2",
    "gts": "^3.0.0",
    "mocha": "^8.0.0",
    "rimraf": "^3.0.2",
    "rollup": "^2.26.10",
    "standardx": "^7.0.0",
    "ts-transform-default-export": "^1.0.2",
    "typescript": "^4.0.0"
  },
  "files": [
    "build",
    "index.mjs",
    "!*.d.ts"
  ],
  "engines": {
    "node": ">=10"
  },
  "standardx": {
    "ignore": [
      "build"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\yallist\package.json
============================================================
{
  "name": "yallist",
  "version": "3.1.1",
  "description": "Yet Another Linked List",
  "main": "yallist.js",
  "directories": {
    "test": "test"
  },
  "files": [
    "yallist.js",
    "iterator.js"
  ],
  "dependencies": {},
  "devDependencies": {
    "tap": "^12.1.0"
  },
  "scripts": {
    "test": "tap test/*.js --100",
    "preversion": "npm test",
    "postversion": "npm publish",
    "postpublish": "git push origin --all; git push origin --tags"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/isaacs/yallist.git"
  },
  "author": "Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)",
  "license": "ISC"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\yargs\helpers\package.json
============================================================
{
  "type": "commonjs"
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\yargs\node_modules\emoji-regex\package.json
============================================================
{
  "name": "emoji-regex",
  "version": "8.0.0",
  "description": "A regular expression to match all Emoji-only symbols as per the Unicode Standard.",
  "homepage": "https://mths.be/emoji-regex",
  "main": "index.js",
  "types": "index.d.ts",
  "keywords": [
    "unicode",
    "regex",
    "regexp",
    "regular expressions",
    "code points",
    "symbols",
    "characters",
    "emoji"
  ],
  "license": "MIT",
  "author": {
    "name": "Mathias Bynens",
    "url": "https://mathiasbynens.be/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mathiasbynens/emoji-regex.git"
  },
  "bugs": "https://github.com/mathiasbynens/emoji-regex/issues",
  "files": [
    "LICENSE-MIT.txt",
    "index.js",
    "index.d.ts",
    "text.js",
    "es2015/index.js",
    "es2015/text.js"
  ],
  "scripts": {
    "build": "rm -rf -- es2015; babel src -d .; NODE_ENV=es2015 babel src -d ./es2015; node script/inject-sequences.js",
    "test": "mocha",
    "test:watch": "npm run test -- --watch"
  },
  "devDependencies": {
    "@babel/cli": "^7.2.3",
    "@babel/core": "^7.3.4",
    "@babel/plugin-proposal-unicode-property-regex": "^7.2.0",
    "@babel/preset-env": "^7.3.4",
    "mocha": "^6.0.2",
    "regexgen": "^1.3.0",
    "unicode-12.0.0": "^0.7.9"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\yargs\node_modules\string-width\package.json
============================================================
{
	"name": "string-width",
	"version": "4.2.3",
	"description": "Get the visual width of a string - the number of columns required to display it",
	"license": "MIT",
	"repository": "sindresorhus/string-width",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"string",
		"character",
		"unicode",
		"width",
		"visual",
		"column",
		"columns",
		"fullwidth",
		"full-width",
		"full",
		"ansi",
		"escape",
		"codes",
		"cli",
		"command-line",
		"terminal",
		"console",
		"cjk",
		"chinese",
		"japanese",
		"korean",
		"fixed-width"
	],
	"dependencies": {
		"emoji-regex": "^8.0.0",
		"is-fullwidth-code-point": "^3.0.0",
		"strip-ansi": "^6.0.1"
	},
	"devDependencies": {
		"ava": "^1.4.1",
		"tsd": "^0.7.1",
		"xo": "^0.24.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\yargs\node_modules\strip-ansi\package.json
============================================================
{
	"name": "strip-ansi",
	"version": "6.0.1",
	"description": "Strip ANSI escape codes from a string",
	"license": "MIT",
	"repository": "chalk/strip-ansi",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "sindresorhus.com"
	},
	"engines": {
		"node": ">=8"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"strip",
		"trim",
		"remove",
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"dependencies": {
		"ansi-regex": "^5.0.1"
	},
	"devDependencies": {
		"ava": "^2.4.0",
		"tsd": "^0.10.0",
		"xo": "^0.25.3"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\yargs\package.json
============================================================
{
  "name": "yargs",
  "version": "17.7.2",
  "description": "yargs the modern, pirate-themed, successor to optimist.",
  "main": "./index.cjs",
  "exports": {
    "./package.json": "./package.json",
    ".": [
      {
        "import": "./index.mjs",
        "require": "./index.cjs"
      },
      "./index.cjs"
    ],
    "./helpers": {
      "import": "./helpers/helpers.mjs",
      "require": "./helpers/index.js"
    },
    "./browser": {
      "import": "./browser.mjs",
      "types": "./browser.d.ts"
    },
    "./yargs": [
      {
        "import": "./yargs.mjs",
        "require": "./yargs"
      },
      "./yargs"
    ]
  },
  "type": "module",
  "module": "./index.mjs",
  "contributors": [
    {
      "name": "Yargs Contributors",
      "url": "https://github.com/yargs/yargs/graphs/contributors"
    }
  ],
  "files": [
    "browser.mjs",
    "browser.d.ts",
    "index.cjs",
    "helpers/*.js",
    "helpers/*",
    "index.mjs",
    "yargs",
    "yargs.mjs",
    "build",
    "locales",
    "LICENSE",
    "lib/platform-shims/*.mjs",
    "!*.d.ts",
    "!**/*.d.ts"
  ],
  "dependencies": {
    "cliui": "^8.0.1",
    "escalade": "^3.1.1",
    "get-caller-file": "^2.0.5",
    "require-directory": "^2.1.1",
    "string-width": "^4.2.3",
    "y18n": "^5.0.5",
    "yargs-parser": "^21.1.1"
  },
  "devDependencies": {
    "@types/chai": "^4.2.11",
    "@types/mocha": "^9.0.0",
    "@types/node": "^18.0.0",
    "c8": "^7.7.0",
    "chai": "^4.2.0",
    "chalk": "^4.0.0",
    "coveralls": "^3.0.9",
    "cpr": "^3.0.1",
    "cross-env": "^7.0.2",
    "cross-spawn": "^7.0.0",
    "eslint": "^7.23.0",
    "gts": "^3.0.0",
    "hashish": "0.0.4",
    "mocha": "^9.0.0",
    "rimraf": "^3.0.2",
    "rollup": "^2.23.0",
    "rollup-plugin-cleanup": "^3.1.1",
    "rollup-plugin-terser": "^7.0.2",
    "rollup-plugin-ts": "^2.0.4",
    "typescript": "^4.0.2",
    "which": "^2.0.0",
    "yargs-test-extends": "^1.0.1"
  },
  "scripts": {
    "fix": "gts fix && npm run fix:js",
    "fix:js": "eslint . --ext cjs --ext mjs --ext js --fix",
    "posttest": "npm run check",
    "test": "c8 mocha --enable-source-maps ./test/*.cjs --require ./test/before.cjs --timeout=12000 --check-leaks",
    "test:esm": "c8 mocha --enable-source-maps ./test/esm/*.mjs --check-leaks",
    "coverage": "c8 report --check-coverage",
    "prepare": "npm run compile",
    "pretest": "npm run compile -- -p tsconfig.test.json && cross-env NODE_ENV=test npm run build:cjs",
    "compile": "rimraf build && tsc",
    "postcompile": "npm run build:cjs",
    "build:cjs": "rollup -c rollup.config.cjs",
    "postbuild:cjs": "rimraf ./build/index.cjs.d.ts",
    "check": "gts lint && npm run check:js",
    "check:js": "eslint . --ext cjs --ext mjs --ext js",
    "clean": "gts clean"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/yargs/yargs.git"
  },
  "homepage": "https://yargs.js.org/",
  "keywords": [
    "argument",
    "args",
    "option",
    "parser",
    "parsing",
    "cli",
    "command"
  ],
  "license": "MIT",
  "engines": {
    "node": ">=12"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\yargs-parser\package.json
============================================================
{
  "name": "yargs-parser",
  "version": "21.1.1",
  "description": "the mighty option parser used by yargs",
  "main": "build/index.cjs",
  "exports": {
    ".": [
      {
        "import": "./build/lib/index.js",
        "require": "./build/index.cjs"
      },
      "./build/index.cjs"
    ],
    "./browser": [
      "./browser.js"
    ]
  },
  "type": "module",
  "module": "./build/lib/index.js",
  "scripts": {
    "check": "standardx '**/*.ts' && standardx '**/*.js' && standardx '**/*.cjs'",
    "fix": "standardx --fix '**/*.ts' && standardx --fix '**/*.js' && standardx --fix '**/*.cjs'",
    "pretest": "rimraf build && tsc -p tsconfig.test.json && cross-env NODE_ENV=test npm run build:cjs",
    "test": "c8 --reporter=text --reporter=html mocha test/*.cjs",
    "test:esm": "c8 --reporter=text --reporter=html mocha test/*.mjs",
    "test:browser": "start-server-and-test 'serve ./ -p 8080' http://127.0.0.1:8080/package.json 'node ./test/browser/yargs-test.cjs'",
    "pretest:typescript": "npm run pretest",
    "test:typescript": "c8 mocha ./build/test/typescript/*.js",
    "coverage": "c8 report --check-coverage",
    "precompile": "rimraf build",
    "compile": "tsc",
    "postcompile": "npm run build:cjs",
    "build:cjs": "rollup -c",
    "prepare": "npm run compile"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/yargs/yargs-parser.git"
  },
  "keywords": [
    "argument",
    "parser",
    "yargs",
    "command",
    "cli",
    "parsing",
    "option",
    "args",
    "argument"
  ],
  "author": "Ben Coe <ben@npmjs.com>",
  "license": "ISC",
  "devDependencies": {
    "@types/chai": "^4.2.11",
    "@types/mocha": "^9.0.0",
    "@types/node": "^16.11.4",
    "@typescript-eslint/eslint-plugin": "^3.10.1",
    "@typescript-eslint/parser": "^3.10.1",
    "c8": "^7.3.0",
    "chai": "^4.2.0",
    "cross-env": "^7.0.2",
    "eslint": "^7.0.0",
    "eslint-plugin-import": "^2.20.1",
    "eslint-plugin-node": "^11.0.0",
    "gts": "^3.0.0",
    "mocha": "^10.0.0",
    "puppeteer": "^16.0.0",
    "rimraf": "^3.0.2",
    "rollup": "^2.22.1",
    "rollup-plugin-cleanup": "^3.1.1",
    "rollup-plugin-ts": "^3.0.2",
    "serve": "^14.0.0",
    "standardx": "^7.0.0",
    "start-server-and-test": "^1.11.2",
    "ts-transform-default-export": "^1.0.2",
    "typescript": "^4.0.0"
  },
  "files": [
    "browser.js",
    "build",
    "!*.d.ts",
    "!*.d.cts"
  ],
  "engines": {
    "node": ">=12"
  },
  "standardx": {
    "ignore": [
      "build"
    ]
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\node_modules\yocto-queue\package.json
============================================================
{
	"name": "yocto-queue",
	"version": "0.1.0",
	"description": "Tiny queue data structure",
	"license": "MIT",
	"repository": "sindresorhus/yocto-queue",
	"funding": "https://github.com/sponsors/sindresorhus",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"engines": {
		"node": ">=10"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"queue",
		"data",
		"structure",
		"algorithm",
		"queues",
		"queuing",
		"list",
		"array",
		"linkedlist",
		"fifo",
		"enqueue",
		"dequeue",
		"data-structure"
	],
	"devDependencies": {
		"ava": "^2.4.0",
		"tsd": "^0.13.1",
		"xo": "^0.35.0"
	}
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\components\Checkout.jsx
============================================================

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\components\Header.jsx
============================================================
// src/components/Header.jsx
import React from 'react';
import { Link } from 'react-router-dom';
import { useTranslation } from 'react-i18next';

const Header = () => {
  const { t, i18n } = useTranslation();

  const toggleLanguage = () => {
    const newLang = i18n.language === 'en' ? 'zh' : 'en';
    i18n.changeLanguage(newLang);
  };

  return (
    <header className="header">
      <nav className="navbar">
        <div className="nav-container">
          <Link to="/" className="nav-logo">
            {t('welcome')}
          </Link>
          
          <div className="nav-menu">
            <Link to="/" className="nav-link">
              Home
            </Link>
            <Link to="/products" className="nav-link">
              {t('categories')}
            </Link>
            <Link to="/cart" className="nav-link">
              {t('cart')}
            </Link>
            <Link to="/login" className="nav-link">
              {t('login')}
            </Link>
            <Link to="/register" className="nav-link">
              {t('register')}
            </Link>
            <Link to="/profile" className="nav-link">
              Profile
            </Link>
          </div>
          
          <button onClick={toggleLanguage} className="lang-toggle">
            {i18n.language === 'en' ? '中文' : 'English'}
          </button>
        </div>
      </nav>
    </header>
  );
};

export default Header;

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\components\ProductDetail.jsx
============================================================
// frontend/src/components/ProductDetail.jsx
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { useTranslation } from 'react-i18next';
import apiClient from '../config/api';

const ProductDetail = () => {
  const { id } = useParams();
  const { t, i18n } = useTranslation();
  const [product, setProduct] = useState(null);
  const [selectedImage, setSelectedImage] = useState(0);
  const [quantity, setQuantity] = useState(1);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchProduct = async () => {
      try {
        const response = await apiClient.get(`/products/${id}?lang=${i18n.language}`);
        setProduct(response.data);
      } catch (error) {
        console.error('Error fetching product:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchProduct();
  }, [id, i18n.language]);

  const addToCart = async () => {
    try {
      await apiClient.post('/cart/items', {
        productId: product.id,
        quantity: quantity
      });
      alert(t('addedToCart'));
    } catch (error) {
      console.error('Error adding to cart:', error);
    }
  };

  if (loading) return <div>{t('loading')}</div>;
  if (!product) return <div>{t('productNotFound')}</div>;

  return (
    <div className="product-detail">
      <div className="product-images">
        <div className="main-image">
          <img 
            src={product.images[selectedImage].imageUrl} 
            alt={product.images[selectedImage].altText} 
          />
        </div>
        <div className="image-thumbnails">
          {product.images.map((image, index) => (
            <img
              key={image.id}
              src={image.imageUrl}
              alt={image.altText}
              className={index === selectedImage ? 'active' : ''}
              onClick={() => setSelectedImage(index)}
            />
          ))}
        </div>
      </div>
      
      <div className="product-info">
        <h1>{i18n.language === 'zh' ? product.nameZh : product.nameEn}</h1>
        <div className="price">${product.price}</div>
        {product.comparePrice && (
          <div className="compare-price">${product.comparePrice}</div>
        )}
        
        <div className="description">
          <h3>{t('description')}</h3>
          <p>{i18n.language === 'zh' ? product.descriptionZh : product.descriptionEn}</p>
        </div>
        
        <div className="add-to-cart">
          <div className="quantity-selector">
            <button onClick={() => setQuantity(Math.max(1, quantity - 1))}>-</button>
            <span>{quantity}</span>
            <button onClick={() => setQuantity(quantity + 1)}>+</button>
          </div>
          <button className="add-cart-btn" onClick={addToCart}>
            {t('addToCart')}
          </button>
        </div>
      </div>
    </div>
  );
};

export default ProductDetail;

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\components\SEOHead.jsx
============================================================

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\components\TestComponent.jsx
============================================================
import React from 'react';

const TestComponent = () => {
  return <div>Test</div>;
};

export default TestComponent;

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\config\api.js
============================================================
// src/config/api.js
import axios from 'axios';

// API base URL configuration
// In development, use '/api' to go through Vite proxy
// In production, use your actual production URL
const API_BASE_URL = process.env.NODE_ENV === 'production' 
  ? 'https://your-production-domain.com/furniture-store/api'
  : '/api'; // This will use the Vite proxy

// Create axios instance with base configuration
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  }
});

// Request interceptor to add auth token
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor to handle errors
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem('token');
      // Redirect to login page
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default apiClient;

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\i18n\config.js
============================================================
// frontend/src/i18n/config.js
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';

const resources = {
  en: {
    translation: {
      welcome: "Welcome to Furniture Store",
      search: "Search products...",
      categories: "Categories",
      cart: "Shopping Cart",
      login: "Login",
      register: "Register",
      addToCart: "Add to Cart",
      addedToCart: "Added to cart!",
      price: "Price",
      description: "Description",
      features: "Features",
      reviews: "Reviews",
      loading: "Loading...",
      productNotFound: "Product not found"
    }
  },
  zh: {
    translation: {
      welcome: "歡迎來到傢俱商店",
      search: "搜尋產品...",
      categories: "產品分類",
      cart: "購物車",
      login: "登入",
      register: "註冊",
      addToCart: "加入購物車",
      addedToCart: "已加入購物車!",
      price: "價格",
      description: "產品描述",
      features: "產品特點",
      reviews: "客戶評價",
      loading: "載入中...",
      productNotFound: "找不到產品"
    }
  }
};

i18n
  .use(initReactI18next)
  .init({
    resources,
    lng: "zh",
    fallbackLng: "en",
    interpolation: {
      escapeValue: false
    }
  });

export default i18n;

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\pages\Cart.jsx
============================================================
// src/pages/Cart.jsx
import React, { useState, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import apiClient from '../config/api';

const Cart = () => {
  const { t } = useTranslation();
  const [cartItems, setCartItems] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchCartItems = async () => {
      try {
        const response = await apiClient.get('/cart/items');
        setCartItems(response.data);
      } catch (error) {
        console.error('Error fetching cart items:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchCartItems();
  }, []);

  const updateQuantity = async (itemId, newQuantity) => {
    try {
      await apiClient.put(`/cart/items/${itemId}`, { quantity: newQuantity });
      setCartItems(cartItems.map(item => 
        item.id === itemId ? { ...item, quantity: newQuantity } : item
      ));
    } catch (error) {
      console.error('Error updating quantity:', error);
    }
  };

  const removeItem = async (itemId) => {
    try {
      await apiClient.delete(`/cart/items/${itemId}`);
      setCartItems(cartItems.filter(item => item.id !== itemId));
    } catch (error) {
      console.error('Error removing item:', error);
    }
  };

  const getTotalPrice = () => {
    return cartItems.reduce((total, item) => total + (item.price * item.quantity), 0).toFixed(2);
  };

  if (loading) return <div>{t('loading')}</div>;

  return (
    <div className="cart">
      <h1>{t('cart')}</h1>
      
      {cartItems.length === 0 ? (
        <div className="empty-cart">
          <p>Your cart is empty</p>
        </div>
      ) : (
        <div className="cart-content">
          <div className="cart-items">
            {cartItems.map((item) => (
              <div key={item.id} className="cart-item">
                <div className="item-info">
                  <h3>{item.productName}</h3>
                  <p>${item.price}</p>
                </div>
                <div className="quantity-controls">
                  <button onClick={() => updateQuantity(item.id, item.quantity - 1)}>-</button>
                  <span>{item.quantity}</span>
                  <button onClick={() => updateQuantity(item.id, item.quantity + 1)}>+</button>
                </div>
                <div className="item-total">
                  ${(item.price * item.quantity).toFixed(2)}
                </div>
                <button onClick={() => removeItem(item.id)} className="remove-btn">
                  Remove
                </button>
              </div>
            ))}
          </div>
          
          <div className="cart-summary">
            <h3>Total: ${getTotalPrice()}</h3>
            <button className="checkout-btn">Proceed to Checkout</button>
          </div>
        </div>
      )}
    </div>
  );
};

export default Cart;

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\pages\Home.jsx
============================================================
// src/pages/Home.jsx
import React, { useEffect, useState } from 'react';
import { useTranslation } from 'react-i18next';
import { Link } from 'react-router-dom';
import { testBackendConnection, testProxyConnection, testDirectConnection } from '../utils/backendTest';
import { testConnections, explainResults } from '../utils/connectionTester';

const Home = () => {
  const { t } = useTranslation();
  const [connectionStatus, setConnectionStatus] = useState({
    backend: null,
    proxy: null,
    direct: null
  });

  useEffect(() => {
    const runTests = async () => {
      console.log('🚀 Running connection tests...');
      
      const backendTest = await testBackendConnection();
      const proxyTest = await testProxyConnection();
      const directTest = await testDirectConnection();
      
      setConnectionStatus({
        backend: backendTest,
        proxy: proxyTest,
        direct: directTest
      });
    };

    runTests();
  }, []);

  const runDetailedTests = async () => {
    console.log('🔬 Running detailed connection tests...');
    const results = await testConnections();
    explainResults(results);
  };

  return (
    <div className="home">
      <div className="hero-section">
        <h1>{t('welcome')}</h1>
        <p>Discover our beautiful furniture collection</p>
        <Link to="/products" className="cta-button">
          {t('categories')}
        </Link>
      </div>
      
           
      <div className="featured-section">
        <h2>Featured Products</h2>
        <div className="product-grid">
          <div className="product-card">
            <h3>Sample Chair</h3>
            <p>$299.99</p>
          </div>
          <div className="product-card">
            <h3>Sample Table</h3>
            <p>$599.99</p>
          </div>
          <div className="product-card">
            <h3>Sample Sofa</h3>
            <p>$899.99</p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Home;

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\pages\Login.jsx
============================================================
// src/pages/Login.jsx
import React, { useState } from 'react';
import { useTranslation } from 'react-i18next';
import { useNavigate, Link } from 'react-router-dom';
import apiClient from '../config/api';

const Login = () => {
  const { t } = useTranslation();
  const navigate = useNavigate();
  const [formData, setFormData] = useState({
    email: '',
    password: ''
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      const response = await apiClient.post('/auth/login', formData);
      localStorage.setItem('token', response.data.token);
      localStorage.setItem('user', JSON.stringify(response.data.user));
      navigate('/');
    } catch (error) {
      setError('Invalid email or password');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="login">
      <div className="login-container">
        <h1>{t('login')}</h1>
        
        {error && <div className="error-message">{error}</div>}
        
        <form onSubmit={handleSubmit} className="login-form">
          <div className="form-group">
            <label htmlFor="email">Email:</label>
            <input
              type="email"
              id="email"
              name="email"
              value={formData.email}
              onChange={handleChange}
              required
            />
          </div>
          
          <div className="form-group">
            <label htmlFor="password">Password:</label>
            <input
              type="password"
              id="password"
              name="password"
              value={formData.password}
              onChange={handleChange}
              required
            />
          </div>
          
          <button type="submit" disabled={loading} className="login-btn">
            {loading ? 'Logging in...' : t('login')}
          </button>
        </form>
        
        <p className="auth-link">
          Don't have an account? <Link to="/register">{t('register')}</Link>
        </p>
      </div>
    </div>
  );
};

export default Login;

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\pages\OrderHistory.jsx
============================================================
// src/pages/OrderHistory.jsx
import React, { useState, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { useNavigate } from 'react-router-dom';
import apiClient from '../config/api';

const OrderHistory = () => {
  const { t } = useTranslation();
  const navigate = useNavigate();
  const [orders, setOrders] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchOrders = async () => {
      try {
        const response = await apiClient.get('/orders');
        setOrders(response.data);
      } catch (error) {
        console.error('Error fetching orders:', error);
        if (error.response?.status === 401) {
          navigate('/login');
        }
      } finally {
        setLoading(false);
      }
    };

    fetchOrders();
  }, [navigate]);

  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString();
  };

  const getStatusClass = (status) => {
    switch (status.toLowerCase()) {
      case 'pending': return 'status-pending';
      case 'processing': return 'status-processing';
      case 'shipped': return 'status-shipped';
      case 'delivered': return 'status-delivered';
      case 'cancelled': return 'status-cancelled';
      default: return '';
    }
  };

  if (loading) return <div>{t('loading')}</div>;

  return (
    <div className="order-history">
      <div className="orders-container">
        <h1>Order History</h1>
        
        {orders.length === 0 ? (
          <div className="no-orders">
            <p>You haven't placed any orders yet.</p>
          </div>
        ) : (
          <div className="orders-list">
            {orders.map((order) => (
              <div key={order.id} className="order-card">
                <div className="order-header">
                  <div className="order-info">
                    <h3>Order #{order.id}</h3>
                    <p className="order-date">
                      Ordered on {formatDate(order.createdAt)}
                    </p>
                  </div>
                  <div className="order-status">
                    <span className={`status ${getStatusClass(order.status)}`}>
                      {order.status}
                    </span>
                  </div>
                </div>
                
                <div className="order-items">
                  {order.items && order.items.map((item) => (
                    <div key={item.id} className="order-item">
                      <div className="item-info">
                        <h4>{item.productName}</h4>
                        <p>Quantity: {item.quantity}</p>
                      </div>
                      <div className="item-price">
                        ${(item.price * item.quantity).toFixed(2)}
                      </div>
                    </div>
                  ))}
                </div>
                
                <div className="order-total">
                  <strong>Total: ${order.totalAmount}</strong>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default OrderHistory;

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\pages\ProductDetail.jsx
============================================================
// src/pages/ProductDetail.jsx
import React from 'react';
import ProductDetailComponent from '../components/ProductDetail';

const ProductDetail = () => {
  return (
    <div className="product-detail-page">
      <ProductDetailComponent />
    </div>
  );
};

export default ProductDetail;

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\pages\ProductList.jsx
============================================================
// src/pages/ProductList.jsx
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { useTranslation } from 'react-i18next';
import apiClient from '../config/api';

const ProductList = () => {
  const { t, i18n } = useTranslation();
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchProducts = async () => {
      try {
        console.log('🔄 Fetching products from:', `/products?lang=${i18n.language}`);
        const response = await apiClient.get(`/products?lang=${i18n.language}`);
        console.log('✅ Products fetched successfully:', response.data);
        setProducts(response.data);
        setError(null);
      } catch (error) {
        console.error('❌ Error fetching products:', error);
        console.error('Error details:', {
          message: error.message,
          code: error.code,
          status: error.response?.status,
          url: error.config?.url
        });
        setError(`Failed to fetch products: ${error.message}`);
      } finally {
        setLoading(false);
      }
    };

    fetchProducts();
  }, [i18n.language]);

  if (loading) return <div>{t('loading')}</div>;
  if (error) return <div className="error">{error}</div>;

  return (
    <div className="product-list">
      <h1>{t('categories')}</h1>
      
      <div className="products-grid">
        {products.length > 0 ? (
          products.map((product) => (
            <div key={product.id} className="product-card">
              <Link to={`/products/${product.id}`}>
                {product.images && product.images[0] && (
                  <img 
                    src={product.images[0].imageUrl} 
                    alt={product.images[0].altText}
                    className="product-image"
                  />
                )}
                <div className="product-info">
                  <h3>{i18n.language === 'zh' ? product.nameZh : product.nameEn}</h3>
                  <p className="product-price">${product.price}</p>
                  {product.comparePrice && (
                    <p className="compare-price">${product.comparePrice}</p>
                  )}
                </div>
              </Link>
            </div>
          ))
        ) : (
          <div className="no-products">
            <p>No products available</p>
          </div>
        )}
      </div>
    </div>
  );
};

export default ProductList;

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\pages\Register.jsx
============================================================
// src/pages/Register.jsx
import React, { useState } from 'react';
import { useTranslation } from 'react-i18next';
import { useNavigate, Link } from 'react-router-dom';
import apiClient from '../config/api';

const Register = () => {
  const { t } = useTranslation();
  const navigate = useNavigate();
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    if (formData.password !== formData.confirmPassword) {
      setError('Passwords do not match');
      setLoading(false);
      return;
    }

    try {
      const response = await apiClient.post('/auth/register', {
        firstName: formData.firstName,
        lastName: formData.lastName,
        email: formData.email,
        password: formData.password
      });
      
      localStorage.setItem('token', response.data.token);
      localStorage.setItem('user', JSON.stringify(response.data.user));
      navigate('/');
    } catch (error) {
      setError('Registration failed. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="register">
      <div className="register-container">
        <h1>{t('register')}</h1>
        
        {error && <div className="error-message">{error}</div>}
        
        <form onSubmit={handleSubmit} className="register-form">
          <div className="form-group">
            <label htmlFor="firstName">First Name:</label>
            <input
              type="text"
              id="firstName"
              name="firstName"
              value={formData.firstName}
              onChange={handleChange}
              required
            />
          </div>
          
          <div className="form-group">
            <label htmlFor="lastName">Last Name:</label>
            <input
              type="text"
              id="lastName"
              name="lastName"
              value={formData.lastName}
              onChange={handleChange}
              required
            />
          </div>
          
          <div className="form-group">
            <label htmlFor="email">Email:</label>
            <input
              type="email"
              id="email"
              name="email"
              value={formData.email}
              onChange={handleChange}
              required
            />
          </div>
          
          <div className="form-group">
            <label htmlFor="password">Password:</label>
            <input
              type="password"
              id="password"
              name="password"
              value={formData.password}
              onChange={handleChange}
              required
            />
          </div>
          
          <div className="form-group">
            <label htmlFor="confirmPassword">Confirm Password:</label>
            <input
              type="password"
              id="confirmPassword"
              name="confirmPassword"
              value={formData.confirmPassword}
              onChange={handleChange}
              required
            />
          </div>
          
          <button type="submit" disabled={loading} className="register-btn">
            {loading ? 'Registering...' : t('register')}
          </button>
        </form>
        
        <p className="auth-link">
          Already have an account? <Link to="/login">{t('login')}</Link>
        </p>
      </div>
    </div>
  );
};

export default Register;

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\pages\UserProfile.jsx
============================================================
// src/pages/UserProfile.jsx
import React, { useState, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { useNavigate } from 'react-router-dom';
import apiClient from '../config/api';

const UserProfile = () => {
  const { t } = useTranslation();
  const navigate = useNavigate();
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [editing, setEditing] = useState(false);
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
    email: ''
  });

  useEffect(() => {
    const fetchUserProfile = async () => {
      try {
        const response = await apiClient.get('/user/profile');
        setUser(response.data);
        setFormData({
          firstName: response.data.firstName,
          lastName: response.data.lastName,
          email: response.data.email
        });
      } catch (error) {
        console.error('Error fetching user profile:', error);
        // If unauthorized, redirect to login
        if (error.response?.status === 401) {
          navigate('/login');
        }
      } finally {
        setLoading(false);
      }
    };

    fetchUserProfile();
  }, [navigate]);

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      const response = await apiClient.put('/user/profile', formData);
      setUser(response.data);
      setEditing(false);
    } catch (error) {
      console.error('Error updating profile:', error);
    }
  };

  const handleLogout = () => {
    localStorage.removeItem('token');
    localStorage.removeItem('user');
    navigate('/');
  };

  if (loading) return <div>{t('loading')}</div>;

  return (
    <div className="user-profile">
      <div className="profile-container">
        <h1>User Profile</h1>
        
        {user && (
          <div className="profile-content">
            {!editing ? (
              <div className="profile-view">
                <div className="profile-info">
                  <p><strong>First Name:</strong> {user.firstName}</p>
                  <p><strong>Last Name:</strong> {user.lastName}</p>
                  <p><strong>Email:</strong> {user.email}</p>
                </div>
                
                <div className="profile-actions">
                  <button onClick={() => setEditing(true)} className="edit-btn">
                    Edit Profile
                  </button>
                  <button onClick={handleLogout} className="logout-btn">
                    Logout
                  </button>
                </div>
              </div>
            ) : (
              <form onSubmit={handleSubmit} className="profile-form">
                <div className="form-group">
                  <label htmlFor="firstName">First Name:</label>
                  <input
                    type="text"
                    id="firstName"
                    name="firstName"
                    value={formData.firstName}
                    onChange={handleChange}
                    required
                  />
                </div>
                
                <div className="form-group">
                  <label htmlFor="lastName">Last Name:</label>
                  <input
                    type="text"
                    id="lastName"
                    name="lastName"
                    value={formData.lastName}
                    onChange={handleChange}
                    required
                  />
                </div>
                
                <div className="form-group">
                  <label htmlFor="email">Email:</label>
                  <input
                    type="email"
                    id="email"
                    name="email"
                    value={formData.email}
                    onChange={handleChange}
                    required
                  />
                </div>
                
                <div className="form-actions">
                  <button type="submit" className="save-btn">Save</button>
                  <button 
                    type="button" 
                    onClick={() => setEditing(false)}
                    className="cancel-btn"
                  >
                    Cancel
                  </button>
                </div>
              </form>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

export default UserProfile;

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\App.css
============================================================
/* src/App.css - Furniture Store Styling */

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  line-height: 1.6;
  color: #333;
}

#root {
  min-height: 100vh;
}

.App {
  min-height: 100vh;
}

/* Header Styles */
.header {
  background-color: #2c3e50;
  color: white;
  padding: 1rem 0;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.navbar {
  width: 100%;
}

.nav-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 1rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.nav-logo {
  font-size: 1.5rem;
  font-weight: bold;
  color: white;
  text-decoration: none;
}

.nav-menu {
  display: flex;
  gap: 2rem;
}

.nav-link {
  color: white;
  text-decoration: none;
  padding: 0.5rem 1rem;
  border-radius: 4px;
  transition: background-color 0.3s;
}

.nav-link:hover {
  background-color: rgba(255,255,255,0.1);
}

.lang-toggle {
  background: #3498db;
  color: white;
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 4px;
  cursor: pointer;
}

.lang-toggle:hover {
  background: #2980b9;
}

/* Main Content */
main {
  min-height: calc(100vh - 80px);
  padding: 2rem 0;
}

/* Home Page */
.home {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 1rem;
}

.hero-section {
  text-align: center;
  padding: 4rem 0;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-radius: 8px;
  margin-bottom: 3rem;
}

.hero-section h1 {
  font-size: 3rem;
  margin-bottom: 1rem;
}

.cta-button {
  display: inline-block;
  background: #e74c3c;
  color: white;
  padding: 1rem 2rem;
  text-decoration: none;
  border-radius: 6px;
  margin-top: 1rem;
  transition: background-color 0.3s;
}

.cta-button:hover {
  background: #c0392b;
}

.featured-section h2 {
  text-align: center;
  margin-bottom: 2rem;
  font-size: 2rem;
}

/* Product Grid */
.product-grid, .products-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 2rem;
  margin-top: 2rem;
}

.product-card {
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 1.5rem;
  text-align: center;
  background: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  transition: transform 0.3s, box-shadow 0.3s;
}

.product-card:hover {
  transform: translateY(-4px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.product-card a {
  text-decoration: none;
  color: inherit;
}

.product-image {
  width: 100%;
  height: 200px;
  object-fit: cover;
  border-radius: 4px;
  margin-bottom: 1rem;
}

.product-price {
  font-size: 1.2rem;
  font-weight: bold;
  color: #e74c3c;
}

.compare-price {
  text-decoration: line-through;
  color: #7f8c8d;
  font-size: 0.9rem;
}

/* Product List Page */
.product-list {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 1rem;
}

.product-list h1 {
  text-align: center;
  margin-bottom: 2rem;
  font-size: 2.5rem;
}

.no-products {
  text-align: center;
  padding: 3rem;
  background: #f8f9fa;
  border-radius: 8px;
}

/* Product Detail */
.product-detail {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 3rem;
  margin-top: 2rem;
}

.product-images {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.main-image img {
  width: 100%;
  height: 400px;
  object-fit: cover;
  border-radius: 8px;
}

.image-thumbnails {
  display: flex;
  gap: 0.5rem;
}

.image-thumbnails img {
  width: 80px;
  height: 80px;
  object-fit: cover;
  border-radius: 4px;
  cursor: pointer;
  border: 2px solid transparent;
}

.image-thumbnails img.active {
  border-color: #3498db;
}

.product-info h1 {
  font-size: 2rem;
  margin-bottom: 1rem;
}

.price {
  font-size: 1.5rem;
  font-weight: bold;
  color: #e74c3c;
  margin-bottom: 1rem;
}

.description {
  margin: 2rem 0;
}

.add-to-cart {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-top: 2rem;
}

.quantity-selector {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.quantity-selector button {
  width: 40px;
  height: 40px;
  border: 1px solid #ddd;
  background: white;
  cursor: pointer;
  border-radius: 4px;
}

.quantity-selector span {
  min-width: 40px;
  text-align: center;
  font-weight: bold;
}

.add-cart-btn {
  background: #27ae60;
  color: white;
  border: none;
  padding: 1rem 2rem;
  border-radius: 6px;
  cursor: pointer;
  font-size: 1rem;
}

.add-cart-btn:hover {
  background: #229954;
}

/* Forms and Auth */
.login, .register {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 60vh;
}

.login-container, .register-container {
  background: white;
  padding: 2rem;
  border-radius: 8px;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  width: 100%;
  max-width: 400px;
}

.login-form, .register-form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.form-group {
  display: flex;
  flex-direction: column;
}

.form-group label {
  margin-bottom: 0.5rem;
  font-weight: bold;
}

.form-group input {
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 1rem;
}

.login-btn, .register-btn {
  background: #3498db;
  color: white;
  border: none;
  padding: 1rem;
  border-radius: 6px;
  cursor: pointer;
  font-size: 1rem;
}

.login-btn:hover, .register-btn:hover {
  background: #2980b9;
}

.auth-link {
  text-align: center;
  margin-top: 1rem;
}

.auth-link a {
  color: #3498db;
  text-decoration: none;
}

.error-message {
  background: #e74c3c;
  color: white;
  padding: 1rem;
  border-radius: 4px;
  margin-bottom: 1rem;
}

/* Responsive Design */
@media (max-width: 768px) {
  .nav-container {
    flex-direction: column;
    gap: 1rem;
  }
  
  .nav-menu {
    flex-wrap: wrap;
    justify-content: center;
  }
  
  .product-detail {
    grid-template-columns: 1fr;
  }
  
  .hero-section h1 {
    font-size: 2rem;
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\src\index.css
============================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\package.json
============================================================
{
  "name": "furniture-store-frontend",
  "version": "1.0.0",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "dependencies": {
    "axios": "^1.3.0",
    "i18next": "^22.4.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-i18next": "^12.1.0",
    "react-router-dom": "^6.8.0",
    "styled-components": "^5.3.0"
  },
  "devDependencies": {
    "@babel/core": "^7.28.4",
    "@babel/preset-env": "^7.28.3",
    "@babel/preset-react": "^7.27.1",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@vitejs/plugin-react": "^3.1.0",
    "@vitest/ui": "^4.0.1",
    "babel-jest": "^30.2.0",
    "identity-obj-proxy": "^3.0.0",
    "jest": "^30.2.0",
    "jest-environment-jsdom": "^30.2.0",
    "jest-transform-stub": "^2.0.0",
    "jsdom": "^27.0.1",
    "vite": "^4.1.0",
    "vitest": "^4.0.1"
  }
}

============================================================
FILE: C:\Project\reactjs\furnitureStore\vite.config.js
============================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '/furniture-store/api')
      }
    }
  }
})

